<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ReactNative之AsyncStorage本地存储</title>
      <link href="/2018/01/24/ReactNative%E4%B9%8BAsyncStorage%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"/>
      <content type="html"><![CDATA[<ul><li>在RN开发中，持久化存储数据，可以使用AsyncStorage，对原生的API进行了一层封装</li><li>AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的</li></ul><a id="more"></a><blockquote><h2 id="AsyncStorage原理和使用"><a href="#AsyncStorage原理和使用" class="headerlink" title="AsyncStorage原理和使用"></a>AsyncStorage原理和使用</h2><ul><li>AsyncStorage存储数据，在iOS中，底层会把数据保存到沙盒中的Documents中,并生成manifest.json文件。保存的数据都在manifest.json中。</li><li>AsyncStorage删除数据，也仅仅是删除manifest.json文件中的数据，并不是删除manifest.json文件</li><li>唯有<code>clear</code>方法是将文件删除</li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-59ec94ecc769d233.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="数据持久化.jpg"></p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-296bd2a19ea5dc90.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="json文件内容.jpg"></p><h3 id="一-存储"><a href="#一-存储" class="headerlink" title="一. 存储"></a>一. 存储</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static setItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; void) </span><br><span class="line">//将key字段的值设置成value，并在完成后调用callback函数。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象</span><br></pre></td></tr></table></figure><ul><li>注意：<code>AsyncStorage</code>只能存储字符串，需要把对象转换为字符串才行</li><li>具体使用</li><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//key值</span><br><span class="line">var key = &apos;per&apos;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name:&apos;jun&apos;,</span><br><span class="line">    age:20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//json转成字符串</span><br><span class="line">var jsonStr = JSON.stringify(person)</span><br><span class="line"></span><br><span class="line">//存储</span><br><span class="line">AsyncStorage.setItem(&apos;person&apos;, jsonStr, function (error) &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        alert(&apos;存储失败&apos;)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        alert(&apos;存储完成&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="二-读取"><a href="#二-读取" class="headerlink" title="二. 读取"></a>二. 读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static getItem(key: string, callback?: ?(error: ?Error, result: ?string) =&gt; void) </span><br><span class="line">//读取key字段并将结果作为第二个参数传递给callback。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。</span><br></pre></td></tr></table></figure><blockquote><p>使用方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//读取</span><br><span class="line">_readData()&#123;</span><br><span class="line">    console.log(&apos;读取&apos;)</span><br><span class="line">    AsyncStorage.getItem(&apos;per&apos;, function (error, result) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            alert(&apos;读取失败&apos;)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            console.log(result)</span><br><span class="line">            alert(&apos;读取完成&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-删除"><a href="#三-删除" class="headerlink" title="三. 删除"></a>三. 删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static removeItem(key: string, callback?: ?(error: ?Error) =&gt; void) </span><br><span class="line">//删除一个字段。返回一个Promise对象。</span><br><span class="line"></span><br><span class="line">static clear(callback?: ?(error: ?Error) =&gt; void) </span><br><span class="line">//删除全部的AsyncStorage数据，即直接删除该缓存文件</span><br></pre></td></tr></table></figure><blockquote><p>函数用法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//删除</span><br><span class="line">_deleteData()&#123;</span><br><span class="line">    console.log(&apos;删除&apos;)</span><br><span class="line"></span><br><span class="line">    //删除一条数据</span><br><span class="line">    AsyncStorage.removeItem(&apos;per&apos;, function (error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            alert(&apos;删除失败&apos;)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            alert(&apos;删除完成&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //删除json文件</span><br><span class="line">    AsyncStorage.clear(function (error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            alert(&apos;文件删除失败&apos;)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            alert(&apos;文件删除完成&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-其他用法"><a href="#四-其他用法" class="headerlink" title="四. 其他用法"></a>四. 其他用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static mergeItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; void) </span><br><span class="line">//假设已有的值和新的值都是字符串化的JSON，则将两个值合并。返回一个Promise对象。还没有被所有原生实现都支持</span><br><span class="line"></span><br><span class="line">static getAllKeys(callback?: ?(error: ?Error, keys: ?Array&lt;string&gt;) =&gt; void) </span><br><span class="line">//获取所有本应用可以访问到的数据，不论来自什么库或调用者。返回一个Promise对象。</span><br><span class="line"></span><br><span class="line">static flushGetRequests() </span><br><span class="line">//清除所有进行中的查询操作。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AsyncStorage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Node.js搭建Web服务器</title>
      <link href="/2018/01/20/Node.js%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8"/>
      <content type="html"><![CDATA[<ul><li>服务器种类<ul><li>Web服务器: 处理HTTP请求的服务器</li><li>Socket服务器(即时通讯): 通过socket传输<ul><li>即时通讯(IM): 允许两人或多人使用网路即时的传递文字讯息、档案、语音与视频交流</li></ul></li><li>流媒体服务器: 音视频处理程序, 接受流媒体格式文件,flv/ts等</li></ul></li></ul><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><ul><li>简单效果图</li><li><img src="http://upload-images.jianshu.io/upload_images/4122543-be8bdfac135d99e8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求返回结果.jpg"></li></ul><hr><h2 id="一-Node-js介绍"><a href="#一-Node-js介绍" class="headerlink" title="一. Node.js介绍"></a>一. Node.js介绍</h2><ul><li>Node.js发布于2009年5月，由Ryan Dahl(瑞恩·达尔)在GitHub上发布了最初版本的部分Node.js包，随后几个月里，有人开始使用Node.js开发应用</li><li>Node.js是一个基于Chrome JavaScript运行时建立的平台， 是一个Javascript运行环境</li><li>Node 是一个服务器程序, 用Javascript这个语言开发服务器</li><li>Node.js的实质是对Chrome V8引擎进行了封装</li><li>V8 JavaScript 引擎是 Google 用于其 Chrome 浏览器的底层 JavaScript 引擎</li><li>传统意义上的 JavaScript 运行在浏览器上，这是因为浏览器内核实际上分为两个部分:渲染引擎和 JavaScript 引擎。前者负责渲染 HTML + CSS，后者则负责运行 JavaScript。Chrome 使用的 JavaScript 引擎是 V8，它的速度非常快</li><li>参考<a href="https://www.ibm.com/developerworks/cn/opensource/os-nodejs/" target="_blank" rel="noopener">Node.js 究竟是什么？</a>和<a href="https://nodejs.org/dist/latest-v7.x/docs/api/" target="_blank" rel="noopener">Node.js的SDK文档</a></li></ul><h3 id="1-Node-js的优缺点"><a href="#1-Node-js的优缺点" class="headerlink" title="1. Node.js的优缺点"></a>1. Node.js的优缺点</h3><ul><li>Node.js优点：<ul><li>采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。</li><li>Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。</li><li>Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。</li></ul></li><li>Node.js缺点：<ul><li>可靠性低</li><li>单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。</li><li>一旦这个进程崩掉，那么整个web服务就崩掉了。</li></ul></li></ul><h3 id="2-Node-js使用介绍"><a href="#2-Node-js使用介绍" class="headerlink" title="2. Node.js使用介绍"></a>2. Node.js使用介绍</h3><ul><li>Node.js使用Module模块去划分不同的功能，以简化App开发，Module就是库，跟组件化差不多，一个功能一个库。</li><li>NodeJS内建了一个HTTP服务器，可以轻而易举的实现一个网站和服务器的组合，不像PHP那样，在使用PHP的时候，必须先搭建一个Apache之类的HTTP服务器，然后通过HTTP服务器的模块加载CGI调用，才能将PHP脚本的执行结果呈现给用户</li><li>require() 函数，用于在当前模块中加载和使用其他模块；</li></ul><h2 id="二-Express模块-框架"><a href="#二-Express模块-框架" class="headerlink" title="二. Express模块(框架)"></a>二. Express模块(框架)</h2><ul><li>Express是Node.JS第三方库</li><li>Express可以处理各种HTTP请求</li><li>Express是目前最流行的基于Node.js的Web开发框架，</li><li>Express框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器</li></ul><h3 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1. 安装Node.js"></a>1. 安装Node.js</h3><ul><li>打开终端，输入node -v，先查看是否已经安装</li><li>如果没有安装，就需要安装node软件</li><li>参考<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">Node.js 安装配置</a></li></ul><h3 id="2-安装npm"><a href="#2-安装npm" class="headerlink" title="2. 安装npm"></a>2. 安装npm</h3><ul><li>npm是随同NodeJS一起安装的包管理工具，用于下载NodeJS第三方库。</li><li>类似iOS开发中cocoapods，用于安装第三方框架</li><li>新版的NodeJS已经集成了npm，所以只要安装好Node.JS就好<h3 id="3-下载第三方模块Express"><a href="#3-下载第三方模块Express" class="headerlink" title="3. 下载第三方模块Express"></a>3. 下载第三方模块Express</h3></li><li>首先先创建项目<ul><li>新建一个文件夹, 打开终端</li><li>cd到当前文件夹, 创建一个js文件, 如: <code>touch app.js</code></li></ul></li><li>安装<code>package.json</code>文件, 类似于CocoaPods中的<code>Podfile</code>   - cd到当前文件夹<ul><li>终端输入: <code>npm init</code></li></ul></li><li>最后安装express库 <ul><li>终端输入: <code>npm install express --save</code></li></ul></li></ul><h2 id="三-搭建简单的Http服务器"><a href="#三-搭建简单的Http服务器" class="headerlink" title="三. 搭建简单的Http服务器"></a>三. 搭建简单的Http服务器</h2><h3 id="1-开始搭建Http服务器"><a href="#1-开始搭建Http服务器" class="headerlink" title="1. 开始搭建Http服务器"></a>1. 开始搭建Http服务器</h3><ul><li>require加载模块</li><li>监听端口号和网址, 端口号不能使用已经占用的端口比如（80），每个服务器相当于一个app，都需要端口，才能找到入口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//创建HTTP服务器</span><br><span class="line"></span><br><span class="line">//1. 加载http模块</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">//2. 创建http服务器</span><br><span class="line">// 参数: 请求的回调, 当有人访问服务器的时候,就会自动调用回调函数</span><br><span class="line">var server = http.createServer(function (request, response) &#123;</span><br><span class="line">    console.log(&apos;有人访问了服务器&apos;)</span><br><span class="line"></span><br><span class="line">    //回调数据</span><br><span class="line">    response.write(&apos;Hello, My Love&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//3. 绑定端口</span><br><span class="line">server.listen(3030, &apos;192.168.2.11&apos;)</span><br><span class="line"></span><br><span class="line">//4. 执行</span><br><span class="line">console.log(&apos;执行了3030&apos;)</span><br></pre></td></tr></table></figure><h3 id="2-开始运行服务器"><a href="#2-开始运行服务器" class="headerlink" title="2. 开始运行服务器"></a>2. 开始运行服务器</h3><ul><li>那么还是要打开终端</li><li>输入: <code>node app.js</code><ul><li><code>app.ja</code>为文件名</li></ul></li></ul><h2 id="四-express搭建服务器"><a href="#四-express搭建服务器" class="headerlink" title="四. express搭建服务器"></a>四. express搭建服务器</h2><h3 id="1-express框架的使用"><a href="#1-express框架的使用" class="headerlink" title="1. express框架的使用"></a>1. express框架的使用</h3><ul><li>引入express模块</li><li>创建express服务器</li><li>get, post请求中: <ul><li>参数一: 请求根路径,若传<code>&#39;/&#39;</code>, 则url为: <code>http://192.168.0.0:3030</code></li><li>若传<code>&#39;/home&#39;</code>, 则url为: <code>http://192.168.0.0:3030/home</code></li><li>参数二: 请求数据的回调函数</li></ul></li><li>监听端口: 默认url为当前电脑的IP地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* express的服务器 */</span><br><span class="line"></span><br><span class="line">//1. 导入express</span><br><span class="line">var express = require(&apos;express&apos;)</span><br><span class="line"></span><br><span class="line">//2. 创建express服务器</span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line">//3. 访问服务器(get或者post)</span><br><span class="line">//参数一: 请求根路径</span><br><span class="line">//3.1 get请求</span><br><span class="line">server.get(&apos;/&apos;, function (request, response) &#123;</span><br><span class="line">    // console.log(request)</span><br><span class="line">    response.send(&apos;get请求成功&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//3.2 post请求</span><br><span class="line">server.post(&apos;/&apos;, function (request, response) &#123;</span><br><span class="line">    response.send(&apos;post请求成功&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//4. 绑定端口</span><br><span class="line">server.listen(4040)</span><br><span class="line">console.log(&apos;启动4040&apos;)</span><br></pre></td></tr></table></figure><h3 id="2-路由"><a href="#2-路由" class="headerlink" title="2. 路由"></a>2. 路由</h3><ul><li>路由:针对不同的URL有不同的处理方式，比如以后会有首页，发现模块，每个模块处理不一样。</li><li>添加url路径,根据不同路径，显示不同内容</li><li>路由句柄(索引):执行完一个函数，在执行下一个 ,因为有时候处理一个请求，需要做很多其他事情，写在一起业务逻辑不好分开,所以多弄几个行数</li><li>函数一定要添加next参数，一定要调用next(),才会进行下面操作，代码使一行一行执行，解释性语言</li><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* express的路由 */</span><br><span class="line"></span><br><span class="line">//1. 导入express</span><br><span class="line">var express = require(&apos;express&apos;)</span><br><span class="line"></span><br><span class="line">//2. 创建express服务器</span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line">//3. 访问服务器(get或者post)</span><br><span class="line">//参数一: 请求根路径</span><br><span class="line">//3.1 get请求</span><br><span class="line">server.get(&apos;/&apos;, function (request, response, next) &#123;</span><br><span class="line">    // console.log(request)</span><br><span class="line">    console.log(&apos;从据库获取数据&apos;)</span><br><span class="line">    next()</span><br><span class="line">&#125;, function (request, response) &#123;</span><br><span class="line">    response.send(&apos;get请求成功&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//3. 绑定端口</span><br><span class="line">server.listen(4040)</span><br><span class="line">console.log(&apos;启动4040&apos;)</span><br></pre></td></tr></table></figure><h3 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3. 中间件"></a>3. 中间件</h3><ul><li>优化代码，使代码清晰可读</li><li>原理，发送一个请求给服务器的时候，会被中间件拦截，先由中间件处理，每个中间件都有一个回调函数作为参数,拦截到参数，就会自动执行回调函数。</li><li>注意：有中间件use，会先执行中间件的回调函数，然后才会调用get或者post的回调函数，也就是当监听到请求，先执行中间件，才会到get,post请求。</li><li>use是express注册中间件的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* express的中间件 */</span><br><span class="line"></span><br><span class="line">//1. 导入express</span><br><span class="line">var express = require(&apos;express&apos;)</span><br><span class="line"></span><br><span class="line">//2. 创建express服务器</span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line">//3. 创建中间件:use</span><br><span class="line">//截取请求, 拦截回调</span><br><span class="line">server.use(&apos;/&apos;, function (request, response, next) &#123;</span><br><span class="line">    console.log(&apos;执行中间件&apos;)</span><br><span class="line">    // console.log(&apos;获取数据库数据&apos;)</span><br><span class="line">    console.log(request.query.page)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//4. 访问服务器(get或者post)</span><br><span class="line">//参数一: 请求根路径</span><br><span class="line">//4.1 get请求</span><br><span class="line">server.get(&apos;/home&apos;, function (request, response) &#123;</span><br><span class="line">    // console.log(request)</span><br><span class="line">    response.send(&apos;get参数请求成功&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//5. 绑定端口</span><br><span class="line">server.listen(4040)</span><br><span class="line">console.log(&apos;启动4040&apos;)</span><br></pre></td></tr></table></figure><h3 id="4-get请求参数"><a href="#4-get请求参数" class="headerlink" title="4. get请求参数"></a>4. get请求参数</h3><ul><li>request.query会把请求参数包装成字典对象，直接通过点就能获取参数</li><li>这里的请求地址为: <code>http://192.168.2.11:4040/home?page=12</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* express的中间件 */</span><br><span class="line"></span><br><span class="line">//1. 导入express</span><br><span class="line">var express = require(&apos;express&apos;)</span><br><span class="line"></span><br><span class="line">//2. 创建express服务器</span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line">//4. 访问服务器(get或者post)</span><br><span class="line">//参数一: 请求根路径</span><br><span class="line">//4.1 get请求</span><br><span class="line">server.get(&apos;/home&apos;, function (request, response) &#123;</span><br><span class="line">    // console.log(request)</span><br><span class="line">    console.log(request.query.page)</span><br><span class="line">    response.send(&apos;get参数请求成功&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//5. 绑定端口</span><br><span class="line">server.listen(4040)</span><br><span class="line">console.log(&apos;启动4040&apos;)</span><br></pre></td></tr></table></figure><ul><li>输出结果<br>-<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动4040</span><br><span class="line">12</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-post请求参数"><a href="#5-post请求参数" class="headerlink" title="5. post请求参数"></a>5. post请求参数</h3><ul><li>这里先让我们看一下request的部分参数</li><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">headers: </span><br><span class="line">   &#123; </span><br><span class="line">   //请求头</span><br><span class="line">     host: &apos;192.168.2.11:4040/home&apos;,</span><br><span class="line">     //保持长连接</span><br><span class="line">     connection: &apos;keep-alive&apos;,</span><br><span class="line">     &apos;cache-control&apos;: &apos;max-age=0&apos;,</span><br><span class="line">     &apos;user-agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36&apos;,</span><br><span class="line">     &apos;upgrade-insecure-requests&apos;: &apos;1&apos;,</span><br><span class="line">     //可接受的数据解析方式</span><br><span class="line">     accept: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&apos;,</span><br><span class="line">     &apos;accept-encoding&apos;: &apos;gzip, deflate&apos;,</span><br><span class="line">     &apos;accept-language&apos;: &apos;zh-CN,zh;q=0.9&apos;,</span><br><span class="line">     &apos;if-none-match&apos;: &apos;W/&quot;15-H7HlVCzzVfmRL56LAnLfNUaMM+8&quot;&apos; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>使用http发送请求，需要设置content-type字段</li><li>content-type字段<ul><li>application/x-www-form-urlencoded(普通请求，默认一般使用这种)</li><li><code>application/json</code>(带有json格式的参数，需要使用这个，比如参数是字典或者数组)</li><li><code>multipart/form-data</code>(传输文件，文件上传使用这个)</li></ul></li><li>AFN框架中<code>AFHTTPRequestSerializer</code>使用的是<code>application/x-www-form-urlencoded</code>，<code>AFJSONRequestSerializer</code>使用的是<code>application/json</code></li><li>Node.JS需要使用body-parser模块,解析post请求参数</li><li>可以采用中间件的方式解析post请求参数<ul><li>注意bodyParser.urlencoded参数是一个字典，需要添加<code>{}`</code>包装</li><li>extends必传参数，是否展开</li></ul></li><li>完整代码示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建Post请求</span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">//1. 导入express</span><br><span class="line">var express = require(&apos;express&apos;)</span><br><span class="line"></span><br><span class="line">//2. 加载模块</span><br><span class="line">var bodyParse = require(&apos;body-parser&apos;)</span><br><span class="line"></span><br><span class="line">//3. 创建服务器</span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line">//4. 生成解析器</span><br><span class="line">// application/x-www-form-urlencoded</span><br><span class="line">var urlencoded = bodyParse.urlencoded(&#123; extends:true &#125;)</span><br><span class="line"></span><br><span class="line">// application/json</span><br><span class="line">var jsonParser = bodyParse.json()</span><br><span class="line"></span><br><span class="line">//5. 中间件: 把请求体参数 存放到request.body</span><br><span class="line">server.use(&apos;./home&apos;, jsonParser)</span><br><span class="line"></span><br><span class="line">//6. 请求数据</span><br><span class="line">// request:request请求头,请求体</span><br><span class="line">server.post(&apos;./home&apos;, function (request, response) &#123;</span><br><span class="line">    //解析post请求参数</span><br><span class="line">    console.log(request.body)</span><br><span class="line">    response.send(request.body)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//7. 绑定端口</span><br><span class="line">server.listen(5050)</span><br></pre></td></tr></table></figure><hr><blockquote><h4 id="Demo地址"><a href="#Demo地址" class="headerlink" title="Demo地址"></a><a href="https://github.com/CoderTitan/WebServer" target="_blank" rel="noopener">Demo地址</a></h4></blockquote><hr><blockquote><p>参考文章:</p><ol><li><a href="http://blog.csdn.net/kaosini/article/details/8089597" target="_blank" rel="noopener">Node.js优缺点</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-nodejs/" target="_blank" rel="noopener">Node.js 究竟是什么？</a></li><li><a href="http://www.expressjs.com.cn/4x/api.html" target="_blank" rel="noopener">Express 4.x API 中文手册</a></li><li><a href="https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94" target="_blank" rel="noopener">JavaScript 语言参考</a>.aspx)</li></ol></blockquote>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Web服务器 </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactNative之TabBariOS和TabNavigator</title>
      <link href="/2018/01/06/ReactNative%E4%B9%8BTabBariOS%E5%92%8CTabNavigator"/>
      <content type="html"><![CDATA[<blockquote><p>效果图</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-ecacb6e40602657c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="底部选项条.png"></p><h2 id="一-TabBarIOS"><a href="#一-TabBarIOS" class="headerlink" title="一. TabBarIOS"></a>一. TabBarIOS</h2><ul><li>底部选项条, 不能跨平台,只能iOS端使用</li><li>添加如下代码, 就会出现底部选项条</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">    &lt;TabBarIOS&gt;&lt;/TabBarIOS&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-相关属性"><a href="#1-相关属性" class="headerlink" title="1. 相关属性"></a>1. 相关属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">barTintColor=&apos;yellow&apos;</span><br><span class="line">//标签栏的背景颜色</span><br><span class="line"></span><br><span class="line">tintColor=&apos;#ed7f30&apos;</span><br><span class="line">//当前被选中的标签图标的颜色</span><br><span class="line"></span><br><span class="line">unselectedItemTintColor=&apos;#a19a9a&apos;</span><br><span class="line">//当前没有被选中的标签图标的颜色。仅在iOS 10及以上版本有效</span><br><span class="line"></span><br><span class="line">translucent=&#123;false&#125; </span><br><span class="line">//一个布尔值，决定标签栏是否需要半透明化</span><br><span class="line">//默认为true, 有透明效果</span><br></pre></td></tr></table></figure><h2 id="二-选项卡-TabBarIOS-Item"><a href="#二-选项卡-TabBarIOS-Item" class="headerlink" title="二. 选项卡: TabBarIOS.Item"></a>二. 选项卡: <code>TabBarIOS.Item</code></h2><ul><li><code>TabBarIOS</code>: 只是表示底部的一个选项条</li><li><code>TabBarIOS.Item</code>: 才代表每一个选项卡</li><li><code>TabBarIOS.Item</code>必须包装一个View,作为点击tabBar按钮，切换的View</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;TabBarIOS.Item title=&apos;首页&apos;</span><br><span class="line">                icon=&#123;&#123;uri:&apos;btn_home_normal&apos;&#125;&#125;</span><br><span class="line">                selectedIcon=&#123;&#123;uri:&apos;btn_home_selected&apos;&#125;&#125;</span><br><span class="line">                onPress=&#123;()=&gt;&#123;</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        selectedIndex:0</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;&#125;</span><br><span class="line">                selected=&#123;this.state.selectedIndex == 0&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;View style=&#123;&#123;backgroundColor:&apos;red&apos;, flex:1&#125;&#125;/&gt;</span><br><span class="line">&lt;/TabBarIOS.Item&gt;</span><br></pre></td></tr></table></figure><h3 id="1-常用属性"><a href="#1-常用属性" class="headerlink" title="1. 常用属性"></a>1. 常用属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">badge string, number </span><br><span class="line">badge=&apos;我&apos;</span><br><span class="line">badge=&#123;12&#125;</span><br><span class="line">//在图标右上角显示一个红色的气泡, 可接受string和number类型</span><br><span class="line"></span><br><span class="line">title string </span><br><span class="line">//在图标下面显示的标题文字。如果定义了systemIcon属性，这个属性会被忽略。</span><br><span class="line"></span><br><span class="line">icon Image.propTypes.source </span><br><span class="line">//给当前标签指定一个自定义的图标。如果定义了systemIcon属性， 这个属性会被忽略。</span><br><span class="line"></span><br><span class="line">selectedIcon Image.propTypes.source </span><br><span class="line">//当标签被选中的时候显示的自定义图标。如果定义了systemIcon属性，这个属性会被忽略。如果定义了icon而没定义这个属性，在选中的时候图标会染上蓝色。</span><br><span class="line"></span><br><span class="line">onPress function </span><br><span class="line">//当此标签被选中时调用。你应该修改组件的状态来使得selected属性为true</span><br><span class="line"></span><br><span class="line">selected bool </span><br><span class="line">//这个属性决定了子视图是否可见。如果你看到一个空白的页面，很可能是没有选中任何一个标签</span><br><span class="line"></span><br><span class="line">systemIcon enum(&apos;bookmarks&apos;, &apos;contacts&apos;, &apos;downloads&apos;, &apos;favorites&apos;, &apos;featured&apos;, &apos;history&apos;, &apos;more&apos;, &apos;most-recent&apos;, &apos;most-viewed&apos;, &apos;recents&apos;, &apos;search&apos;, &apos;top-rated&apos;) </span><br><span class="line">//一些预定义的系统图标。注意如果你使用了此属性，标题和自定义图标都会被覆盖为系统定义的值。</span><br></pre></td></tr></table></figure><ul><li>只要设置对应的tabBarItem的selected为true,就会自动跳转到对应界面<ul><li>注意：tabBarItem的selected属性不能写死，可以搞个角标记录当前选中那个角标</li></ul></li><li>监听tabBarItem的点击，修改selected属性</li><li>相关示例代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">export default class App extends Component&lt;&#123;&#125;&gt; &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            selectedIndex:0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当一个组件要显示的时候,就会自动调用render,渲染组件</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;TabBarIOS tintColor=&apos;#ed7f30&apos;&gt;</span><br><span class="line">                &lt;TabBarIOS.Item title=&apos;首页&apos;</span><br><span class="line">                         icon=&#123;&#123;uri:&apos;btn_home_normal&apos;&#125;&#125;</span><br><span class="line">                                selectedIcon=&#123;&#123;uri:&apos;btn_home_selected&apos;&#125;&#125;</span><br><span class="line">                                badge=&apos;我&apos;</span><br><span class="line">                                onPress=&#123;()=&gt;&#123;</span><br><span class="line">                                    this.setState(&#123;</span><br><span class="line">                                        selectedIndex:0</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                &#125;&#125;</span><br><span class="line">                                selected=&#123;this.state.selectedIndex == 0&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;&#123;backgroundColor:&apos;red&apos;, flex:1&#125;&#125;/&gt;</span><br><span class="line">                &lt;/TabBarIOS.Item&gt;</span><br><span class="line"></span><br><span class="line">                &lt;TabBarIOS.Item title=&apos;直播&apos;</span><br><span class="line">                                icon=&#123;&#123;uri:&apos;btn_column_normal&apos;&#125;&#125;</span><br><span class="line">                                selectedIcon=&#123;&#123;uri:&apos;btn_column_selected&apos;&#125;&#125;</span><br><span class="line">                                badge=&#123;12&#125;</span><br><span class="line">                                onPress=&#123;()=&gt;&#123;</span><br><span class="line">                                    this.setState(&#123;</span><br><span class="line">                                        selectedIndex:1</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                &#125;&#125;</span><br><span class="line">                                selected=&#123;this.state.selectedIndex == 1&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;&#123;backgroundColor:&apos;yellow&apos;, flex:1&#125;&#125;/&gt;</span><br><span class="line">                &lt;/TabBarIOS.Item&gt;</span><br><span class="line">            &lt;/TabBarIOS&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-TabNavigator"><a href="#三-TabNavigator" class="headerlink" title="三. TabNavigator"></a>三. TabNavigator</h2><ul><li>TabBarIOS只能用于iOS平台，如果在安卓上也需要有TabBar,就不能使用TabBarIOS。</li><li>TabNavigator:一个跨平台的TabBar第三方框架组件，可以用于iOS和安卓平台</li><li><a href="https://github.com/expo/react-native-tab-navigator" target="_blank" rel="noopener">TabNavigator地址</a></li></ul><h3 id="1-安装和导入"><a href="#1-安装和导入" class="headerlink" title="1. 安装和导入"></a>1. 安装和导入</h3><h4 id="1-1-安装第三方框架"><a href="#1-1-安装第三方框架" class="headerlink" title="1-1. 安装第三方框架"></a>1-1. 安装第三方框架</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-native-tab-navigator</span><br></pre></td></tr></table></figure><h4 id="1-2-导入框架"><a href="#1-2-导入框架" class="headerlink" title="1-2. 导入框架"></a>1-2. 导入框架</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import TabNavigator from &apos;react-native-tab-navigator&apos;;</span><br></pre></td></tr></table></figure><h3 id="2-TabNavigator常用属性"><a href="#2-TabNavigator常用属性" class="headerlink" title="2. TabNavigator常用属性"></a>2. TabNavigator常用属性</h3><table><thead><tr><th>属性</th><th>默认值</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>sceneStyle</td><td>inherited</td><td>object (style)</td><td>定义渲染的场景</td></tr><tr><td>tabBarStyle</td><td>inherited</td><td>object (style)</td><td>为TabBar定义样式</td></tr><tr><td>tabBarShadowStyle</td><td>inherited</td><td>object (style)</td><td>为TabBar定义阴影样式</td></tr><tr><td>hidesTabTouch</td><td>false</td><td>boolean</td><td>禁用选项卡的onPress</td></tr></tbody></table><h3 id="3-TabNavigator-Item常用属性"><a href="#3-TabNavigator-Item常用属性" class="headerlink" title="3. TabNavigator.Item常用属性"></a>3. TabNavigator.Item常用属性</h3><table><thead><tr><th>属性</th><th>默认值</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>renderIcon</td><td>none</td><td>function</td><td>选项卡图标</td></tr><tr><td>renderSelectedIcon</td><td>none</td><td>function</td><td>选项卡选中状态图标</td></tr><tr><td>badgeText</td><td>none</td><td>string or number</td><td>图标右上角显示</td></tr><tr><td>title</td><td>none</td><td>string</td><td>tabbar标题</td></tr><tr><td>titleStyle</td><td>inherited</td><td>style</td><td>标题样式</td></tr><tr><td>selectedTitleStyle</td><td>inherited</td><td>style</td><td>选中状态标题样式</td></tr><tr><td>tabStyle</td><td>inherited</td><td>style</td><td>选项卡样式</td></tr><tr><td>hidesTabTouch</td><td>false</td><td>boolean</td><td>是否选中该tabbar</td></tr><tr><td>onPress</td><td>none</td><td>function</td><td>选项卡的点击方法</td></tr><tr><td>allowFontScaling</td><td>false</td><td>boolean</td><td>允许标题的字体缩放</td></tr></tbody></table><ul><li>使用示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;TabNavigator&gt;</span><br><span class="line">                &lt;TabNavigator.Item title=&apos;首页&apos;</span><br><span class="line">                                   selected=&#123;this.state.selectedIndex == 0&#125;</span><br><span class="line">                                   titleStyle=&#123;&#123;color:&apos;#9d9d9d&apos;&#125;&#125;</span><br><span class="line">                                   selectedTitleStyle=&#123;&#123;color:&apos;#ed7f30&apos;&#125;&#125;</span><br><span class="line">                                   badgeText=&apos;首页&apos;</span><br><span class="line">                                   allowFontScaling=&#123;false&#125;</span><br><span class="line">                                   renderIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:&apos;btn_home_normal&apos;&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   renderSelectedIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:&apos;btn_home_selected&apos;&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   onPress=&#123;()=&gt;</span><br><span class="line">                                       this.setState(&#123;</span><br><span class="line">                                           selectedIndex:0</span><br><span class="line">                                       &#125;)</span><br><span class="line">                                   &#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;[styles.viewStyle, &#123;backgroundColor:&apos;red&apos;&#125;]&#125;&gt;</span><br><span class="line">                        &lt;Text&gt;首页&lt;/Text&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line">                &lt;/TabNavigator.Item&gt;</span><br><span class="line"></span><br><span class="line">                &lt;TabNavigator.Item title=&apos;我的&apos;</span><br><span class="line">                                   selected=&#123;this.state.selectedIndex == 1&#125;</span><br><span class="line">                                   titleStyle=&#123;&#123;color:&apos;#9d9d9d&apos;&#125;&#125;</span><br><span class="line">                                   selectedTitleStyle=&#123;&#123;color:&apos;#ed7f30&apos;&#125;&#125;</span><br><span class="line">                                   badgeText=&#123;10&#125;</span><br><span class="line">                                   renderIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:&apos;btn_user_normal&apos;&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   renderSelectedIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:&apos;btn_user_selected&apos;&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   onPress=&#123;()=&gt;</span><br><span class="line">                                       this.setState(&#123;</span><br><span class="line">                                           selectedIndex:1</span><br><span class="line">                                       &#125;)</span><br><span class="line">                                   &#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;[styles.viewStyle, &#123;backgroundColor:&apos;green&apos;&#125;]&#125;&gt;</span><br><span class="line">                        &lt;Text&gt;我的&lt;/Text&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/TabNavigator.Item&gt;</span><br><span class="line">            &lt;/TabNavigator&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> TabBariOS </tag>
            
            <tag> TabNavigator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React Native之导航组件NavigatorIOS和Navigator</title>
      <link href="/2018/01/05/React%20Native%E4%B9%8B%E5%AF%BC%E8%88%AA%E7%BB%84%E4%BB%B6NavigatorIOS%E5%92%8CNavigator"/>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4122543-d1e3e673185be43f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="Navigator.png"></p><h2 id="一-NavigatorIOS"><a href="#一-NavigatorIOS" class="headerlink" title="一. NavigatorIOS"></a>一. NavigatorIOS</h2><ul><li><code>NavigatorIOS</code>是一个包装<code>UINavigationController</code>，能够实现一个导航堆栈, 且只能在iOS上使用的组件</li><li>它的工作原理与使用本地应用程序<code>UINavigationController</code>的效果完全相同，从<code>UIKIt</code>提供相同的动画和行为</li></ul><h3 id="1-常用属性"><a href="#1-常用属性" class="headerlink" title="1. 常用属性"></a>1. 常用属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//样式, 必须设置&#123;flex:1&#125;, 否则看不到子控件</span><br><span class="line">style=&#123;&#123;flex:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">//导航条的背景颜色</span><br><span class="line">barTintColor=&apos;yellow&apos;</span><br><span class="line"></span><br><span class="line">//为true , 隐藏导航栏</span><br><span class="line">navigationBarHidden=&#123;false&#125;</span><br><span class="line"></span><br><span class="line">//是否隐藏阴影，true／false。</span><br><span class="line">shadowHidden=&#123;false&#125;</span><br><span class="line"></span><br><span class="line">//导航栏上按钮的颜色设置</span><br><span class="line">tintColor=&apos;black&apos;</span><br><span class="line"></span><br><span class="line">//导航栏上标题的颜色设置</span><br><span class="line">titleTextColor=&apos;blue&apos;</span><br><span class="line"></span><br><span class="line">//导航栏是否是半透明的，true／false。</span><br><span class="line">translucent=&#123;true&#125;</span><br></pre></td></tr></table></figure><h3 id="2-NavigatorIOS的使用"><a href="#2-NavigatorIOS的使用" class="headerlink" title="2. NavigatorIOS的使用"></a>2. NavigatorIOS的使用</h3><ul><li>必须初始化路由: <code>initialRoute{}</code></li><li>注意:<code>component</code>，需要传入组件，自定义组件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//用于初始化路由。其参数对象中的各个属性如下：</span><br><span class="line">initialRoute：</span><br><span class="line"> &#123;</span><br><span class="line">  component: function, //加载的视图组件</span><br><span class="line">  title: string, //当前视图的标题</span><br><span class="line">  passPros: object, //传递的数据</span><br><span class="line">  backButtonIcon: Image.propTypes.source, // 后退按钮图标</span><br><span class="line">  backButtonTitle: string, //后退按钮标题</span><br><span class="line">  leftButtonIcon: Image.propTypes.soruce, // 左侧按钮图标</span><br><span class="line">  leftButtonTitle: string, //左侧按钮标题</span><br><span class="line">  onLeftButtonPress: function, //左侧按钮点击事件</span><br><span class="line">  rightButtonIcon: Image.propTypes.soruce, // 右侧按钮图标</span><br><span class="line">  rightButtonTitle: string, //右侧按钮标题</span><br><span class="line">  onRightButtonPress: function, //右侧按钮点击事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavigatorIOS initialRoute=&#123;</span><br><span class="line">        &#123;</span><br><span class="line">        //JunNavigatorView: 为自定义的组件</span><br><span class="line">            component:JunNavigatorView,</span><br><span class="line">            title: &apos;首页&apos;,</span><br><span class="line">            leftButtonTitle:&apos;左按钮&apos;,</span><br><span class="line">            rightButtonTitle:&apos;跳转&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3 id="3-页面间的跳转"><a href="#3-页面间的跳转" class="headerlink" title="3. 页面间的跳转"></a>3. 页面间的跳转</h3><ul><li>获取Navigator，只有它才能跳转</li><li>只要是导航控制器下的组件，都可以通过props获取</li><li><code>this.props.navigator</code></li><li>界面跳转方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pust(route)：//加载一个新的页面（视图或者路由）并且路由到该页面。</span><br><span class="line">pop()：//返回到上一个页面。</span><br><span class="line">popN(n)：//一次性返回N个页面。当 N=1 时，相当于 pop() 方法的效果。</span><br><span class="line">replace(route)：//替换当前的路由。</span><br><span class="line">replacePrevious（route）：//替换前一个页面的视图并且回退过去。</span><br><span class="line">resetTo(route)：//取代最顶层的路由并且回退过去。</span><br><span class="line">popToTop()：//回到最上层视图。</span><br></pre></td></tr></table></figure><ul><li>使用示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text onPress=&#123;()=&gt;&#123;</span><br><span class="line">    this.props.navigator.push(&#123;</span><br><span class="line">        component:JunTwoView,</span><br><span class="line">        title:&apos;第二页面&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br><span class="line">&gt;点击跳转到第二个页面&lt;/Text&gt;</span><br></pre></td></tr></table></figure><h2 id="二-Navigator"><a href="#二-Navigator" class="headerlink" title="二. Navigator"></a>二. Navigator</h2><ul><li><code>Navigator</code>很好解决了<code>NavigatorIOS</code>不能跨平台和自定义的问题</li><li>RN开发中通常使用<code>Navigator</code></li><li>Navigator作用：只提供跳转功能，支持iOS,安卓</li><li>导航条需要自定义，需要导航条的界面，自己添加<br>只要一个控件，包装成Navigator就能获取跳转功能</li></ul><h3 id="1-Navigator导入问题"><a href="#1-Navigator导入问题" class="headerlink" title="1. Navigator导入问题"></a>1. Navigator导入问题</h3><ul><li>在0,43版本之前(包括0.43), <code>Navigator</code>在<code>react-native</code>库中</li><li>从0.44版本开始<code>Navigator</code>就被移入了<code>react-native-deprecated-custom-components</code>库中</li><li>使用前,先进入当前项目文件，安装Navigator所在的库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//终端输入</span><br><span class="line">yarn add react-native-deprecated-custom-components</span><br><span class="line"></span><br><span class="line">//下面方法可能已经失效(亲测失败)</span><br><span class="line">npm install react-native-deprecated-custom-components --save</span><br></pre></td></tr></table></figure><ul><li>下载完成后，导入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Navigator的使用"><a href="#2-Navigator的使用" class="headerlink" title="2. Navigator的使用"></a>2. Navigator的使用</h3><h4 id="2-1-initialRoute：-初始化路由"><a href="#2-1-initialRoute：-初始化路由" class="headerlink" title="2-1. initialRoute： 初始化路由"></a>2-1. <code>initialRoute</code>： 初始化路由</h4><ul><li>定义启动时加载的路由</li><li>路由是导航栏用来识别渲染场景的一个对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Navigator initialRoute=&#123;&#123;component: JunOneView&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure><h4 id="2-2-配置场景动画和手势"><a href="#2-2-配置场景动画和手势" class="headerlink" title="2-2. 配置场景动画和手势"></a>2-2. 配置场景动画和手势</h4><ul><li>可选的函数, 设置跳转方向</li><li>会带有两个参数调用，一个是当前的路由，一个是当前的路由栈</li><li>返回一个场景配置对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_configureScene(route, routeStack) &#123;</span><br><span class="line">    return Navigator.SceneConfigs.PushFromLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他跳转方向参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Navigator.SceneConfigs.PushFromRight (默认)</span><br><span class="line">Navigator.SceneConfigs.FloatFromRight</span><br><span class="line">Navigator.SceneConfigs.FloatFromLeft</span><br><span class="line">Navigator.SceneConfigs.FloatFromBottom</span><br><span class="line">Navigator.SceneConfigs.FloatFromBottomAndroid</span><br><span class="line">Navigator.SceneConfigs.FadeAndroid</span><br><span class="line">Navigator.SceneConfigs.HorizontalSwipeJump</span><br><span class="line">Navigator.SceneConfigs.HorizontalSwipeJumpFromRight</span><br><span class="line">Navigator.SceneConfigs.VerticalUpSwipeJump</span><br><span class="line">Navigator.SceneConfigs.VerticalDownSwipeJump</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-渲染指定路由的场景"><a href="#2-3-渲染指定路由的场景" class="headerlink" title="2-3. 渲染指定路由的场景"></a>2-3. 渲染指定路由的场景</h4><ul><li>必要参数, 调用的参数是路由和导航器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_renderScene(route, navigator) &#123;</span><br><span class="line">        // ...扩展符, 作用:如果是对象,就获取对象中所有值,如果是数组,就获取数组中所有值</span><br><span class="line">    return (&lt;route.component navigator=&#123;navigator&#125; &#123;... route.props&#125;/&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-设置导航尺寸"><a href="#2-4-设置导航尺寸" class="headerlink" title="2-4. 设置导航尺寸"></a>2-4. 设置导航尺寸</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=&#123;&#123;flex:1&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-其他属性或方法"><a href="#3-其他属性或方法" class="headerlink" title="3. 其他属性或方法"></a>3. 其他属性或方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onDidFocus function </span><br><span class="line">//每当导航切换完成或初始化之后，调用此回调，参数为新场景的路由。</span><br><span class="line"></span><br><span class="line">onWillFocus function </span><br><span class="line">//会在导航切换之前调用，参数为目标路由。</span><br></pre></td></tr></table></figure><h2 id="三-延展符"><a href="#三-延展符" class="headerlink" title="三. 延展符"></a>三. 延展符</h2><ul><li>文中用到了一个操作符: <code>...</code>即为延展符</li><li>延展符的作用<ul><li>遍历数组</li><li>遍历对象的属性,一个一个传值给下一个控件</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, 3, 4, 5]</span><br><span class="line">var arr2 = [0]</span><br><span class="line">        </span><br><span class="line">arr2.push(...arr1)</span><br><span class="line">console.log(arr2)</span><br><span class="line">//输出结果: [0, 1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><ul><li>作用等同于<code>JavaScript</code>数组中的concat方法</li><li>区别在于<code>concat</code>只能作用于数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, 3, 4, 5]</span><br><span class="line">var arr2 = [0]</span><br><span class="line"></span><br><span class="line">// arr2.push(...arr1)</span><br><span class="line">arr2 = arr2.concat(arr1)</span><br><span class="line">console.log(arr2)</span><br><span class="line">//输出结果: [0, 1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><blockquote><h4 id="关于JavaScript的数组语法-请查看我的另一篇文章JavaScript基本语法01"><a href="#关于JavaScript的数组语法-请查看我的另一篇文章JavaScript基本语法01" class="headerlink" title="关于JavaScript的数组语法, 请查看我的另一篇文章JavaScript基本语法01"></a>关于<code>JavaScript</code>的数组语法, 请查看我的另一篇文章<a href="https://www.jianshu.com/p/b15d884772c2" target="_blank" rel="noopener">JavaScript基本语法01</a></h4></blockquote>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> NavigatorIOS </tag>
            
            <tag> Navigator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactNaive之ScrollView和ListView</title>
      <link href="/2018/01/03/ReactNaive%E4%B9%8BScrollView%E5%92%8CListView"/>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4122543-45456c9ba9799576.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="ListView.png"></p><h2 id="一-ScrollView"><a href="#一-ScrollView" class="headerlink" title="一. ScrollView"></a>一. ScrollView</h2><ul><li>记住ScrollView必须有一个确定的高度才能正常工作，因为它实际上所做的就是将一系列不确定高度的子组件装进一个确定高度的容器（通过滚动操作）</li><li>要给一个ScrollView确定一个高度的话，要么直接给它设置高度（不建议），要么确定所有的父容器都有确定的高度</li><li><h3 id="1-ScrollView常用的属性"><a href="#1-ScrollView常用的属性" class="headerlink" title="1. ScrollView常用的属性"></a>1. ScrollView常用的属性</h3></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">horizontal <span class="keyword">bool</span> </span><br><span class="line"><span class="comment">//当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。</span></span><br><span class="line"></span><br><span class="line">showsHorizontalScrollIndicator <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当此属性为true的时候，显示一个水平方向的滚动条。</span></span><br><span class="line">showsVerticalScrollIndicator <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当此属性为true的时候，显示一个垂直方向的滚动条。</span></span><br><span class="line"></span><br><span class="line">alwaysBounceHorizontal <span class="keyword">bool</span> </span><br><span class="line"><span class="comment">//当此属性为true时，水平方向即使内容比滚动视图本身还要小，也可以弹性地拉动一截。当horizontal=&#123;true&#125;时默认值为true，否则为false。</span></span><br><span class="line"></span><br><span class="line">refreshControl element </span><br><span class="line"><span class="comment">//指定RefreshControl组件，用于为ScrollView提供下拉刷新功能</span></span><br><span class="line"></span><br><span class="line">(ios) alwaysBounceVertical <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当此属性为true时，垂直方向即使内容比滚动视图本身还要小，也可以弹性地拉动一截。</span></span><br><span class="line"><span class="comment">//当horizontal=&#123;true&#125;时默认值为false，否则为true。</span></span><br><span class="line"></span><br><span class="line">(ios) automaticallyAdjustContentInsets <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当滚动视图放在一个导航条或者工具条后面的时候，iOS系统是否要自动调整内容的范围。默认值为true。（译注：如果你的ScrollView或ListView的头部出现莫名其妙的空白，尝试将此属性置为false）</span></span><br><span class="line"></span><br><span class="line">(ios) bounces <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当值为true时，如果内容范围比滚动视图本身大，在到达内容末尾的时候，可以弹性地拉动一截。如果为false，尾部的所有弹性都会被禁用，即使alwaysBounce*属性为true。默认值为true。</span></span><br><span class="line"></span><br><span class="line">(ios) bouncesZoom <span class="keyword">bool</span> </span><br><span class="line"><span class="comment">//当值为true时，使用手势缩放内容可以超过min/max的限制，然后在手指抬起之后弹回min/max的缩放比例。否则的话，缩放不能超过限制。</span></span><br><span class="line"></span><br><span class="line">(ios) contentInset &#123;top: number, left: number, bottom: number, right: number&#125; </span><br><span class="line"><span class="comment">//内容范围相对滚动视图边缘的坐标。默认为&#123;0, 0, 0, 0&#125;</span></span><br><span class="line"></span><br><span class="line">(ios) contentOffset PointPropType</span><br><span class="line"><span class="comment">//用来手动设置初始的滚动坐标。默认值为&#123;x: 0, y: 0&#125;</span></span><br><span class="line"></span><br><span class="line">pagingEnabled <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。</span></span><br><span class="line"></span><br><span class="line">scrollEnabled <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当值为false的时候，内容不能滚动，默认值为true。</span></span><br><span class="line"></span><br><span class="line">(ios) scrollEventThrottle number</span><br><span class="line"><span class="comment">//这个属性控制在滚动过程中，scroll事件被调用的频率（单位是每秒事件数量）。更大的数值能够更及时的跟踪滚动位置，不过可能会带来性能问题，因为更多的信息会通过bridge传递。默认值为0，意味着每次视图被滚动，scroll事件只会被调用一次。</span></span><br><span class="line"></span><br><span class="line">(ios)scrollIndicatorInsets &#123;top: number, left: number, bottom: number, right: number&#125; </span><br><span class="line"><span class="comment">//决定滚动条距离视图边缘的坐标。这个值应该和contentInset一样。默认值为&#123;0, 0, 0, 0&#125;。</span></span><br><span class="line"></span><br><span class="line">(ios) scrollsToTop <span class="keyword">bool</span> </span><br><span class="line"><span class="comment">//当此值为true时，点击状态栏的时候视图会滚动到顶部。默认值为true。</span></span><br><span class="line"></span><br><span class="line">stickyHeaderIndices [number]</span><br><span class="line"><span class="comment">//一个子视图下标的数组，用于决定哪些成员会在滚动之后固定在屏幕顶端。</span></span><br><span class="line"><span class="comment">//举个例子，传递stickyHeaderIndices=&#123;[0]&#125;会让第一个成员固定在滚动视图顶端。</span></span><br><span class="line"><span class="comment">//这个属性不能和horizontal=&#123;true&#125;一起使用。</span></span><br><span class="line"></span><br><span class="line">(ios) maximumZoomScale number </span><br><span class="line"><span class="comment">//允许的最大缩放比例。默认值为1.0。</span></span><br><span class="line"></span><br><span class="line">(ios) minimumZoomScale number </span><br><span class="line"><span class="comment">//允许的最小缩放比例。默认值为1.0。</span></span><br></pre></td></tr></table></figure><h3 id="2-ScrollView常用的方法"><a href="#2-ScrollView常用的方法" class="headerlink" title="2. ScrollView常用的方法"></a>2. ScrollView常用的方法</h3><ul><li>开发中，常需要在滚动的时候做事情，那怎么监听ScrollView滚动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 监听滚动开始</span><br><span class="line">onMomentumScrollBegin=&#123;this._onMomentumScrollBegin.bind(this)&#125;</span><br><span class="line"></span><br><span class="line">// 监听滚动结束</span><br><span class="line">onMomentumScrollEnd=&#123;this._onMomentumScrollEnd.bind(this)&#125;</span><br><span class="line"></span><br><span class="line">// 监听开始拖拽</span><br><span class="line">onScrollBeginDrag=&#123;this._onScrollBeginDrag.bind(this)&#125;</span><br><span class="line"></span><br><span class="line">// 监听结束拖拽</span><br><span class="line">onScrollEndDrag=&#123;this._onScrollEndDrag.bind(this)&#125;</span><br><span class="line"></span><br><span class="line">// 监听滚动动画完成</span><br><span class="line">onScrollAnimationEnd=&#123;this._onScrollAnimationEnd.bind(this)&#125;</span><br><span class="line"></span><br><span class="line">onMomentumScrollStart?: function </span><br><span class="line">//滚动动画开始时调用此函数。</span><br><span class="line"></span><br><span class="line">onMomentumScrollEnd?: function </span><br><span class="line">//滚动动画结束时调用此函数。</span><br><span class="line"></span><br><span class="line">// 监听滚动的时候</span><br><span class="line">onScroll=&#123;this._onScroll.bind(this)&#125;</span><br><span class="line"></span><br><span class="line">// 设置滚动频率,一滚动就监听,需要和onScroll配套使用</span><br><span class="line">scrollEventThrottle=&#123;1&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scrollTo(y: number | &#123; x?: number, y?: number, animated?: boolean &#125;, x: number, animated: boolean) </span><br><span class="line">//滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画。</span><br><span class="line">//使用示例:</span><br><span class="line">scrollTo(&#123;x: 0, y: 0, animated: true&#125;)</span><br><span class="line"></span><br><span class="line">scrollToEnd(options?) </span><br><span class="line">//滚动到视图底部（水平方向的视图则滚动到最右边）。</span><br><span class="line">//加上动画参数 scrollToEnd(&#123;animated: true&#125;)则启用平滑滚动动画，或是调用 scrollToEnd(&#123;animated: false&#125;)来立即跳转。如果不使用参数，则animated选项默认启用。</span><br></pre></td></tr></table></figure><h3 id="3-获取原生事件"><a href="#3-获取原生事件" class="headerlink" title="3. 获取原生事件"></a>3. 获取原生事件</h3><ul><li>滚动的时候,会传入一个合成事件作为监听滚动方法的参数，每个方法都会有这个合成事件</li><li>通过合成事件能获取原生事件nativeEvent,原生事件nativeEvent会有我们想要的信息.</li><li>什么是合成事件：在RN中，事件的处理由其内部自己实现的事件系统完成，触发的事件都叫做 合成事件（SyntheticEvent）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 滚动完成的时候调用</span><br><span class="line">_onMomentumScrollEnd(e)&#123;</span><br><span class="line">    // 获取原生事件</span><br><span class="line">    var nativeEvent = e.nativeEvent</span><br><span class="line">    //获取当前偏移量</span><br><span class="line">    var contentX = nativeEvent.contentOffset.x</span><br><span class="line">    //当前页</span><br><span class="line">    var page = contentX / kScreenWidth</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        currentPage:page</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-ListView"><a href="#二-ListView" class="headerlink" title="二. ListView"></a>二. ListView</h2><ul><li>官方文档提示: 在0.46版本开始此组件已过期, 并推荐使用<code>FlatList</code>或<code>SectionList</code>替代, 但是在0.51版本依然可以使用</li><li><code>ListView</code>: 一个核心组件，用于高效地显示一个可以垂直滚动的变化的数据列表</li><li>ListView内部是通过<code>ListViewDataSource</code>这个对象，显示数据，因此使用ListView必须先创建<code>ListViewDataSource</code>对象。</li><li><code>ListViewDataSource</code>构造方法(创建对象):可选择性传入4个参数,描述怎么提取数据，怎么刷新cell</li><li>这些参数：都是函数，当产生对应的事件的时候，会自动执行这些函数.</li></ul><h3 id="1-ListView常用的属性和方法"><a href="#1-ListView常用的属性和方法" class="headerlink" title="1. ListView常用的属性和方法"></a>1. ListView常用的属性和方法</h3><ul><li>ListView可以使用所有ScrollView的属性。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialListSize number </span><br><span class="line">//指定在组件刚挂载的时候渲染多少行数据。用这个属性来确保首屏显示合适数量的数据，而不是花费太多帧逐步显示出来</span><br><span class="line"></span><br><span class="line">dataSource ListViewDataSource </span><br><span class="line">//ListView.DataSource实例（列表依赖的数据源）</span><br></pre></td></tr></table></figure><ul><li><code>ListViewDataSource</code>构造函数可以接受下列四种参数（都是可选）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getRowData(dataBlob, sectionID, rowID);</span><br><span class="line">//怎么获取行数据</span><br><span class="line">getSectionHeaderData(dataBlob, sectionID);</span><br><span class="line">//怎么获取每一组头部数据</span><br><span class="line">rowHasChanged(prevRowData, nextRowData);</span><br><span class="line">//决定什么情况行数据才发生改变，当行数据发生改变，就会绘制下一行cell</span><br><span class="line">sectionHeaderHasChanged(prevSectionData, nextSectionData);</span><br><span class="line">//决定什么情况头部数据才发生改变，当行数据发生改变，就会绘制下一行cell</span><br></pre></td></tr></table></figure><ul><li><code>ListViewDataSource</code>为<code>ListView</code>组件提供高性能的数据处理和访问。我们需要调用clone方法从原始输入数据中抽取数据来创建<code>ListViewDataSource</code>对象。</li><li>要更新<code>datasource</code>中的数据，请（每次都重新）调用<code>cloneWithRows</code>方法（如果用到了section，则对应<code>cloneWithRowsAndSections</code>方法）clone方法会自动提取新数据并进行逐行对比（使用<code>rowHasChanged</code>方法中的策略），这样<code>ListView</code>就知道哪些行需要重新渲染了</li><li>注意：初始化<code>ListViewDataSource</code>的时候，如果不需要修改提取数据的方式，只需要实现<code>rowHasChanged</code>，告诉什么时候刷新下一行数据.</li><li>注意：默认<code>ListViewDataSource</code>有提取数据方式，可以使用默认的提取方式.</li></ul><h3 id="2-ListView使用步骤"><a href="#2-ListView使用步骤" class="headerlink" title="2. ListView使用步骤"></a>2. ListView使用步骤</h3><ul><li>1). 创建数据源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1. 创建数据源对象</span><br><span class="line">var datas = new ListView.DataSource(&#123;</span><br><span class="line">    //设置数据改变的时候刷新下一行数据</span><br><span class="line">    rowHasChanged: (r1, r2)=&gt;&#123;r1 != r2&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//2. 请求数据&apos;</span><br><span class="line">var foodArr = require(&apos;./Resource/food.json&apos;)</span><br><span class="line"></span><br><span class="line">//3. 设置数据</span><br><span class="line">datas = datas.cloneWithRows(foodArr)</span><br><span class="line"></span><br><span class="line">//5. 保存数据源</span><br><span class="line">this.state = &#123;</span><br><span class="line">    dataArr: datas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2). ListView实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView style=&#123;&#123;backgroundColor:&apos;white&apos;, marginTop:20&#125;&#125;</span><br><span class="line">    //设置数据源</span><br><span class="line">          dataSource=&#123;this.state.dataArr&#125;</span><br><span class="line">    //渲染哪一行(设置cell样式)</span><br><span class="line">          renderRow=&#123;this._renderRow.bind(this)&#125;</span><br><span class="line">          //设置头部样式</span><br><span class="line">          renderHeader=&#123;this._renderHeader.bind(this)&#125;</span><br><span class="line">          //设置section的头部样式</span><br><span class="line">          renderSectionHeader=&#123;this._renderSectionHeader.bind(this)&#125;</span><br><span class="line">          //设置尾部样式</span><br><span class="line">          renderFooter=&#123;this._renderFooter.bind(this)&#125;</span><br><span class="line">          //设置分割线样式</span><br><span class="line">          renderSeparator=&#123;this._renderSeparator.bind(this)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ul><li>3). 相关属性方法介绍<ul><li>renderRow: 设置每行cell样式</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 实现数据源方法,设置每行cell样式</span><br><span class="line">/*这个方法会自动传入四个参数(rowData,sectionID,rowID,highlightRow)</span><br><span class="line">rowData:当前行数据</span><br><span class="line">sectionID:当前行所在组ID</span><br><span class="line">rowID：哪一行的角标</span><br><span class="line">highlightRow:高亮函数</span><br><span class="line">*/</span><br><span class="line">    _renderRow(rowData, sectionID, rowID, highlightRow) &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>ListView头部和尾部视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//头部视图</span><br><span class="line"> _renderHeader() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Text&gt;头部视图&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">//尾部视图</span><br><span class="line"> _renderFooter() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Text&gt;尾部视图&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>renderSectionHeader: 设置每一个section的头部样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//sectionData: 每一组的头部数据</span><br><span class="line">//sectionID: 组ID</span><br><span class="line">_renderSectionHeader(sectionData, sectionID)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ListView分割线<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 哪一组,哪一行,相邻行是否高亮</span><br><span class="line">   _renderSeparator(sectionID, rowID, adjacentRowHighlighted)  &#123;</span><br><span class="line">       console.log(sectionID,rowID,adjacentRowHighlighted);</span><br><span class="line">       return (</span><br><span class="line">           &lt;View style=&#123;&#123;height:1,backgroundColor:&apos;black&apos;&#125;&#125;&gt;&lt;/View&gt;</span><br><span class="line">       )</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> ScrollView </tag>
            
            <tag> ListView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift语音和文本的转换</title>
      <link href="/2017/12/10/Swift%E8%AF%AD%E9%9F%B3%E5%92%8C%E6%96%87%E6%9C%AC%E7%9A%84%E8%BD%AC%E6%8D%A2"/>
      <content type="html"><![CDATA[<blockquote><p>谈到语音和文本的转换, 就要说到语音转文本和文本转语音两大技术</p><ul><li>文本转语音是iOS7以后的技术, 用到的是AVFoundation框架</li><li>语音转文本是iOS10以后, 苹果发布的一个<a href="https://developer.apple.com/documentation/speech" target="_blank" rel="noopener">Speech</a>框架</li><li>下面先介绍一下简单的文本转语音</li><li><a href="https://github.com/CoderTitan/TextAndVoice" target="_blank" rel="noopener">GitHub上Demo地址</a></li><li>项目包括<ul><li>文本转语音</li><li>实时语音转文本</li><li>本地语音转文本</li><li>录音保存本地,转文本</li></ul></li></ul></blockquote><h2 id="一-文本转语音"><a href="#一-文本转语音" class="headerlink" title="一. 文本转语音"></a>一. 文本转语音</h2><ul><li>文本转语音技术, 简称TTS (是<code>Text To Speech</code>的缩写), <a href="https://developer.apple.com/documentation/avfoundation/speech_synthesis" target="_blank" rel="noopener">语音合成苹果官方文档</a></li><li>是苹果iOS7以后新增的功能, 使用AVFoundation 库</li><li>下面介绍一下需要用到的类</li></ul><h3 id="1-AVSpeechSynthesizer-语音合成器"><a href="#1-AVSpeechSynthesizer-语音合成器" class="headerlink" title="1. AVSpeechSynthesizer: 语音合成器"></a>1. <code>AVSpeechSynthesizer</code>: 语音合成器</h3><h4 id="1-1-属性"><a href="#1-1-属性" class="headerlink" title="1-1. 属性"></a>1-1. 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//是否正在语音播放</span><br><span class="line">open var isSpeaking: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//是否停止语音播放</span><br><span class="line">open var isPaused: Bool &#123; get &#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1-2. 方法"></a>1-2. 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//播放语音</span><br><span class="line">open func speak(_ utterance: AVSpeechUtterance)</span><br><span class="line"></span><br><span class="line">//停止语音播放</span><br><span class="line">open func stopSpeaking(at boundary: AVSpeechBoundary) -&gt; Bool</span><br><span class="line"></span><br><span class="line">//暂停语音播放</span><br><span class="line">open func pauseSpeaking(at boundary: AVSpeechBoundary) -&gt; Bool</span><br><span class="line"></span><br><span class="line">//继续语音播放</span><br><span class="line">open func continueSpeaking() -&gt; Bool</span><br><span class="line"></span><br><span class="line">//(iOS10以上, 输出通道)</span><br><span class="line">open var outputChannels: [AVAudioSessionChannelDescription]?</span><br></pre></td></tr></table></figure><h3 id="2-AVSpeechBoundary"><a href="#2-AVSpeechBoundary" class="headerlink" title="2. AVSpeechBoundary"></a>2. AVSpeechBoundary</h3><ul><li>描述语音可能被暂停或停止的枚举值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case immediate</span><br><span class="line">//表示发言应该暂停或立即停止。</span><br><span class="line"></span><br><span class="line">case word</span><br><span class="line">//说完整个词语之后再暂停或者停止</span><br></pre></td></tr></table></figure><h3 id="3-AVSpeechUtterance"><a href="#3-AVSpeechUtterance" class="headerlink" title="3. AVSpeechUtterance"></a>3. AVSpeechUtterance</h3><ul><li>可以将文本和成一段语音的类, 或者说就是一段要播放的语音<h4 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3-1. 属性"></a>3-1. 属性</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//使用的声音</span><br><span class="line">open var voice: AVSpeechSynthesisVoice?</span><br><span class="line"></span><br><span class="line">//文本属性    </span><br><span class="line">open var speechString: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//富文本属性</span><br><span class="line">@available(iOS 10.0, *)</span><br><span class="line">open var attributedSpeechString: NSAttributedString &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//说话的速度    </span><br><span class="line">open var rate: Float </span><br><span class="line">//提供了两个语速 AVSpeechUtteranceMinimumSpeechRate和 AVSpeechUtteranceMaximumSpeechRate和AVSpeechUtteranceDefaultSpeechRate</span><br><span class="line"></span><br><span class="line">//说话的基线音高, [0.5 - 2] Default = 1   </span><br><span class="line">open var pitchMultiplier: Float </span><br><span class="line"></span><br><span class="line">//说话音量, [0-1] Default = 1</span><br><span class="line">open var volume: Float </span><br><span class="line"></span><br><span class="line">//开始一段语音之前等待的时间</span><br><span class="line">open var preUtteranceDelay: TimeInterval </span><br><span class="line"></span><br><span class="line">//语音合成器在当前语音结束之后处理下一个排队的语音之前需要等待的时间, 默认0.0 </span><br><span class="line">open var postUtteranceDelay: TimeInterval</span><br></pre></td></tr></table></figure><h4 id="3-2-初始化方法"><a href="#3-2-初始化方法" class="headerlink" title="3-2. 初始化方法"></a>3-2. 初始化方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public init(string: String)</span><br><span class="line"></span><br><span class="line">@available(iOS 10.0, *)</span><br><span class="line">public init(attributedString string: NSAttributedString)</span><br></pre></td></tr></table></figure><h3 id="4-AVSpeechSynthesisVoice"><a href="#4-AVSpeechSynthesisVoice" class="headerlink" title="4. AVSpeechSynthesisVoice"></a>4. AVSpeechSynthesisVoice</h3><ul><li>用于语音合成的独特声音, 主要是不同的语言和地区</li><li>所支持的所有语言种类详见最底部附录</li></ul><h4 id="4-1-相关属性"><a href="#4-1-相关属性" class="headerlink" title="4-1. 相关属性"></a>4-1. 相关属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//获得当前的语言</span><br><span class="line">open var language: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//返回用户当前语言环境的代码</span><br><span class="line">@available(iOS 9.0, *)</span><br><span class="line">open var identifier: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line">@available(iOS 9.0, *)</span><br><span class="line">open var name: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line">@available(iOS 9.0, *)</span><br><span class="line">open var quality: AVSpeechSynthesisVoiceQuality &#123; get &#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-相关方法"><a href="#4-2-相关方法" class="headerlink" title="4-2. 相关方法"></a>4-2. 相关方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init?(language: String?)</span><br><span class="line">//返回指定语言和语言环境的语音对象。</span><br><span class="line"></span><br><span class="line">class func speechVoices()</span><br><span class="line">//返回所有可用的语音。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class func currentLanguageCode()</span><br><span class="line">//返回用户当前语言环境的代码。</span><br></pre></td></tr></table></figure><h3 id="5-AVSpeechSynthesizerDelegate代理"><a href="#5-AVSpeechSynthesizerDelegate代理" class="headerlink" title="5. AVSpeechSynthesizerDelegate代理"></a>5. AVSpeechSynthesizerDelegate代理</h3><ul><li>所有代理方法都是支持iOS7.0以上的系统</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//开始播放</span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didStart utterance: AVSpeechUtterance)</span><br><span class="line"></span><br><span class="line">//播放完成</span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance)</span><br><span class="line"></span><br><span class="line">//暂停播放</span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didPause utterance: AVSpeechUtterance)</span><br><span class="line"></span><br><span class="line">//继续播放</span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didContinue utterance: AVSpeechUtterance)</span><br><span class="line"></span><br><span class="line">//取消播放</span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didCancel utterance: AVSpeechUtterance)</span><br><span class="line"></span><br><span class="line">//将要播放某一段话  </span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, willSpeakRangeOfSpeechString characterRange: NSRange, utterance: AVSpeechUtterance)</span><br></pre></td></tr></table></figure><h3 id="6-具体功能的核心代码"><a href="#6-具体功能的核心代码" class="headerlink" title="6. 具体功能的核心代码"></a>6. 具体功能的核心代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//MARK: 开始/停止转换</span><br><span class="line">extension TextToVoiceController&#123;</span><br><span class="line">    //开始转换</span><br><span class="line">    fileprivate func startTranslattion()&#123;</span><br><span class="line">        //1. 创建需要合成的声音类型</span><br><span class="line">        let voice = AVSpeechSynthesisVoice(language: &quot;zh-CN&quot;)</span><br><span class="line">        </span><br><span class="line">        //2. 创建合成的语音类</span><br><span class="line">        let utterance = AVSpeechUtterance(string: textView.text)</span><br><span class="line">        utterance.rate = AVSpeechUtteranceDefaultSpeechRate</span><br><span class="line">        utterance.voice = voice</span><br><span class="line">        utterance.volume = 1</span><br><span class="line">        utterance.postUtteranceDelay = 0.1</span><br><span class="line">        utterance.pitchMultiplier = 1</span><br><span class="line">        //开始播放</span><br><span class="line">        avSpeech.speak(utterance)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //暂停播放</span><br><span class="line">    fileprivate func pauseTranslation()&#123;</span><br><span class="line">        avSpeech.pauseSpeaking(at: .immediate)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //继续播放</span><br><span class="line">    fileprivate func continueSpeek()&#123;</span><br><span class="line">        avSpeech.continueSpeaking()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //取消播放</span><br><span class="line">    fileprivate func cancleSpeek()&#123;</span><br><span class="line">        avSpeech.stopSpeaking(at: .immediate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-语音转文本"><a href="#二-语音转文本" class="headerlink" title="二. 语音转文本"></a>二. 语音转文本</h2><ul><li>在2016 WWDC大会上，Apple公司介绍了一个很好的语音识别的API,那就是Speech框架</li><li>Speech框架支持iOS10以上系统</li><li><a href="https://developer.apple.com/documentation/speech" target="_blank" rel="noopener">Speech框架官方文档</a></li><li>下面简单介绍一下主要的操作类</li></ul><h3 id="1-SFSpeechRecognizer-语音识别器"><a href="#1-SFSpeechRecognizer-语音识别器" class="headerlink" title="1. SFSpeechRecognizer: 语音识别器"></a>1. <code>SFSpeechRecognizer</code>: 语音识别器</h3><ul><li>这个类是语音识别的操作类</li><li>用于语音识别用户权限的申请，语言环境的设置，语音模式的设置以及向Apple服务发送语音识别的请求</li><li>初始化方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//这个初始化方法将默认以设备当前的语言环境作为语音识别的语言环境</span><br><span class="line">public convenience init?() </span><br><span class="line"></span><br><span class="line">//根据支持的语言初始化</span><br><span class="line">public init?(locale: Locale) </span><br><span class="line">//示例</span><br><span class="line">let recognize = SFSpeechRecognizer(locale: Locale(identifier: &quot;zh-CN&quot;))</span><br></pre></td></tr></table></figure><ul><li>类方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取所有支持的语言</span><br><span class="line">open class func supportedLocales() -&gt; Set&lt;Locale&gt;</span><br><span class="line"></span><br><span class="line">//获取当前用户权限状态</span><br><span class="line">open class func authorizationStatus() -&gt; SFSpeechRecognizerAuthorizationStatus</span><br><span class="line"></span><br><span class="line">//申请语音识别用户权限</span><br><span class="line">open class func requestAuthorization(_ handler: @escaping (SFSpeechRecognizerAuthorizationStatus) -&gt; Swift.Void)</span><br></pre></td></tr></table></figure><ul><li>其他属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var isAvailable: Bool</span><br><span class="line">//指示语音识别器是否可用</span><br><span class="line"></span><br><span class="line">var locale: Locale</span><br><span class="line">//当前语音识别器的语言环境</span><br><span class="line"></span><br><span class="line">class func supportedLocales()</span><br><span class="line">//获取语音识别所有支持的语言</span><br><span class="line"></span><br><span class="line">var queue: OperationQueue</span><br><span class="line">//语音识别器用于识别任务处理程序和委托消息的队列</span><br></pre></td></tr></table></figure><ul><li>相关方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//识别与指定请求关联的音频来源的语音，使用指定的协议返回结果</span><br><span class="line">open func recognitionTask(with request: SFSpeechRecognitionRequest, resultHandler: @escaping (SFSpeechRecognitionResult?, Error?) -&gt; Swift.Void) -&gt; SFSpeechRecognitionTask</span><br><span class="line"></span><br><span class="line">//识别与指定请求关联的音频源的语音, 使用闭包结果</span><br><span class="line">open func recognitionTask(with request: SFSpeechRecognitionRequest, delegate: SFSpeechRecognitionTaskDelegate) -&gt; SFSpeechRecognitionTask</span><br></pre></td></tr></table></figure><ul><li>代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weak var delegate: SFSpeechRecognizerDelegate? &#123; get set &#125;</span><br><span class="line"></span><br><span class="line">//代理方法: 监视语音识别器的可用性</span><br><span class="line">func speechRecognizer(SFSpeechRecognizer, availabilityDidChange: Bool)</span><br></pre></td></tr></table></figure><h3 id="2-SFSpeechRecognitionRequest"><a href="#2-SFSpeechRecognitionRequest" class="headerlink" title="2. SFSpeechRecognitionRequest"></a>2. <code>SFSpeechRecognitionRequest</code></h3><ul><li>语音识别请求类，需要通过其子类来进行实例化</li><li>相关属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var contextualStrings: [String]</span><br><span class="line">//一系列应该被识别的语言种类</span><br><span class="line"></span><br><span class="line">var shouldReportPartialResults: Bool</span><br><span class="line">//是否获取每个语句的最终结果。</span><br><span class="line"></span><br><span class="line">var taskHint: SFSpeechRecognitionTaskHint</span><br><span class="line">//正在执行的语音识别的类型</span><br><span class="line"></span><br><span class="line">var interactionIdentifier: String?</span><br><span class="line">//标识与请求关联的识别请求对象的字符串</span><br></pre></td></tr></table></figure><ul><li>子类<ul><li><code>SFSpeechURLRecognitionRequest</code></li><li><code>SFSpeechAudioBufferRecognitionRequest</code></li></ul></li></ul><h4 id="2-1-SFSpeechURLRecognitionRequest"><a href="#2-1-SFSpeechURLRecognitionRequest" class="headerlink" title="2-1. SFSpeechURLRecognitionRequest"></a>2-1. <code>SFSpeechURLRecognitionRequest</code></h4><ul><li>通过制定的URL路径识别本地的语音</li><li>方法和属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个语音识别请求，使用指定的URL进行初始化</span><br><span class="line">public init(url URL: URL)</span><br><span class="line"></span><br><span class="line">//获取当前的usl路径    </span><br><span class="line">open var url: URL &#123; get &#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-SFSpeechAudioBufferRecognitionRequest"><a href="#2-2-SFSpeechAudioBufferRecognitionRequest" class="headerlink" title="2-2. SFSpeechAudioBufferRecognitionRequest"></a>2-2. <code>SFSpeechAudioBufferRecognitionRequest</code></h4><ul><li>识别音频缓冲区中提供的语音的请求</li><li>识别即时语音, 类似于iPhone 中的Siri</li><li><a href="https://developer.apple.com/documentation/speech/sfspeechaudiobufferrecognitionrequest" target="_blank" rel="noopener">官方文档</a></li><li>音频缓冲区相关方法属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func append(AVAudioPCMBuffer)</span><br><span class="line">//将PCM格式的音频追加到识别请求的末尾。</span><br><span class="line"></span><br><span class="line">func appendAudioSampleBuffer(CMSampleBuffer)</span><br><span class="line">//将音频附加到识别请求的末尾。</span><br><span class="line"></span><br><span class="line">func endAudio()</span><br><span class="line">//完成输入</span><br></pre></td></tr></table></figure><ul><li>获取音频格式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var nativeAudioFormat: AVAudioFormat</span><br><span class="line">//用于最佳语音识别的首选音频格式。</span><br></pre></td></tr></table></figure><h3 id="3-SFSpeechRecognitionTask"><a href="#3-SFSpeechRecognitionTask" class="headerlink" title="3. SFSpeechRecognitionTask"></a>3. <code>SFSpeechRecognitionTask</code></h3><ul><li>语音识别请求结果类</li><li>语音识别任务，监视识别进度</li><li>相关方法属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func cancel()</span><br><span class="line">//取消当前的语音识别任务。</span><br><span class="line"></span><br><span class="line">var isCancelled: Bool</span><br><span class="line">//语音识别任务是否已被取消。</span><br><span class="line"></span><br><span class="line">func finish()</span><br><span class="line">//停止接受新的音频，并完成已接受的音频输入处理</span><br><span class="line"></span><br><span class="line">var isFinishing: Bool</span><br><span class="line">//音频输入是否已停止。</span><br><span class="line"></span><br><span class="line">var state: SFSpeechRecognitionTaskState</span><br><span class="line">//获取语音识别任务的当前状态。</span><br><span class="line"></span><br><span class="line">var error: Error?</span><br><span class="line">//在语音识别任务期间发生的错误的错误对象。</span><br></pre></td></tr></table></figure><h4 id="3-1-SFSpeechRecognitionTaskDelegate协议"><a href="#3-1-SFSpeechRecognitionTaskDelegate协议" class="headerlink" title="3-1. SFSpeechRecognitionTaskDelegate协议"></a>3-1. <code>SFSpeechRecognitionTaskDelegate</code>协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//当开始检测音频源中的语音时首先调用此方法</span><br><span class="line">optional public func speechRecognitionDidDetectSpeech(_ task: SFSpeechRecognitionTask)</span><br><span class="line"></span><br><span class="line">//当识别出一条可用的信息后 会调用</span><br><span class="line">//apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法</span><br><span class="line">optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didHypothesizeTranscription transcription: SFTranscription)</span><br><span class="line"></span><br><span class="line">//当识别完成所有可用的结果后调用</span><br><span class="line">optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishRecognition recognitionResult: SFSpeechRecognitionResult)</span><br><span class="line"></span><br><span class="line">//当不再接受音频输入时调用 即开始处理语音识别任务时调用   </span><br><span class="line">optional public func speechRecognitionTaskFinishedReadingAudio(_ task: SFSpeechRecognitionTask)</span><br><span class="line"></span><br><span class="line">//当语音识别任务被取消时调用    </span><br><span class="line">optional public func speechRecognitionTaskWasCancelled(_ task: SFSpeechRecognitionTask)</span><br><span class="line"></span><br><span class="line">//语音识别任务完成时被调用    </span><br><span class="line">optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishSuccessfully successfully: Bool)</span><br></pre></td></tr></table></figure><h3 id="4-SFTranscription"><a href="#4-SFTranscription" class="headerlink" title="4. SFTranscription"></a>4. SFTranscription</h3><ul><li>语音转换后的信息类, 包含改短语音信息的类</li><li>你所说的一句话，可能是有好几个词语拼成的，<code>formattedString</code>就是你所说的那句话，<code>segments</code>就是你所说的你那句话的组成每个单词的集合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//返回了一条表达语音译文的字符数据</span><br><span class="line">open var formattedString: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//所有的可能的识别数据</span><br><span class="line">open var segments: [SFTranscriptionSegment] &#123; get &#125;</span><br></pre></td></tr></table></figure><h3 id="5-SFTranscriptionSegment"><a href="#5-SFTranscriptionSegment" class="headerlink" title="5. SFTranscriptionSegment"></a>5. SFTranscriptionSegment</h3><ul><li>语音转换中的音频节点类</li><li>相关属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//当前节点识别后的文本信息</span><br><span class="line">open var substring: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//当前节点识别后的文本信息在整体识别语句中的位置</span><br><span class="line">open var substringRange: NSRange &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//当前节点的音频时间戳</span><br><span class="line">open var timestamp: TimeInterval &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//当前节点音频的持续时间</span><br><span class="line">open var duration: TimeInterval &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//可信度/准确度 0-1之间</span><br><span class="line">open var confidence: Float &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//关于此节点的其他可能的识别结果 </span><br><span class="line">open var alternativeSubstrings: [String] &#123; get &#125;</span><br></pre></td></tr></table></figure><h3 id="6-SFSpeechRecognitionResult-语音识别结果类"><a href="#6-SFSpeechRecognitionResult-语音识别结果类" class="headerlink" title="6. SFSpeechRecognitionResult: 语音识别结果类"></a>6. <code>SFSpeechRecognitionResult</code>: 语音识别结果类</h3><ul><li>是语音识别结果的封装，其中包含了许多套平行的识别信息，其每一份识别信息都有可信度属性来描述其准确程度</li><li>该类只是语音识别结果的一个封装，真正的识别信息定义在SFTranscription类中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//准确性最高的识别实例</span><br><span class="line">@NSCopying open var bestTranscription: SFTranscription &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//识别到的多套语音转换信息数组 其会按照准确度进行排序</span><br><span class="line">open var transcriptions: [SFTranscription] &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//是否已经完成 如果YES 则所有所有识别信息都已经获取完成</span><br><span class="line">open var isFinal: Bool &#123; get &#125;</span><br></pre></td></tr></table></figure><h2 id="三-语音识别转文本"><a href="#三-语音识别转文本" class="headerlink" title="三. 语音识别转文本"></a>三. 语音识别转文本</h2><ul><li>添加Speech框架<ul><li><code>import Speech</code></li></ul></li><li><code>info.plist</code>必须添加相关权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Privacy - Speech Recognition Usage Description</span><br><span class="line">//语音识别权限</span><br><span class="line"></span><br><span class="line">Privacy - Microphone Usage Description</span><br><span class="line">//麦克风使用权限</span><br></pre></td></tr></table></figure><ul><li>判断用户授权<ul><li>在使用speech framework做语音识别之前，你必须首先得到用户的允许</li><li>因为不仅仅只有本地的ios设备会进行识别，苹果的服务器也会识别</li><li>所有的语音数据都会被传递到苹果的后台进行处理</li><li>因此，获取用户授权是强制必须的</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">///语音识别权限认证</span><br><span class="line">fileprivate func addSpeechRecordLimit()&#123;</span><br><span class="line">    SFSpeechRecognizer.requestAuthorization &#123; (state) in</span><br><span class="line">        var isEnable = false</span><br><span class="line">        switch state &#123;</span><br><span class="line">        case .authorized:</span><br><span class="line">            isEnable = true</span><br><span class="line">            print(&quot;已授权语音识别&quot;)</span><br><span class="line">        case .notDetermined:</span><br><span class="line">            isEnable = false</span><br><span class="line">            print(&quot;没有授权语音识别&quot;)</span><br><span class="line">        case .denied:</span><br><span class="line">            isEnable = false</span><br><span class="line">            print(&quot;用户已拒绝访问语音识别&quot;)</span><br><span class="line">        case .restricted:</span><br><span class="line">            isEnable = false</span><br><span class="line">            print(&quot;不能在该设备上进行语音识别&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">            self.recordBtn.isEnabled = isEnable</span><br><span class="line">            self.recordBtn.backgroundColor = isEnable ? UIColor(red: 255/255.0, green: 64/255.0, blue: 64/255.0, alpha: 1) : UIColor.lightGray</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再然后就是初始化相关请求和识别类处理相关语音</li><li><a href="https://github.com/CoderTitan/TextAndVoice" target="_blank" rel="noopener">详细代码参考GitHub的Demo地址</a></li></ul><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><h3 id="AVSpeechSynthesisVoice支持的语言种类"><a href="#AVSpeechSynthesisVoice支持的语言种类" class="headerlink" title="AVSpeechSynthesisVoice支持的语言种类"></a><code>AVSpeechSynthesisVoice</code>支持的语言种类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">ar-SA  沙特阿拉伯（阿拉伯文）</span><br><span class="line"></span><br><span class="line">en-ZA, 南非（英文）</span><br><span class="line"></span><br><span class="line">nl-BE, 比利时（荷兰文）</span><br><span class="line"></span><br><span class="line">en-AU, 澳大利亚（英文）</span><br><span class="line"></span><br><span class="line">th-TH, 泰国（泰文）</span><br><span class="line"></span><br><span class="line">de-DE, 德国（德文）</span><br><span class="line"></span><br><span class="line">en-US, 美国（英文）</span><br><span class="line"></span><br><span class="line">pt-BR, 巴西（葡萄牙文）</span><br><span class="line"></span><br><span class="line">pl-PL, 波兰（波兰文）</span><br><span class="line"></span><br><span class="line">en-IE, 爱尔兰（英文）</span><br><span class="line"></span><br><span class="line">el-GR, 希腊（希腊文）</span><br><span class="line"></span><br><span class="line">id-ID, 印度尼西亚（印度尼西亚文）</span><br><span class="line"></span><br><span class="line">sv-SE, 瑞典（瑞典文）</span><br><span class="line"></span><br><span class="line">tr-TR, 土耳其（土耳其文）</span><br><span class="line"></span><br><span class="line">pt-PT, 葡萄牙（葡萄牙文）</span><br><span class="line"></span><br><span class="line">ja-JP, 日本（日文）</span><br><span class="line"></span><br><span class="line">ko-KR, 南朝鲜（朝鲜文）</span><br><span class="line"></span><br><span class="line">hu-HU, 匈牙利（匈牙利文）</span><br><span class="line"></span><br><span class="line">cs-CZ, 捷克共和国（捷克文）</span><br><span class="line"></span><br><span class="line">da-DK, 丹麦（丹麦文）</span><br><span class="line"></span><br><span class="line">es-MX, 墨西哥（西班牙文）</span><br><span class="line"></span><br><span class="line">fr-CA, 加拿大（法文）</span><br><span class="line"></span><br><span class="line">nl-NL, 荷兰（荷兰文）</span><br><span class="line"></span><br><span class="line">fi-FI, 芬兰（芬兰文）</span><br><span class="line"></span><br><span class="line">es-ES, 西班牙（西班牙文）</span><br><span class="line"></span><br><span class="line">it-IT, 意大利（意大利文）</span><br><span class="line"></span><br><span class="line">he-IL, 以色列（希伯莱文，阿拉伯文）</span><br><span class="line"></span><br><span class="line">no-NO, 挪威（挪威文）</span><br><span class="line"></span><br><span class="line">ro-RO, 罗马尼亚（罗马尼亚文）</span><br><span class="line"></span><br><span class="line">zh-HK, 香港（中文）</span><br><span class="line"></span><br><span class="line">zh-TW, 台湾（中文）</span><br><span class="line"></span><br><span class="line">sk-SK, 斯洛伐克（斯洛伐克文）</span><br><span class="line"></span><br><span class="line">zh-CN, 中国（中文）</span><br><span class="line"></span><br><span class="line">ru-RU, 俄罗斯（俄文）</span><br><span class="line"></span><br><span class="line">en-GB, 英国（英文）</span><br><span class="line"></span><br><span class="line">fr-FR, 法国（法文）</span><br><span class="line"></span><br><span class="line">hi-IN  印度（印度文）</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Speech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift之Vision 图像识别框架</title>
      <link href="/2017/11/29/Swift%E4%B9%8BVision%20%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E6%A1%86%E6%9E%B6"/>
      <content type="html"><![CDATA[<ul><li>2017年苹果大大又推出了新机型iPhone 8和iPhone 8Plus, 这还不是重点, 重点是那一款价值9000RMB的iPhone X, 虽说网上吐槽声从未停止过, 但是我觉得还是不错的哈!</li><li>软件方面, 苹果大大也推出了iOS 11, 经本人iPhone 7手机亲测, 耗电快外加通知栏改不完的bug</li><li>当然了随着iOS 11的推出, 也随之推出了一些新的API，如：<a href="https://developer.apple.com/documentation/arkit" target="_blank" rel="noopener"><code>ARKit</code></a> 、<a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener"><code>Core ML</code></a>、<a href="https://developer.apple.com/documentation/fileprovider" target="_blank" rel="noopener"><code>FileProvider</code></a>、<a href="https://developer.apple.com/documentation/identitylookup" target="_blank" rel="noopener"><code>IdentityLookup</code></a> 、<a href="https://developer.apple.com/documentation/corenfc" target="_blank" rel="noopener"><code>Core NFC</code></a>、<a href="https://developer.apple.com/documentation/vision" target="_blank" rel="noopener"><code>Vison</code></a> 等。</li><li>这里我们还要说的就是Apple 在 WWDC 2017 推出的图像识别框架–<code>Vison</code><a href="https://developer.apple.com/documentation/vision" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://github.com/coderQuanjun/JunVisionFace" target="_blank" rel="noopener">Demo地址</a></li></ul><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h2 id="一-Vision应用场景"><a href="#一-Vision应用场景" class="headerlink" title="一. Vision应用场景"></a>一. Vision应用场景</h2><ul><li><code>Face Detection and Recognition</code> : 人脸检测<ul><li>支持检测笑脸、侧脸、局部遮挡脸部、戴眼镜和帽子等场景，可以标记出人脸的矩形区域</li><li>可以标记出人脸和眼睛、眉毛、鼻子、嘴、牙齿的轮廓，以及人脸的中轴线</li></ul></li><li><code>Image Alignment Analysis</code>: 图像对比分析</li><li><code>Barcode Detection</code>: 二维码/条形码检测<ul><li>用于查找和识别图像中的条码</li><li>检测条形码信息</li></ul></li><li><code>Text Detection</code>: 文字检测<ul><li>查找图像中可见文本的区域</li><li>检测文本区域的信息</li></ul></li><li><code>Object Detection and Tracking</code>: 目标跟踪<ul><li>脸部，矩形和通用模板</li></ul></li></ul><h2 id="二-Vision支持的图片类型"><a href="#二-Vision支持的图片类型" class="headerlink" title="二. Vision支持的图片类型"></a>二. Vision支持的图片类型</h2><h3 id="1-Objective-C中"><a href="#1-Objective-C中" class="headerlink" title="1. Objective-C中"></a>1. Objective-C中</h3><ul><li><code>CVPixelBufferRef</code></li><li><code>CGImageRef</code></li><li><code>CIImage</code></li><li><code>NSURL</code></li><li><code>NSData</code></li></ul><h3 id="2-Swift中"><a href="#2-Swift中" class="headerlink" title="2. Swift中"></a>2. Swift中</h3><ul><li><code>CVPixelBuffer</code></li><li><code>CGImage</code></li><li><code>CIImage</code></li><li><code>URL</code></li><li><code>Data</code></li></ul><blockquote><p>具体详情可在<code>Vision.framework</code>的<code>VNImageRequestHandler.h</code>文件中查看</p></blockquote><h2 id="三-Vision之API介绍"><a href="#三-Vision之API介绍" class="headerlink" title="三. Vision之API介绍"></a>三. Vision之API介绍</h2><ul><li>使用在<code>vision</code>的时候，我们首先需要明确自己需要什么效果，然后根据想要的效果来选择不同的类</li><li>给各种功能的 <code>Request</code> 提供给一个 <code>RequestHandler</code></li><li><code>Handler</code> 持有需要识别的图片信息，并将处理结果分发给每个 <code>Request</code> 的 <code>completion Block</code> 中</li><li>可以从 <code>results</code> 属性中得到 <code>Observation</code> 数组</li><li><code>observations</code>数组中的内容根据不同的request请求返回了不同的<code>observation</code></li><li>每种<code>Observation</code>有<code>boundingBox</code>，<code>landmarks</code>等属性，存储的是识别后物体的坐标，点位等</li><li>我们拿到坐标后，就可以进行一些UI绘制。</li></ul><h3 id="1-RequestHandler处理请求对象"><a href="#1-RequestHandler处理请求对象" class="headerlink" title="1. RequestHandler处理请求对象"></a>1. <code>RequestHandler</code>处理请求对象</h3><ul><li><code>VNImageRequestHandler</code>: 处理与单个图像有关的一个或多个图像分析请求的对象<ul><li>一般情况下都是用该类处理识别请求</li><li>初始化方法支持<code>CVPixelBuffer</code>, <code>CGImage</code>, <code>CIImage</code>, <code>URL</code>, <code>Data</code></li></ul></li><li><code>VNSequenceRequestHandler</code>: 处理与多个图像序列有关的图像分析请求的对象<ul><li>目前我在处理物体跟踪的时候使用该类</li><li>初始化方法同上</li></ul></li></ul><h3 id="2-VNRequest介绍"><a href="#2-VNRequest介绍" class="headerlink" title="2. VNRequest介绍"></a>2. VNRequest介绍</h3><ul><li><code>VNRequest</code>: 图像分析请求的抽象类, 继承于<code>NSObject</code></li><li><code>VNBaseImageRequest</code>: 专注于图像的特定部分的分析请求</li><li>具体分析请求类如下: </li><li><img src="http://upload-images.jianshu.io/upload_images/4122543-b58783bec9d07551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VNImageBasedRequest.png"></li></ul><h3 id="3-VNObservation检测对象"><a href="#3-VNObservation检测对象" class="headerlink" title="3. VNObservation检测对象"></a>3. <code>VNObservation</code>检测对象</h3><ul><li><code>VNObservation</code>: 图像分析结果的抽象类, 继承与<code>NSObject</code></li><li>图像检测结果的相关处理类如下:</li><li><img src="http://upload-images.jianshu.io/upload_images/4122543-c0b83aa723e149ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VNObservation.png"></li></ul><h2 id="四-实战演练"><a href="#四-实战演练" class="headerlink" title="四. 实战演练"></a>四. 实战演练</h2><h3 id="1-文本检测"><a href="#1-文本检测" class="headerlink" title="1. 文本检测"></a>1. 文本检测</h3><ul><li>方式一: 识别出具体的每一个字体的位置信息</li><li>方式二: 识别一行字体的位置信息</li><li>如图效果:</li><li><img src="http://upload-images.jianshu.io/upload_images/4122543-0c09426c80013322.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="WechatIMG3.jpeg"> </li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-8b970c464c26ffb0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="WechatIMG5.jpeg"></p><h4 id="1-1-现将图片转成初始化VNImageRequestHandler对象时-可接受的的CIImage"><a href="#1-1-现将图片转成初始化VNImageRequestHandler对象时-可接受的的CIImage" class="headerlink" title="1.1 现将图片转成初始化VNImageRequestHandler对象时, 可接受的的CIImage"></a>1.1 现将图片转成初始化<code>VNImageRequestHandler</code>对象时, 可接受的的<code>CIImage</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//1. 转成ciimage</span><br><span class="line">guard let ciImage = CIImage(image: image) else &#123; return &#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-创建处理请求的handle"><a href="#1-2-创建处理请求的handle" class="headerlink" title="1.2 创建处理请求的handle"></a>1.2 创建处理请求的handle</h4><ul><li>参数一: 图片类型</li><li>参数二: 字典类型, 有默认值为[:]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let requestHandle = VNImageRequestHandler(ciImage: ciImage, options: [:])</span><br></pre></td></tr></table></figure><h4 id="1-3-创建回调闭包"><a href="#1-3-创建回调闭包" class="headerlink" title="1.3 创建回调闭包"></a>1.3 创建回调闭包</h4><ul><li>两个参数, 无返回值</li><li><code>VNRequest</code>: 是所有请求Request的父类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public typealias VNRequestCompletionHandler = (VNRequest, Error?) -&gt; Swift.Void</span><br></pre></td></tr></table></figure><ul><li>具体代码如下: </li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 设置回调</span></span><br><span class="line">let completionHandle: VNRequestCompletionHandler = &#123; request, error <span class="keyword">in</span></span><br><span class="line">    let observations = request.results</span><br><span class="line">    <span class="comment">//识别出来的对象数组    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-创建识别请求"><a href="#1-4-创建识别请求" class="headerlink" title="1.4 创建识别请求"></a>1.4 创建识别请求</h4><ul><li>两种初始化方式</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参数</span></span><br><span class="line">public convenience init()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//闭包参数</span></span><br><span class="line">public init(completionHandler: Vision.VNRequestCompletionHandler? = <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><ul><li>这里使用带闭包的初始化方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let baseRequest = VNDetectTextRectanglesRequest(completionHandler: completionHandle)</span><br></pre></td></tr></table></figure><ul><li>属性设置(是否识别具体的每一个文字)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置识别具体文字</span><br><span class="line">baseRequest.setValue(true, forKey: &quot;reportCharacterBoxes&quot;)</span><br></pre></td></tr></table></figure><ul><li>不设置该属性, 识别出来的是一行文字</li></ul><h4 id="1-5-发送请求"><a href="#1-5-发送请求" class="headerlink" title="1.5 发送请求"></a>1.5 发送请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open func perform(_ requests: [VNRequest]) throws</span><br></pre></td></tr></table></figure><ul><li>该方法会抛出一个异常错误</li><li>在连续不断(摄像头扫描)发送请求过程中, 必须在子线程执行该方法, 否则会造成线程堵塞</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6. 发送请求</span></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        try requestHandle.perform([baseRequest])</span><br><span class="line">    &#125;catch&#123;</span><br><span class="line">        print(<span class="string">"Throws：\(error)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-处理识别的Observations对象"><a href="#1-6-处理识别的Observations对象" class="headerlink" title="1.6 处理识别的Observations对象"></a>1.6 处理识别的<code>Observations</code>对象</h4><ul><li>识别出来的<code>results</code>是<code>[Any]?</code>类型</li><li>根据<code>boundingBox</code>属性可以获取到对应的文本区域的尺寸</li><li>需要注意的是:<ul><li><code>boundingBox</code>得到的是相对iamge的比例尺寸, 都是小于1的</li><li>Y轴坐标于UIView坐标系是相反的</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 获取识别到的VNTextObservation</span></span><br><span class="line">guard let boxArr = observations as? [VNTextObservation] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2. 创建rect数组</span></span><br><span class="line">var bigRects = [<span class="built_in">CGRect</span>](), smallRects = [<span class="built_in">CGRect</span>]()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//3. 遍历识别结果</span></span><br><span class="line"><span class="keyword">for</span> boxObj <span class="keyword">in</span> boxArr &#123;</span><br><span class="line">    <span class="comment">// 3.1尺寸转换</span></span><br><span class="line">    <span class="comment">//获取一行文本的区域位置</span></span><br><span class="line">    bigRects.append(convertRect(boxObj.boundingBox, image))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取</span></span><br><span class="line">    guard let rectangleArr = boxObj.characterBoxes <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">    <span class="keyword">for</span> rectangle <span class="keyword">in</span> rectangleArr&#123;</span><br><span class="line">        <span class="comment">//3. 得到每一个字体的的尺寸</span></span><br><span class="line">        let boundBox = rectangle.boundingBox</span><br><span class="line">        smallRects.append(convertRect(boundBox, image))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>坐标转换</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// image坐标转换</span></span><br><span class="line">fileprivate func convertRect(_ rectangleRect: <span class="built_in">CGRect</span>, _ image: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">CGRect</span> &#123;</span><br><span class="line"><span class="comment">//此处是将Image的实际尺寸转化成imageView的尺寸</span></span><br><span class="line">    let imageSize = image.scaleImage()</span><br><span class="line">    let w = rectangleRect.width * imageSize.width</span><br><span class="line">    let h = rectangleRect.height * imageSize.height</span><br><span class="line">    let x = rectangleRect.minX * imageSize.width</span><br><span class="line">    <span class="comment">//该Y坐标与UIView的Y坐标是相反的</span></span><br><span class="line">    let y = (<span class="number">1</span> - rectangleRect.minY) * imageSize.height - h</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: x, y: y, width: w, height: h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-矩形识别和静态人脸识别"><a href="#2-矩形识别和静态人脸识别" class="headerlink" title="2. 矩形识别和静态人脸识别"></a>2. 矩形识别和静态人脸识别</h3><ul><li>识别图像中的矩形</li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-05e6a9cc6c193b1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511935758595.jpg"></p></li><li><p>静态人脸识别</p></li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-e5faf93cebae945e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511936019734.jpg"></p></li><li><p>主要核心代码</p></li><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//1. 转成ciimage</span><br><span class="line">guard let ciImage = CIImage(image: image) else &#123; return &#125;</span><br><span class="line">        </span><br><span class="line">//2. 创建处理request</span><br><span class="line">let requestHandle = VNImageRequestHandler(ciImage: ciImage, options: [:])</span><br><span class="line">        </span><br><span class="line">//3. 创建baseRequest</span><br><span class="line">//大多数识别请求request都继承自VNImageBasedRequest</span><br><span class="line">var baseRequest = VNImageBasedRequest()</span><br><span class="line">        </span><br><span class="line">//4. 设置回调</span><br><span class="line">let completionHandle: VNRequestCompletionHandler = &#123; request, error in</span><br><span class="line">    let observations = request.results</span><br><span class="line">    self.handleImageObservable(type: type, image: image, observations, completeBack)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">//5. 创建识别请求</span><br><span class="line">switch type &#123;</span><br><span class="line">case .rectangle:</span><br><span class="line">    baseRequest = VNDetectRectanglesRequest(completionHandler: completionHandle)</span><br><span class="line">case .staticFace:</span><br><span class="line">    baseRequest = VNDetectFaceRectanglesRequest(completionHandler: completionHandle)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理识别的observation</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 矩形检测</span></span><br><span class="line">fileprivate func rectangleDectect(_ observations: [Any]?, image: <span class="built_in">UIImage</span>, _ complecHandle: JunDetectHandle)&#123;</span><br><span class="line">    <span class="comment">//1. 获取识别到的VNRectangleObservation</span></span><br><span class="line">    guard let boxArr = observations as? [VNRectangleObservation] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//2. 创建rect数组</span></span><br><span class="line">    var bigRects = [<span class="built_in">CGRect</span>]()</span><br><span class="line">    <span class="comment">//3. 遍历识别结果</span></span><br><span class="line">    <span class="keyword">for</span> boxObj <span class="keyword">in</span> boxArr &#123;</span><br><span class="line">        <span class="comment">// 3.1</span></span><br><span class="line">        bigRects.append(convertRect(boxObj.boundingBox, image))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 回调结果</span></span><br><span class="line">    complecHandle(bigRects, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态人脸识别需要将<code>observation</code>转成<code>VNFaceObservation</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">guard let boxArr = observations as? [VNFaceObservation] else &#123; return &#125;</span><br></pre></td></tr></table></figure><h3 id="3-条码识别"><a href="#3-条码识别" class="headerlink" title="3. 条码识别"></a>3. 条码识别</h3><p><img src="http://upload-images.jianshu.io/upload_images/4122543-9f199a027f186a5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511936988374.jpg"></p><ul><li>这里请求的步骤与矩形识别相同, 这里不再赘述</li><li>需要注意的是,在初始化request的时候需要设一个置可识别的条码类型参数</li><li>这里先看一下<code>VNDetectBarcodesRequest</code>的两个参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//支持的可识别的条码类型(需要直接用class调用)</span><br><span class="line">open class var supportedSymbologies: [VNBarcodeSymbology] &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//设置可识别的条码类型</span><br><span class="line">open var symbologies: [VNBarcodeSymbology]</span><br></pre></td></tr></table></figure><ul><li>此处设置可识别到的条码类型为, 该请求支持是别的所有类型, 如下</li><li>注意<code>supportedSymbologies</code>参数的调用方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let request = VNDetectBarcodesRequest(completionHandler: completionHandle)</span><br><span class="line">request.symbologies = VNDetectBarcodesRequest.supportedSymbologies</span><br></pre></td></tr></table></figure><ul><li>条码识别不但能识别条码的位置信息, 还可以识别出条码的相关信息, 这里以二维码为例</li><li>这里需要将识别的<code>observations</code>转成<code>[VNBarcodeObservation]</code></li><li><code>VNBarcodeObservation</code>有三个属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条码类型: qr, code128....等等</span></span><br><span class="line">open var symbology: VNBarcodeSymbology &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条码的相关信息</span></span><br><span class="line">open var barcodeDescriptor: <span class="built_in">CIBarcodeDescriptor</span>? &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是二维码, 则是二维码的网址链接    </span></span><br><span class="line">open var payloadStringValue: String? &#123; get &#125;</span><br></pre></td></tr></table></figure><ul><li>如上述图片识别出来的<code>payloadStringValue</code>参数则是小编的<a href="http://www.jianshu.com/u/5bd5e9ed569e" target="_blank" rel="noopener">简书地址</a></li><li>下面是以上述图片的二维码为例处理的<code>CIBarcodeDescriptor</code>对象</li><li>有兴趣的可以仔细研究研究</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 二维码信息处理</span></span><br><span class="line">fileprivate func qrCodeHandle(barCode: <span class="built_in">CIBarcodeDescriptor</span>?)&#123;</span><br><span class="line">    <span class="comment">//1. 转成对应的条码对象</span></span><br><span class="line">    guard let code = barCode as? <span class="built_in">CIQRCodeDescriptor</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 解读条码信息</span></span><br><span class="line">    let level = code.errorCorrectionLevel.hashValue</span><br><span class="line">    let version = code.symbolVersion</span><br><span class="line">    let mask = code.maskPattern</span><br><span class="line">    let data = code.errorCorrectedPayload</span><br><span class="line">    let dataStr = String(data: data, encoding: .utf8)</span><br><span class="line">    print(<span class="string">"这是二维码信息--"</span>, level, <span class="string">"---"</span>, version, <span class="string">"----"</span>, mask, <span class="string">"---"</span>, dataStr ?? <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-人脸特征识别"><a href="#4-人脸特征识别" class="headerlink" title="4. 人脸特征识别"></a>4. 人脸特征识别</h3><ul><li>可识别出人脸的轮廓, 眼睛, 鼻子, 嘴巴等具体位置</li><li><img src="http://upload-images.jianshu.io/upload_images/4122543-895670df5fd8e2c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511944652200.jpg"></li></ul><ul><li><code>VNFaceLandmarks2D</code>介绍</li><li></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 脸部轮廓</span></span><br><span class="line">var faceContour: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 左眼, 右眼</span></span><br><span class="line">var leftEye: VNFaceLandmarkRegion2D?</span><br><span class="line">var rightEye: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 左睫毛, 右睫毛</span></span><br><span class="line">var leftEyebrow: VNFaceLandmarkRegion2D?</span><br><span class="line">var rightEyebrow: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 左眼瞳, 右眼瞳</span></span><br><span class="line">var leftPupil: VNFaceLandmarkRegion2D?</span><br><span class="line">var rightPupil: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 鼻子, 鼻嵴, 正中线</span></span><br><span class="line">var nose: VNFaceLandmarkRegion2D?</span><br><span class="line">var noseCrest: VNFaceLandmarkRegion2D?</span><br><span class="line">var medianLine: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 外唇, 内唇</span></span><br><span class="line">var outerLips: VNFaceLandmarkRegion2D?</span><br><span class="line">var innerLips: VNFaceLandmarkRegion2D?</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//某一部位所有的像素点</span><br><span class="line">@nonobjc public var normalizedPoints: [CGPoint] &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//某一部位的所有像素点的个数</span><br><span class="line">open var pointCount: Int &#123; get &#125;</span><br></pre></td></tr></table></figure><ul><li>将所有的像素点坐标转换成image对应的尺寸坐标</li><li>使用图像上下文, 对应部位画线</li><li>在UIView中重写<code>func draw(_ rect: CGRect)</code>方法</li><li></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.1 获取当前上下文</span></span><br><span class="line">let content = <span class="built_in">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.2 设置填充颜色(setStroke设置描边颜色)</span></span><br><span class="line"><span class="built_in">UIColor</span>.green.set()</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.3 设置宽度</span></span><br><span class="line">content?.setLineWidth(<span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.4. 设置线的类型(连接处)</span></span><br><span class="line">content?.setLineJoin(.round)</span><br><span class="line">content?.setLineCap(.round)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.5. 设置抗锯齿效果</span></span><br><span class="line">content?.setShouldAntialias(<span class="literal">true</span>)</span><br><span class="line">content?.setAllowsAntialiasing(<span class="literal">true</span>)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.6 开始绘制</span></span><br><span class="line">content?.addLines(between: pointArr)</span><br><span class="line">content?.drawPath(using: .stroke)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.7 结束绘制</span></span><br><span class="line">content?.strokePath()</span><br></pre></td></tr></table></figure><h3 id="5-动态人脸识别和实时动态添加"><a href="#5-动态人脸识别和实时动态添加" class="headerlink" title="5. 动态人脸识别和实时动态添加"></a>5. 动态人脸识别和实时动态添加</h3><blockquote><p>由于真机不好录制gif图(尝试了一下, 效果不是很好, 放弃了), 想看效果的朋友<a href="https://github.com/coderQuanjun/JunVisionFace" target="_blank" rel="noopener">下载源码</a>真机运行吧</p><ul><li>这里提供一张<a href="http://upload-images.jianshu.io/upload_images/4122543-e390e4107c0b811b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener">可供扫描的图片</a></li></ul></blockquote><ul><li><code>request</code>的初始化这里就不做介绍了, 说一下<code>handle</code>的初始化方法<ul><li><code>CVPixelBuffer</code>: 扫描实时输出的对象</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//1. 创建处理请求</span><br><span class="line">let faceHandle = VNImageRequestHandler(cvPixelBuffer: pixelBuffer, options: [:])</span><br></pre></td></tr></table></figure><ul><li>主要强调一点, 相机扫描, 获取实时图像的过程, 必须在子线程执行, 否在会堵塞线程, 整个app失去响应, 亲自踩过的坑</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    do&#123;</span><br><span class="line">        try faceHandle.perform([baseRequest])</span><br><span class="line">    &#125;catch&#123;</span><br><span class="line">        print(&quot;Throws：\(error)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扫描结果处理"><a href="#扫描结果处理" class="headerlink" title="扫描结果处理"></a>扫描结果处理</h4><ul><li>动态人脸识别和静态人脸识别不同的地方就是, 动态实时刷新, 更新UI, 所以处理结果的方法相同</li><li>动态添加: 这里处理方式是添加一个眼镜效果</li><li>这里需要获取到两只眼睛的位置和宽度<ul><li>先获取到左右眼的所有的像素点和像素点的个数</li><li>遍历所有的像素点, 转换成合适的坐标</li><li>将左右眼的所有的point, 分别获取X和Y坐标放到不同的数组</li><li>将数组有小到大排序, 得到X的最大和最小的差值, Y的最大和最小的差值</li><li>具体代码如下</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// H偶去转换后的尺寸坐标</span></span><br><span class="line">fileprivate func getEyePoint(faceModel: FaceFeatureModel, position: <span class="built_in">AVCaptureDevice</span>.Position) -&gt; <span class="built_in">CGRect</span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取左右眼</span></span><br><span class="line">    guard let leftEye = faceModel.leftEye <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">CGRect</span>.zero &#125;</span><br><span class="line">    guard let rightEye = faceModel.rightEye <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">CGRect</span>.zero &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 位置数组</span></span><br><span class="line">    let leftPoint = conventPoint(landmark: leftEye, faceRect: faceModel.faceObservation.boundingBox, position: position)</span><br><span class="line">    let rightPoint = conventPoint(landmark: rightEye, faceRect: faceModel.faceObservation.boundingBox, position: position)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 排序</span></span><br><span class="line">    let pointXs = (leftPoint<span class="number">.0</span> + rightPoint<span class="number">.0</span>).sorted()</span><br><span class="line">    let pointYs = (leftPoint<span class="number">.1</span> + rightPoint<span class="number">.1</span>).sorted()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 添加眼睛</span></span><br><span class="line">    let image = <span class="built_in">UIImage</span>(named: <span class="string">"eyes"</span>)!</span><br><span class="line">    let imageWidth = (pointXs.last ?? <span class="number">0.0</span>) - (pointXs.first ?? <span class="number">0</span>) + <span class="number">40</span></span><br><span class="line">    let imageHeight = image.size.height / image.size.width * imageWidth</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: (pointXs.first ?? <span class="number">0</span>) - <span class="number">20</span>, y: (pointYs.first ?? <span class="number">0</span>) - <span class="number">5</span>, width: imageWidth, height: imageHeight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每一只眼睛的坐标处理</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 坐标转换</span></span><br><span class="line">fileprivate func conventPoint(landmark: VNFaceLandmarkRegion2D, faceRect: <span class="built_in">CGRect</span>, position: <span class="built_in">AVCaptureDevice</span>.Position) -&gt; ([<span class="built_in">CGFloat</span>], [<span class="built_in">CGFloat</span>])&#123;</span><br><span class="line">    <span class="comment">//1. 定义</span></span><br><span class="line">    var XArray = [<span class="built_in">CGFloat</span>](), YArray = [<span class="built_in">CGFloat</span>]()</span><br><span class="line">    let viewRect = previewLayer.frame</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;landmark.pointCount &#123;</span><br><span class="line">        <span class="comment">//2.1 获取当前位置并转化到合适尺寸</span></span><br><span class="line">        let point = landmark.normalizedPoints[i]</span><br><span class="line">        let rectWidth = viewRect.width * faceRect.width</span><br><span class="line">        let rectHeight = viewRect.height * faceRect.height</span><br><span class="line">        let rectY = viewRect.height - (point.y * rectHeight + faceRect.minY * viewRect.height)</span><br><span class="line">        var rectX = point.x * rectWidth + faceRect.minX * viewRect.width</span><br><span class="line">        <span class="keyword">if</span> position == .front&#123;</span><br><span class="line">            rectX = viewRect.width + (point.x - <span class="number">1</span>) * rectWidth</span><br><span class="line">        &#125;</span><br><span class="line">        XArray.append(rectX)</span><br><span class="line">        YArray.append(rectY)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (XArray, YArray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后获取到该<code>CGRect</code>, 添加眼镜效果即可</li></ul><h3 id="6-物体跟踪"><a href="#6-物体跟踪" class="headerlink" title="6. 物体跟踪"></a>6. 物体跟踪</h3><ul><li>简介<ul><li>我们在屏幕上点击某物体, 然后Vision就会根据点击的物体, 实时跟踪该物体</li><li>当你移动手机或者物体时, 识别的对象和红框的位置是统一的</li></ul></li><li>这里我们出的的对象是<code>VNDetectedObjectObservation</code></li><li>定义一个观察属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileprivate var lastObservation: VNDetectedObjectObservation?</span><br></pre></td></tr></table></figure><ul><li>创建一个处理多个图像序列的请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//处理与多个图像序列的请求handle</span><br><span class="line">let sequenceHandle = VNSequenceRequestHandler()</span><br></pre></td></tr></table></figure><ul><li>创建跟踪识别请求</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 创建跟踪识别请求</span></span><br><span class="line">let trackRequest = VNTrackObjectRequest(detectedObjectObservation: lastObservation, completionHandler: completionHandle)</span><br><span class="line"><span class="comment">//将精度设置为高</span></span><br><span class="line">trackRequest.trackingLevel = .accurate</span><br></pre></td></tr></table></figure><ul><li>当用户点击屏幕时，我们想要找出用户点击的位置,</li><li>根据点击的位置, 获取到一个新的物体对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//2. 转换坐标</span><br><span class="line">let convertRect = visionTool.convertRect(viewRect: redView.frame, layerRect: previewLayer.frame)</span><br><span class="line">        </span><br><span class="line">//3. 根据点击的位置获取新的对象</span><br><span class="line">let newObservation = VNDetectedObjectObservation(boundingBox: convertRect)</span><br><span class="line">lastObservation = newObservation</span><br></pre></td></tr></table></figure><ul><li>获取到扫描的结果, 如果是一个<code>VNDetectedObjectObservation</code>对象, 重新赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//1. 获取一个实际的结果</span><br><span class="line">guard let newObservation = observations?.first as? VNDetectedObjectObservation else &#123; return &#125;</span><br><span class="line">            </span><br><span class="line">//2. 重新赋值</span><br><span class="line">self.lastObservation = newObservation</span><br></pre></td></tr></table></figure><ul><li>根据获取到的新值, 获取物体的坐标位置</li><li>转换坐标, 改变红色框的位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//4. 坐标转换</span><br><span class="line">let newRect = newObservation.boundingBox</span><br><span class="line">let convertRect = visionTool.convertRect(newRect, self.previewLayer.frame)</span><br><span class="line">self.redView.frame = convertRect</span><br></pre></td></tr></table></figure><blockquote><p>以上就是iOS 11的新框架Vision在Swift中的所有使用的情况</p><ul><li>文中所列的内容可能有点空洞, 也稍微有点乱</li><li>小编也是刚接触Vision, 文中如有解释不全, 或者错误的地方, 还请不吝赐教</li></ul></blockquote><hr><h3 id="GitHub–Demo地址"><a href="#GitHub–Demo地址" class="headerlink" title="GitHub–Demo地址"></a>GitHub–<a href="https://github.com/coderQuanjun/JunVisionFace" target="_blank" rel="noopener">Demo地址</a></h3><ul><li>注意:  <ul><li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li><li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li><li>如果方便的话, 还望star一下</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Swift黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Vision </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS黑科技之(AVFoundation)动态人脸识别(二)</title>
      <link href="/2017/11/22/iOS%E9%BB%91%E7%A7%91%E6%8A%80%E4%B9%8B(AVFoundation)%E5%8A%A8%E6%80%81%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB(%E4%BA%8C)"/>
      <content type="html"><![CDATA[<blockquote><p>人脸识别原理简介：每一张图片都是由每一个像素点组成，而每一个像素点中又有对应的颜色值(如RGB)，人的面部特征中，不同的五官，颜色值肯定存在差异，而人脸识别技术就是通过对照片中每一个像素的识别进行大量的算法处理，最终得出五官的轮廓</p></blockquote><a id="more"></a><h2 id="一-首先介绍一些人脸识别的方式"><a href="#一-首先介绍一些人脸识别的方式" class="headerlink" title="一. 首先介绍一些人脸识别的方式"></a>一. 首先介绍一些人脸识别的方式</h2><h3 id="1-CoreImage静态人脸识别-可识别照片-图像等"><a href="#1-CoreImage静态人脸识别-可识别照片-图像等" class="headerlink" title="1. CoreImage静态人脸识别, 可识别照片, 图像等"></a>1. <code>CoreImage</code>静态人脸识别, 可识别照片, 图像等</h3><ul><li>详情可查看上一篇博客介绍</li></ul><h3 id="2-Face"><a href="#2-Face" class="headerlink" title="2. Face++"></a>2. Face++</h3><ul><li>是北京旷视科技有限公司旗下的新型视觉服务平台, 旨在提供简单易用，功能强大，平台通用的视觉服务</li><li>Face++是新一代云端视觉服务平台，提供一整套世界领先的人脸检测，人脸识别，面部分析的视觉技术服务</li><li><a href="https://baike.baidu.com/item/Face++/6754083" target="_blank" rel="noopener">Face++百度百科介绍</a></li><li><a href="https://www.faceplusplus.com.cn/pricing/" target="_blank" rel="noopener">Face++官网</a></li></ul><h3 id="3-OpenCV"><a href="#3-OpenCV" class="headerlink" title="3. OpenCV"></a>3. OpenCV</h3><ul><li>由一系列 C 函数和少量 C++ 类构成, 实现了图像处理和计算机视觉方面的很多通用算法, 其他的具体的不是很了解</li><li><a href="https://baike.baidu.com/item/opencv/10320623?fr=aladdin" target="_blank" rel="noopener">这是百度百科的内容</a></li></ul><h3 id="4-Vision"><a href="#4-Vision" class="headerlink" title="4. Vision"></a>4. Vision</h3><ul><li>Vision 是 Apple 在 WWDC 2017 伴随iOS 11推出的基于CoreML的图像识别框架</li><li>根据<a href="https://developer.apple.com/documentation/vision" target="_blank" rel="noopener">Vision官方文档看</a>，<code>Vision</code> 本身就有<code>Face Detection and Recognition</code>(人脸检测识别)、<code>Machine Learning Image Analysis</code>(机器学习图片分析)、<code>Barcode Detection</code>(条形码检测)、<code>Text Detection</code>(文本检测)。。。。。等等这些功能</li><li>感兴趣的同学可以查看相关文档学习一下, 这里小编就不过多作介绍了</li></ul><h4 id="5-AVFoundation"><a href="#5-AVFoundation" class="headerlink" title="5. AVFoundation"></a>5. AVFoundation</h4><ul><li>可以用来使用和创建基于时间的视听媒体的框架</li><li>这里我们使用的人脸识别方式也是使用<code>AVFoundation</code>框架</li></ul><h2 id="二-对关键类的简单介绍"><a href="#二-对关键类的简单介绍" class="headerlink" title="二. 对关键类的简单介绍"></a>二. 对关键类的简单介绍</h2><h3 id="1-AVCaptureDevice-代表硬件设备"><a href="#1-AVCaptureDevice-代表硬件设备" class="headerlink" title="1. AVCaptureDevice:代表硬件设备"></a>1. <code>AVCaptureDevice</code>:代表硬件设备</h3><ul><li>我们可以从这个类中获取手机硬件的照相机、声音传感器等。</li><li>当我们在应用程序中需要改变一些硬件设备的属性（例如：切换摄像头、闪光模式改变、相机聚焦改变）的时候必须要先为设备加锁，修改完成后解锁。</li><li>示例: 切换摄像头</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 移除旧输入，添加新输入</span></span><br><span class="line"><span class="comment">//4.1 设备加锁</span></span><br><span class="line">session.beginConfiguration()</span><br><span class="line"><span class="comment">//4.2. 移除旧设备</span></span><br><span class="line">session.removeInput(deviceIn)</span><br><span class="line"><span class="comment">//4.3 添加新设备</span></span><br><span class="line">session.addInput(newVideoInput)</span><br><span class="line"><span class="comment">//4.4 设备解锁</span></span><br><span class="line">session.commitConfiguration()</span><br></pre></td></tr></table></figure><h3 id="2-AVCaptureDeviceInput-设备输入数据管理对象"><a href="#2-AVCaptureDeviceInput-设备输入数据管理对象" class="headerlink" title="2. AVCaptureDeviceInput:设备输入数据管理对象"></a>2. <code>AVCaptureDeviceInput</code>:设备输入数据管理对象</h3><ul><li>可以根据<code>AVCaptureDevice</code>创建对应的AVCaptureDeviceInput对象，</li><li>该对象将会被添加到AVCaptureSession中管理,代表输入设备，它配置抽象硬件设备的ports。通常的输入设备有（麦克风，相机等）</li></ul><h3 id="3-AVCaptureOutput-代表输出数据"><a href="#3-AVCaptureOutput-代表输出数据" class="headerlink" title="3. AVCaptureOutput: 代表输出数据"></a>3. <code>AVCaptureOutput</code>: 代表输出数据</h3><ul><li>输出的可以是图片（<code>AVCaptureStillImageOutput</code>）或者视频（<code>AVCaptureMovieFileOutput</code>）</li></ul><h3 id="4-AVCaptureSession-媒体（音、视频）捕捉会话"><a href="#4-AVCaptureSession-媒体（音、视频）捕捉会话" class="headerlink" title="4. AVCaptureSession: 媒体（音、视频）捕捉会话"></a>4. <code>AVCaptureSession</code>: 媒体（音、视频）捕捉会话</h3><ul><li>负责把捕捉的音频视频数据输出到输出设备中。</li><li>一个<code>AVCaptureSession</code>可以有多个输入或输出。</li><li>是连接<code>AVCaptureInput</code>和<code>AVCaptureOutput</code>的桥梁，它协调input到output之间传输数据。</li><li>它有startRunning和stopRunning两种方法来开启会话和结束会话。</li><li>每个session称之为一个会话，也就是在应用运行过程中如果你需要改变会话的一些配置（例如：切换摄像头）,此时需要先开启配置，配置完成之后再提交配置。</li></ul><h3 id="5-AVCaptureVideoPreviewLayer-图片预览层"><a href="#5-AVCaptureVideoPreviewLayer-图片预览层" class="headerlink" title="5. AVCaptureVideoPreviewLayer: 图片预览层"></a>5. <code>AVCaptureVideoPreviewLayer</code>: 图片预览层</h3><ul><li>我们的照片以及视频是如何显示在手机上的呢？那就是通过把这个对象添加到<code>UIView</code>的<code>layer</code>上的</li></ul><blockquote><p>好了, 上面吧啦吧啦的说了那么多废话, 那么我们的人脸识别究竟是怎样实现的呢? 下面干货来了</p></blockquote><h2 id="三-添加扫描设备"><a href="#三-添加扫描设备" class="headerlink" title="三. 添加扫描设备"></a>三. 添加扫描设备</h2><ul><li>获取设备(摄像头)</li><li>创建输入设备</li><li>创建扫描输出</li><li>创建捕捉回话</li></ul><h3 id="1-输出设备"><a href="#1-输出设备" class="headerlink" title="1. 输出设备"></a>1. 输出设备</h3><ul><li>这里使用<code>AVCaptureMetadataOutput</code>, 可以扫描人脸, 二维码, 条形码等信息</li><li>必须设置代理, 否则获取不到扫描结果</li><li>需要设置要输出什么样的数据: face(人脸), qr(二维码)等等</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.创建原数据的输出对象</span></span><br><span class="line">let metadataOutput = <span class="built_in">AVCaptureMetadataOutput</span>()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4.设置代理监听输出对象输出的数据，在主线程中刷新</span></span><br><span class="line">metadataOutput.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: DispatchQueue.main)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.告诉输出对象要输出什么样的数据,识别人脸, 最多可识别10张人脸</span></span><br><span class="line">metadataOutput.metadataObjectTypes = [.face]</span><br></pre></td></tr></table></figure><blockquote><p>主要代码如下:</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func addScaningVideo()&#123;</span><br><span class="line">    <span class="comment">//1.获取输入设备（摄像头）</span></span><br><span class="line">    guard let device = <span class="built_in">AVCaptureDevice</span>.default(<span class="keyword">for</span>: .video) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.根据输入设备创建输入对象</span></span><br><span class="line">    guard let deviceIn = try? <span class="built_in">AVCaptureDeviceInput</span>(device: device) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    deviceInput = deviceIn</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.创建原数据的输出对象</span></span><br><span class="line">    let metadataOutput = <span class="built_in">AVCaptureMetadataOutput</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.设置代理监听输出对象输出的数据，在主线程中刷新</span></span><br><span class="line">    metadataOutput.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: DispatchQueue.main)</span><br><span class="line">    <span class="comment">//4.2 设置输出代理</span></span><br><span class="line">    faceDelegate = previewView</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.设置输出质量(高像素输出)</span></span><br><span class="line">    session.sessionPreset = .high</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.添加输入和输出到会话</span></span><br><span class="line">    <span class="keyword">if</span> session.canAddInput(deviceInput!) &#123;</span><br><span class="line">        session.addInput(deviceInput!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> session.canAddOutput(metadataOutput) &#123;</span><br><span class="line">        session.addOutput(metadataOutput)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.告诉输出对象要输出什么样的数据,识别人脸, 最多可识别10张人脸</span></span><br><span class="line">    metadataOutput.metadataObjectTypes = [.face]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8.创建预览图层</span></span><br><span class="line">    previewLayer = <span class="built_in">AVCaptureVideoPreviewLayer</span>(session: session)</span><br><span class="line">    previewLayer.videoGravity = .resizeAspectFill</span><br><span class="line">    previewLayer.frame = view.bounds</span><br><span class="line">    previewView.layer.insertSublayer(previewLayer, at: <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9.设置有效扫描区域(默认整个屏幕区域)（每个取值0~1, 以屏幕右上角为坐标原点）</span></span><br><span class="line">    metadataOutput.rectOfInterest = previewView.bounds</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10. 开始扫描</span></span><br><span class="line">    <span class="keyword">if</span> !session.isRunning &#123;</span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            <span class="keyword">self</span>.session.startRunning()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-切换摄像头"><a href="#2-切换摄像头" class="headerlink" title="2. 切换摄像头"></a>2. 切换摄像头</h3><ul><li>获取当前摄像头方向</li><li>创建新的输入input</li><li>移除旧输入<code>capture</code>, 添加新的输入<code>capture</code></li><li>具体代码如下: </li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func switchCameraAction(_ sender: Any) &#123;</span><br><span class="line">    <span class="comment">//1. 执行转场动画</span></span><br><span class="line">    let anima = <span class="built_in">CATransition</span>()</span><br><span class="line">    anima.type = <span class="string">"oglFlip"</span></span><br><span class="line">    anima.subtype = <span class="string">"fromLeft"</span></span><br><span class="line">    anima.duration = <span class="number">0.5</span></span><br><span class="line">    view.layer.add(anima, forKey: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取当前摄像头</span></span><br><span class="line">    guard let deviceIn = deviceInput <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    let position: <span class="built_in">AVCaptureDevice</span>.Position = deviceIn.device.position == .back ? .front : .back</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 创建新的input</span></span><br><span class="line">    let deviceSession = <span class="built_in">AVCaptureDevice</span>.DiscoverySession(deviceTypes: [.builtInWideAngleCamera], mediaType: .video, position: position)</span><br><span class="line">    guard let newDevice = deviceSession.devices.filter(&#123; $<span class="number">0.</span>position == position &#125;).first <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    guard let newVideoInput = try? <span class="built_in">AVCaptureDeviceInput</span>(device: newDevice) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 移除旧输入，添加新输入</span></span><br><span class="line">    <span class="comment">//4.1 设备加锁</span></span><br><span class="line">    session.beginConfiguration()</span><br><span class="line">    <span class="comment">//4.2. 移除旧设备</span></span><br><span class="line">    session.removeInput(deviceIn)</span><br><span class="line">    <span class="comment">//4.3 添加新设备</span></span><br><span class="line">    session.addInput(newVideoInput)</span><br><span class="line">    <span class="comment">//4.4 设备解锁</span></span><br><span class="line">    session.commitConfiguration()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 保存最新输入</span></span><br><span class="line">    deviceInput = newVideoInput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-处理扫描结果"><a href="#3-处理扫描结果" class="headerlink" title="3. 处理扫描结果"></a>3. 处理扫描结果</h3><blockquote><p>实现<code>AVCaptureMetadataOutputObjectsDelegate</code>该协议的协议方法(只有一个方法)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//`metadataObjects`就是返回的扫描结果</span><br><span class="line">optional public func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection)</span><br></pre></td></tr></table></figure><h3 id="4-AVMetadataFaceObject介绍"><a href="#4-AVMetadataFaceObject介绍" class="headerlink" title="4. AVMetadataFaceObject介绍"></a>4. <code>AVMetadataFaceObject</code>介绍</h3><ul><li><code>faceID</code>: 人脸的唯一标识 <ul><li>扫描出来的每一个人, 有不同的<code>faceID</code></li><li>同一个人, 不同的状态下(摇头, 歪头, 抬头等), 都会有不同<code>faceID</code></li></ul></li><li><code>hasRollAngle</code>: 是否有倾斜角,侧倾角(左右歪头)(BOOL类型)</li><li><code>rollAngle</code>: 倾斜角,侧倾角的角度(<code>CGFloat</code>类型)</li><li><code>hasYawAngle</code>: 是否有偏转角(左右摇头)</li><li><code>yawAngle</code>: 偏转角角度</li></ul><h3 id="5-处理扫描结果"><a href="#5-处理扫描结果" class="headerlink" title="5. 处理扫描结果"></a>5. 处理扫描结果</h3><h4 id="5-1-获取预览图层的人脸数组"><a href="#5-1-获取预览图层的人脸数组" class="headerlink" title="5.1 获取预览图层的人脸数组"></a>5.1 获取预览图层的人脸数组</h4><ul><li>遍历扫描的人脸数组, 转换成在预览图层的人脸数组</li><li>主要是人脸在图层的左边的转换</li><li>返回转换后的新的数组</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func transformedFaces(faceObjs: [<span class="built_in">AVMetadataObject</span>]) -&gt; [<span class="built_in">AVMetadataObject</span>] &#123;</span><br><span class="line">    var faceArr = [<span class="built_in">AVMetadataObject</span>]()</span><br><span class="line">    <span class="keyword">for</span> face <span class="keyword">in</span> faceObjs &#123;</span><br><span class="line">        <span class="comment">//将扫描的人脸对象转成在预览图层的人脸对象(主要是坐标的转换)</span></span><br><span class="line">        <span class="keyword">if</span> let transFace = previewLayer.transformedMetadataObject(<span class="keyword">for</span>: face)&#123;</span><br><span class="line">            faceArr.append(transFace)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> faceArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-根据人脸位置添加红框"><a href="#5-2-根据人脸位置添加红框" class="headerlink" title="5.2 根据人脸位置添加红框"></a>5.2 根据人脸位置添加红框</h4><ul><li>设置红框的frame</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faceLayer?.frame = face.bounds</span><br></pre></td></tr></table></figure><ul><li>根据偏转角和倾斜角的角度获取<code>CATransform3D</code></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func transformDegress(yawAngle: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">CATransform3D</span> &#123;</span><br><span class="line">    let yaw = degreesToRadians(degress: yawAngle)</span><br><span class="line">    <span class="comment">//围绕Y轴旋转</span></span><br><span class="line">    let yawTran = <span class="built_in">CATransform3DMakeRotation</span>(yaw, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//红框旋转问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DConcat</span>(yawTran, <span class="built_in">CATransform3DIdentity</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理偏转角问题</span></span><br><span class="line">fileprivate func transformDegress(rollAngle: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">CATransform3D</span> &#123;</span><br><span class="line">    let roll = degreesToRadians(degress: rollAngle)</span><br><span class="line">    <span class="comment">//围绕Z轴旋转</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DMakeRotation</span>(roll, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//角度转换</span></span><br><span class="line">fileprivate func degreesToRadians(degress: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">CGFloat</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degress * <span class="built_in">CGFloat</span>(Double.pi) / <span class="number">180</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据有无偏转角和倾斜角旋转红框</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.4 设置偏转角(左右摇头)</span></span><br><span class="line"><span class="keyword">if</span> face.hasYawAngle&#123;</span><br><span class="line">    let tranform3D = transformDegress(yawAngle: face.yawAngle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//矩阵处理</span></span><br><span class="line">    faceLayer?.transform = <span class="built_in">CATransform3DConcat</span>(faceLayer!.transform, tranform3D)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.5 设置倾斜角,侧倾角(左右歪头)</span></span><br><span class="line"><span class="keyword">if</span> face.hasRollAngle&#123;</span><br><span class="line">    let tranform3D = transformDegress(rollAngle: face.rollAngle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//矩阵处理</span></span><br><span class="line">    faceLayer?.transform = <span class="built_in">CATransform3DConcat</span>(faceLayer!.transform, tranform3D)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>至此, 动态的人脸识别就完成了, 会在人脸位置增加红框显示, 并且红框会根据人脸的位置动态的, 实时的调整</li><li>下面就快拿起你的相机测试吧</li></ul><hr><h3 id="GitHub–Demo地址"><a href="#GitHub–Demo地址" class="headerlink" title="GitHub–Demo地址"></a>GitHub–<a href="https://github.com/coderQuanjun/JunFaceRecognition" target="_blank" rel="noopener">Demo地址</a></h3><ul><li>注意:  <ul><li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li><li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Swift黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> AVFoundation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS黑科技之(CoreImage)静态人脸识别(一)</title>
      <link href="/2017/11/22/iOS%E9%BB%91%E7%A7%91%E6%8A%80%E4%B9%8B(CoreImage)%E9%9D%99%E6%80%81%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB(%E4%B8%80)"/>
      <content type="html"><![CDATA[<blockquote><p>人脸识别原理简介：每一张图片都是由每一个像素点组成，而每一个像素点中又有对应的颜色值(如RGB)，人的面部特征中，不同的五官，颜色值肯定存在差异，而人脸识别技术就是通过对照片中每一个像素的识别进行大量的算法处理，最终得出五官的轮廓</p></blockquote><a id="more"></a><ul><li>这里我们将使用<code>CoreImage</code>框架,进行静态的人脸识别(类似照片, 图像等)</li><li>苹果原生的人脸识别并不是一个独立的框架，而是放在<code>CoreImage</code>框架中</li><li>Apple 已经帮我们把image的分类处理好了</li><li>CoreImage是iOS5新增的强大类库之一，它可以处理图片的各种效果，什么饱和度啊，旋转变形啊，色彩啊等等。</li><li>在使用CoreImage之前要导入CoreImage.framework框架</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-3f1d091e07de5a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Core Image框架图.png"></p><h2 id="一-主要类介绍"><a href="#一-主要类介绍" class="headerlink" title="一. 主要类介绍"></a>一. 主要类介绍</h2><ul><li>CIImage<ul><li>Core Image中的图像类，类似于UIKit中的UIImage类。</li></ul></li><li>CIContext: 上下文对象<ul><li>所有图像处理都在CIContext对象中实现，通过Quartz 2D、OpenGL渲染CIImage对象; 如滤镜、颜色等渲染处理</li></ul></li><li>CIColor：颜色<ul><li>图片的关联与画布、图片像素颜色的处理。</li></ul></li><li><p>CIVector：向量</p><ul><li>图片的坐标向量等几何方法处理。</li></ul></li><li><p>CIDetector<br>特征识别类</p><ul><li>该类集成了苹果有关特征识别的一些功能。</li><li>可检测图片中人脸的眼睛、嘴巴、等等</li></ul></li><li>CIFilter<ul><li>滤镜类，包含一个字典结构，对各种滤镜定义了属于自己的属性</li><li>CIFilter 产生一个CIImage</li><li>接受一到多的图片作为输入，经过一些过滤操作，产生指定输出的图片</li></ul></li><li>CIFeature: 代表由 detector处理后产生的特征</li></ul><h2 id="二-项目代码介绍"><a href="#二-项目代码介绍" class="headerlink" title="二. 项目代码介绍"></a>二. 项目代码介绍</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h3><h4 id="1-1-这里要先介绍一下检测器的类别"><a href="#1-1-这里要先介绍一下检测器的类别" class="headerlink" title="1.1 这里要先介绍一下检测器的类别"></a>1.1 这里要先介绍一下检测器的类别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//人脸检测器</span><br><span class="line">public let CIDetectorTypeFace: String</span><br><span class="line"></span><br><span class="line">//矩形识别</span><br><span class="line">public let CIDetectorTypeRectangle: String</span><br><span class="line"></span><br><span class="line">//二维码识别</span><br><span class="line">public let CIDetectorTypeQRCode: String</span><br><span class="line"></span><br><span class="line">//文本识别</span><br><span class="line">public let CIDetectorTypeText: String</span><br><span class="line"></span><br><span class="line">//指定检测精度</span><br><span class="line">public let CIDetectorAccuracy: String</span><br><span class="line"></span><br><span class="line">//指定使用特征跟踪，这个功能就像相机中的人脸跟踪功能</span><br><span class="line">public let CIDetectorTracking: String</span><br><span class="line"></span><br><span class="line">//设置将要识别的特征的最小尺寸</span><br><span class="line">public let CIDetectorMinFeatureSize: String</span><br><span class="line"></span><br><span class="line">//针对矩形探测器的，用于设置返回矩形特征的最多个数。</span><br><span class="line">//这个关键字的值是一个1~...的NSNumber值。有效范围1 &lt; = CIDetectorMaxFeatureCount &lt; = 256。默认值为1</span><br><span class="line">public let CIDetectorMaxFeatureCount: String</span><br><span class="line"></span><br><span class="line">//脸部透视数, 值为包含1、3、5、7、9、11的NSNumber对象</span><br><span class="line">public let CIDetectorNumberOfAngles: String</span><br><span class="line"></span><br><span class="line">//设置识别方向，值是一个从1 ~ 8的整型的NSNumber</span><br><span class="line">public let CIDetectorImageOrientation: String</span><br><span class="line"></span><br><span class="line">//设置这个参数为true(bool类型的NSNumber)，识别器将提取眨眼特征</span><br><span class="line">public let CIDetectorEyeBlink: String</span><br><span class="line"></span><br><span class="line">//如果设置这个参数为ture(bool类型的NSNumber)，识别器将提取微笑特征</span><br><span class="line">public let CIDetectorSmile: String</span><br><span class="line"></span><br><span class="line">//用于设置每帧焦距，值得类型为floot类型的NSNumber</span><br><span class="line">public let CIDetectorFocalLength: String</span><br><span class="line"></span><br><span class="line">//用于设置矩形的长宽比，值得类型为floot类型的NSNumber</span><br><span class="line">public let CIDetectorAspectRatio: String</span><br><span class="line"></span><br><span class="line">//控制文本检测器是否应该检测子特征。默认值是否，值的类型为bool类型的NSNumber</span><br><span class="line">public let CIDetectorReturnSubFeatures: String</span><br></pre></td></tr></table></figure><ul><li>这里需要的是人脸识别的<code>CIDetectorTypeFace</code></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建上下文对象</span></span><br><span class="line">let context = <span class="built_in">CIContext</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. UIImage转成CIImage</span></span><br><span class="line">guard let image = imageView.image  <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">guard let ciImage = <span class="built_in">CIImage</span>(image: image) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 参数设置(精度设置)</span></span><br><span class="line">let parmes = [<span class="built_in">CIDetectorAccuracy</span>: <span class="built_in">CIDetectorAccuracyHigh</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 创建识别类</span></span><br><span class="line">let detector = <span class="built_in">CIDetector</span>(ofType: <span class="built_in">CIDetectorTypeFace</span>, context: context, options: parmes)</span><br></pre></td></tr></table></figure><h3 id="2-参数设置"><a href="#2-参数设置" class="headerlink" title="2. 参数设置"></a>2. 参数设置</h3><ul><li>这里设置了一个识别精度CIDetectorAccuracy，识别精度的值有：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//识别精度低，但识别速度快、性能高</span><br><span class="line">public let CIDetectorAccuracyLow: String </span><br><span class="line"></span><br><span class="line">// 识别精度高，但识别速度慢、性能低</span><br><span class="line">public let CIDetectorAccuracyHigh: String</span><br></pre></td></tr></table></figure><ul><li>除了精度的设置，还有<code>CIDetectorMinFeatureSize</code>用于设置将要识别的特征的最小尺寸，也就是说小于这个尺寸的特征将不识别。<ul><li>对于人脸检测器，这个关键字的值是从0.0 ~ 1.0的<code>NSNumber</code>值，这个值表示：基于输入图像短边长度的百分比。有效值范围:0.01 &lt;= <code>CIDetectorMinFeatureSize</code> &lt;= 0.5。为这个参数设定更高值仅用于提高性能。默认值是0.15。</li><li>对于矩形探测器，这个关键字的值是从0.0 ~ 1.0的<code>NSNumber</code>值，这个值表示：基于输入图像短边长度的百分比。有效值范围:0.2 &lt;= <code>CIDetectorMinFeatureSize</code> &lt;= 1.0的默认值是0.2。</li><li>对于文本探测器，这个关键字的值是一个范围从0.0 ~ 1.0的<code>NSNumber</code>值，这个值表示：基于输入图像高度的百分比。有效值范围:0.0 &lt;= <code>CIDetectorMinFeatureSize</code> &lt;= 1.0。默认值是10/(输入图像的高度)</li></ul></li></ul><h3 id="3-CIFaceFeature概述"><a href="#3-CIFaceFeature概述" class="headerlink" title="3. CIFaceFeature概述"></a>3. CIFaceFeature概述</h3><ul><li><code>CIFaceFeature</code>是保存脸部所有信息的类</li><li><code>CIFaceFeature</code>是<code>CIFeature</code>的子类</li><li><code>CIFeature</code>类只保存基本信息， 所有的附加信息由子类(<code>CIFaceFeature</code>)保存</li><li>各属性简介:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测到的脸部在图片中的frame</span></span><br><span class="line">open var bounds: <span class="built_in">CGRect</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否检测到左眼的位置</span></span><br><span class="line">open var hasLeftEyePosition: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左眼的位置</span></span><br><span class="line">open var leftEyePosition: <span class="built_in">CGPoint</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否检测到右眼的位置</span></span><br><span class="line">open var hasRightEyePosition: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右眼的位置</span></span><br><span class="line">open var rightEyePosition: <span class="built_in">CGPoint</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否检测到嘴巴的位置</span></span><br><span class="line">open var hasMouthPosition: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//嘴巴的位置</span></span><br><span class="line">open var mouthPosition: <span class="built_in">CGPoint</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//脸部是否倾斜    </span></span><br><span class="line">open var hasFaceAngle: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//脸部倾斜角度</span></span><br><span class="line">open var faceAngle: Float &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否微笑    </span></span><br><span class="line">open var hasSmile: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左眼是否闭上</span></span><br><span class="line">open var leftEyeClosed: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右眼是否闭上</span></span><br><span class="line">open var rightEyeClosed: Bool &#123; get &#125;</span><br></pre></td></tr></table></figure><h3 id="4-Core-Image坐标系问题"><a href="#4-Core-Image坐标系问题" class="headerlink" title="4. Core Image坐标系问题"></a>4. <code>Core Image</code>坐标系问题</h3><ul><li>如图: </li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-a8af4dc80c214d1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="坐标系对比.png"></p></li><li><p><code>UIView</code>坐标系</p><ul><li>图中上半部分坐标系</li><li>Y轴自上而下依次增大</li></ul></li><li><code>Core Image</code>坐标系<ul><li>图中下半部分显示坐标系</li><li>X轴与<code>UIView</code>坐标系相同, Y轴坐标系最底部为0, 自下而上依次增大, 与<code>UIView</code>坐标系相反</li><li>所以需要对以次坐标设置frame的控件, 做一次针对Y轴的翻转, 如下: </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultView.transform = CGAffineTransform(scaleX: 1, y: -1)</span><br></pre></td></tr></table></figure><h3 id="5-人脸检测-核心代码"><a href="#5-人脸检测-核心代码" class="headerlink" title="5. 人脸检测(核心代码)"></a>5. 人脸检测(核心代码)</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 通过人脸识别提取有效的人脸图片</span></span><br><span class="line"><span class="keyword">static</span> func faceImagesByFaceRecognition(imageView: <span class="built_in">UIImageView</span>, resultCallback: @escaping ((_ count: Int) -&gt; ())) &#123;</span><br><span class="line">    <span class="comment">//0. 删除子控件</span></span><br><span class="line">    let subViews = imageView.subviews</span><br><span class="line">    <span class="keyword">for</span> subview <span class="keyword">in</span> subViews &#123;</span><br><span class="line">        <span class="keyword">if</span> subview.isKind(of: <span class="built_in">UIView</span>.self) &#123;</span><br><span class="line">            subview.removeFromSuperview()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 创建上下文对象</span></span><br><span class="line">    let context = <span class="built_in">CIContext</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. UIImage转成CIImage</span></span><br><span class="line">    guard let image = imageView.image  <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    guard let ciImage = <span class="built_in">CIImage</span>(image: image) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 参数设置(精度设置)</span></span><br><span class="line">    let parmes = [<span class="built_in">CIDetectorAccuracy</span>: <span class="built_in">CIDetectorAccuracyHigh</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 创建识别类</span></span><br><span class="line">    let detector = <span class="built_in">CIDetector</span>(ofType: <span class="built_in">CIDetectorTypeFace</span>, context: context, options: parmes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 找到识别其中的人连对象</span></span><br><span class="line">    guard let faceArr = detector?.features(<span class="keyword">in</span>: ciImage) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6. 添加识别的红框</span></span><br><span class="line">    let resultView = <span class="built_in">UIView</span>(frame: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: imageView.frame.width, height: imageView.frame.height))</span><br><span class="line">    imageView.addSubview(resultView)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7. 遍历扫描结果</span></span><br><span class="line">    <span class="keyword">for</span> faceFeature <span class="keyword">in</span> faceArr &#123;</span><br><span class="line">        resultView.addSubview(addRedrectangleView(rect: faceFeature.bounds))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.1 如果识别到眼睛</span></span><br><span class="line">        guard let feature = faceFeature as? <span class="built_in">CIFaceFeature</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="comment">//左眼</span></span><br><span class="line">        <span class="keyword">if</span> feature.hasLeftEyePosition &#123;</span><br><span class="line">            let leftView = addRedrectangleView(rect: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">5</span>, height: <span class="number">5</span>))</span><br><span class="line">            leftView.center = feature.leftEyePosition</span><br><span class="line">            resultView.addSubview(leftView)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右眼</span></span><br><span class="line">        <span class="keyword">if</span> feature.hasRightEyePosition &#123;</span><br><span class="line">            let rightView = addRedrectangleView(rect: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">5</span>, height: <span class="number">5</span>))</span><br><span class="line">            rightView.setValue(feature.rightEyePosition, forKey: <span class="string">"center"</span>)</span><br><span class="line">            resultView.addSubview(rightView)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.2 识别嘴巴</span></span><br><span class="line">        <span class="keyword">if</span> feature.hasMouthPosition &#123;</span><br><span class="line">            let mouthView = addRedrectangleView(rect: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">10</span>, height: <span class="number">5</span>))</span><br><span class="line">            mouthView.setValue(feature.mouthPosition, forKey: <span class="string">"center"</span>)</span><br><span class="line">            resultView.addSubview(mouthView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8. 将resultView沿x轴翻转</span></span><br><span class="line">    resultView.transform = <span class="built_in">CGAffineTransform</span>(scaleX: <span class="number">1</span>, y: <span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9. 结果回调</span></span><br><span class="line">    resultCallback(faceArr.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-检测结果展示"><a href="#6-检测结果展示" class="headerlink" title="6. 检测结果展示"></a>6. 检测结果展示</h3><ul><li>检测到的人脸部位展示红色矩形框</li><li>眼镜和嘴巴部位显示红色矩形框</li><li>照片随机选取的, 不喜勿喷</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-424e5a9f1da0e4b5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="WechatIMG29.jpeg"></p><h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项:"></a>7. 注意事项:</h3><ul><li>image的实际尺寸需要和imageView的尺寸完全一样,获取的脸部各个部位的尺寸才能完全吻合</li><li>这里我只做了简单的尺寸比例转换</li><li>代码如下:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> func getScale(imageView: <span class="built_in">UIImageView</span>, image: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">CGFloat</span>&#123;</span><br><span class="line">    let viewSize = imageView.frame.size</span><br><span class="line">    let imageSize = image.size</span><br><span class="line">    </span><br><span class="line">    let widthScale = imageSize.width / viewSize.width</span><br><span class="line">    let heightScale = imageSize.height / viewSize.height</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> widthScale &gt; heightScale ? widthScale : heightScale</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="GitHub–Demo地址"><a href="#GitHub–Demo地址" class="headerlink" title="GitHub–Demo地址"></a>GitHub–<a href="https://github.com/coderQuanjun/JunFaceRecognition" target="_blank" rel="noopener">Demo地址</a></h3><ul><li>注意:  <ul><li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li><li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Swift黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> CIDetector </tag>
            
            <tag> AVFoundation </tag>
            
            <tag> CoreImage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift之二维码的生成、识别和扫描</title>
      <link href="/2017/11/16/Swift%E4%B9%8B%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E7%94%9F%E6%88%90%E3%80%81%E8%AF%86%E5%88%AB%E5%92%8C%E6%89%AB%E6%8F%8F"/>
      <content type="html"><![CDATA[<blockquote><p>最近在项目中遇到了涉及二维码相关的问题, 这里想记录总结一下二维码相关技术</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h2 id="一-二维码的介绍"><a href="#一-二维码的介绍" class="headerlink" title="一. 二维码的介绍"></a>一. 二维码的介绍</h2><ul><li>二维条码/二维码是用某种特定的几何图形按一定规律在平面分布的黑白相间的图形记录数据符号信息的</li><li>总结: 用图形记录标记一些信息,方便通过图形识别来获取信息</li><li>应用场景<ul><li>信息获取（名片、地图、WIFI密码、资料）</li><li>手机电商（用户扫码、手机直接购物下单）</li><li>手机支付（扫描商品二维码，通过银行或第三方支付提供的手机端通道完成支付)</li><li>微信添加好友</li></ul></li></ul><h2 id="二-二维码的生成"><a href="#二-二维码的生成" class="headerlink" title="二. 二维码的生成"></a>二. 二维码的生成</h2><ul><li>生成二维码的方式<ul><li>采用第三方框架(放弃)<ul><li>ZXing/ZBar</li><li>框架不支持64位(2015年2月1号起, - 不允许不支持64位处理器的APP 上架)</li></ul></li><li>系统自带API</li></ul></li><li>生成二维码的步骤<ul><li>创建二维码滤镜–CIFilter</li><li>恢复滤镜的默认属性</li><li>设置滤镜的输入数据</li><li>将传入的字符串转换成Data(OC为NSData)数据</li><li>通过KVC来设置输入的内容<code>inputMessage</code><h3 id="1-二维码容错率"><a href="#1-二维码容错率" class="headerlink" title="1. 二维码容错率"></a>1. 二维码容错率</h3></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter?.setValue(&quot;H&quot;, forKey: &quot;inputCorrectionLevel&quot;)</span><br></pre></td></tr></table></figure><ul><li><code>inputCorrectionLevel</code> 是一个单字母（@”L”, @”M”, @”Q”, @”H” 中的一个），表示不同级别的容错率，默认为 @”M”.</li><li>QR码有容错能力，QR码图形如果有破损，仍然可以被机器读取内容，最高可以到7%~30%面积破损仍可被读取,相对而言，容错率愈高，QR码图形面积愈大。所以一般折衷使用15%容错能力。</li><li>L水平 7%的字码可被修正.</li><li>M水平 15%的字码可被修正</li><li>Q水平 25%的字码可被修正</li><li>H水平 30%的字码可被修正</li><li>代码: </li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *  @param inputMsg 二维码保存的信息</span></span><br><span class="line"><span class="comment">   *  @param fgImage  前景图片  */</span></span><br><span class="line">func generateCode(inputMsg: String, fgImage: <span class="built_in">UIImage</span>?) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    <span class="comment">//1. 将内容生成二维码</span></span><br><span class="line">    <span class="comment">//1.1 创建滤镜</span></span><br><span class="line">    let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CIQRCodeGenerator"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.2 恢复默认设置</span></span><br><span class="line">    filter?.setDefaults()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.3 设置生成的二维码的容错率</span></span><br><span class="line">    <span class="comment">//value = @"L/M/Q/H"</span></span><br><span class="line">    filter?.setValue(<span class="string">"H"</span>, forKey: <span class="string">"inputCorrectionLevel"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.设置输入的内容(KVC)</span></span><br><span class="line">    <span class="comment">// 注意:key = inputMessage, value必须是NSData类型</span></span><br><span class="line">    let inputData = inputMsg.data(using: .utf8)</span><br><span class="line">    filter?.setValue(inputData, forKey: <span class="string">"inputMessage"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 获取输出的图片</span></span><br><span class="line">    guard let outImage = filter?.outputImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">UIImage</span>() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 获取高清图片</span></span><br><span class="line">    let hdImage = getHDImage(outImage)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 判断是否有前景图片</span></span><br><span class="line">    <span class="keyword">if</span> fgImage == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hdImage</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6. 获取有前景图片的二维码</span></span><br><span class="line">    <span class="keyword">return</span> getResultImage(hdImage: hdImage, fgImage: fgImage!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-获取高清图片"><a href="#2-获取高清图片" class="headerlink" title="2. 获取高清图片"></a>2. 获取高清图片</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 获取高清图片</span></span><br><span class="line">fileprivate func getHDImage(_ outImage: <span class="built_in">CIImage</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    let transform = <span class="built_in">CGAffineTransform</span>(scaleX: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line">    <span class="comment">//放大图片</span></span><br><span class="line">    let ciImage = outImage.transformed(by: transform)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(ciImage: ciImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-将图片合成到二维码中"><a href="#3-将图片合成到二维码中" class="headerlink" title="3. 将图片合成到二维码中"></a>3. 将图片合成到二维码中</h3><ul><li>需要用到图形上下文</li><li>将二维码画到图形上下文</li><li>将图片合成到图行上下文</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取前景图片</span></span><br><span class="line">fileprivate func getResultImage(hdImage: <span class="built_in">UIImage</span>, fgImage: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    let hdSize = hdImage.size</span><br><span class="line">    <span class="comment">//1. 开启图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(hdSize)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 将高清图片画到上下文</span></span><br><span class="line">    hdImage.draw(<span class="keyword">in</span>: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: hdSize.width, height: hdSize.height))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 将前景图片画到上下文</span></span><br><span class="line">    let fgWidth: <span class="built_in">CGFloat</span> = <span class="number">80</span></span><br><span class="line">    fgImage.draw(<span class="keyword">in</span>: <span class="built_in">CGRect</span>(x: (hdSize.width - fgWidth) / <span class="number">2</span>, y: (hdSize.height - fgWidth) / <span class="number">2</span>, width: fgWidth, height: fgWidth))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 获取上下文</span></span><br><span class="line">    guard let resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>() <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">UIImage</span>() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 关闭上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后续会研究彩色二维码的黑科技, 敬请期待…</p></blockquote><h2 id="识别二维码"><a href="#识别二维码" class="headerlink" title="识别二维码"></a>识别二维码</h2><blockquote><p>识别图片中二维码步骤</p><ul><li>创建探测器<ul><li>属于CoreImage框架(CIDetector)</li></ul></li><li>获取CIImage类型的图片</li><li>获取图片中所有符合特征的内容(CIQRCodeFeature)</li><li>遍历所有的特性(CIQRCodeFeature)</li><li>获取特征中代表的信息(messageString)</li><li>识别二维码的代码实现</li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *  @param qrCodeImage 二维码的图片</span></span><br><span class="line"><span class="comment">   *  @return 结果的数组 */</span></span><br><span class="line">func recognitionQRCode(qrCodeImage: <span class="built_in">UIImage</span>) -&gt; [String]? &#123;</span><br><span class="line">    <span class="comment">//1. 创建过滤器</span></span><br><span class="line">    let detector = <span class="built_in">CIDetector</span>(ofType: <span class="built_in">CIDetectorTypeQRCode</span>, context: <span class="literal">nil</span>, options: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取CIImage</span></span><br><span class="line">    guard let ciImage = <span class="built_in">CIImage</span>(image: qrCodeImage) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 识别二维码</span></span><br><span class="line">    guard let features = detector?.features(<span class="keyword">in</span>: ciImage) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 遍历数组, 获取信息</span></span><br><span class="line">    var resultArr = [String]()</span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> features &#123;</span><br><span class="line">        resultArr.append(feature.type)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-二维码的扫描"><a href="#三-二维码的扫描" class="headerlink" title="三. 二维码的扫描"></a>三. 二维码的扫描</h2><ul><li>创建输入设备(摄像头)<ul><li>获取摄像头设备</li><li>创建输入对象</li></ul></li><li>创建输出设置(元数据)<ul><li>创建输出对象</li><li>设置输出对象的代理(在代理中获取扫描到的数据)</li><li>设置输出数据的类型</li></ul></li><li>创建捕捉会话<ul><li>将输入添加到会话中</li><li>将输出添加到会话中</li></ul></li><li>添加预览图片(方便用于查看)<ul><li>创建图层,将图片添加到View图层中</li></ul></li><li>开始扫描</li></ul><h3 id="1-懒加载输入输出中间会话"><a href="#1-懒加载输入输出中间会话" class="headerlink" title="1. 懒加载输入输出中间会话"></a>1. 懒加载输入输出中间会话</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入输出中间桥梁(会话)</span></span><br><span class="line">fileprivate lazy var session : <span class="built_in">AVCaptureSession</span> = <span class="built_in">AVCaptureSession</span>()</span><br></pre></td></tr></table></figure><h3 id="2-初始化扫描设备"><a href="#2-初始化扫描设备" class="headerlink" title="2. 初始化扫描设备"></a>2. 初始化扫描设备</h3><h4 id="2-1-注意-AVCaptureMetadataOutputObjectsDelegate的代理设置-该协议中的方法会将扫描的结果返回"><a href="#2-1-注意-AVCaptureMetadataOutputObjectsDelegate的代理设置-该协议中的方法会将扫描的结果返回" class="headerlink" title="2.1. 注意: AVCaptureMetadataOutputObjectsDelegate的代理设置, 该协议中的方法会将扫描的结果返回"></a>2.1. 注意: <code>AVCaptureMetadataOutputObjectsDelegate</code>的代理设置, 该协议中的方法会将扫描的结果返回</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func addScaningVideo()&#123;</span><br><span class="line">    <span class="comment">//1.获取输入设备（摄像头）</span></span><br><span class="line">    guard let device = <span class="built_in">AVCaptureDevice</span>.default(<span class="keyword">for</span>: .video) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.根据输入设备创建输入对象</span></span><br><span class="line">    guard let deviceInput = try? <span class="built_in">AVCaptureDeviceInput</span>(device: device) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.创建原数据的输出对象</span></span><br><span class="line">    let metadataOutput = <span class="built_in">AVCaptureMetadataOutput</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.设置代理监听输出对象输出的数据，在主线程中刷新</span></span><br><span class="line">    metadataOutput.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: DispatchQueue.main)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.创建会话（桥梁）</span></span><br><span class="line">    <span class="comment">//        let session = AVCaptureSession()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.添加输入和输出到会话</span></span><br><span class="line">    <span class="keyword">if</span> session.canAddInput(deviceInput) &#123;</span><br><span class="line">        session.addInput(deviceInput)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> session.canAddOutput(metadataOutput) &#123;</span><br><span class="line">        session.addOutput(metadataOutput)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.告诉输出对象要输出什么样的数据(二维码还是条形码),要先创建会话才能设置</span></span><br><span class="line">    metadataOutput.metadataObjectTypes = [.qr, .code128, .code39, .code93, .code39Mod43, .ean8, .ean13, .upce, .pdf417, .aztec]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8.创建预览图层</span></span><br><span class="line">    let previewLayer: <span class="built_in">AVCaptureVideoPreviewLayer</span> = <span class="built_in">AVCaptureVideoPreviewLayer</span>(session: session)</span><br><span class="line">    previewLayer.videoGravity = .resizeAspectFill</span><br><span class="line">    previewLayer.frame = view.bounds</span><br><span class="line">    view.layer.insertSublayer(previewLayer, at: <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9.设置有效扫描区域(默认整个屏幕区域)（每个取值0~1, 以屏幕右上角为坐标原点）</span></span><br><span class="line">    let rect = <span class="built_in">CGRect</span>(x: scanImageView.frame.minY / kScreenHeight, y: scanImageView.frame.minX / kScreenWidth, width: scanImageView.frame.height / kScreenHeight, height: scanImageView.frame.width / kScreenWidth)</span><br><span class="line">    metadataOutput.rectOfInterest = rect</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10. 开始扫描</span></span><br><span class="line">    session.startRunning()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-代理方法的实现"><a href="#2-2-代理方法的实现" class="headerlink" title="2.2 代理方法的实现"></a>2.2 代理方法的实现</h4><ul><li>需要将扫描的结果转化成机器可读的编码数据,才能获取二维码的相关信息</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">extension ScaningViewController: <span class="built_in">AVCaptureMetadataOutputObjectsDelegate</span> &#123;</span><br><span class="line">    func metadataOutput(_ output: <span class="built_in">AVCaptureMetadataOutput</span>, didOutput metadataObjects: [<span class="built_in">AVMetadataObject</span>], from connection: <span class="built_in">AVCaptureConnection</span>) &#123;</span><br><span class="line">        <span class="comment">//1. 取出扫描到的数据: metadataObjects</span></span><br><span class="line">        <span class="comment">//2. 以震动的形式告知用户扫描成功</span></span><br><span class="line">        AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 关闭session</span></span><br><span class="line">        session.stopRunning()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 遍历结果</span></span><br><span class="line">        var resultArr = [String]()</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> metadataObjects &#123;</span><br><span class="line">            <span class="comment">//转换成机器可读的编码数据</span></span><br><span class="line">            <span class="keyword">if</span> let code = result as? <span class="built_in">AVMetadataMachineReadableCodeObject</span> &#123;</span><br><span class="line">                resultArr.append(code.stringValue ?? <span class="string">""</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                resultArr.append(result.type.rawValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5. 将结果</span></span><br><span class="line">        let vc = ShowViewController()</span><br><span class="line">        vc.scanDataArr = resultArr</span><br><span class="line">        navigationController?.pushViewController(vc, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目地址-Github"><a href="#项目地址-Github" class="headerlink" title="项目地址: Github "></a><a href="https://github.com/coderQuanjun/JunQRCode" target="_blank" rel="noopener">项目地址: Github </a></h2><ul><li>感谢大家的支持</li></ul><hr><h3 id="其他相关文章"><a href="#其他相关文章" class="headerlink" title="其他相关文章"></a>其他相关文章</h3><ul><li><a href="http://www.jianshu.com/p/0a30d1af8335" target="_blank" rel="noopener">Swift之二维码的生成、识别和扫描</a></li><li><a href="http://www.jianshu.com/p/168007f6f8b4" target="_blank" rel="noopener">iOS黑科技之(CoreImage)静态人脸识别(一)</a></li><li><a href="http://www.jianshu.com/p/5e624dc68a64" target="_blank" rel="noopener">iOS黑科技之(AVFoundation)动态人脸识别(二)</a></li><li><a href="http://www.jianshu.com/p/08174663d2e9" target="_blank" rel="noopener">Swift之Vision 图像识别框架</a></li></ul>]]></content>
      
      <categories>
          
          <category> Swift黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> CIFilter </tag>
            
            <tag> CIDetector </tag>
            
            <tag> AVFoundation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift之删除HTML5页面的广告</title>
      <link href="/2017/11/11/Swift%E4%B9%8B%E5%88%A0%E9%99%A4HTML5%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%B9%BF%E5%91%8A"/>
      <content type="html"><![CDATA[<p>好久没来博客了,最近工作中任务(Bug)比较多!除了改Bug之外发现最近新出的一部电视剧不错, 给大家推荐一下&lt;&lt;&lt;&lt;猎场&gt;&gt;&gt;&gt;</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-050601a063e14ce8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="猎场.jpg"></p><h2 id="一-UIWebViewDelegate"><a href="#一-UIWebViewDelegate" class="headerlink" title="一. UIWebViewDelegate"></a>一. UIWebViewDelegate</h2><ul><li>好了,言归正传,今天遇到了一个关于UIWebView问题的问题,如何删除H5页面的广告问题(一般出现在第三方的H5页面的情况)</li><li>APP中嵌入一个H5的网页，但出现的广告条或是无关头尾，相当大煞风景, 那该如何去掉呢?</li><li>嵌入webview 一段JavaScript代码来隐藏，目前Android和iOS都支持此方法(这就是iOS中常说的js和OC交互)</li><li>UIWebVIew的基本使用这里就不多做介绍了</li><li>下面介绍一下UIWebViewDelegate的一些代理方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当网页视图被指示载入内容而得到通知。应当返回YES，这样会进行加载。通过导航类型参数可以得到请求发起的原因</span></span><br><span class="line">optional public func webView(_ webView: <span class="built_in">UIWebView</span>, shouldStartLoadWith request: URLRequest, navigationType: <span class="built_in">UIWebViewNavigationType</span>) -&gt; Bool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//UIWebView的控件加载网页的监听函数方法：</span></span><br><span class="line"><span class="comment">//1. 当网页视图已经开始加载一个请求后，得到通知。</span></span><br><span class="line">optional public func webViewDidStartLoad(_ webView: <span class="built_in">UIWebView</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 当网页视图结束加载一个请求之后，得到通知。</span></span><br><span class="line">optional public func webViewDidFinishLoad(_ webView: <span class="built_in">UIWebView</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 当前请求加载中发生错误时，得到通知。</span></span><br><span class="line">optional public func webView(_ webView: <span class="built_in">UIWebView</span>, didFailLoadWithError error: Error)</span><br></pre></td></tr></table></figure><h2 id="二-基于JavaScript的H5代码"><a href="#二-基于JavaScript的H5代码" class="headerlink" title="二. 基于JavaScript的H5代码"></a>二. 基于JavaScript的H5代码</h2><ul><li>首先,我们先看一下HTML5在浏览器中的现实情况, <a href="http://mini.eastday.com/mobile/170818161313395.html" target="_blank" rel="noopener">参考地址</a></li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-146823b54ab03b8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除前的原网页"></p></li><li><p>下面我们就要找到广告或者其他你想删除的部分对应的HTML代码</p></li><li>用浏览器打开<a href="http://mini.eastday.com/mobile/170818161313395.html" target="_blank" rel="noopener">参考地址</a>, 建议使用谷歌浏览器</li><li>找到浏览器的开发者工具, 按照如下操作</li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-c3efc0cb6e21f3ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看网页代码"></p></li><li><p>控制网页和js源码的显示方式</p></li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-ea333a6efa617e15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20171111_6.png"></p><ul><li>调节手机/电脑显示: 你要选择在那种情境下显示网页,通俗来说,就是模拟器</li><li>放大镜:你可以通过放大镜对网页上的控件进行选取,然后找到html代码</li><li>手机:转化为手机模式,但是前提必须要转换Device的模式,要不然,光是视图上的转变,没有实际的转变(注意:我现在拿手机的网页做示例,所有我需要转化,当你做的电脑的就不需要转换这些了)</li></ul></li><li><p>下面这就是要找到广告对应的js源码了(这里以订阅按钮为例)<br><img src="http://upload-images.jianshu.io/upload_images/4122543-e8c6dd62b00d9c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20171111_8.png"></p><ul><li>将右侧按钮为选中状态</li><li>用鼠标选中你要删除的控件(这里以订阅按钮为例), 这时你会发现右侧代码会有一行背景颜色被加深</li><li>我们要做的就是调用js语法删除这行js代码, 从而删除订阅按钮</li><li>找到该控件的class标签或者id标签</li><li>通过以下代码控制删除</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//class类型</span><br><span class="line">document.getElementsByClassName(&apos;gg-item news-gg-img3&apos;).style.display = &apos;none&apos;</span><br><span class="line">//id类型</span><br><span class="line">document.getElementsById(&apos;gg-item news-gg-img3&apos;).style.display = &apos;none&apos;</span><br></pre></td></tr></table></figure><ul><li>如果找到的该控件所在的js代码没有class或者id标志, 可以继续找到其父控件,通过以下方式删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByClassName(&apos;gg-item news-gg-img3&apos;)[0].style.display=&apos;none&apos;</span><br></pre></td></tr></table></figure><h2 id="三-具体核心代码如下"><a href="#三-具体核心代码如下" class="headerlink" title="三. 具体核心代码如下"></a>三. 具体核心代码如下</h2><ul><li>删除广告后的效果如图</li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-26d52ecdfceb0f52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="最终效果图"></p></li><li><p>核心代码</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extension NoneADViewController: <span class="built_in">UIWebViewDelegate</span>&#123;</span><br><span class="line">    func webViewDidFinishLoad(_ webView: <span class="built_in">UIWebView</span>) &#123;</span><br><span class="line">        <span class="comment">//最顶部的广告</span></span><br><span class="line">        webView.stringByEvaluatingJavaScript(from: <span class="string">"document.getElementsByClassName('gg-item news-gg-img3')[0].style.display='none'"</span>)</span><br><span class="line">        <span class="comment">//删除页面浮框广告</span></span><br><span class="line">        webView.stringByEvaluatingJavaScript(from: <span class="string">"document.getElementsByClassName('dbleleven-wrap')[0].style.display='none'"</span>)</span><br><span class="line">        <span class="comment">//第一张图片下面的广告</span></span><br><span class="line">        webView.stringByEvaluatingJavaScript(from: <span class="string">"document.getElementsByClassName('baiduimageplusm-title-img-only')[0].style.display = 'none'"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func webView(_ webView: <span class="built_in">UIWebView</span>, shouldStartLoadWith request: URLRequest, navigationType: <span class="built_in">UIWebViewNavigationType</span>) -&gt; Bool &#123;</span><br><span class="line">        guard let urlStr = request.url?.absoluteString <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">        print(urlStr)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 入坑指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> HTML5 </tag>
            
            <tag> WebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift之微信朋友圈图片浏览器</title>
      <link href="/2017/10/28/Swift%E4%B9%8B%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8"/>
      <content type="html"><![CDATA[<blockquote><p>最近闲来无事,突然对微信, 微博, QQ等社交APP的九宫格的图片浏览功能非常感兴趣, 最近就尝试着研究了一下:</p></blockquote><blockquote><p>这里先附上<a href="https://github.com/coderQuanjun/JunPhotoBrowseDemo" target="_blank" rel="noopener">Demo地址</a></p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><ul><li>在介绍项目之前, 先介绍三个基础知识<ul><li><code>CATransition</code>转场动画</li><li><code>ViewController</code>自定义转场</li><li><code>UIBesization</code>贝塞尔曲线</li></ul></li></ul><h2 id="一-CATransition转场动画"><a href="#一-CATransition转场动画" class="headerlink" title="一. CATransition转场动画"></a>一. CATransition转场动画</h2><blockquote><p>示例代码</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 转场动画</span></span><br><span class="line">let transition = <span class="built_in">CATransition</span>()</span><br><span class="line">transition.type = transitionType</span><br><span class="line">transition.subtype = isNext ? kCATransitionFromRight : kCATransitionFromLeft</span><br><span class="line">transition.duration = <span class="number">1</span></span><br><span class="line">downloadImage(url: imageURL)</span><br><span class="line">baseImage.layer.add(transition, forKey: <span class="string">"transition"</span>)</span><br></pre></td></tr></table></figure><p>更多关于该动画的详细介绍, 可参考<a href="http://www.jianshu.com/p/2b2f49399b7e" target="_blank" rel="noopener">iOS出门必备之CoreAnimation(核心动画)</a>中第七种CA动画, 故这里不多做介绍</p><h2 id="二-ViewController自定义转场"><a href="#二-ViewController自定义转场" class="headerlink" title="二. ViewController自定义转场"></a>二. <code>ViewController</code>自定义转场</h2><blockquote><p>从iOS7开始，苹果更新了自定义ViewController转场的API,会用到的几个协议<code>protocol</code>:</p></blockquote><ul><li>描述ViewController转场的：<ul><li><code>UIViewControllerTransitioningDelegate</code></li><li><code>UINavigationControllerDelegate</code></li><li><code>UITabBarControllerDelegate</code></li></ul></li><li>定义动画内容的<ul><li><code>UIViewControllerAnimatedTransitioning</code></li><li><code>UIViewControllerInteractiveTransitioning</code></li></ul></li><li>表示动画上下文的<ul><li><code>UIViewControllerContextTransitioning</code></li></ul></li></ul><h3 id="1-1-描述ViewController转场的"><a href="#1-1-描述ViewController转场的" class="headerlink" title="1-1. 描述ViewController转场的"></a>1-1. 描述ViewController转场的</h3><ul><li>为什么苹果要引入这一套API？因为在iOS7之前，做转场动画很麻烦，要写一大堆代码在ViewController中。</li><li>引入这一套API之后，在丰富功能的同时极大程度地降低了代码耦合，实现方式就是将之前在ViewController里面的代码通过protocol分离了出来。</li><li>顺着这个思路往下想，实现自定义转场动画首先需要找到ViewController的delegate。</li><li>苹果告诉我们切换ViewController有三种形式：<ul><li><code>UITabBarController</code>内部切换</li><li><code>UINavigationController</code>切换</li><li><code>present  ViewController</code></li><li>这三种方式是不是需要不同的protocol呢？</li></ul></li></ul><h3 id="1-2-详解Protocol"><a href="#1-2-详解Protocol" class="headerlink" title="1-2. 详解Protocol"></a>1-2. 详解Protocol</h3><ul><li><p><code>UIViewControllerTransitioningDelegate</code> 自定义模态转场动画时使用。</p><ul><li>设置<code>UIViewController</code>的属性<code>transitioningDelegate</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak open var transitioningDelegate: UIViewControllerTransitioningDelegate?</span><br></pre></td></tr></table></figure></li><li><p><code>UINavigationControllerDelegate</code> 自定义navigation转场动画时使用</p><ul><li>设置<code>UINavigationController</code>的属性<code>delegate</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak open var delegate: UINavigationControllerDelegate?</span><br></pre></td></tr></table></figure></li><li><p><code>UITabBarControllerDelegate</code>自定义tab转场动画时使用</p><ul><li>设置<code>UITabBarController</code>的属性<code>delegate</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak open var delegate: UITabBarControllerDelegate?</span><br></pre></td></tr></table></figure></li></ul><p>实际上这三个protocol干的事情是一样的只不过他们的应用场景不同罢了。我们下面以UINavigationControllerDelegate为例，其他的类似</p><ul><li><code>UINavigationControllerDelegate</code>主要的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS 7.0, *)</span><br><span class="line">optional public func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@available(iOS 7.0, *)</span><br><span class="line">optional public func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationControllerOperation, from fromVC: UIViewController, to toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?</span><br></pre></td></tr></table></figure><ul><li>两个方法分别返回<code>UIViewControllerInteractiveTransitioning</code>和<code>UIViewControllerAnimatedTransitioning</code>，它们的任务是描述动画行为（转场动画如何执行，就看它俩的）。</li><li>从名字可以看出，这两个<code>protocol</code>的区别在于是否是<code>interactive</code>的。如何理解？</li><li><code>interactive</code>动画可以根据输入信息的变化改变动画的进程。例如iOS系统为<code>UINavigationController</code>提供的默认右滑退出手势就是一个<code>interactive</code> 动画，整个动画的进程由用户手指的移动距离控制</li></ul><h3 id="1-3-UIViewControllerInteractiveTransitioning协议"><a href="#1-3-UIViewControllerInteractiveTransitioning协议" class="headerlink" title="1-3. UIViewControllerInteractiveTransitioning协议"></a>1-3. <code>UIViewControllerInteractiveTransitioning</code>协议</h3><blockquote><p>定义了两个属性可以做到平滑过渡</p><ul><li><code>completionCurve</code>: 交互结束后剩余动画的速率曲线</li><li><code>completionSpeed</code>: 交互结束后动画的开始速率由该参数与原来的速率相乘得到，实际上是个缩放参数，这里应该使用单位变化速率(即你要的速率/距离)。</li><li>注意：<ul><li><code>completionSpeed</code>会影响剩余的动画时间，而不是之前设定的转场动画时间剩下的时间；</li><li>当<code>completionSpeed</code>很小时剩余的动画时间可能会被拉伸得很长，所以过滤下较低的速率比较好。</li><li>如果不设置两个参数，转场动画将以原来的速率曲线在当前进度的速率继续。</li><li>不过从实际使用效果来看，往往不到0.5s的动画时间，基本上看不出什么效果来</li></ul></li></ul></blockquote><h3 id="1-4-定义动画内容的UIViewControllerAnimatedTransitioning"><a href="#1-4-定义动画内容的UIViewControllerAnimatedTransitioning" class="headerlink" title="1-4. 定义动画内容的UIViewControllerAnimatedTransitioning"></a>1-4. 定义动画内容的<code>UIViewControllerAnimatedTransitioning</code></h3><ul><li>必须实现的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//返回动画的执行时间</span><br><span class="line">public func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval</span><br><span class="line"></span><br><span class="line">//处理具体的动画  </span><br><span class="line">public func animateTransition(using transitionContext: UIViewControllerContextTransitioning)</span><br></pre></td></tr></table></figure><h3 id="1-5-表示动画上下文UIViewControllerContextTransitioning"><a href="#1-5-表示动画上下文UIViewControllerContextTransitioning" class="headerlink" title="1-5. 表示动画上下文UIViewControllerContextTransitioning"></a>1-5. 表示动画上下文<code>UIViewControllerContextTransitioning</code></h3><ul><li><code>UIViewControllerContextTransitioning提供了一系列方法</code></li><li>是唯一一个我们不需要实现的Protocol</li><li>下面是一些我们常用的属性和方法: </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//转场动画发生在该View中    </span><br><span class="line">public var containerView: UIView &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//上报动画执行完毕</span><br><span class="line">public func completeTransition(_ didComplete: Bool)</span><br><span class="line"></span><br><span class="line">//根据key返回一个ViewController。我们通过`FromViewControllerKey`找到将被替换掉的VC，通过`ToViewControllerKey`找到将要显示的VC</span><br><span class="line">public func viewController(forKey key: UITransitionContextViewControllerKey) -&gt; UIViewController?</span><br><span class="line"></span><br><span class="line">//根据key返回一个view, 我们通过from找到将要消失的view, 根据to找到将要弹出的view</span><br><span class="line">@available(iOS 8.0, *)</span><br><span class="line">public func view(forKey key: UITransitionContextViewKey) -&gt; UIView?</span><br></pre></td></tr></table></figure><h3 id="1-5-UIViewControllerTransitioningDelegate自定义模态转场时使用"><a href="#1-5-UIViewControllerTransitioningDelegate自定义模态转场时使用" class="headerlink" title="1-5. UIViewControllerTransitioningDelegate自定义模态转场时使用"></a>1-5. <code>UIViewControllerTransitioningDelegate</code>自定义模态转场时使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 该方法是告诉系统,弹出动画交给谁来处理</span><br><span class="line">func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">    isPresent = true</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 该方法是告诉系统,消失动画交给谁来处理</span><br><span class="line">func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">    isPresent = false</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-图片浏览器项目介绍"><a href="#三-图片浏览器项目介绍" class="headerlink" title="三. 图片浏览器项目介绍"></a>三. 图片浏览器项目介绍</h2><h3 id="1-项目结构Alamofire-MVVM"><a href="#1-项目结构Alamofire-MVVM" class="headerlink" title="1. 项目结构Alamofire + MVVM"></a>1. 项目结构<code>Alamofire + MVVM</code></h3><p><img src="http://upload-images.jianshu.io/upload_images/4122543-20b3afa03d389bb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="框架结构"></p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-a54d1b9e6d553950.gif?imageMogr2/auto-orient/strip" alt="图片浏览器.gif"></p><h3 id="2-自定义ViewController的弹出和消失动画"><a href="#2-自定义ViewController的弹出和消失动画" class="headerlink" title="2. 自定义ViewController的弹出和消失动画"></a>2. 自定义<code>ViewController</code>的弹出和消失动画</h3><h4 id="2-1-自定义ViewController弹出和消失的Protocol"><a href="#2-1-自定义ViewController弹出和消失的Protocol" class="headerlink" title="2-1. 自定义ViewController弹出和消失的Protocol"></a>2-1. 自定义<code>ViewController</code>弹出和消失的Protocol</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//MARK: 自定义协议</span><br><span class="line">protocol JunBrowsePresentDelefate: NSObjectProtocol &#123;</span><br><span class="line">    /// 1. 提供弹出的imageView</span><br><span class="line">    func imageForPresent(indexPath: IndexPath) -&gt; UIImageView</span><br><span class="line">    </span><br><span class="line">    /// 2. 提供弹出的imageView的frame</span><br><span class="line">    func startImageRectForpresent(indexPath: IndexPath) -&gt; CGRect</span><br><span class="line">    </span><br><span class="line">    /// 3.提供弹出后imageView的frame</span><br><span class="line">    func endImageRectForpresent(indexPath: IndexPath) -&gt; CGRect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol JunBrowserDismissDelegate &#123;</span><br><span class="line">    /// 1.提供推出的imageView</span><br><span class="line">    func imageViewForDismiss() -&gt; UIImageView</span><br><span class="line">    </span><br><span class="line">    /// 2. 提供推出的indexPath</span><br><span class="line">    func indexPathForDismiss() -&gt; IndexPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-遵循协议"><a href="#2-2-遵循协议" class="headerlink" title="2-2. 遵循协议"></a>2-2. 遵循协议</h3><ul><li><code>UIViewControllerTransitioningDelegate</code>告诉系统弹出/消失动画的处理页面</li><li><code>UIViewControllerAnimatedTransitioning</code><ul><li>需要返回动画的执行时间</li><li>需要在弹出和消失页面的时候分别执行不同的动画</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: UIViewControllerTransitioningDelegate</span></span><br><span class="line">extension PhotoBrowseAnimation: <span class="built_in">UIViewControllerTransitioningDelegate</span> &#123;</span><br><span class="line">    <span class="comment">// 该方法是告诉系统,弹出动画交给谁来处理</span></span><br><span class="line">    func animationController(forPresented presented: <span class="built_in">UIViewController</span>, presenting: <span class="built_in">UIViewController</span>, source: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">        isPresent = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法是告诉系统,消失动画交给谁来处理</span></span><br><span class="line">    func animationController(forDismissed dismissed: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">        isPresent = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK: 继承AnimatedTransitioning协议</span></span><br><span class="line">extension PhotoBrowseAnimation: <span class="built_in">UIViewControllerAnimatedTransitioning</span> &#123;</span><br><span class="line">    <span class="comment">//返回动画的执行时间</span></span><br><span class="line">    func transitionDuration(using transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>?) -&gt; TimeInterval &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.6</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理具体的动画</span></span><br><span class="line">    func animateTransition(using transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>) &#123;</span><br><span class="line">        isPresent ? presentAnimation(transitionContext) : dismissAnimation(transitionContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-图片列表界面"><a href="#2-3-图片列表界面" class="headerlink" title="2-3. 图片列表界面"></a>2-3. 图片列表界面</h3><h4 id="1-在点击需要展示的imageView的时候-调用下面的方法"><a href="#1-在点击需要展示的imageView的时候-调用下面的方法" class="headerlink" title="1. 在点击需要展示的imageView的时候,调用下面的方法"></a>1. 在点击需要展示的imageView的时候,调用下面的方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK:- 弹出照片浏览器</span></span><br><span class="line">extension JunScrollViewController &#123;</span><br><span class="line">    fileprivate func presentPhotoBrowse(indexPath: IndexPath) &#123;</span><br><span class="line">        <span class="comment">//1. 创建图片浏览器</span></span><br><span class="line">        let photoBrowseVC = BrowseViewController(images: imageVM.imageArray, currentIndexP: indexPath)</span><br><span class="line">        <span class="comment">//2. 设置弹出样式为自定义</span></span><br><span class="line">        photoBrowseVC.modalPresentationStyle = .custom</span><br><span class="line">        <span class="comment">//3. 设置转场动画代理</span></span><br><span class="line">        photoBrowseVC.transitioningDelegate = photoAnimation</span><br><span class="line">        <span class="comment">//4. 设置broseAnimation的属性</span></span><br><span class="line">        photoAnimation.setProperty(indexPath: indexPath, <span class="keyword">self</span>, photoBrowseVC)</span><br><span class="line">        <span class="comment">//5. 弹出图片浏览器</span></span><br><span class="line">        present(photoBrowseVC, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-遵循并实现自定义的协议方法"><a href="#2-遵循并实现自定义的协议方法" class="headerlink" title="2. 遵循并实现自定义的协议方法"></a>2. 遵循并实现自定义的协议方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: JunBrowsePresentDelefate</span></span><br><span class="line">extension JunScrollViewController: JunBrowsePresentDelefate &#123;</span><br><span class="line">    func imageForPresent(indexPath: IndexPath) -&gt; <span class="built_in">UIImageView</span> &#123;</span><br><span class="line">        let imageV = <span class="built_in">UIImageView</span>()</span><br><span class="line">        imageV.contentMode = .scaleAspectFill</span><br><span class="line">        imageV.clipsToBounds = <span class="literal">true</span></span><br><span class="line">        <span class="comment">//设置图片</span></span><br><span class="line">        imageV.kf.setImage(with: URL(string: imageVM.imageArray[indexPath.item].pic74), placeholder: <span class="built_in">UIImage</span>(named: <span class="string">"coderJun"</span>))</span><br><span class="line">        <span class="keyword">return</span> imageV</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func startImageRectForpresent(indexPath: IndexPath) -&gt; <span class="built_in">CGRect</span> &#123;</span><br><span class="line">        <span class="comment">// 1.取出cell</span></span><br><span class="line">        guard let cell = imageCollection.cellForItem(at: indexPath) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: imageCollection.bounds.width * <span class="number">0.5</span>, y: kScreenHeight + <span class="number">50</span>, width: <span class="number">0</span>, height: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.计算转化为UIWindow上时的frame</span></span><br><span class="line">        <span class="keyword">return</span> imageCollection.convert( cell.frame, to: <span class="built_in">UIApplication</span>.shared.keyWindow)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func endImageRectForpresent(indexPath: IndexPath) -&gt; <span class="built_in">CGRect</span> &#123;</span><br><span class="line">        <span class="comment">//1. 取出对应的image的url</span></span><br><span class="line">        let imageUrl = URL(string: imageVM.imageArray[indexPath.item].pic74)!</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.从缓存中取出image</span></span><br><span class="line">        var image = KingfisherManager.shared.cache.retrieveImageInDiskCache(forKey: imageUrl.absoluteString)</span><br><span class="line">        <span class="keyword">if</span> image == <span class="literal">nil</span> &#123;</span><br><span class="line">            image = <span class="built_in">UIImage</span>(named: <span class="string">"coderJun"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.根据image计算位置</span></span><br><span class="line">        let imageH = kScreenWidth / image!.size.width * image!.size.height</span><br><span class="line">        let y: <span class="built_in">CGFloat</span> = imageH &lt; kScreenHeight ? (kScreenHeight - imageH) / <span class="number">2</span> : <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: y, width: kScreenWidth, height: imageH)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-在图片展示界面"><a href="#2-4-在图片展示界面" class="headerlink" title="2-4. 在图片展示界面"></a>2-4. 在图片展示界面</h3><ul><li>遵循并实现相关dismiss协议方法</li><li>该协议主要实现viewController返回到该图片对应的<code>IndexPath</code>所在的位置</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: JunBrowserDismissDelegate</span></span><br><span class="line">extension JunTranstionPhotoController: JunBrowserDismissDelegate&#123;</span><br><span class="line">    func imageViewForDismiss() -&gt; <span class="built_in">UIImageView</span> &#123;</span><br><span class="line">        let imageV = <span class="built_in">UIImageView</span>()</span><br><span class="line">        imageV.contentMode = .scaleAspectFill</span><br><span class="line">        imageV.clipsToBounds = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置图片</span></span><br><span class="line">        imageV.image = baseImage.image</span><br><span class="line">        imageV.frame = baseImage.convert(baseImage.frame, to: <span class="built_in">UIApplication</span>.shared.keyWindow)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> imageV</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func indexPathForDismiss() -&gt; IndexPath &#123;</span><br><span class="line">        <span class="keyword">return</span> IndexPath(item: currentIndex, section: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="GitHubDemo地址"><a href="#GitHubDemo地址" class="headerlink" title="GitHubDemo地址"></a>GitHub<a href="https://github.com/coderQuanjun/JunPhotoBrowseDemo" target="_blank" rel="noopener">Demo地址</a></h3><ul><li>注意:  <ul><li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li><li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Swiftk框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> CATransition </tag>
            
            <tag> UIBesizationv </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift开发之3DTouch实用演练</title>
      <link href="/2017/10/23/Swift%E5%BC%80%E5%8F%91%E4%B9%8B3DTouch%E5%AE%9E%E7%94%A8%E6%BC%94%E7%BB%83"/>
      <content type="html"><![CDATA[<blockquote><p>2015年，苹果发布了iOS9以及<code>iphone6s/iphone6s Plus</code>，其中最具有创新的就是新的触控方式3D Touch,相对于多点触摸在平面二维空间的操作，3D Touch技术增加了对力度和手指面积的感知，可以通过长按快速预览、查看你想要的短信、图片或者超链接等内容，Peek和Pop手势的响应时间可迅捷到 10ms和15ms等。</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><ul><li>用户现在可以按主屏幕图标立即访问应用程序提供的功能。</li><li>在您的应用程序中，用户现在可以按视图来查看其他内容的预览，并获得对功能的加速访问</li><li>在日常开发中,我们经常需要使用3D Touch中的两个功能<ul><li>在主屏幕上对应用图标使用3DTouch操作</li><li>在应用程序内对某一控件使用3DTouch操作</li></ul></li><li>功能需要iOS9以上系统和<code>iphone6s/iphone6s Plus</code>及以上机型(模拟机现在也是可以的)</li><li><a href="https://github.com/coderQuanjun/DouYuTV" target="_blank" rel="noopener">demo地址</a></li></ul><h2 id="一-效果演练"><a href="#一-效果演练" class="headerlink" title="一. 效果演练"></a>一. 效果演练</h2><h3 id="1-主屏幕快速操作"><a href="#1-主屏幕快速操作" class="headerlink" title="1. 主屏幕快速操作"></a>1. 主屏幕快速操作</h3><ul><li>通过按下iPhone 6s或iPhone 6s Plus上的应用程序图标，用户可以获得一组快速操作。</li><li>当用户选择快速操作时，您的应用程序激活或启动，并跳转到相应界面<br><img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/maps_directions_home_2x.png" alt="主屏幕快速操作"></li></ul><h3 id="2-Peek-and-Pop"><a href="#2-Peek-and-Pop" class="headerlink" title="2. Peek and Pop"></a>2. Peek and Pop</h3><blockquote><ul><li>对界面内某一控件的3DTouch操作</li><li>Peek和Pop是应用内的一种全新交互模式,当用户不断增加力量在控件上按压,会依次进入四个阶段</li></ul><ul><li>轻按控件,除触发Peek的控件外,其他区域全部虚化</li><li>继续用力Peek被触发,展示Pop界面快照</li><li>向上滑动展示快捷选项</li><li>继续用力跳转进入Pop界面</li></ul></blockquote><p><img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/preview_available_2_2x.png" alt="轻按控件,除触发Peek的控件外,其他区域全部虚化"></p><p><img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/peek_2x.png" alt="继续用力Peek被触发,展示Pop界面快照"></p><p><img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/peek_quick_actions_2x.png" alt="向上滑动展示快捷选项"></p><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h3><ul><li>3D Touch仅在3D Touch设备上可用，如果启用。在iOS 9以上，默认情况下启用3D Touch。</li><li>用户可以在设置&gt;常规&gt;辅助功能&gt; 3D触摸中关闭3D触摸。</li><li>当3D Touch可用时，利用其功能。当它不可用时，提供替代方法，例如通过使用触摸和保持。</li><li>3D Touch功能支持VoiceOver。</li></ul><h2 id="二-主屏幕操作"><a href="#二-主屏幕操作" class="headerlink" title="二. 主屏幕操作"></a>二. 主屏幕操作</h2><ul><li><code>ShortcutItem</code>功能允许用户在主屏幕上对应用图标使用<code>3DTouch</code>操作,如果本次操作有效,则会给出几个快捷可选项允许用户进行操作</li><li>主屏幕icon上的快捷标签的实现方式有两种，一种是在工程文件info.plist里静态设置，另一种是代码的动态实现</li><li>优先显示静态添加，总数达到4个不再显示</li></ul><h3 id="1-静态设置"><a href="#1-静态设置" class="headerlink" title="1. 静态设置"></a>1. 静态设置</h3><ul><li>在info.plist中添加<code>UIApplicationShortcutItems</code>关键字,以如下方式配置即可</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-e90081ad823f9859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIApplicationShortcutItems配置"></p><blockquote><p>其中各个关键字释义如下:</p><ul><li><code>UIApplicationShortcutItemType</code>: 快捷可选项的特定字符串(必填)</li><li><code>UIApplicationShortcutItemTitle</code>: 快捷可选项的标题(必填)</li><li><code>UIApplicationShortcutItemSubtitle</code>: 快捷可选项的子标题(可选)</li><li><code>UIApplicationShortcutItemIconType</code>: 快捷可选项的图标(可选)</li><li><code>UIApplicationShortcutItemIconFile</code>: 快捷可选项的自定义图标(可选)</li><li><code>UIApplicationShortcutItemUserInfo</code>: 快捷可选项的附加信息(可选)</li></ul></blockquote><h3 id="2-动态添加UIApplicationShortcutItem"><a href="#2-动态添加UIApplicationShortcutItem" class="headerlink" title="2. 动态添加UIApplicationShortcutItem"></a>2. 动态添加<code>UIApplicationShortcutItem</code></h3><h4 id="2-1-UIApplicationShortcutItem初始化方法"><a href="#2-1-UIApplicationShortcutItem初始化方法" class="headerlink" title="2-1. UIApplicationShortcutItem初始化方法"></a>2-1. <code>UIApplicationShortcutItem</code>初始化方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIApplicationShortcutItem</span>(type: String, localizedTitle: String, localizedSubtitle: String?, icon: <span class="built_in">UIApplicationShortcutIcon</span>?, userInfo: [AnyHashable : Any]?)</span><br></pre></td></tr></table></figure><ul><li>参数介绍<ul><li><code>type</code>: 快捷可选项的特定字符串(必填)</li><li><code>localizedTitle</code>: 快捷可选项的标题(必填)</li><li><code>localizedSubtitle</code>: 快捷可选项的子标题(可选)</li><li><code>icon</code>: 快捷可选项的图标(可选)</li><li><code>userInfo</code>: 快捷可选项的附加信息(可选)</li></ul></li></ul><h4 id="2-1-图标"><a href="#2-1-图标" class="headerlink" title="2-1. 图标"></a>2-1. 图标</h4><h5 id="2-1-1-初始化方式"><a href="#2-1-1-初始化方式" class="headerlink" title="2-1-1. 初始化方式"></a>2-1-1. 初始化方式</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一: 自定义图标</span></span><br><span class="line"><span class="comment">//注: 自定义图标需要使用镂空图标,同时建议1倍图标大小为35*35</span></span><br><span class="line"><span class="built_in">UIApplicationShortcutIcon</span>(templateImageName: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二: 使用系统图标</span></span><br><span class="line"><span class="built_in">UIApplicationShortcutIcon</span>(type: <span class="built_in">UIApplicationShortcutIconType</span>)</span><br></pre></td></tr></table></figure><h5 id="2-1-2-系统图标样式如下"><a href="#2-1-2-系统图标样式如下" class="headerlink" title="2-1-2. 系统图标样式如下"></a>2-1-2. 系统图标样式如下</h5><p><img src="http://upload-images.jianshu.io/upload_images/4122543-50ce942abc9a5174.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统图片一览表"></p><h4 id="2-3-具体实现代码如下"><a href="#2-3-具体实现代码如下" class="headerlink" title="2-3. 具体实现代码如下"></a>2-3. 具体实现代码如下</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func application(_ application: <span class="built_in">UIApplication</span>, didFinishLaunchingWithOptions launchOptions: [<span class="built_in">UIApplicationLaunchOptionsKey</span>: Any]?) -&gt; Bool &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3D Touch</span></span><br><span class="line">    let homeIcon = <span class="built_in">UIApplicationShortcutIcon</span>(type: .compose)</span><br><span class="line">    let homeItem = <span class="built_in">UIApplicationShortcutItem</span>(type: <span class="string">"homeAnchor"</span>, localizedTitle: <span class="string">"首页"</span>, localizedSubtitle: <span class="string">"点击进入首页"</span>, icon: homeIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line">    let playIcon = <span class="built_in">UIApplicationShortcutIcon</span>(type: .play)</span><br><span class="line">    let playItem = <span class="built_in">UIApplicationShortcutItem</span>(type: <span class="string">"play"</span>, localizedTitle: <span class="string">"播放"</span>, localizedSubtitle: <span class="string">""</span>, icon: playIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line">    let userIcon = <span class="built_in">UIApplicationShortcutIcon</span>(type: .search)</span><br><span class="line">    let userItem = <span class="built_in">UIApplicationShortcutItem</span>(type: <span class="string">"username"</span>, localizedTitle: <span class="string">"用户名"</span>, localizedSubtitle: <span class="string">""</span>, icon: userIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIApplication</span>.shared.shortcutItems = [homeItem, playItem, userItem]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-item点击跳转"><a href="#2-4-item点击跳转" class="headerlink" title="2-4. item点击跳转"></a>2-4. item点击跳转</h4><ul><li>可根据<code>type</code>标识判断</li><li>可根据<code>localizedTitle</code>标识判断</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜单跳转</span></span><br><span class="line">func application(_ application: <span class="built_in">UIApplication</span>, performActionFor shortcutItem: <span class="built_in">UIApplicationShortcutItem</span>, completionHandler: @escaping (Bool) -&gt; Void) &#123;</span><br><span class="line">    guard let tabBarVC = window?.rootViewController as? MainViewController <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据type唯一标识进行判断跳转, 或者根据localizedTitle判断</span></span><br><span class="line">    <span class="keyword">switch</span> shortcutItem.type &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"homeAnchor"</span>:</span><br><span class="line">        tabBarVC.selectedIndex = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"play"</span>:</span><br><span class="line">        let username = ShowRoomViewController()</span><br><span class="line">        username.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">        tabBarVC.selectedViewController?.childViewControllers.first?.present(username, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"username"</span>:</span><br><span class="line">        let username = NameViewController()</span><br><span class="line">        username.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">        tabBarVC.selectedViewController?.childViewControllers.last?.navigationController?.pushViewController(username, animated: <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        tabBarVC.selectedIndex = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-Peek-and-Pop"><a href="#三-Peek-and-Pop" class="headerlink" title="三. Peek and Pop"></a>三. Peek and Pop</h2><ul><li>Peek和Pop是应用内的一种全新交互模式,当用户不断增加力量在控件上按压,会依次进入四个阶段</li><li>这里小编将通过ViewController里面的UITableViewCell进行延时功能</li></ul><hr><blockquote><p>注意: 在动态添加快捷可选项前,需要用判断是否支持3D Touch功能,以免在不支持的设备上运行程序导致闪退</p></blockquote><h3 id="1-判断是否支持3D-Touch功能"><a href="#1-判断是否支持3D-Touch功能" class="headerlink" title="1. 判断是否支持3D Touch功能"></a>1. 判断是否支持3D Touch功能</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func tableView(_ tableView: <span class="built_in">UITableView</span>, cellForRowAt indexPath: IndexPath) -&gt; <span class="built_in">UITableViewCell</span> &#123;</span><br><span class="line">    var cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>)</span><br><span class="line">    let model = happyVM.anchorGroups[indexPath.section].anchors[indexPath.row]</span><br><span class="line">    <span class="keyword">if</span> cell == <span class="literal">nil</span> &#123;</span><br><span class="line">        cell = <span class="built_in">UITableViewCell</span>(style: .default, reuseIdentifier: <span class="string">"cell"</span>)</span><br><span class="line">        cell?.textLabel?.text = model.room_name</span><br><span class="line">        cell?.accessoryType = .disclosureIndicator</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">---</span><br><span class="line">    <span class="comment">//这里是添加判断是否支持3D Touch的代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="meta">#available(iOS 9.0, *) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> traitCollection.forceTouchCapability == .available &#123;</span><br><span class="line">            <span class="comment">//支持3D Touch</span></span><br><span class="line">            <span class="comment">//注册Peek &amp; Pop功能</span></span><br><span class="line">            registerForPreviewing(with: <span class="keyword">self</span>, sourceView: cell!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>检测是否支持3D Touch：UIForceTouchCapability是一个枚举值,取值如下：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> unknown      <span class="comment">//3D Touch检测失败</span></span><br><span class="line"><span class="keyword">case</span> unavailable <span class="comment">//3D Touch不可用</span></span><br><span class="line"><span class="keyword">case</span> available  <span class="comment">//3D Touch可用</span></span><br></pre></td></tr></table></figure><h3 id="2-给对应view注册3Dtouch事件"><a href="#2-给对应view注册3Dtouch事件" class="headerlink" title="2. 给对应view注册3Dtouch事件"></a>2. 给对应view注册3Dtouch事件</h3><ul><li>在判断支持3Dtouch里面注册</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册Peek &amp; Pop功能</span></span><br><span class="line"><span class="keyword">self</span>.registerForPreviewing(with: <span class="keyword">self</span>, sourceView: cell!)</span><br></pre></td></tr></table></figure><h3 id="3-遵守UIViewControllerPreviewingDelegate协议"><a href="#3-遵守UIViewControllerPreviewingDelegate协议" class="headerlink" title="3. 遵守UIViewControllerPreviewingDelegate协议"></a>3. 遵守<code>UIViewControllerPreviewingDelegate</code>协议</h3><ul><li>需要实现Peek &amp; Pop交互的控件所在的控制器遵循协议并实现两个代理方法</li></ul><h4 id="3-1-当进入Peek状态时-系统会回调如下方法"><a href="#3-1-当进入Peek状态时-系统会回调如下方法" class="headerlink" title="3-1. 当进入Peek状态时,系统会回调如下方法"></a>3-1. 当进入Peek状态时,系统会回调如下方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func previewingContext(_ previewingContext: <span class="built_in">UIViewControllerPreviewing</span>, viewControllerForLocation location: <span class="built_in">CGPoint</span>) -&gt; <span class="built_in">UIViewController</span>? &#123;</span><br><span class="line">    <span class="comment">//1. 获取按压的cell所在的行</span></span><br><span class="line">    guard let cell = previewingContext.sourceView as? <span class="built_in">UITableViewCell</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">UIViewController</span>() &#125;</span><br><span class="line">    let indexPath = tableVIew.indexPath(<span class="keyword">for</span>: cell) ?? IndexPath(row: <span class="number">0</span>, section: <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 设定预览界面</span></span><br><span class="line">    let vc = ShowRoomViewController()</span><br><span class="line">    <span class="comment">// 预览区域大小(可不设置), 0为默认尺寸</span></span><br><span class="line">    vc.preferredContentSize = <span class="built_in">CGSize</span>(width: <span class="number">0</span>, height: <span class="number">0</span>)</span><br><span class="line">    vc.showStr =  <span class="string">"我是第\(indexPath.row)行用力按压进来的"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调整不被虚化的范围，按压的那个cell不被虚化（轻轻按压时周边会被虚化，再少用力展示预览，再加力跳页至设定界面）</span></span><br><span class="line">    let rect = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: kScreenWidth, height: <span class="number">44</span>)</span><br><span class="line">    <span class="comment">//设置触发操作的视图的不被虚化的区域</span></span><br><span class="line">    previewingContext.sourceRect = rect</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回预览界面</span></span><br><span class="line">    <span class="keyword">return</span> vc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-当进入Pop状态时-系统会回调如下方法"><a href="#3-2-当进入Pop状态时-系统会回调如下方法" class="headerlink" title="3-2. 当进入Pop状态时,系统会回调如下方法"></a>3-2. 当进入Pop状态时,系统会回调如下方法</h4><ul><li>用力按压进入<code>viewControllerToCommit</code></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func previewingContext(_ previewingContext: <span class="built_in">UIViewControllerPreviewing</span>, commit viewControllerToCommit: <span class="built_in">UIViewController</span>) &#123;</span><br><span class="line">    viewControllerToCommit.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">    show(viewControllerToCommit, sender: <span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>来看看效果</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-e093ea0e213ef573.gif?imageMogr2/auto-orient/strip" alt="3D Touch1演示.gif"></p><h4 id="3-4-当弹出预览时，上滑预览视图，出现预览视图中快捷选项"><a href="#3-4-当弹出预览时，上滑预览视图，出现预览视图中快捷选项" class="headerlink" title="3-4. 当弹出预览时，上滑预览视图，出现预览视图中快捷选项"></a>3-4. 当弹出预览时，上滑预览视图，出现预览视图中快捷选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var previewActionItems: [UIPreviewActionItem] &#123; get &#125;</span><br></pre></td></tr></table></figure><ul><li><code>previewActionItems</code>用户在3D Touch预览上向上滑动时显示的快速操作</li><li>在将要弹出的页面内重写previewActionItems的get属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">extension ShowRoomViewController &#123;</span><br><span class="line">    <span class="comment">//重写previewActionItems的get方法</span></span><br><span class="line">    override var previewActionItems: [<span class="built_in">UIPreviewActionItem</span>] &#123;</span><br><span class="line">        let action1 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">"跳转"</span>, style: .default) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            let showVC = ShowRoomViewController()</span><br><span class="line">            showVC.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">            previewViewController.navigationController?.pushViewController(showVC, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let action3 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">"取消"</span>, style: .destructive) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">"我是取消按钮"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">////该按钮可以是一个组，点击该组时，跳到组里面的按钮。</span></span><br><span class="line">        let subAction1 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">"测试1"</span>, style: .selected) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">"我是测试按钮1"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        let subAction2 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">"测试2"</span>, style: .selected) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">"我是测试按钮2"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        let subAction3 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">"测试3"</span>, style: .selected) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">"我是测试按钮3"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        let groupAction = <span class="built_in">UIPreviewActionGroup</span>(title: <span class="string">"更多"</span>, style: .default, actions: [subAction1, subAction2, subAction3])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [action1, action3, groupAction]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>action的各种样式</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">enum</span> <span class="built_in">UIPreviewActionStyle</span> : Int &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认样式</span></span><br><span class="line">    <span class="keyword">case</span> `<span class="keyword">default</span>`</span><br><span class="line">    <span class="comment">//右侧有对勾的样式</span></span><br><span class="line">    <span class="keyword">case</span> selected</span><br><span class="line">    <span class="comment">//红色字体的样式</span></span><br><span class="line">    <span class="keyword">case</span> destructive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-force-和-maximumPossibleForce"><a href="#3-5-force-和-maximumPossibleForce" class="headerlink" title="3-5. force 和 maximumPossibleForce"></a>3-5. <code>force</code> 和 <code>maximumPossibleForce</code></h4><blockquote><p>到此，3DTouch在APP中的集成就先介绍这些，3DTouch中还有个重要的属性–压力属性（force 和 maximumPossibleForce）这里简单介绍下</p></blockquote><ul><li>手指在屏幕上慢慢增加力度在减少力度，可以看到view背景色的变化</li><li>程序运行后找到<code>我的</code> -&gt; <code>头像(用户名)</code>查看效果</li><li>代码找到<code>NameViewController.swift</code>查看</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">override func touchesMoved(_ touches: Set&lt;<span class="built_in">UITouch</span>&gt;, with event: <span class="built_in">UIEvent</span>?) &#123;</span><br><span class="line">    let touch = touches.first ?? <span class="built_in">UITouch</span>()</span><br><span class="line">    <span class="comment">//获取重按力度</span></span><br><span class="line">    print(<span class="string">"平均触摸的力--\(touch.force)"</span>)</span><br><span class="line">    print(<span class="string">"触摸的最大可能力--\(touch.maximumPossibleForce)"</span>)</span><br><span class="line">    </span><br><span class="line">    let change = touch.force / touch.maximumPossibleForce</span><br><span class="line">        view.backgroundColor = <span class="built_in">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.5</span>, blue: change, alpha: <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>此外还有以下属性, 详细可参考<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/3DTouchAPIs.html#//apple_ref/doc/uid/TP40016543-CH4-SW1" target="_blank" rel="noopener">3D Touch官方文档</a></p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var tapCount: Int</span><br><span class="line"><span class="comment">//手指触摸此次触摸的次数。</span></span><br><span class="line"></span><br><span class="line">var timestamp: TimeInterval</span><br><span class="line"><span class="comment">//触摸发生的时间或最后一次突变的时间。</span></span><br><span class="line"></span><br><span class="line">var type: <span class="built_in">UITouchType</span></span><br><span class="line"><span class="comment">//触摸的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="built_in">UITouchType</span></span><br><span class="line"><span class="comment">//接收的触摸类型。</span></span><br><span class="line"></span><br><span class="line">var phase: <span class="built_in">UITouchPhase</span></span><br><span class="line"><span class="comment">//触摸的阶段。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="built_in">UITouchPhase</span></span><br><span class="line"><span class="comment">//手指触摸的阶段。</span></span><br><span class="line"></span><br><span class="line">var maximumPossibleForce: <span class="built_in">CGFloat</span></span><br><span class="line"><span class="comment">//触摸的最大可能力。</span></span><br><span class="line"></span><br><span class="line">var force: <span class="built_in">CGFloat</span></span><br><span class="line"><span class="comment">//触摸力，其中值表示平均触摸的力（由系统预定，不是用户特定的）。1.0</span></span><br><span class="line"></span><br><span class="line">var altitudeAngle: <span class="built_in">CGFloat</span></span><br><span class="line"><span class="comment">//手写笔的高度（弧度）。</span></span><br><span class="line"></span><br><span class="line">func azimuthAngle(<span class="keyword">in</span>: <span class="built_in">UIView</span>?)</span><br><span class="line"><span class="comment">//返回触控笔的方位角（弧度）。</span></span><br><span class="line"></span><br><span class="line">func azimuthUnitVector(<span class="keyword">in</span>: <span class="built_in">UIView</span>?)</span><br><span class="line"><span class="comment">//返回指向触控笔方位角方向的单位向量。</span></span><br></pre></td></tr></table></figure><h3 id="最后附上Demo地址"><a href="#最后附上Demo地址" class="headerlink" title="最后附上Demo地址"></a>最后附上<a href="https://github.com/coderQuanjun/DouYuTV" target="_blank" rel="noopener">Demo地址</a></h3><hr><blockquote><p>参考资料</p></blockquote><p><a href="http://liuyanwei.jumppo.com/2016/04/01/iOS-3DTouch-2.html" target="_blank" rel="noopener">iOS 3D touch开发 </a></p><p><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/3DTouchAPIs.html#//apple_ref/doc/uid/TP40016543-CH4-SW1" target="_blank" rel="noopener">3D Touch官方文档</a></p>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 3DTouch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactNaive之CSS和Flex布局</title>
      <link href="/2017/10/23/ReactNaive%E4%B9%8BCSS%E5%92%8CFlex%E5%B8%83%E5%B1%80"/>
      <content type="html"><![CDATA[<blockquote><p>ReactNaive相关文章</p><ol><li><a href="https://reactnative.cn/" target="_blank" rel="noopener">React Native 中文网</a></li><li><a href="https://github.com/CoderTitan/ReactNativeDemo" target="_blank" rel="noopener">GitHub相关代码地址</a></li><li><a href="https://www.jianshu.com/p/522e4668aab4" target="_blank" rel="noopener">ReactNaive之CSS和Flex布局</a></li><li><a href="https://www.jianshu.com/p/d923555c580a" target="_blank" rel="noopener">ReactNative之基本组件</a></li><li><a href="https://www.jianshu.com/p/4a0d1982f691" target="_blank" rel="noopener">React Naive之ScrollView和ListView</a></li><li><a href="https://www.jianshu.com/p/4a0d1982f691" target="_blank" rel="noopener">React Native之导航组件NavigatorIOS和Navigator</a></li><li><a href="https://www.jianshu.com/p/5f063aeca62d" target="_blank" rel="noopener">ReactNative之TabBariOS和TabNavigator</a></li></ol></blockquote><hr><a id="more"></a><h2 id="一-和-的使用"><a href="#一-和-的使用" class="headerlink" title="一. {}和()的使用"></a>一. {}和()的使用</h2><h3 id="1-的使用"><a href="#1-的使用" class="headerlink" title="1. {}的使用"></a>1. {}的使用</h3><h4 id="1-1-ReactNative中，使用表达式的时候需要用-包住"><a href="#1-1-ReactNative中，使用表达式的时候需要用-包住" class="headerlink" title="1-1. ReactNative中，使用表达式的时候需要用{}包住"></a>1-1. ReactNative中，使用表达式的时候需要用{}包住</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=&#123;styles.mainStyle&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-ReactNative中-在字符串中使用变量的时候，需要用-包住"><a href="#1-2-ReactNative中-在字符串中使用变量的时候，需要用-包住" class="headerlink" title="1-2. ReactNative中,在字符串中使用变量的时候，需要用{}包住"></a>1-2. ReactNative中,在字符串中使用变量的时候，需要用{}包住</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello&apos;</span><br><span class="line">&lt;Text&gt;&#123;str&#125;&lt;/Text&gt;</span><br></pre></td></tr></table></figure><h4 id="1-3-ReactNative中，对象，字典需要用-包住"><a href="#1-3-ReactNative中，对象，字典需要用-包住" class="headerlink" title="1-3. ReactNative中，对象，字典需要用{}包住"></a>1-3. ReactNative中，对象，字典需要用{}包住</h4><ul><li><code>style = {}</code>,最外层表达式，用{}包住</li><li><code>{flex:1}</code>,对象，用{}包住</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;&lt;/View&gt;</span><br></pre></td></tr></table></figure><h3 id="2-的使用"><a href="#2-的使用" class="headerlink" title="2. ()的使用"></a>2. ()的使用</h3><ul><li>创建组件<code>&lt;View&gt;&lt;/View&gt;</code>，必须要用()包住<ul><li>因此只要返回组件，都需要用()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;View style=&#123;styles.mainStyle&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="二-ReactNative之CSS布局"><a href="#二-ReactNative之CSS布局" class="headerlink" title="二. ReactNative之CSS布局"></a>二. ReactNative之CSS布局</h2><ul><li>ReactNative支持CSS中的布局属性，因此可以使用CSS布局属性</li><li>CSS颜色大全，下面会用到，点击这<a href="http://www.cnblogs.com/axing/archive/2011/04/09/CSS.html" target="_blank" rel="noopener">CSS颜色代码大全</a></li></ul><h3 id="1-视图边框"><a href="#1-视图边框" class="headerlink" title="1. 视图边框"></a>1. 视图边框</h3><ul><li>什么时候使用？想设置自己周边有边框的时候</li><li>注意点：<strong><em>一定要设置边框宽度</em></strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">borderBottomWidth number <span class="comment">//底部边框宽度</span></span><br><span class="line">borderLeftWidth number <span class="comment">//左边框宽度</span></span><br><span class="line">borderRightWidth number <span class="comment">//右边框宽度</span></span><br><span class="line">borderTopWidth number <span class="comment">//顶部边框宽度</span></span><br><span class="line">borderWidth number <span class="comment">//边框宽度</span></span><br><span class="line">border&lt;Bottom|Left|Right|Top&gt;Color <span class="comment">//各方向边框的颜色,&lt;&gt;表示连着一起，例如borderBottomColor</span></span><br><span class="line">borderColor <span class="comment">//边框颜色</span></span><br></pre></td></tr></table></figure><h3 id="2-尺寸"><a href="#2-尺寸" class="headerlink" title="2. 尺寸"></a>2. 尺寸</h3><h4 id="2-1-设置宽高"><a href="#2-1-设置宽高" class="headerlink" title="2-1. 设置宽高"></a>2-1. 设置宽高</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width number</span><br><span class="line">height number</span><br></pre></td></tr></table></figure><h4 id="2-2-外边距"><a href="#2-2-外边距" class="headerlink" title="2-2. 外边距"></a>2-2. 外边距</h4><ul><li>设置组件与组件之间的间距<ul><li>注意：第一个组件比较特殊，参照父组件，与父控件之间的间距。</li><li>其他组件间距，相对于上一个组件</li></ul></li><li>什么时候使用？想设置自己在父控件的位置的时候使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">margin number 外边距</span><br><span class="line">marginBottom number 下外边距</span><br><span class="line">marginHorizontal number 左右外边距</span><br><span class="line">marginLeft number 左外边距</span><br><span class="line">marginRight number 右外边距</span><br><span class="line">marginTop number 上外边距</span><br><span class="line">marginVertical number 上下外边距</span><br><span class="line"></span><br><span class="line">//注意marginRight和width冲突，如果设置了width，marginRight无效。</span><br></pre></td></tr></table></figure><h4 id="2-3-内边距"><a href="#2-3-内边距" class="headerlink" title="2-3. 内边距"></a>2-3. 内边距</h4><ul><li>设置子控件与当前控件的位置</li><li>什么时候使用？想设置自己的子控件相对自己的位置的时候使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">padding number 内边距</span><br><span class="line">paddingBottom number 下内边距</span><br><span class="line">paddingHorizontal number 左右内边距</span><br><span class="line">paddingLeft number 做内边距</span><br><span class="line">paddingRight number 右内边距</span><br><span class="line">paddingTop number 上内边距</span><br><span class="line">paddingVertical number 上下内边距</span><br></pre></td></tr></table></figure><h4 id="2-4-相对定位和绝对定位"><a href="#2-4-相对定位和绝对定位" class="headerlink" title="2-4. 相对定位和绝对定位"></a>2-4. 相对定位和绝对定位</h4><h4 id="2-4-1-边缘"><a href="#2-4-1-边缘" class="headerlink" title="2-4-1. 边缘"></a>2-4-1. 边缘</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left   number  左边缘。</span><br><span class="line">right  number  右边缘。</span><br><span class="line">top    number  顶部边缘。</span><br><span class="line">bottom number  底部边缘。</span><br></pre></td></tr></table></figure><h4 id="2-4-2-定位-position"><a href="#2-4-2-定位-position" class="headerlink" title="2-4-2. 定位(position):"></a>2-4-2. 定位(position):</h4><ul><li><p>通过 <code>left</code>, <code>top</code>, <code>right</code> 以及 <code>bottom</code> 边缘属性进行定位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">absolute：绝对定位，参照父控件位置定位</span><br><span class="line">relative：相对定位，参照当前控件原始位置定位</span><br></pre></td></tr></table></figure></li><li><p>什么时候使用绝对定位，当想把一个已经设置了宽度的控件快速的放在左下角，右下角的时候，可以使用绝对定位</p></li><li>什么时候使用相对定位，当想相对自己做出一些改变的时候，采用相对定位,比如相对自己，往下移动一点</li></ul><h2 id="ReactNative之Flex布局"><a href="#ReactNative之Flex布局" class="headerlink" title="ReactNative之Flex布局"></a>ReactNative之Flex布局</h2><ul><li>一般使用ReactNative开发App,一般都采用Flex布局，使用这套布局就非常快。</li></ul><h3 id="1-Flex简介"><a href="#1-Flex简介" class="headerlink" title="1. Flex简介"></a>1. Flex简介</h3><ul><li>Flex又叫弹性布局，会把当前组件看做一个容器，他的所有子组件都是他容器中的成员，通过Flex，就能迅速的布局容器中的成员。</li><li>使用场景：当想快速布局一个组件中所有子组件的时候，可以使用Flex布局</li></ul><h3 id="2-Flex主轴和侧轴"><a href="#2-Flex主轴和侧轴" class="headerlink" title="2. Flex主轴和侧轴"></a>2. Flex主轴和侧轴</h3><ul><li>Flex中有两个主要的概念：主轴和侧轴</li><li>主轴与侧轴的关系：相互垂直的。</li><li>主轴：决定容器中子组件默认的布局方向：水平，垂直</li><li>侧轴：决定容器中子组件与主轴垂直的布局方向<ul><li>比如主轴水平，那么子组件默认就是水平布局排布，侧轴就是控制子组件在垂直方向的布局</li></ul></li></ul><h3 id="3-flexDirection属性"><a href="#3-flexDirection属性" class="headerlink" title="3. flexDirection属性"></a>3. flexDirection属性</h3><ul><li>flexDirection:决定主轴的方向，水平或者垂直，这样子组件就会水平排布或者垂直排布</li><li>flexDirection共有四个值，在RN中默认为column。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row（默认值）：主轴为水平方向，从左向右。依次排列</span><br><span class="line">row-reverse：主轴为水平方向，从右向左依次排列</span><br><span class="line">column：主轴为垂直方向，默认的排列方式，从上向下排列</span><br><span class="line">column-reverse：主轴为垂直方向，从下向上排列</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-flexWrap属性"><a href="#4-flexWrap属性" class="headerlink" title="4. flexWrap属性"></a>4. flexWrap属性</h3><ul><li>flexWrap:决定子控件在父视图内是否允许多行排列。</li><li>flexWrap共有两个值，默认为nowrap。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nowrap 组件只排列在一行上，可能导致溢出。</span><br><span class="line">wrap   组件在一行排列不下时，就进行多行排列</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-justifyContent"><a href="#5-justifyContent" class="headerlink" title="5. justifyContent"></a>5. justifyContent</h3><ul><li><code>justifyContent</code>:决定子组件在主轴中具体布局，是靠左，还是居中等</li><li><code>justifyContent</code>共有五个值，默认为<code>flex-start</code></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start: <span class="comment">//子组件向主轴起点对齐，如果主轴水平，从左开始，主轴垂直，从上开始。</span></span><br><span class="line">flex-end:  <span class="comment">//子组件向主轴终点对齐，如果主轴水平，从右开始，主轴垂直，从下开始。</span></span><br><span class="line">center: <span class="comment">//居中显示，注意：并不是让某一个子组件居中，而是整体有居中效果</span></span><br><span class="line">space-between: <span class="comment">//均匀分配,相邻元素间距离相同。每行第一个组件与行首对齐，每行最后一个组件与行尾对齐。</span></span><br><span class="line">space-around: <span class="comment">//均匀分配,相邻元素间距离相同。每行第一个组件到行首的距离和每行最后一个组件到行尾的距离将会是相邻元素之间距离的一半</span></span><br></pre></td></tr></table></figure><h3 id="6-alignItems"><a href="#6-alignItems" class="headerlink" title="6. alignItems"></a>6. alignItems</h3><ul><li><code>alignItems</code>:决定子组件在测轴中具体布局<br>一直都没有管过侧轴，如果侧轴垂直，决定子组件在上，还是下，或者居中</li><li><code>alignItems</code>共有四个值，默认为<code>stretch</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex-start 子组件向侧轴起点对齐。</span><br><span class="line">flex-end 子组件向侧轴终点对齐。</span><br><span class="line">center 子组件在侧轴居中。</span><br><span class="line">stretch 子组件在侧轴方向被拉伸到与容器相同的高度或宽度。</span><br></pre></td></tr></table></figure><h3 id="7-alignSelf"><a href="#7-alignSelf" class="headerlink" title="7. alignSelf"></a>7. alignSelf</h3><ul><li><code>alignSelf</code>:自定义自己的侧轴布局，用于一个子组件设置。</li><li>注意：当某个子组件不想参照默认的<code>alignItems</code>时，可以设置<code>alignSelf</code>，自定义自己的侧轴布局。</li><li><code>alignSelf</code>共有五个值，默认为<code>auto</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto 继承它的父容器的alignItems属性。如果没有父容器则为 &quot;stretch&quot;</span><br><span class="line">flex-start 子组件向侧轴起点对齐。</span><br><span class="line">flex-end 子组件向侧轴终点对齐。</span><br><span class="line">center 子组件在侧轴居中。</span><br><span class="line">stretch 子组件在侧轴方向被拉伸到与容器相同的高度或宽度。</span><br></pre></td></tr></table></figure><h3 id="8-flex"><a href="#8-flex" class="headerlink" title="8. flex"></a>8. flex</h3><ul><li><code>flex</code>: 决定子控件在主轴中占据几等分。</li><li><code>flex</code>: 任意数字，所有子控件<code>flex</code>相加，自己<code>flex</code>占总共多少，就有多少宽度.</li></ul><h2 id="三-ReactNative之组件属性-Props、State"><a href="#三-ReactNative之组件属性-Props、State" class="headerlink" title="三. ReactNative之组件属性(Props、State)"></a>三. ReactNative之组件属性(Props、State)</h2><ul><li>在App开发中，少不了组件之间的传值，在RN中组件之间通信需要用到Props和State。</li></ul><h3 id="1-Props-属性"><a href="#1-Props-属性" class="headerlink" title="1. Props(属性)"></a>1. Props(属性)</h3><ul><li>什么是Props？一般用于自定义组件，大多数组件在创建时就可以使用各种参数来进行定制，用于定制的这些参数就称为props（属性）。</li><li>props不能在自己的组件中修改, 只能在父组件中修改</li><li>如果想在自己的组件中修改属性, 需要用state</li><li><code>name</code>:就是<code>Props</code>，通过<code>this.props.name</code>访问<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Room name=&quot;小码哥&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：props是在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。</p></blockquote><h3 id="2-State"><a href="#2-State" class="headerlink" title="2. State"></a>2. State</h3><ul><li>State：如果以后想修改某个属性，就修改界面，就需要用state。</li><li>注意:State属性一般在constructor中声明(ES6)，在setState中修改数据.</li><li><p>定义state属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">    num:1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>修改state属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">    num : number</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Flex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift之Facebook的POP动画使用和实战</title>
      <link href="/2017/10/17/Swift%E4%B9%8BFacebook%E7%9A%84POP%E5%8A%A8%E7%94%BB%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98"/>
      <content type="html"><![CDATA[<ul><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a>是一个来自于Facebook，在iOS与OSX上通用的极具扩展性的动画引擎。它在基本的静态动画的基础上增加的弹簧动画与衰减动画，使之能创造出更真实更具物理性的交互动画。</li><li><code>Pop Animation</code>在使用上和<code>Core Animation</code>很相似，都涉及<code>Animation</code>对象以及<code>Animation</code>的载体的概念</li><li>关于<code>Core Animation</code>的相关详解, 可参考我的上一篇文章<a href="http://blog.csdn.net/ShmilyCoder/article/details/78219044" target="_blank" rel="noopener">Core Animation(核心动画)</a></li><li>不同的是<code>Core Animation</code>的载体只能是<code>CALayer</code>，而<code>Pop Animation</code>可以是任意基于<code>NSObject</code>的对象</li><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a> 使用 <code>Objective-C++</code> 编写，<code>Objective-C++</code> 是对 <code>C++</code> 的扩展</li></ul><h3 id="GitHub项目地址"><a href="#GitHub项目地址" class="headerlink" title="GitHub项目地址"></a><a href="https://github.com/coderQuanjun/POPAnimationDemo" target="_blank" rel="noopener">GitHub项目地址</a></h3><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-a85faa1b734ebc00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="一-POP自我介绍"><a href="#一-POP自我介绍" class="headerlink" title="一. POP自我介绍"></a>一. POP自我介绍</h1><ul><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a> 目前由四部分组成：1. Animations；2. Engine；3. Utility；4. WebCore。</li><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a> 动画极为流畅，主要在于Enimator 里，POP 通过 CADisplayLink 高达 60 FPS 的特性，打造了一个游戏级的动画引擎。</li><li>CADisplayLink 是类似 NSTimer 的定时器，不同之处在于，NSTimer 用于我们定义任务的执行周期、资料的更新周期，他的执行受到 CPU 的阻塞影响，而 CADisplayLink 则用于定义画面的重绘、动画的演变，他的执行基于 frames 的间隔。<ul><li>通过 CADisplayLink，Apple 允许你将 App 的重绘速度设定到和屏幕刷新频率一致，由此你可以获得非常流畅的交互动画，这项技术的应用在游戏中非常常见，著名的 Cocos-2D 也应用了这个重要的技术。</li><li><a href="https://opensource.apple.com/source/WebCore/" target="_blank" rel="noopener">WebCore</a> 里包含了一些从 Apple 的开源的网页渲染引擎里拿出的源文件，与 Utility 里的组件一并，提供了 POP 的各项复杂计算的基本支持</li></ul></li></ul><h1 id="二-POP参数介绍"><a href="#二-POP参数介绍" class="headerlink" title="二. POP参数介绍"></a>二. POP参数介绍</h1><blockquote><h6 id="POP默认支持三种动画，但同时也支持自定义动画"><a href="#POP默认支持三种动画，但同时也支持自定义动画" class="headerlink" title="POP默认支持三种动画，但同时也支持自定义动画"></a>POP默认支持三种动画，但同时也支持自定义动画</h6><ul><li><code>POPBasicAnimation</code>   //基础动画</li><li><code>POPSpringAnimation</code>  //弹簧动画</li><li><code>POPDecayAnimation</code>   //衰减动画</li><li><code>POPCustomAnimation</code>  //自定义动画</li></ul></blockquote><h2 id="1、相关属性介绍"><a href="#1、相关属性介绍" class="headerlink" title="1、相关属性介绍"></a>1、相关属性介绍</h2><h3 id="1-1、属性简单介绍"><a href="#1-1、属性简单介绍" class="headerlink" title="1-1、属性简单介绍"></a>1-1、属性简单介绍</h3><ul><li>POP动画大部分属性和CoreAnimation(核心动画)的含义和用法一样</li><li>具体可参考<a href="http://blog.csdn.net/ShmilyCoder/article/details/78219044" target="_blank" rel="noopener">Core Animation(核心动画)</a></li><li>每种动画的特殊属性会在下文中继续介绍</li></ul><h4 id="1-2、动画可配置属性"><a href="#1-2、动画可配置属性" class="headerlink" title="1-2、动画可配置属性"></a>1-2、动画可配置属性</h4><ul><li>CALayer层各属性(比较简单,就不加注释了)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common CALayer property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBackgroundColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBounds;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerCornerRadius;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBorderWidth;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBorderColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerOpacity;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPosition;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPositionX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPositionY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotation;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSize;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubscaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationZ;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationZ;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerZPosition;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowOffset;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowOpacity;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowRadius;</span><br></pre></td></tr></table></figure><ul><li>UIVIew层</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> Common UIView property names.</span><br><span class="line"> */</span><br><span class="line">extern NSString * const kPOPViewAlpha;</span><br><span class="line">extern NSString * const kPOPViewBackgroundColor;</span><br><span class="line">extern NSString * const kPOPViewBounds;</span><br><span class="line">extern NSString * const kPOPViewCenter;</span><br><span class="line">extern NSString * const kPOPViewFrame;</span><br><span class="line">extern NSString * const kPOPViewScaleX;</span><br><span class="line">extern NSString * const kPOPViewScaleXY;</span><br><span class="line">extern NSString * const kPOPViewScaleY;</span><br><span class="line">extern NSString * const kPOPViewSize;</span><br><span class="line">extern NSString * const kPOPViewTintColor;</span><br></pre></td></tr></table></figure><ul><li>其他层视图层</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UINavigationBar property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPNavigationBarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UIToolbar property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPToolbarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UITabBar property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPTabBarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UILabel property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLabelTextColor;</span><br></pre></td></tr></table></figure><blockquote><p>以上仅仅列出了常用的一些属性,更多控件/更多参考框架里面类<br>POPAnimatableProperty.h</p></blockquote><h4 id="1-3、POPBasicAnimation可配置的属性与默认值为"><a href="#1-3、POPBasicAnimation可配置的属性与默认值为" class="headerlink" title="1-3、POPBasicAnimation可配置的属性与默认值为"></a>1-3、POPBasicAnimation可配置的属性与默认值为</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POPBasicAnimation *basic = [POPBasicAnimation linearAnimation];</span><br><span class="line">basic.fromValue = @(<span class="number">0</span>);<span class="comment">//从0开始    basic.toValue = @(3*60);//180秒后结束</span></span><br><span class="line">basic.duration = <span class="number">3</span>*<span class="number">60</span>;<span class="comment">//持续3分钟</span></span><br><span class="line">[lab pop_addAnimation:basic forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let basic1 = POPBasicAnimation(propertyNamed: kPOPLayerPositionX)</span><br><span class="line">basic1?.fromValue = redView.layer.position.x</span><br><span class="line">basic1?.toValue = <span class="number">300</span></span><br><span class="line">basic1?.beginTime = <span class="built_in">CFTimeInterval</span>() + <span class="number">1.0</span></span><br><span class="line">redView.pop_add(basic1, forKey: <span class="string">"position.x"</span>)</span><br></pre></td></tr></table></figure><h2 id="三-POPBasicAnimation基础动画"><a href="#三-POPBasicAnimation基础动画" class="headerlink" title="三. POPBasicAnimation基础动画"></a>三. POPBasicAnimation基础动画</h2><h4 id="1-先看一下效果-其动画效果如下"><a href="#1-先看一下效果-其动画效果如下" class="headerlink" title="1. 先看一下效果, 其动画效果如下"></a>1. 先看一下效果, 其动画效果如下</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-1efeb167ad71b59d.gif?imageMogr2/auto-orient/strip" alt="image"></p><h4 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let basic1 = POPBasicAnimation(propertyNamed: kPOPLayerPositionX)</span><br><span class="line">basic1?.toValue = <span class="number">300</span></span><br><span class="line"><span class="comment">//开始时间</span></span><br><span class="line">basic1?.beginTime = <span class="built_in">CFTimeInterval</span>() + <span class="number">1.0</span></span><br><span class="line">redView.pop_add(basic1, forKey: <span class="string">"position.x"</span>)</span><br></pre></td></tr></table></figure><h4 id="3-可以看到，添加一个动画最少仅需三步"><a href="#3-可以看到，添加一个动画最少仅需三步" class="headerlink" title="3. 可以看到，添加一个动画最少仅需三步"></a>3. 可以看到，添加一个动画最少仅需三步</h4><ul><li>1）定义一个<code>animation</code>对象，并指定对应的动画属性（<code>kPOPLayerPositionX</code>）</li><li>2）设置初始值结束值(初始值可以不指定，会默认从当前值开始）</li><li>3）添加到想产生动画的对象上</li></ul><h4 id="4-Core-Animation-和-POP-运行动画对比"><a href="#4-Core-Animation-和-POP-运行动画对比" class="headerlink" title="4. Core Animation 和 POP 运行动画对比"></a>4. Core Animation 和 POP 运行动画对比</h4><ul><li>由于 POP 是基于定时器定时刷新添加动画的原理，那么如果将动画库运行在主线程上，会由于线程阻塞的问题导致动画效果出现卡顿、不流畅的情况。</li><li>更为关键的是，你不能将动画效果放在子线程，因为你不能将对 view 和 layer 的操作放到主线程之外</li><li>POP 受主线程阻塞的影响很大，在使用过程中，应避免在有可能发生主线程阻塞的情况下使用 POP ，避免制作卡顿的动画效果，产生不好的用户体验</li></ul><h2 id="四-POPSpringAnimation弹性动画"><a href="#四-POPSpringAnimation弹性动画" class="headerlink" title="四. POPSpringAnimation弹性动画"></a>四. POPSpringAnimation弹性动画</h2><h4 id="1-属性介绍"><a href="#1-属性介绍" class="headerlink" title="1. 属性介绍"></a>1. 属性介绍</h4><ul><li><code>velocity</code>: 设置动画开始速度</li><li><code>springBounciness</code>: 振幅, 可以设置的范围是0-20，默认为4。值越大振动的幅度越大</li><li><code>springSpeed</code>: 速度, 可以设置的范围是0-20，默认为12.值越大速度越快，结束的越快</li><li><code>dynamicsMass</code>: 质量, 质量越大，动画的速度越慢，振动的幅度越大，结束的越慢</li><li><code>dynamicsTension</code>: 拉力 拉力越大，动画的速度越快，结束的越快</li><li><code>dynamicsFriction</code>: 摩擦力, 摩擦力越大，动画的速度越慢，振动的幅度越小。</li></ul><blockquote><p>注意: 以上的六个属性中一般只会设置<code>springBounciness</code>和<code>springSpeed</code>, 如有特殊需求才会设置其他属性</p></blockquote><h4 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let spring = POPSpringAnimation(propertyNamed: kPOPViewScaleXY)</span><br><span class="line">//注意: 这里改变的是x和y的比例,参数赋值也要传两个; 若只需要其中一个,则可设置</span><br><span class="line">//`spring?.fromValue = 0.4`即可</span><br><span class="line">spring?.fromValue = CGSize(width: 0.3, height: 0.3)</span><br><span class="line">spring?.toValue = CGSize(width: 2, height: 2)</span><br><span class="line">spring?.springSpeed = 5</span><br><span class="line">spring?.springBounciness = 15</span><br><span class="line">lightBlue.pop_add(spring, forKey: &quot;scale&quot;)</span><br></pre></td></tr></table></figure><h2 id="五-POPDecayAnimation"><a href="#五-POPDecayAnimation" class="headerlink" title="五. POPDecayAnimation"></a>五. POPDecayAnimation</h2><ul><li><code>POPDecayAnimation</code>提供一个过阻尼效果（其实<code>Spring</code>是一种欠阻尼效果）可以实现类似<code>UIScrollView</code>的滑动衰减效果（是的你可以靠它来自己实现一个<code>UIScrollView</code>）</li></ul><blockquote><p>属性介绍</p><ul><li><code>deceleration</code> （负加速度, 衰减系数(越小则衰减得越快)） 是一个你会很少用到的值，默认是就是我们地球的 0.998，如果你开发APP给火星人用，那么这个值你使用 0.376 会更合适</li><li><code>velocity</code> 也是必须和你操作的属性有相同的结构，如果你操作的是 bounds, 传CGRect类型;如果 velocity 是负值，那么就会反向递减</li></ul></blockquote><blockquote><p>代码示例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let decay = POPDecayAnimation(propertyNamed: kPOPViewSize)</span><br><span class="line">decay?.velocity = CGSize(width: 300, height: pictureBtn.frame.height)</span><br><span class="line">//延迟1秒后执行</span><br><span class="line">decay?.beginTime = CACurrentMediaTime() + 1.0</span><br><span class="line">pictureBtn.pop_add(decay, forKey: &quot;size&quot;)</span><br></pre></td></tr></table></figure><h2 id="六-自定义属性"><a href="#六-自定义属性" class="headerlink" title="六. 自定义属性"></a>六. 自定义属性</h2><p>POP默认支持的三种动画都继承自<code>POPPropertyAnimation</code>,  <code>POPPropertyAnimation</code>中定义了一个叫<code>property</code>的属性（之前没有用到它是因为POP根据不同的默认动画属性帮你生成了默认的<code>property</code>这个属性则是用来驱动POP的动画效果中的重要一环</p><h3 id="1-实力模块"><a href="#1-实力模块" class="headerlink" title="1. 实力模块"></a>1. 实力模块</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> let proper = POPAnimatableProperty.property(withName: <span class="string">"prop"</span>, initializer: &#123; (prop) <span class="keyword">in</span></span><br><span class="line">    guard let prop = prop <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//read</span></span><br><span class="line">    prop.readBlock = &#123; (obj, values) <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//write</span></span><br><span class="line">    prop.writeBlock = &#123;(obj, values) <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    prop.threshold = <span class="number">0.01</span></span><br><span class="line">            </span><br><span class="line">&#125;) as? POPAnimatableProperty &#123;</span><br><span class="line">    anim.property = proper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-属性介绍"><a href="#2-属性介绍" class="headerlink" title="2. 属性介绍"></a>2. 属性介绍</h3><blockquote><p>其组成就是一个readBlock一个writeBlock和一个threashold</p><ul><li><code>readBlock</code>告诉POP当前的属性值</li><li><code>writeBlock</code>中修改变化后的属性值</li><li><code>threashold</code>决定了动画变化间隔的阈值 值越大<code>writeBlock</code>的调用次数越少</li></ul></blockquote><p>POPAnimatableProperty其实是POP中一个比较重要的东西 像上面提到的POP自带的动画属性 查看源代码可以看到也只是POP自动帮你设置好了POPAnimatableProperty而已 其作用就是当动画的某个时间片被触发时 告诉系统如何根据当前时间片做出变化</p><blockquote><p>还是以一个实际的例子来说明如何使用自定义属性 比如我们要实现一个像系统的时钟APP里秒表计时的一个效果</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-070c23772942ed82.gif?imageMogr2/auto-orient/strip" alt="计时器效果"></p><h3 id="3-完整代码示例"><a href="#3-完整代码示例" class="headerlink" title="3. 完整代码示例"></a>3. 完整代码示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> let proper = POPAnimatableProperty.property(withName: <span class="string">"prop"</span>, initializer: &#123; (prop) <span class="keyword">in</span></span><br><span class="line">    guard let prop = prop <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//read</span></span><br><span class="line">    prop.readBlock = &#123; (obj, values) <span class="keyword">in</span></span><br><span class="line">        guard let array = values <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        print(array[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//write</span></span><br><span class="line">    prop.writeBlock = &#123;(obj, values) <span class="keyword">in</span></span><br><span class="line">        guard let button = obj as? <span class="built_in">UIButton</span>, let array = values <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        let value = array[<span class="number">0</span>]</span><br><span class="line">        button.setTitle(String(format: <span class="string">"%02d:%02d:%02d"</span>, Int(value / <span class="number">60</span>), Int(value.truncatingRemainder(dividingBy: <span class="number">60</span>)), Int((value * <span class="number">100</span>).truncatingRemainder(dividingBy: <span class="number">100</span>))), <span class="keyword">for</span>: .normal)</span><br><span class="line">    &#125;</span><br><span class="line">    prop.threshold = <span class="number">0.01</span></span><br><span class="line">    </span><br><span class="line">&#125;) as? POPAnimatableProperty &#123;</span><br><span class="line">    <span class="keyword">if</span> let popBasic = POPBasicAnimation.linear() &#123;</span><br><span class="line">        <span class="comment">//秒表用线性的时间函数初始化</span></span><br><span class="line">        popBasic.property = proper</span><br><span class="line">        popBasic.fromValue = <span class="number">0</span> <span class="comment">//从0开始</span></span><br><span class="line">        popBasic.toValue = <span class="number">18</span>  <span class="comment">//到18秒</span></span><br><span class="line">        popBasic.duration = <span class="number">18</span> <span class="comment">//持续18秒</span></span><br><span class="line">        popBasic.beginTime = <span class="built_in">CACurrentMediaTime</span>() + <span class="number">2</span> <span class="comment">//延迟2秒开始</span></span><br><span class="line">        pictureBtn.pop_add(popBasic, forKey: <span class="string">"linear"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意:"></a>4. 注意:</h3><ul><li>在Swift4.0版本(4.0之前版本未知)中,初始化出来的对象都是可选类型</li><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a>官方的建议是添加<code>if</code>条件判断,详情可到GitHub上查看示例</li><li>正如上段代码所示: 闭包中涉及的可选类型都添加了<code>guard</code>判断</li></ul><h2 id="七-类似微博中间发布按钮弹出动画"><a href="#七-类似微博中间发布按钮弹出动画" class="headerlink" title="七. 类似微博中间发布按钮弹出动画"></a>七. 类似微博中间发布按钮弹出动画</h2><h4 id="先看一下效果吧"><a href="#先看一下效果吧" class="headerlink" title="先看一下效果吧"></a>先看一下效果吧</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-737cf17a9cb95542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="微博动画效果图"></p><blockquote><p>动画分为两个部分</p></blockquote><ul><li>中间六个按钮依次执行动画弹出</li><li>上面标题图片最后动画落下</li></ul><h4 id="下面来看一下部分的核心代码"><a href="#下面来看一下部分的核心代码" class="headerlink" title="下面来看一下部分的核心代码"></a>下面来看一下部分的核心代码</h4><h5 id="1-六个按钮的弹出和消失动画"><a href="#1-六个按钮的弹出和消失动画" class="headerlink" title="1. 六个按钮的弹出和消失动画"></a>1. 六个按钮的弹出和消失动画</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;titles.count &#123;</span><br><span class="line">    let button = BaseButton()</span><br><span class="line">    button.setTitle(titles[i], <span class="keyword">for</span>: .normal)</span><br><span class="line">    button.setImage(<span class="built_in">UIImage</span>(named: images[i]), <span class="keyword">for</span>: .normal)</span><br><span class="line">    button.addTarget(<span class="keyword">self</span>, action: <span class="meta">#selector(buttonClick(button:)), for: .touchUpInside)</span></span><br><span class="line">    addSubview(button)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算X/Y</span></span><br><span class="line">    let row = i / maxCols</span><br><span class="line">    let col = i % maxCols</span><br><span class="line">    let buttonX = btnStsrtX + <span class="built_in">CGFloat</span>(col) * (xMargin + buttonW)</span><br><span class="line">    let buttonEndY = btnStartY + <span class="built_in">CGFloat</span>(row) * buttonH</span><br><span class="line">    let buttonStartY = buttonEndY - kScreenHeight</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按钮动画</span></span><br><span class="line">    let popSpring = POPSpringAnimation(propertyNamed: kPOPViewFrame)</span><br><span class="line">    popSpring?.fromValue = <span class="built_in">CGRect</span>(x: buttonX, y: buttonStartY, width: buttonW, height: buttonH)</span><br><span class="line">    popSpring?.toValue = <span class="built_in">CGRect</span>(x: buttonX, y: buttonEndY, width: buttonW, height: buttonH)</span><br><span class="line">    popSpring?.springBounciness = kSpringFactor</span><br><span class="line">    popSpring?.springSpeed = kSpringFactor</span><br><span class="line">    popSpring?.beginTime = <span class="built_in">CACurrentMediaTime</span>() + kAnimationDelay * Double(i)</span><br><span class="line">    button.pop_add(popSpring, forKey: <span class="string">"spring"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-最上部分标语的弹出和消失"><a href="#2-最上部分标语的弹出和消失" class="headerlink" title="2. 最上部分标语的弹出和消失"></a>2. 最上部分标语的弹出和消失</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//z执行动画</span></span><br><span class="line">let imagePOP = POPSpringAnimation(propertyNamed: kPOPViewCenter)</span><br><span class="line">imagePOP?.fromValue = <span class="built_in">CGPoint</span>(x: kScreenWidth * <span class="number">0.5</span>, y: <span class="number">0.2</span> * kScreenHeight - kScreenHeight)</span><br><span class="line">imagePOP?.toValue = <span class="built_in">CGPoint</span>(x: kScreenWidth * <span class="number">0.5</span>, y: <span class="number">0.2</span> * kScreenHeight)</span><br><span class="line">imagePOP?.springSpeed = kSpringFactor</span><br><span class="line">imagePOP?.springBounciness = kSpringFactor</span><br><span class="line">imagePOP?.beginTime = <span class="built_in">CACurrentMediaTime</span>() + Double(btnCount) * kAnimationDelay</span><br><span class="line">imagePOP?.completionBlock = &#123; popAnim, finished <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//所有动画执行完毕,回复View点击事件</span></span><br><span class="line">    kRootView?.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">self</span>.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">topImage.pop_add(imagePOP, forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><p>以上是类似微博动画的部分核心代码, 具体代码详见<a href="https://github.com/coderQuanjun/POPAnimationDemo" target="_blank" rel="noopener">GitHub项目</a>, 喜欢请star</p></blockquote><h4 id="github项目介绍"><a href="#github项目介绍" class="headerlink" title="github项目介绍"></a><a href="https://github.com/coderQuanjun/POPAnimationDemo" target="_blank" rel="noopener">github项目介绍</a></h4><ul><li>折叠图片</li><li>音量震动条</li><li>活动指示器</li><li>微博动画</li><li>倒计时-计时器</li><li>类似QQ信息条数的粘性动画</li><li>类似雷达-水波纹动画</li></ul><blockquote><p>注: 项目持续更新中……</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS动画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Facebook POP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS出门必备之CoreAnimation(核心动画)</title>
      <link href="/2017/10/12/iOS%E5%87%BA%E9%97%A8%E5%BF%85%E5%A4%87%E4%B9%8BCoreAnimation(%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB)"/>
      <content type="html"><![CDATA[<h1 id="CoreAnimation"><a href="#CoreAnimation" class="headerlink" title="CoreAnimation"></a>CoreAnimation</h1><ul><li>前段时间接触到了一个牛逼的动画框架<a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a>,本来想来装装逼,突然发现,苹果大大的CoreAnimation我还不会用呢!</li><li>依稀记得乔帮主在2007年的WWDC大会上亲自为你演示Core Animation的强大：<a href="http://v.youku.com/v_show/id_XMzQ2MTcwNDQ0.html" target="_blank" rel="noopener">点击查看视频</a>(不好意思,又装逼了)</li><li>言归正传,我只是来温习一下CoreAnimation,还望路过的大神不要吐槽我太low</li></ul><h3 id="GitHub项目地址"><a href="#GitHub项目地址" class="headerlink" title="GitHub项目地址"></a><a href="https://github.com/coderQuanjun/POPAnimationDemo" target="_blank" rel="noopener">GitHub项目地址</a></h3><a id="more"></a><h2 id="一、Core-Animation简介"><a href="#一、Core-Animation简介" class="headerlink" title="一、Core Animation简介"></a>一、Core Animation简介</h2><ul><li>Core Animation，中文翻译为核心动画，它是一组非常强大的动画处理API，使用它能做出非常炫丽的动画效果，而且往往是事半功倍。也就是说，使用少量的代码就可以实现非常强大的功能。</li><li>Core Animation可以用在Mac OS X和iOS平台。</li><li>Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。</li><li>要注意的是，Core Animation是直接作用在CALayer上的，并非UIView</li><li>通过调用CALayer的addAnimation:forKey:方法增加CAAnimation对象到CALayer中，这样就能开始执行动画了</li><li>通过调用CALayer的removeAnimationForKey:方法可以停止CALayer中的动画</li></ul><h2 id="二-Core-Animation及其相关属性"><a href="#二-Core-Animation及其相关属性" class="headerlink" title="二. Core Animation及其相关属性"></a>二. Core Animation及其相关属性</h2><ul><li>要想执行动画，就必须初始化一个CAAnimation对象。</li><li>一般情况下，我们使用的比较多的是CAAnimation的子类，因此，先大致看看CAAnimation的继承结构</li><li>黑线代表继承，黑色文字代表类名，白色文字代表属性。其中CAMediaTiming是一个协议(protocol)</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-7bc6a9dcfc3ff80f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="Core Animation结构划分.png"></p><blockquote><p>需要注意的是</p><ul><li>CAAnimation是所有动画类的父类，但是它不能直接使用，应该使用它的子类</li><li>CAPropertyAnimation也是不能直接使用的，也要使用它的子类</li><li>能用的动画类只剩下4个：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup</li></ul></blockquote><blockquote><p>常用属性</p></blockquote><p><strong>1). <code>removedOnCompletion</code>：默认为true，代表动画执行完毕后就从图层上移除</strong></p><ul><li>图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为false，不过还要设置<code>fillMode</code>为<code>kCAFillModeForwards</code></li></ul><p><strong>2). timingFunction：控制动画运行的节奏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/** timingFunction可选的值 **/</span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCAMediaTimingFunctionLinear: String</span><br><span class="line">//1.(匀速): 在整个动画时间内动画都是以一个相同的速度来改变</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCAMediaTimingFunctionEaseIn: String</span><br><span class="line">//2. (渐进): 缓慢进入, 加速离开</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCAMediaTimingFunctionEaseOut: String</span><br><span class="line">//3. (渐出): 快速进入, 减速离开</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCAMediaTimingFunctionEaseInEaseOut: String</span><br><span class="line">//4. (渐进渐出): 缓慢进入, 中间加速, 减速离开</span><br><span class="line"></span><br><span class="line">@available(iOS 3.0, *)</span><br><span class="line">public let kCAMediaTimingFunctionDefault: String</span><br><span class="line">//5. (默认): 效果基本等同于EaseOut(渐出)</span><br></pre></td></tr></table></figure><p><strong>3). fillMode决定当前对象在非active时间段的行为。</strong></p><ul><li>要想fillMode有效，需设置removedOnCompletion = false</li><li>fillMode可选的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* `fillMode&apos; options. */</span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCAFillModeForwards: String</span><br><span class="line">//1. 当动画结束后，layer会一直保持着动画最后的状态</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCAFillModeBackwards: String</span><br><span class="line">//2. 设置为该值，将会立即执行动画的第一帧，不论是否设置了 beginTime属性。观察发现，设置该值，刚开始视图不见，还不知道应用在哪里</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCAFillModeBoth: String</span><br><span class="line">//3. 该值是 kCAFillModeForwards 和 kCAFillModeBackwards的组合状态; 动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCAFillModeRemoved: String</span><br><span class="line">//4. 默认值，动画将在设置的 beginTime 开始执行（如没有设置beginTime属性，则动画立即执行），动画执行完成后会将layer的改变恢复原状</span><br></pre></td></tr></table></figure><p><strong>4). <code>delegate</code>：动画代理，用来监听动画的执行过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public protocol CAAnimationDelegate : NSObjectProtocol &#123;</span><br><span class="line"></span><br><span class="line">    // 动画开始执行的时候触发这个方法</span><br><span class="line">    @available(iOS 2.0, *)</span><br><span class="line">    optional public func animationDidStart(_ anim: CAAnimation)</span><br><span class="line"></span><br><span class="line">    // 动画执行完毕的时候触发这个方法</span><br><span class="line">    @available(iOS 2.0, *)</span><br><span class="line">    optional public func animationDidStop(_ anim: CAAnimation, finished flag: Bool)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5). 其他相关属性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">duration    动画的时长</span><br><span class="line">repeatCount    重复的次数。不停重复设置为 HUGE_VALF</span><br><span class="line">repeatDuration    设置动画的时间。在该时间内动画一直执行，不计次数。</span><br><span class="line">beginTime    指定动画开始的时间。从开始延迟几秒的话，设置为【CACurrentMediaTime() + 秒数】 的方式</span><br><span class="line">timingFunction    设置动画的速度变化</span><br><span class="line">autoreverses    动画结束时是否执行逆动画</span><br><span class="line">fromValue    所改变属性的起始值(Swift中为Any类型,OC中要包装成NSValue对象)</span><br><span class="line">toValue    所改变属性的结束时的值(类型与fromValue相同)</span><br><span class="line">byValue    所改变属性相同起始值的改变量(类型与fromValue相同)</span><br></pre></td></tr></table></figure><h2 id="三-CABasicAnimation"><a href="#三-CABasicAnimation" class="headerlink" title="三. CABasicAnimation"></a>三. CABasicAnimation</h2><ul><li>CABasicAnimation是CAPropertyAnimation的子类，使用它可以实现一些基本的动画效果，它可以让CALayer的某个属性从某个值渐变到另一个值。下面就用CABasicAnimation实现几个简单的动画</li></ul><h3 id="1-平移动画"><a href="#1-平移动画" class="headerlink" title="1. 平移动画"></a>1. 平移动画</h3><h4 id="方法一-改变label的position"><a href="#方法一-改变label的position" class="headerlink" title="方法一: 改变label的position"></a>方法一: 改变label的position</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let caBasic = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"position"</span>)</span><br><span class="line">caBasic.duration = <span class="number">2</span></span><br><span class="line">caBasic.fromValue = redLabel.layer.position</span><br><span class="line">caBasic.toValue = <span class="built_in">CGPoint</span>(x: kScreenWidth - <span class="number">50</span>, y: <span class="number">200</span>)</span><br><span class="line">caBasic.delegate = <span class="keyword">self</span></span><br><span class="line">caBasic.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line">caBasic.fillMode = kCAFillModeForwards</span><br><span class="line">redLabel.layer.add(caBasic, forKey: <span class="string">"redLabel1"</span>)</span><br></pre></td></tr></table></figure><ul><li>初始化方法中是@”position”，说明要修改的是CALayer的position属性，也就是会执行平移动画</li><li>默认情况下，动画执行完毕后，动画会自动从CALayer上移除，CALayer又会回到原来的状态。为了保持动画执行后的状态，可以加入第6、7行代码</li><li>第8行后面的@”redLabel1”是给动画对象起个名称，以后可以调用CALayer的removeAnimationForKey:方法根据动画名称停止相应的动画</li><li>遵循的代理方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController: CAAnimationDelegate &#123;</span><br><span class="line">    //开始执行</span><br><span class="line">    func animationDidStart(_ anim: CAAnimation) &#123;</span><br><span class="line">        print(&quot;开始动画--layer:&quot;, redLabel.layer.position)</span><br><span class="line">    &#125;</span><br><span class="line">    //结束之行</span><br><span class="line">    func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123;</span><br><span class="line">        print(&quot;结束动画--layer:&quot;, redLabel.layer.position)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//打印结果为:</span><br><span class="line">//开始动画--layer: (35.0, 213.0)</span><br><span class="line">//结束动画--layer: (35.0, 213.0)</span><br></pre></td></tr></table></figure><blockquote><p>从打印信息可以看出，实际上，动画执行完毕后，并没有真正改变CALayer的position属性的值！</p></blockquote><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二."></a>方法二.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> let basic = CABasicAnimation(keyPath: &quot;transform&quot;)</span><br><span class="line">basic.duration = 2</span><br><span class="line">let form = CATransform3DMakeTranslation(350, 400, 0)</span><br><span class="line">basic.toValue = form</span><br><span class="line">blueLabel.layer.add(basic, forKey: &quot;blueLabel&quot;)</span><br></pre></td></tr></table></figure><h3 id="2-旋转动画"><a href="#2-旋转动画" class="headerlink" title="2. 旋转动画"></a>2. 旋转动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let basic1 = CABasicAnimation(keyPath: &quot;transform&quot;)</span><br><span class="line">basic1.duration = 1</span><br><span class="line">basic1.toValue = CATransform3DMakeRotation(0.25, 0, 0, 1)</span><br><span class="line">basic1.isRemovedOnCompletion = false</span><br><span class="line">basic1.fillMode = kCAFillModeForwards</span><br><span class="line">blueLabel.layer.add(basic1, forKey: &quot;basic1&quot;)</span><br></pre></td></tr></table></figure><ul><li>可以不用设置fromValue，这里只设置了toValue</li></ul><h3 id="3-缩放动画"><a href="#3-缩放动画" class="headerlink" title="3. 缩放动画"></a>3. 缩放动画</h3><ul><li>CALayer的宽度从0.5倍变为2倍</li><li>CALayer的高度从0.5倍变为1.5倍<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let basic1 = CABasicAnimation(keyPath: &quot;transform&quot;)</span><br><span class="line">basic1.duration = 1</span><br><span class="line">basic1.toValue = CATransform3DMakeScale(0.5, 0.5, 1)</span><br><span class="line">basic1.toValue = CATransform3DMakeScale(2, 1.5, 1)</span><br><span class="line">basic1.isRemovedOnCompletion = false</span><br><span class="line">basic1.fillMode = kCAFillModeForwards</span><br><span class="line">blueLabel.layer.add(basic1, forKey: &quot;basic1&quot;)</span><br></pre></td></tr></table></figure></li></ul><blockquote></blockquote><ul><li>CABasicAnimation虽然能够做很多基本的动画效果，但是有个局限性，只能让CALayer的属性从某个值渐变到另一个值，仅仅是在2个值之间渐变</li><li>总结一些常用的animationKeyPath值的</li></ul><table><thead><tr><th>值</th><th>说明</th><th>使用形式</th></tr></thead><tbody><tr><td>transform.scale</td><td>比例转化</td><td>0.5</td></tr><tr><td>transform.scale.x</td><td>宽的比例</td><td>0.5</td></tr><tr><td>transform.rotation.x</td><td>围绕x轴旋转</td><td>@(M_PI_4)(OC), 0.25(Swift)</td></tr><tr><td>cornerRadius</td><td>圆角的设置</td><td>30</td></tr><tr><td>backgroundColor</td><td>背景颜色的变化</td><td>UIColor.purpleColor.cgColor</td></tr><tr><td>bounds</td><td>大小，中心不变</td><td>CGRect</td></tr><tr><td>position</td><td>位置(中心点的改变)</td><td>CGPoint</td></tr><tr><td>contents</td><td>内容，比如UIImageView的图片</td><td>imageAnima.toValue = UIImage(named: “toImage”)?.cgImage</td></tr><tr><td>opacity</td><td>透明度</td><td>0.7</td></tr><tr><td>contentsRect.size.width</td><td>横向拉伸缩放</td><td>最好是0~1之间的</td></tr></tbody></table><h2 id="四-CAKeyframeAnimation——关键帧动画"><a href="#四-CAKeyframeAnimation——关键帧动画" class="headerlink" title="四. CAKeyframeAnimation——关键帧动画"></a>四. CAKeyframeAnimation——关键帧动画</h2><ul><li>关键帧动画，也是<code>CAPropertyAnimation</code>的子类，与<code>CABasicAnimation</code>的区别是：<ul><li><code>CABasicAnimation</code>只能从一个数值（fromValue）变到另一个数值（toValue）</li><li>而<code>CAKeyframeAnimation</code>会使用一个Array保存这些数值</li></ul></li><li>属性说明：<ul><li><code>values</code>：上述的Array对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧</li><li><code>path</code>：可以设置一个<code>CGPathRef、CGMutablePathRef</code>，让图层按照路径轨迹移动。path只对CALayer的<code>anchorPoint</code>和<code>position</code>起作用。如果设置了path，那么values将被忽略</li><li><code>keyTimes</code>：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的</li><li><code>calculationMode</code>: 该属性决定了物体在每个子路径下是跳着走还是匀速走，跟<code>timeFunctions</code>属性有点类似<ul><li><code>kCAAnimationLinear</code>默认值,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;</li><li><code>kCAAnimationDiscrete</code> 离散的,就是不进行插值计算,所有关键帧直接逐个进行显示;</li><li><code>kCAAnimationPaced</code> 使得动画均匀进行,而不是按<code>keyTimes</code>设置的或者按关键帧平分时间,此时<code>keyTimes</code>和timingFunctions`无效;</li><li><code>kCAAnimationCubic</code> 对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过<code>tensionValues,continuityValues,biasValues</code>来进行调整自定义主要目的是使得运行的轨迹变得圆滑;</li><li><code>kCAAnimationCubicPaced</code> 看这个名字就知道和<code>kCAAnimationCubic</code>有一定联系,其实就是在<code>kCAAnimationCubic</code>的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时<code>keyTimes</code>以及<code>timingFunctions</code>也是无效的.</li></ul></li></ul></li><li><code>CABasicAnimation</code>可看做是只有2个关键帧的<code>CAKeyframeAnimation</code></li></ul><blockquote><p>values方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let key = CAKeyframeAnimation(keyPath: &quot;position&quot;)</span><br><span class="line">key.duration = 3</span><br><span class="line">key.repeatCount = HUGE //无线循环</span><br><span class="line">key.calculationMode = kCAAnimationPaced</span><br><span class="line">key.values = [redLabel.frame.origin, CGPoint(x: 180, y: 70), CGPoint(x: 180, y: 200), redLabel.frame.origin]</span><br><span class="line">key.keyTimes = [NSNumber(value: 0.0), NSNumber(value: 0.6), NSNumber(value: 0.7), NSNumber(value: 0.8)]</span><br><span class="line">redLabel.layer.add(key, forKey: &quot;key&quot;)</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="五-CASpringAnimation"><a href="#五-CASpringAnimation" class="headerlink" title="五. CASpringAnimation"></a>五. CASpringAnimation</h2><ul><li><code>CASpringAnimation</code>是iOS 9 新出的</li><li><code>CASpringAnimation</code> 继承于<code>CABaseAnimation</code></li><li><code>CASpringAnimation</code>是苹果专门解决开发者关于弹簧动画的这个需求而封装的类。</li></ul><h3 id="1-CASpringAnimation相关属性"><a href="#1-CASpringAnimation相关属性" class="headerlink" title="1. CASpringAnimation相关属性"></a>1. CASpringAnimation相关属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//1. 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大, 默认值: 1</span><br><span class="line">open var mass: CGFloat</span><br><span class="line"></span><br><span class="line">//2. 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快(默认值: 100)</span><br><span class="line">open var stiffness: CGFloat</span><br><span class="line"></span><br><span class="line">//3. 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快(默认值: 10)</span><br><span class="line">open var damping: CGFloat</span><br><span class="line"></span><br><span class="line">//4. 初始速率，动画视图的初始速度大小, 默认0</span><br><span class="line">//速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反(默认值: 0)</span><br><span class="line">open var initialVelocity: CGFloat</span><br><span class="line"></span><br><span class="line">//5. 估算时间 返回弹簧动画到停止时的估算时间，根据当前的动画参数估算(只读)</span><br><span class="line">open var settlingDuration: CFTimeInterval &#123; get &#125;</span><br></pre></td></tr></table></figure><h3 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let spring = CASpringAnimation(keyPath: &quot;position.y&quot;)</span><br><span class="line">spring.mass = 5</span><br><span class="line">spring.stiffness = 100</span><br><span class="line">spring.damping = 5</span><br><span class="line">spring.initialVelocity = 2</span><br><span class="line">spring.fromValue = blueLabel.layer.position.y</span><br><span class="line">spring.toValue = kScreenHeight - 150</span><br><span class="line">spring.duration = spring.settlingDuration</span><br><span class="line">blueLabel.layer.add(spring, forKey: &quot;spring&quot;)</span><br></pre></td></tr></table></figure><h2 id="六-CAAnimationGroup动画组"><a href="#六-CAAnimationGroup动画组" class="headerlink" title="六. CAAnimationGroup动画组"></a>六. CAAnimationGroup动画组</h2><ul><li>是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行</li><li>属性说明：<ul><li>animations：用来保存一组动画对象的Array</li></ul></li><li>默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h3><ul><li>同时执行：平移、缩放、位移动画 -&gt; 使用动画组</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动画组</span></span><br><span class="line">fileprivate func getCAAnimationGroup()&#123;</span><br><span class="line">    <span class="comment">//0. 初始化动画组</span></span><br><span class="line">    let group = <span class="built_in">CAAnimationGroup</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 平移动画</span></span><br><span class="line">    let basic1 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"position"</span>)</span><br><span class="line">    basic1.fromValue = blueLabel.layer.position</span><br><span class="line">    basic1.toValue = <span class="built_in">CGPoint</span>(x: <span class="built_in">CGFloat</span>(arc4random_uniform(<span class="number">200</span>)), y: <span class="built_in">CGFloat</span>(arc4random_uniform(<span class="number">500</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 缩放动画</span></span><br><span class="line">    let basic2 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"transform.scale"</span>)</span><br><span class="line">    var scale: <span class="built_in">CGFloat</span> = <span class="number">0.1</span></span><br><span class="line">    scale = scale &lt; <span class="number">1</span> ? <span class="number">1.5</span> : <span class="number">0.5</span></span><br><span class="line">    basic2.toValue = scale</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 旋转动画</span></span><br><span class="line">    let basic3 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"transform.rotation"</span>)</span><br><span class="line">    basic3.toValue = <span class="built_in">CGFloat</span>(arc4random_uniform(<span class="number">360</span>)) / <span class="number">180.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 添加到动画组</span></span><br><span class="line">    group.animations = [basic1, basic2, basic3]</span><br><span class="line">    <span class="comment">//取消反弹</span></span><br><span class="line">    group.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line">    group.fillMode = kCAFillModeForwards</span><br><span class="line">    group.duration = <span class="number">0.5</span></span><br><span class="line">    blueLabel.layer.add(group, forKey: <span class="string">"group"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七-转场动画——CATransition"><a href="#七-转场动画——CATransition" class="headerlink" title="七. 转场动画——CATransition"></a>七. 转场动画——CATransition</h2><ul><li><code>CATransition</code>是<code>CAAnimation</code>的子类，用于做转场动画，能够为layer层提供移出屏幕和移入屏幕的动画效果。</li><li>iOS比Mac OS X的转场动画效果少一点<br><code>UINavigationController</code>就是通过<code>CATransition</code>实现了将控制器的视图推入屏幕的动画效果</li><li>动画属性:<ul><li><code>type</code>：动画过渡类型</li><li><code>subtype</code>：动画过渡方向</li><li><code>startProgress</code>：动画起点(在整体动画的百分比)</li><li><code>endProgress</code>：动画终点(在整体动画的百分比)</li></ul></li></ul><h3 id="1-type和subtype属性说明"><a href="#1-type和subtype属性说明" class="headerlink" title="1. type和subtype属性说明"></a>1. <code>type</code>和<code>subtype</code>属性说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* type类型 */</span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCATransitionFade: String</span><br><span class="line">//交叉淡化过渡</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCATransitionMoveIn: String</span><br><span class="line">//新视图移到旧视图上面</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCATransitionPush: String</span><br><span class="line">//新视图把旧视图推出去</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCATransitionReveal: String</span><br><span class="line">//将旧视图移开,显示下面的新视图</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* subtypes类型 */</span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCATransitionFromRight: String</span><br><span class="line">//从右侧转场</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCATransitionFromLeft: String</span><br><span class="line">//从左侧转场</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCATransitionFromTop: String</span><br><span class="line">//从上部转场</span><br><span class="line"></span><br><span class="line">@available(iOS 2.0, *)</span><br><span class="line">public let kCATransitionFromBottom: String</span><br><span class="line">//从底部转场</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>除了上述四种效果之外,还有很多私有API效果，使用的时候要小心，可能会导致app审核不被通过</li><li>使用的时候要以字符串的形式</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cube     //立方体翻滚效果</span><br><span class="line">oglFlip  //上下左右翻转效果</span><br><span class="line">suckEffect   //收缩效果，如一块布被抽走(不支持过渡方向)</span><br><span class="line">rippleEffect //滴水效果(不支持过渡方向)</span><br><span class="line">pageCurl     //向上翻页效果</span><br><span class="line">pageUnCurl   //向下翻页效果</span><br><span class="line">cameraIrisHollowOpen  //相机镜头打开效果(不支持过渡方向)</span><br><span class="line">cameraIrisHollowClose //相机镜头关上效果(不支持过渡方向)</span><br></pre></td></tr></table></figure><blockquote><p>效果参考</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-48e5ec518c8f535e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="各参数动画效果.png"></p><h3 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例:"></a>2. 代码示例:</h3><ul><li>展示立方体翻滚效果的图片浏览</li></ul><h4 id="1-初始化变量"><a href="#1-初始化变量" class="headerlink" title="1. 初始化变量"></a>1. 初始化变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//初始化变量</span><br><span class="line">fileprivate var imageView = UIImageView(frame: UIScreen.main.bounds)</span><br><span class="line">fileprivate var currentIndex = 0</span><br></pre></td></tr></table></figure><h4 id="2-需要在viewDidLoad中调用一下方法"><a href="#2-需要在viewDidLoad中调用一下方法" class="headerlink" title="2. 需要在viewDidLoad中调用一下方法"></a>2. 需要在<code>viewDidLoad</code>中调用一下方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转场动画</span></span><br><span class="line">    fileprivate func imageCATransition()&#123;</span><br><span class="line">        <span class="comment">//0.初始化ImageView</span></span><br><span class="line">        imageView.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">        imageView.image = <span class="built_in">UIImage</span>(named: <span class="string">"0.jpg"</span>)</span><br><span class="line">        view.addSubview(imageView)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. 添加滑动手势</span></span><br><span class="line">        let left = <span class="built_in">UISwipeGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="meta">#selector(leftSwipe(gesture:)))</span></span><br><span class="line">        left.direction = .left</span><br><span class="line">        imageView.addGestureRecognizer(left)</span><br><span class="line">        let right = <span class="built_in">UISwipeGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="meta">#selector(rightSwipe(gesture:)))</span></span><br><span class="line">        right.direction = .right</span><br><span class="line">        imageView.addGestureRecognizer(right)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-滑动后执行的方法"><a href="#3-滑动后执行的方法" class="headerlink" title="3. 滑动后执行的方法"></a>3. 滑动后执行的方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: 手势相关方法</span></span><br><span class="line"><span class="comment">//左滑</span></span><br><span class="line">@objc fileprivate func leftSwipe(gesture: <span class="built_in">UIGestureRecognizer</span>) &#123;</span><br><span class="line">    print(<span class="string">"左滑动"</span>)</span><br><span class="line">    transitionAnimation(isNext: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右滑</span></span><br><span class="line">@objc fileprivate func rightSwipe(gesture: <span class="built_in">UIGestureRecognizer</span>) &#123;</span><br><span class="line">    print(<span class="string">"右滑动"</span>)</span><br><span class="line">    transitionAnimation(isNext: <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置转场动画</span></span><br><span class="line">fileprivate func transitionAnimation(isNext: Bool)&#123;</span><br><span class="line">    let transition = <span class="built_in">CATransition</span>()</span><br><span class="line">    transition.type = kCATransitionFade</span><br><span class="line">    transition.subtype = isNext ? kCATransitionFromRight : kCATransitionFromLeft</span><br><span class="line">    transition.duration = <span class="number">1</span></span><br><span class="line">    imageView.image = getImage(isNext)</span><br><span class="line">    imageView.layer.add(transition, forKey: <span class="string">"transition"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下/上一张图片</span></span><br><span class="line">fileprivate func getImage(_ isNext: Bool) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    currentIndex = isNext ? currentIndex + <span class="number">1</span> : currentIndex - <span class="number">1</span></span><br><span class="line">    currentIndex = currentIndex &lt; <span class="number">0</span> ? <span class="number">7</span> : currentIndex</span><br><span class="line">    currentIndex = currentIndex &gt; <span class="number">7</span> ? <span class="number">0</span> : currentIndex</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(named: <span class="string">"\(currentIndex)"</span> + <span class="string">".jpg"</span>)!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八-总结"><a href="#八-总结" class="headerlink" title="八. 总结"></a>八. 总结</h2><ul><li>核心动画给我们展示的只是一个假象，layer的的frame、bounds、position并不会在动画完毕之后发生改变。</li><li>UIView封装的动画，会使会真实修改view的一些属性</li><li>以上就是小编总结的关于Core Animation核心动画的相关分类</li><li>总结的知识点比较简单, 个人感觉有点low</li><li>如有不足之处,还望路过的大神多多指教</li></ul>]]></content>
      
      <categories>
          
          <category> iOS动画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> CoreAnimation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift+Moya网络请求之项目实战</title>
      <link href="/2017/10/08/RxSwift+Moya%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B9%8B%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"/>
      <content type="html"><![CDATA[<blockquote><p>RxSwift相关基本介绍和用法可参考:</p><ul><li><a href="http://www.jianshu.com/p/319db438c4d3" target="_blank" rel="noopener">RxSwift的使用详解01</a></li><li><a href="http://www.jianshu.com/p/bcd0dc328308" target="_blank" rel="noopener">RxSwift的使用详解02</a></li></ul></blockquote><h2 id="一-下面将将进行实战项目"><a href="#一-下面将将进行实战项目" class="headerlink" title="一. 下面将将进行实战项目"></a>一. 下面将将进行实战项目</h2><ul><li>1.登录注册功能<ul><li>输入用户名要大于6个字符，不然密码不能输入</li><li>密码必须大于6个字符，不然重复密码不能输入</li><li>重复密码输入必须和密码一样，不然注册按钮不能点击</li><li>根据输入的字符是否合法,按钮动态的改变颜色</li></ul></li><li>2.UITableView和搜索SertchBar的应用<ul><li>searchBar根据输入的字体展示包含该字体的cell列表</li><li><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>实现tableView列表展示</li></ul></li><li>3.<a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>+<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>实现网络请求<ul><li>应用<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>在UICollectionView中的应用</li><li>用<a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>进行网络请求</li><li><a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a>进行json到model的数据解析</li><li>整个<a href="https://github.com/coderQuanjun/RxSwift-Table-Collection" target="_blank" rel="noopener">Demo</a>的架构使用<a href="http://www.codertian.com/2015/11/13/MVVM-patterns-introduce/" target="_blank" rel="noopener">MVVM</a></li></ul></li></ul><h2 id="二-Demo地址"><a href="#二-Demo地址" class="headerlink" title="二. Demo地址"></a>二. <a href="https://github.com/coderQuanjun/RxSwift-Table-Collection" target="_blank" rel="noopener">Demo地址</a></h2><h3 id="下面简单看一下demo的界面"><a href="#下面简单看一下demo的界面" class="headerlink" title="下面简单看一下demo的界面"></a>下面简单看一下demo的界面</h3><h4 id="1-登录注册"><a href="#1-登录注册" class="headerlink" title="1. 登录注册"></a>1. 登录注册</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-6a3971f8ea4a7622.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="登录注册"></p><h4 id="2-UITableView和SearchBar"><a href="#2-UITableView和SearchBar" class="headerlink" title="2. UITableView和SearchBar"></a>2. UITableView和SearchBar</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-e2cff86052a6aa5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="UITableView和SearchBar"></p><h4 id="3-UICollectionView和Moya"><a href="#3-UICollectionView和Moya" class="headerlink" title="3. UICollectionView和Moya"></a>3. UICollectionView和Moya</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-da346221f1ddcba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="UICollectionView和Moya"></p><h2 id="三-项目结构和框架"><a href="#三-项目结构和框架" class="headerlink" title="三. 项目结构和框架"></a>三. 项目结构和框架</h2><h3 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. 结构</h3><p>demo是使用的纯MVVM模式，因为RxSwift就是为MVVM而生。不懂MVVM的猿友可参考<a href="http://www.codertian.com/2015/11/13/MVVM-patterns-introduce/" target="_blank" rel="noopener">MVVM模式快速入门</a> </p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-b180e89ddba220eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="项目结构"></p><h3 id="2-项目框架"><a href="#2-项目框架" class="headerlink" title="2. 项目框架"></a>2. 项目框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Swift三方库</span><br><span class="line">    // Rx</span><br><span class="line">    pod &apos;RxSwift&apos;  //RxSwift的必备库</span><br><span class="line">    pod &apos;RxCocoa&apos;  //对 UIKit Foundation 进行 Rx 化</span><br><span class="line">    pod &apos;RxDataSources&apos;   // 帮助我们优雅的使用tableView的数据源方法</span><br><span class="line"></span><br><span class="line">    // 网络请求</span><br><span class="line">    pod &apos;Moya/RxSwift&apos;  // 为RxSwift专用提供，对Alamofire进行封装的一个网络请求库</span><br><span class="line"></span><br><span class="line">    // 图片处理</span><br><span class="line">    pod &apos;Kingfisher&apos;  //图片处理库</span><br><span class="line"></span><br><span class="line">    // 数据解析</span><br><span class="line">    pod &apos;ObjectMapper&apos;  //json转模型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">// OC库</span><br><span class="line">    // MJRefresh</span><br><span class="line">    pod &apos;MJRefresh&apos;   //MJ上拉下拉刷新</span><br><span class="line">    pod &apos;SVProgressHUD&apos;  //HUD</span><br></pre></td></tr></table></figure><h2 id="四-注册界面"><a href="#四-注册界面" class="headerlink" title="四. 注册界面"></a>四. 注册界面</h2><ul><li>这里主要使用了Observable的相关知识,不了解的童鞋可参考<a href="http://www.jianshu.com/p/319db438c4d3" target="_blank" rel="noopener">RxSwift的使用详解01</a>,了解Observable的操作</li><li>注册和登录并没有保存已注册的账号和密码, 故登录功能并不完善,后期会在完善,望知晓</li><li>下面将针对注册用户名做简单介绍:</li></ul><h3 id="1-首先在model里处理输入字符串的语法法则和字符个数是否符合规范"><a href="#1-首先在model里处理输入字符串的语法法则和字符个数是否符合规范" class="headerlink" title="1. 首先在model里处理输入字符串的语法法则和字符个数是否符合规范"></a>1. 首先在model里处理输入字符串的语法法则和字符个数是否符合规范</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">extension InputValidator &#123;</span><br><span class="line">    <span class="comment">//判断字符串是否符合语法法则</span></span><br><span class="line">    <span class="keyword">class</span> func isValidEmail(_ email: String) -&gt; Bool &#123;</span><br><span class="line">        let regular = try? <span class="built_in">NSRegularExpression</span>(pattern: <span class="string">"^\\S+@\\S+\\.\\S+$"</span>, options: [])</span><br><span class="line">        <span class="keyword">if</span> let re = regular &#123;</span><br><span class="line">            let range = <span class="built_in">NSRange</span>(location: <span class="number">0</span>, length: email.lengthOfBytes(using: .utf8))</span><br><span class="line">            let result = re.matches(<span class="keyword">in</span>: email, options: [], range: range)</span><br><span class="line">            <span class="keyword">return</span> result.count &gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断密码字符个数&gt;8</span></span><br><span class="line">    <span class="keyword">class</span> func isValidPassword(_ password: String) -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> password.characters.count &gt;= <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断用户名</span></span><br><span class="line">    <span class="keyword">class</span> func validateUserName(_ username: String) -&gt; Result &#123;</span><br><span class="line">        <span class="comment">//判断字符个数是否正确</span></span><br><span class="line">        <span class="keyword">if</span> username.characters.count &lt; <span class="number">6</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.failure(message: <span class="string">"输入的字符个数不能少于6个字符"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//账号可用</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(message: <span class="string">"账号可用"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中Result是一个返回是否成功的枚举值,可传入字符串变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Result &#123;</span><br><span class="line">    case success(message: String)</span><br><span class="line">    case failure(message: String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-根据输入的用户名判断该用户名是否可用"><a href="#2-根据输入的用户名判断该用户名是否可用" class="headerlink" title="2. 根据输入的用户名判断该用户名是否可用"></a>2. 根据输入的用户名判断该用户名是否可用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var usernameObserable: Observable&lt;Result&gt;</span><br><span class="line">var passwordObserable: Observable&lt;Result&gt;</span><br><span class="line">var repeatPassObserable: Observable&lt;Result&gt;</span><br><span class="line">var registerBtnObserable: Observable&lt;Bool&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init()&#123;</span><br><span class="line">    <span class="comment">//检测账号</span></span><br><span class="line">    usernameObserable = username.asObservable().map(&#123; (username) -&gt; Result <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> InputValidator.validateUserName(username)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该返回参数Result,控制器将根据该Result是否成功来改变输入框是否是可编辑状态</li><li>初始化方法中，我们对传入的序列进行处理和转换成相对应的Result序列</li></ul><h3 id="3-controller逻辑-根据用户名输入改变各控件状态"><a href="#3-controller逻辑-根据用户名输入改变各控件状态" class="headerlink" title="3. controller逻辑,根据用户名输入改变各控件状态"></a>3. controller逻辑,根据用户名输入改变各控件状态</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 账号判断逻辑</span></span><br><span class="line">        <span class="comment">//1-1. 检测账号</span></span><br><span class="line">        usernameTextField.rx.text</span><br><span class="line">            .orEmpty <span class="comment">// 将String? 类型转为String型</span></span><br><span class="line">            .bindTo(registerVM.username)</span><br><span class="line">            .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1-2. 根据账号监听提示字体的状态</span></span><br><span class="line">        registerVM.usernameObserable</span><br><span class="line">            .bindTo(usernameHintLabel.rx.validationResult)</span><br><span class="line">            .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1-3. 根据账号监听密码输入框的状态</span></span><br><span class="line">        registerVM.usernameObserable</span><br><span class="line">            .bindTo(passwordTextField.rx.enableResult)</span><br><span class="line">            .addDisposableTo(bag)</span><br></pre></td></tr></table></figure><ul><li>检测输入用户名是否符合规范</li><li>根据账号监听提示字体的状态</li><li>根据账号监听密码输入框的状态</li><li>根据账号监听注册按钮的状态</li></ul><h2 id="五-UITableView和SearchBar"><a href="#五-UITableView和SearchBar" class="headerlink" title="五. UITableView和SearchBar"></a>五. UITableView和SearchBar</h2><ul><li>该UITableView展示界面并未涉及网络请求</li><li>数据来源plist文件</li><li>图片为本地图片,可下载demo,在demo中查找图片</li><li>选用自定义UITableViewCell,故cell不做介绍</li><li>model小编这里也不多做介绍,详情可下载demo看具体代码</li></ul><h3 id="1-viewModel中的代码逻辑"><a href="#1-viewModel中的代码逻辑" class="headerlink" title="1. viewModel中的代码逻辑"></a>1. viewModel中的代码逻辑</h3><h4 id="1-1-读取plist文件-获取模型数组"><a href="#1-1-读取plist文件-获取模型数组" class="headerlink" title="1-1. 读取plist文件,获取模型数组"></a>1-1. 读取plist文件,获取模型数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func getHeroData() -&gt; [HeroModel]&#123;</span><br><span class="line">    // 1.获取路径</span><br><span class="line">    let path = Bundle.main.path(forResource: &quot;heros.plist&quot;, ofType: nil)!</span><br><span class="line">        </span><br><span class="line">    // 2.读取文件内容</span><br><span class="line">    let dictArray = NSArray(contentsOfFile: path) as! [[String : Any]]</span><br><span class="line">        </span><br><span class="line">    // 3.遍历所有的字典并且转成模型对象</span><br><span class="line">    return dictArray.map(&#123; HeroModel(dict: $0) &#125;).reversed()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-seachBar"><a href="#1-2-seachBar" class="headerlink" title="1-2. seachBar"></a>1-2. seachBar</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lazy var heroVariable: Variable&lt;[HeroModel]&gt; = &#123;</span><br><span class="line">    <span class="keyword">return</span> Variable(<span class="keyword">self</span>.getHeroData())</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">var searchText: Observable&lt;String&gt;</span><br><span class="line">init(searchText: Observable&lt;String&gt;) &#123;</span><br><span class="line">    <span class="keyword">self</span>.searchText = searchText</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.searchText.subscribe(onNext: &#123; (str: String) <span class="keyword">in</span></span><br><span class="line">        let heros = <span class="keyword">self</span>.getHeroData().filter(&#123; (hero: HeroModel) -&gt; Bool <span class="keyword">in</span></span><br><span class="line">            <span class="comment">//过滤</span></span><br><span class="line">            <span class="keyword">if</span> str.isEmpty &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">            <span class="comment">//model是否包含搜索字符串</span></span><br><span class="line">            <span class="keyword">return</span> hero.name.contains(str)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">self</span>.heroVariable.value = heros</span><br><span class="line">    &#125;).addDisposableTo(bag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中heroVariable是一个数组模型的包装箱,在controller内调用使用前需要asObservable或者asDriver解包装;详细用法可参考:<a href="http://www.jianshu.com/p/319db438c4d3" target="_blank" rel="noopener">RxSwift的使用详解01</a></li><li>searchText搜索框输入的关键字,根据该关键字从数组中过滤出所有包含该关键字的model</li><li>对heroVariable重新赋值,发出事件</li></ul><h3 id="1-3-RxTableViewController-swift主要代码"><a href="#1-3-RxTableViewController-swift主要代码" class="headerlink" title="1-3. RxTableViewController.swift主要代码"></a>1-3. RxTableViewController.swift主要代码</h3><h4 id="1-3-1-searchBar搜索框-输入字符后间隔0-5秒开始搜索"><a href="#1-3-1-searchBar搜索框-输入字符后间隔0-5秒开始搜索" class="headerlink" title="1-3-1.  searchBar搜索框,输入字符后间隔0.5秒开始搜索"></a>1-3-1.  searchBar搜索框,输入字符后间隔0.5秒开始搜索</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var searchText: Observable&lt;String&gt; &#123;</span><br><span class="line">    //输入后间隔0.5秒搜索,在主线程运行</span><br><span class="line">    return searchBar.rx.text.orEmpty.throttle(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-UITableView的设置"><a href="#1-3-2-UITableView的设置" class="headerlink" title="1-3-2.  UITableView的设置"></a>1-3-2.  UITableView的设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//2.给tableView绑定数据</span><br><span class="line">//注意: 三个参数:row, model, cell三个顺序不可以搞错, 不需要的可省略 </span><br><span class="line">heroVM.heroVariable.asDriver().drive(rxTableView.rx.items(cellIdentifier: kCellID, cellType: RxTableViewCell.self)) &#123; (_, hero, cell) in</span><br><span class="line">    cell.heroModel = hero</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line">// 3.监听UITableView的点击</span><br><span class="line">rxTableView.rx.modelSelected(HeroModel.self).subscribe &#123; (event: Event&lt;HeroModel&gt;) in</span><br><span class="line">    print(event.element?.name ?? &quot;&quot;)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure><ul><li>将viewModel中的heroVariable进行解包装，如果是Driver序列，我们这里不使用bingTo，而是使用的Driver，用法和bingTo一模一样。</li><li>Deriver的监听一定发生在主线程，所以很适合我们更新UI的操作</li><li>如需设置delegate的代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rxTableView.rx.setDelegate(self).addDisposableTo(bag)</span><br></pre></td></tr></table></figure><blockquote><p>然后在实现相应的代理方法即可,如: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension RxTableViewController: UITableViewDelegate&#123;</span><br><span class="line">    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;</span><br><span class="line">        return 100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六-UICollectionView-Moya-ObjectMapper网络请求和数据处理"><a href="#六-UICollectionView-Moya-ObjectMapper网络请求和数据处理" class="headerlink" title="六. UICollectionView+Moya+ObjectMapper网络请求和数据处理"></a>六. UICollectionView+Moya+ObjectMapper网络请求和数据处理</h2><ul><li>与上述UITableView不同的是,这部分将以<a href="https://github.com/RxSwiftCommunity/RxDataSources" target="_blank" rel="noopener">RxDataSources</a>处理数据源</li><li>model数组以sections组集合处理</li><li>结合<a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>进行网络请求</li><li>使用<a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a>进行json数据转模型</li></ul><h3 id="1-配合ObjectMapper"><a href="#1-配合ObjectMapper" class="headerlink" title="1. 配合ObjectMapper"></a>1. 配合ObjectMapper</h3><p><strong>这里再介绍一下ObjectMapper</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class AnchorModel: Mappable &#123;</span><br><span class="line"></span><br><span class="line">    var name = &quot;&quot;    //名字</span><br><span class="line">    var pic51 = &quot;&quot;   //头像</span><br><span class="line">    var pic74 = &quot;&quot;   //大图</span><br><span class="line">    var live = 0</span><br><span class="line">    var push = 0</span><br><span class="line">    var focus = 0    //关注量</span><br><span class="line">    </span><br><span class="line">    required init?(map: Map) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func mapping(map: Map) &#123;</span><br><span class="line">        name  &lt;- map[&quot;name&quot;]</span><br><span class="line">        pic51 &lt;- map[&quot;pic51&quot;]</span><br><span class="line">        pic74 &lt;- map[&quot;pic74&quot;]</span><br><span class="line">        live  &lt;- map[&quot;live&quot;]</span><br><span class="line">        push  &lt;- map[&quot;push&quot;]</span><br><span class="line">        focus &lt;- map[&quot;focus&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 ObjectMapper ，需要让自己的 Model 类使用 Mappable 协议，这个协议包括两个方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">required init?(map: Map) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">func mapping(map: Map) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>在 mapping 方法中，用 <code>&lt;-</code> 操作符来处理和映射你的 JSON数据</li><li>详细的 ObjectMapper 教程可以查看它的 <a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">Github 主页</a>，我在这里只做简单的介绍。</li></ul><h3 id="2-Moya的使用"><a href="#2-Moya的使用" class="headerlink" title="2. Moya的使用"></a>2. Moya的使用</h3><ul><li><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>是基于<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>的网络请求库，这里我使用了Moya/Swift，它在Moya的基础上添加了对RxSwift的接口支持。</li><li>Github上的官方介绍罗列了Moya的一些特点：<ul><li>编译时检查正确的API端点访问.   </li><li>使你定义不同端点枚举值对应相应的用途更加明晰. </li><li>提高测试地位从而使单元测试更加容易.</li></ul></li><li>接下来我们来说下Moya的使用</li></ul><h4 id="2-1-创建一个枚举API"><a href="#2-1-创建一个枚举API" class="headerlink" title="2-1. 创建一个枚举API"></a>2-1. 创建一个枚举API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//请求枚举类型</span><br><span class="line">enum JunNetworkTool &#123;</span><br><span class="line">    </span><br><span class="line">    case getNewList</span><br><span class="line">    case getHomeList(page: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-为枚举添加扩展"><a href="#2-2-为枚举添加扩展" class="headerlink" title="2-2. 为枚举添加扩展"></a>2-2. 为枚举添加扩展</h4><ul><li>需遵循协议 TargetType</li><li>这个协议的Moya这个库规定的协议，可以单击进入相应的文件进行查看</li><li>这个协议内的每一个参数(除了<code>validate</code>可不重写)都必须重写,否则会报错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//请求参数</span><br><span class="line">extension JunNetworkTool: TargetType &#123;</span><br><span class="line">    </span><br><span class="line">    //统一基本的url</span><br><span class="line">    var baseURL: URL &#123;</span><br><span class="line">        return (URL(string: &quot;http://qf.56.com/home/v4/moreAnchor.ios&quot;))!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //path字段会追加至baseURL后面</span><br><span class="line">    var path: String &#123;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //请求的方式</span><br><span class="line">    var method: Moya.Method &#123;</span><br><span class="line">        return .get</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //参数编码方式(这里使用URL的默认方式)</span><br><span class="line">    var parameterEncoding: ParameterEncoding &#123;</span><br><span class="line">        return URLEncoding.default</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //用于单元测试</span><br><span class="line">    var sampleData: Data &#123;</span><br><span class="line">        return &quot;getList&quot;.data(using: .utf8)!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将要被执行的任务(请求：request 下载：upload 上传：download)</span><br><span class="line">    var task: Task &#123;</span><br><span class="line">        return .request</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //请求参数(会在请求时进行编码)</span><br><span class="line">    var parameters: [String: Any]? &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .getHomeList(let index):</span><br><span class="line">            return [&quot;index&quot;: index]</span><br><span class="line">        default:</span><br><span class="line">            return [&quot;index&quot;: 1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //是否执行Alamofire验证，默认值为false</span><br><span class="line">    var validate: Bool &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-定义一个全局变量用于整个项目的网络请求"><a href="#2-3-定义一个全局变量用于整个项目的网络请求" class="headerlink" title="2-3. 定义一个全局变量用于整个项目的网络请求"></a>2-3. 定义一个全局变量用于整个项目的网络请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let junNetworkTool = RxMoyaProvider&lt;JunNetworkTool&gt;()</span><br></pre></td></tr></table></figure><p>至此，我们就可以使用这个全局变量来请求数据了</p><h3 id="3-RxDataSources"><a href="#3-RxDataSources" class="headerlink" title="3. RxDataSources"></a>3. <a href="https://github.com/RxSwiftCommunity/RxDataSources" target="_blank" rel="noopener">RxDataSources</a></h3><ul><li>RxDataSources是以section来做为数据结构来传输，这点很重要，比如:在传统的数据源实现的方法中有一个numberOfSection，我们在很多情况下只需要一个section，所以这个方法可实现，也可以不实现，默认返回的就是1，这给我们带来的一个迷惑点：【tableView是由row来组成的】，不知道在坐的各位中有没有是这么想的呢？？有的话那从今天开始就要认清楚这一点，【tableView其实是由section组成的】，所以在使用RxDataSources的过程中，即使你的setion只有一个，那你也得返回一个section的数组出去！！！</li><li>传统方式适用于简单的数据集，但不处理需要将复杂数据集与多个部分进行绑定的情况，或者在添加/修改/删除项目时需要执行动画时。而使用RxDataSources时，它很容易写</li><li>想了解更多关于<a href="https://github.com/RxSwiftCommunity/RxDataSources" target="_blank" rel="noopener">RxDataSources</a>的用法,请参考其GitHub主页</li></ul><h4 id="3-1-Sections自定义"><a href="#3-1-Sections自定义" class="headerlink" title="3-1. Sections自定义"></a>3-1. Sections自定义</h4><ul><li>在我们自定义的Model中创建一个AnchorSection的结构体</li><li>并遵循SectionModelType协议，实现相应的协议方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: SectionModel</span></span><br><span class="line"><span class="keyword">struct</span> AnchorSection &#123;</span><br><span class="line">    <span class="comment">// items就是rows</span></span><br><span class="line">    var items: [Item]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 你也可以这里加你需要的东西，比如 headerView 的 title</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension AnchorSection: SectionModelType &#123;</span><br><span class="line">    <span class="comment">// 重定义 Item 的类型为</span></span><br><span class="line">    typealias Item = AnchorModel</span><br><span class="line">    init(original: AnchorSection, items: [AnchorSection.Item]) &#123;</span><br><span class="line">        <span class="keyword">self</span> = original</span><br><span class="line">        <span class="keyword">self</span>.items = items</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-ViewModel"><a href="#4-ViewModel" class="headerlink" title="4. ViewModel"></a>4. ViewModel</h3><h4 id="4-1-自定义协议BaseViewModel"><a href="#4-1-自定义协议BaseViewModel" class="headerlink" title="4-1. 自定义协议BaseViewModel"></a>4-1. 自定义协议BaseViewModel</h4><p>我们知道MVVM思想就是将原本在ViewController的视图显示逻辑、验证逻辑、网络请求等代码存放于ViewModel中，让我们的ViewController瘦身。这些逻辑由ViewModel负责，外界不需要关心，外界只需要结果，ViewModel也只需要将结果给到外界，基于此，我们定义了一个协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protocol JunViewModelType &#123;</span><br><span class="line">    //associatedtype: 关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定</span><br><span class="line">    associatedtype Input</span><br><span class="line">    associatedtype Output</span><br><span class="line">    </span><br><span class="line">    //我们通过 transform 方法将input携带的数据进行处理，生成了一个Output</span><br><span class="line">    func transform(input: Input) -&gt; Output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-自定义用于网络请求的刷新状态"><a href="#4-2-自定义用于网络请求的刷新状态" class="headerlink" title="4-2. 自定义用于网络请求的刷新状态"></a>4-2. 自定义用于网络请求的刷新状态</h4><ul><li>根据枚举值的判断,改变collection的刷新状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//刷新的状态</span><br><span class="line">enum JunRefreshStatus &#123;</span><br><span class="line">    case none</span><br><span class="line">    case beingHeaderRefresh</span><br><span class="line">    case endHeaderRefresh</span><br><span class="line">    case beingFooterRefresh</span><br><span class="line">    case endFooterRefresh</span><br><span class="line">    case noMoreData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-3-自定义用于继承的BaseViewModel"><a href="#4-3-自定义用于继承的BaseViewModel" class="headerlink" title="4-3. 自定义用于继承的BaseViewModel"></a>4-3. 自定义用于继承的BaseViewModel</h4><ul><li>定义请求数据的页数index</li><li>定义input和output的结构体</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BaseViewModel: <span class="built_in">NSObject</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前的索引值</span></span><br><span class="line">    var index: Int = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> JunInput &#123;</span><br><span class="line">        <span class="comment">// 网络请求类型</span></span><br><span class="line">        let category: JunNetworkTool</span><br><span class="line">        </span><br><span class="line">        init(category: JunNetworkTool) &#123;</span><br><span class="line">            <span class="keyword">self</span>.category = category</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> JunOutput &#123;</span><br><span class="line">        <span class="comment">// tableView的sections数据</span></span><br><span class="line">        let sections: Driver&lt;[AnchorSection]&gt;</span><br><span class="line">        <span class="comment">// 外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载）</span></span><br><span class="line">        let requestCommond = PublishSubject&lt;Bool&gt;()</span><br><span class="line">        <span class="comment">// 告诉外界的tableView当前的刷新状态</span></span><br><span class="line">        let refreshStatus = Variable&lt;JunRefreshStatus&gt;(.none)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化时,section的数据</span></span><br><span class="line">        init(sections: Driver&lt;[AnchorSection]&gt;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sections = sections</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-自定义AnchorViewModel"><a href="#4-4-自定义AnchorViewModel" class="headerlink" title="4-4. 自定义AnchorViewModel"></a>4-4. 自定义AnchorViewModel</h4><ul><li>1) 继承BaseViewModel</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class AnchorViewModel : BaseViewModel&#123;</span><br><span class="line">    // 存放着解析完成的模型数组</span><br><span class="line">    let anchorArr = Variable&lt;[AnchorModel]&gt;([])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2) 遵循JunViewModelType协议</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">extension AnchorViewModel: JunViewModelType &#123;</span><br><span class="line">    typealias Input = JunInput</span><br><span class="line">    typealias Output = JunOutput</span><br><span class="line"></span><br><span class="line">    func transform(input: AnchorViewModel.JunInput) -&gt; AnchorViewModel.JunOutput &#123;</span><br><span class="line">        let sectionArr = anchorArr.asDriver().map &#123; (models) -&gt; [AnchorSection] in</span><br><span class="line">            // 当models的值被改变时会调用</span><br><span class="line">            return [AnchorSection(items: models)]</span><br><span class="line">        &#125;.asDriver(onErrorJustReturn: [])</span><br><span class="line">        </span><br><span class="line">        let output = JunOutput(sections: sectionArr)</span><br><span class="line">        </span><br><span class="line">        output.requestCommond.subscribe(onNext: &#123; (isReloadData) in</span><br><span class="line">            self.index = isReloadData ? 1 : self.index + 1</span><br><span class="line">            //开始请求数据</span><br><span class="line">            junNetworkTool.request(JunNetworkTool.getHomeList(page: self.index))</span><br><span class="line">                .mapObjectArray(AnchorModel.self)</span><br><span class="line">                .subscribe(&#123; (event) in</span><br><span class="line">                    switch event &#123;</span><br><span class="line">                    case let .next(modelArr):</span><br><span class="line">                        self.anchorArr.value = isReloadData ? modelArr : (self.anchorArr.value) + modelArr</span><br><span class="line">                        SVProgressHUD.showSuccess(withStatus: &quot;加载成功&quot;)</span><br><span class="line">                    case let .error(error):</span><br><span class="line">                        SVProgressHUD.showError(withStatus: error.localizedDescription)</span><br><span class="line">                    case .completed:</span><br><span class="line">                        output.refreshStatus.value = isReloadData ? .endHeaderRefresh : .endFooterRefresh</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;).addDisposableTo(bag)</span><br><span class="line">        &#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        return output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sectionArr是将model数组按照section分别存储</li><li>当请求回来的anchorArr数据改变的时候, sectionArr随之会发生改变</li><li>isReloadData用于区分是下拉刷新(true时), 还是上拉加载更多(false时)</li></ul><h3 id="5-RxCollectionViewController控制器中"><a href="#5-RxCollectionViewController控制器中" class="headerlink" title="5. RxCollectionViewController控制器中"></a>5. RxCollectionViewController控制器中</h3><ul><li>创建数据源RxDataSources</li><li>绑定cell</li><li>初始化input和output请求</li><li>绑定section数据</li><li>设置刷新</li></ul><h4 id="5-1-创建数据源RxDataSources"><a href="#5-1-创建数据源RxDataSources" class="headerlink" title="5-1. 创建数据源RxDataSources"></a>5-1. 创建数据源RxDataSources</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个数据源属性，类型为自定义的Section类型</span><br><span class="line">let dataSource = RxCollectionViewSectionedReloadDataSource&lt;AnchorSection&gt;()</span><br></pre></td></tr></table></figure><h4 id="5-2-绑定cell-自定义的cell要提前注册"><a href="#5-2-绑定cell-自定义的cell要提前注册" class="headerlink" title="5-2. 绑定cell(自定义的cell要提前注册)"></a>5-2. 绑定cell(自定义的cell要提前注册)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataSource.configureCell = &#123; dataSource, collectionView, indexPath, item in</span><br><span class="line">    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: kCollecCellID, for: indexPath) as! RxCollectionViewCell</span><br><span class="line">    cell.anchorModel = item</span><br><span class="line">    return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上四个参数的顺序分别为:dataSource, collectionView(或者tableView), indexPath, model, 其对应类型不言而喻,不多做介绍</li></ul><h4 id="5-3-初始化input和output请求"><a href="#5-3-初始化input和output请求" class="headerlink" title="5-3. 初始化input和output请求"></a>5-3. 初始化input和output请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let vmInput = AnchorViewModel.JunInput(category: .getNewList)</span><br><span class="line">let vmOutput = anchorVM.transform(input: vmInput)</span><br></pre></td></tr></table></figure><h4 id="5-4-绑定section数据"><a href="#5-4-绑定section数据" class="headerlink" title="5-4. 绑定section数据"></a>5-4. 绑定section数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//4-1. 通过dataSource和section的model数组绑定数据(demo的用法, 推荐)</span><br><span class="line">vmOutput.sections</span><br><span class="line">    .asDriver()</span><br><span class="line">    .drive(collectionVIew.rx.items(dataSource: dataSource))</span><br><span class="line">    .addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h4 id="5-5-设置刷新"><a href="#5-5-设置刷新" class="headerlink" title="5-5. 设置刷新"></a>5-5. 设置刷新</h4><h4 id="5-5-0-在controller中初始化刷新状态"><a href="#5-5-0-在controller中初始化刷新状态" class="headerlink" title="5-5-0. 在controller中初始化刷新状态"></a>5-5-0. 在controller中初始化刷新状态</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">collectionVIew.mj_header = MJRefreshNormalHeader(refreshingBlock: &#123;</span><br><span class="line">    vmOutput.requestCommond.onNext(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line">collectionVIew.mj_header.beginRefreshing()</span><br><span class="line">        </span><br><span class="line">collectionVIew.mj_footer = MJRefreshAutoNormalFooter(refreshingBlock: &#123;</span><br><span class="line">    vmOutput.requestCommond.onNext(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="5-5-1-添加刷新的序列"><a href="#5-5-1-添加刷新的序列" class="headerlink" title="5-5-1. 添加刷新的序列"></a>5-5-1. 添加刷新的序列</h4><ul><li>在JunOutput的结构体中添加刷新序列</li><li>我们在进行网络请求并得到结果之后，修改refreshStatus的value为相应的JunRefreshStatus项</li><li>MJRefre遍会根据该状态做出相应的刷新事件</li><li>默认状态为none<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 告诉外界的tableView当前的刷新状态</span><br><span class="line">let refreshStatus = Variable&lt;JunRefreshStatus&gt;(.none)</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-5-2-外界订阅output的refreshStatus"><a href="#5-5-2-外界订阅output的refreshStatus" class="headerlink" title="5-5-2. 外界订阅output的refreshStatus"></a>5-5-2. 外界订阅output的refreshStatus</h4><ul><li>外界订阅output的refreshStatus，并且根据接收到的值进行相应的操作</li><li>refreshStatus每次改变都会触发刷新事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5. 设置刷新状态</span></span><br><span class="line">vmOutput.refreshStatus.asObservable().subscribe(onNext: &#123; (status) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> status &#123;</span><br><span class="line">    <span class="keyword">case</span> .beingHeaderRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_header.beginRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .endHeaderRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_header.endRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .beingFooterRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_footer.beginRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .endFooterRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_footer.endRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .noMoreData:                   </span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_footer.endRefreshingWithNoMoreData()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h4 id="5-5-3-output提供一个requestCommond用于控制是否请求数据"><a href="#5-5-3-output提供一个requestCommond用于控制是否请求数据" class="headerlink" title="5-5-3. output提供一个requestCommond用于控制是否请求数据"></a>5-5-3. output提供一个requestCommond用于控制是否请求数据</h4><ul><li>PublishSubject 的特点：即可以作为Observable，也可以作为Observer，说白了就是可以发送信号，也可以订阅信号</li><li>当你订阅PublishSubject的时候，你只能接收到订阅他之后发生的事件。subject.onNext()发出onNext事件，对应的还有onError()和onCompleted()事件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载）</span><br><span class="line">let requestCommond = PublishSubject&lt;Bool&gt;()</span><br></pre></td></tr></table></figure><h2 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h2><ul><li>为了研究RxSwift相关知识, 工作之余的时间,差不多一个月了</li><li>学习的瓶颈大部分在于网络请求和配合刷新这一模块</li><li>文中如出现self循环引用的问题,还望大神多多指正</li><li>小编目前也还在初学阶段,文中如出现小错误还望多多指正,如有更好的方法,也希望不吝分享</li><li>如果喜欢,可以收藏,也可以在Github上star一下</li></ul><h3 id="最后再一次附上Demo地址"><a href="#最后再一次附上Demo地址" class="headerlink" title="最后再一次附上Demo地址"></a>最后再一次附上<a href="https://github.com/coderQuanjun/RxSwift-Table-Collection" target="_blank" rel="noopener">Demo地址</a></h3><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h4><ul><li><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a></li><li><a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a></li><li><a href="https://github.com/RxSwiftCommunity/RxDataSources" target="_blank" rel="noopener">RxDataSources</a></li><li><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener">Kingfisher</a></li><li><a href="http://www.jianshu.com/p/319db438c4d3" target="_blank" rel="noopener">RxSwift的使用详解01</a></li><li><a href="http://www.jianshu.com/p/bcd0dc328308" target="_blank" rel="noopener">RxSwift的使用详解02</a></li><li><a href="https://www.2cto.com/kf/201703/611678.html" target="_blank" rel="noopener">moya + RxSwift 进行网络请求</a></li><li><a href="http://www.jianshu.com/p/9d536d3a1740" target="_blank" rel="noopener">扒一扒swift中的unowned和weak下</a></li><li><a href="http://mp.weixin.qq.com/s/B-AdatKDkjknKCYorqSfEw" target="_blank" rel="noopener">iOS - RxSwift -项目实战记录</a></li></ul>]]></content>
      
      <categories>
          
          <category> RxSwift框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
            <tag> 响应式编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift的使用详解02</title>
      <link href="/2017/09/21/RxSwift%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A302"/>
      <content type="html"><![CDATA[<h1 id="一-RxSwift简介"><a href="#一-RxSwift简介" class="headerlink" title="一. RxSwift简介"></a>一. RxSwift简介</h1><blockquote><ul><li><h4 id="推荐-RxSwift官方文档"><a href="#推荐-RxSwift官方文档" class="headerlink" title="推荐: RxSwift官方文档"></a>推荐: <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift官方文档</a></h4></li><li><h4 id="中文-RxSwift官方文档的中文翻译"><a href="#中文-RxSwift官方文档的中文翻译" class="headerlink" title="中文: RxSwift官方文档的中文翻译"></a>中文: <a href="https://github.com/jhw-dev/RxSwift-CN" target="_blank" rel="noopener">RxSwift官方文档的中文翻译</a></h4></li><li><h4 id="上一篇-RxSwift的使用详解01"><a href="#上一篇-RxSwift的使用详解01" class="headerlink" title="上一篇: RxSwift的使用详解01"></a>上一篇: <a href="http://www.jianshu.com/p/319db438c4d3" target="_blank" rel="noopener">RxSwift的使用详解01</a></h4></li></ul></blockquote><h3 id="上一篇主要讲了"><a href="#上一篇主要讲了" class="headerlink" title="上一篇主要讲了"></a>上一篇主要讲了</h3><ul><li>RxSwift简介</li><li>RxSwift简单体验(在控件中的简单使用)</li><li>RxSwift常见操作(never, just, of, empty, creat等10个sequence的使用)</li><li>RxSwift中Subjects</li><li>变换操作(map, flatMap等)和资源释放DisposeBag</li><li>UIBindingObserver创建自己的监听者</li></ul><h3 id="本文主要内容"><a href="#本文主要内容" class="headerlink" title="本文主要内容"></a>本文主要内容</h3><ul><li>联合操作: 把多个Observable流合成单个Observable流</li><li>elementAt, single, skip等过滤和约束操作</li><li>toArray, reduce, concat等数学操作</li></ul><h1 id="一-联合操作"><a href="#一-联合操作" class="headerlink" title="一. 联合操作"></a>一. 联合操作</h1><ul><li>联合操作就是把多个Observable流合成单个Observable流</li></ul><h2 id="1-startWith"><a href="#1-startWith" class="headerlink" title="1. startWith"></a>1. startWith</h2><ul><li>在发出事件消息之前，先发出某个特定的事件消息。</li><li>比如发出事件2 ，3然后我startWith(1)，那么就会先发出1，然后2 ，3.</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未添加startWith</span></span><br><span class="line">Observable.of(<span class="string">"2"</span>, <span class="string">"3"</span>).subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序:</span></span><br><span class="line"><span class="comment">        next(2)</span></span><br><span class="line"><span class="comment">        next(3)</span></span><br><span class="line"><span class="comment">        completed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用startWith</span></span><br><span class="line">Observable.of(<span class="string">"2"</span>, <span class="string">"3"</span>).startWith(<span class="string">"1"</span>).subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序:</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         next(3)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">```        </span><br><span class="line"><span class="meta">## 2. merge</span></span><br><span class="line">- 合并两个Observable流合成单个Observable流，根据时间轴发出对应的事件</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.of(subject1, subject2)</span><br><span class="line">    .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"-------------------------"</span>)</span><br><span class="line"></span><br><span class="line">Observable.of(subject1, subject2)</span><br><span class="line">    .merge()</span><br><span class="line">    .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">subject1.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"jun"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"ya"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"jie"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"tian"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"guo"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         next(quan)</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         next(ya)</span></span><br><span class="line"><span class="comment">         next(jie)</span></span><br><span class="line"><span class="comment">         next(tian)</span></span><br><span class="line"><span class="comment">         next(guo)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="3-zip"><a href="#3-zip" class="headerlink" title="3. zip"></a>3. zip</h2><ul><li>绑定超过最多不超过8个的Observable流，结合在一起处理。</li><li>注意Zip是一个事件对应另一个流一个事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">let subject3 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject4 = PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.zip(subject3, subject4) &#123; (sub3, sub4) -&gt; String <span class="keyword">in</span></span><br><span class="line">        sub3 + <span class="string">"+"</span> + sub4</span><br><span class="line">    &#125;.subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">subject3.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject3.onNext(<span class="string">"jun"</span>)</span><br><span class="line">subject4.onNext(<span class="string">"ya"</span>)</span><br><span class="line">subject4.onNext(<span class="string">"jie"</span>)</span><br><span class="line">subject3.onNext(<span class="string">"tian"</span>)</span><br><span class="line">subject4.onNext(<span class="string">"guo"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         将subject3和subject4压缩到一起共同处理</span></span><br><span class="line"><span class="comment">         next(quan+ya)</span></span><br><span class="line"><span class="comment">         next(jun+jie)</span></span><br><span class="line"><span class="comment">         next(tian+guo)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">```        </span><br><span class="line">        </span><br><span class="line"><span class="meta">## 4. combineLatest</span></span><br><span class="line">- 绑定超过最多不超过<span class="number">8</span>个的Observable流，结合在一起处理。</span><br><span class="line">- 和Zip不同的是combineLatest是一个流的事件对应另一个流的最新的事件，两个事件都会是最新的事件，可将下图与Zip的图进行对比</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">let subject5 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject6 = PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.combineLatest(subject5, subject6) &#123; (sub5, sub6) -&gt; String <span class="keyword">in</span></span><br><span class="line">        sub5 + <span class="string">"+"</span> + sub6</span><br><span class="line">    &#125;.subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line"></span><br><span class="line">subject5.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject5.onNext(<span class="string">"1"</span>)</span><br><span class="line">subject6.onNext(<span class="string">"ya"</span>)</span><br><span class="line">subject6.onNext(<span class="string">"2"</span>)</span><br><span class="line">subject5.onNext(<span class="string">"--"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         将subject3的最新事件和subject4的最新事件一起处理</span></span><br><span class="line"><span class="comment">         next(1+ya)</span></span><br><span class="line"><span class="comment">         next(1+2)</span></span><br><span class="line"><span class="comment">         next(--+2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">```    </span><br><span class="line">        </span><br><span class="line"><span class="meta">## 5. switchLatest</span></span><br><span class="line">- switchLatest可以对事件流进行转换，本来监听的subject1，我可以通过更改variable里面的value更换事件源。变成监听subject2了</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">let subject7 = BehaviorSubject(value: <span class="string">"love"</span>)</span><br><span class="line"><span class="comment">//BehaviorSubject: 接受订阅之前的最后一个事件</span></span><br><span class="line">let subject8 = BehaviorSubject(value: <span class="string">"love to"</span>)</span><br><span class="line">let variable = Variable(subject7)</span><br><span class="line">variable.asObservable()</span><br><span class="line">        .switchLatest()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">subject7.onNext(<span class="string">"ya"</span>)</span><br><span class="line">subject7.onNext(<span class="string">"jie"</span>)</span><br><span class="line"></span><br><span class="line">variable.value = subject8</span><br><span class="line">subject7.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject8.onNext(<span class="string">"jun"</span>)</span><br><span class="line">        </span><br><span class="line">variable.value = subject7</span><br><span class="line">subject8.onNext(<span class="string">"jie"</span>)</span><br><span class="line">subject7.onNext(<span class="string">"guo"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         next(love)</span></span><br><span class="line"><span class="comment">         next(ya)</span></span><br><span class="line"><span class="comment">         next(jie)</span></span><br><span class="line"><span class="comment">         next(love to)</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         next(quan)</span></span><br><span class="line"><span class="comment">         next(guo)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h1 id="二-过滤和约束"><a href="#二-过滤和约束" class="headerlink" title="二. 过滤和约束"></a>二. 过滤和约束</h1><h2 id="1-1-distinctUntilChanged"><a href="#1-1-distinctUntilChanged" class="headerlink" title="1. 1. distinctUntilChanged"></a>1. 1. distinctUntilChanged</h2><ul><li>distinctUntilChanged就是当: 下一个事件与前一个事件是不同事件的事件才进行处理操作</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        .distinctUntilChanged()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(3)</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="2-elementAt"><a href="#2-elementAt" class="headerlink" title="2. elementAt"></a>2. elementAt</h2><ul><li>只处理在指定位置的事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .elementAt(<span class="number">3</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="3-single"><a href="#3-single" class="headerlink" title="3. single"></a>3. single</h2><ul><li>找出在sequence只发出一次的事件，如果超过一个就会发出error错误</li></ul><h4 id="gt-1-多个信号输出的情况"><a href="#gt-1-多个信号输出的情况" class="headerlink" title="&gt;1 多个信号输出的情况"></a>&gt;1 多个信号输出的情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(1) //单一信号超过了一个,只会输出第一个,然后输出error</span></span><br><span class="line"><span class="comment">         error(Sequence contains more than one element.)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h4 id="gt-2-指定某唯一信号的情况"><a href="#gt-2-指定某唯一信号的情况" class="headerlink" title="&gt;2 指定某唯一信号的情况"></a>&gt;2 指定某唯一信号的情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single(&#123; $<span class="number">0</span> == <span class="number">2</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h4 id="gt-3-指定某不唯一信号的情况"><a href="#gt-3-指定某不唯一信号的情况" class="headerlink" title="&gt;3 指定某不唯一信号的情况"></a>&gt;3 指定某不唯一信号的情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Observable.of(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single(&#123; $<span class="number">0</span> == <span class="number">4</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4) //单一信号超过了一个,只会输出第一个,然后输出error</span></span><br><span class="line"><span class="comment">         error(Sequence contains more than one element.)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h4 id="gt-4-找不到该信号的情况"><a href="#gt-4-找不到该信号的情况" class="headerlink" title="&gt;4 找不到该信号的情况"></a>&gt;4 找不到该信号的情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single(&#123; $<span class="number">0</span> == <span class="number">2</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         没有对应的参数,然后输出error</span></span><br><span class="line"><span class="comment">         error(Sequence doesn't contain any elements.)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="4-filter"><a href="#4-filter" class="headerlink" title="4. filter"></a>4. filter</h2><ul><li>过滤掉某些不符合要求的事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .filter(&#123; $<span class="number">0</span> &gt; <span class="number">3</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="5-take"><a href="#5-take" class="headerlink" title="5. take"></a>5. take</h2><ul><li>只处理前几个事件信号</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="6-takeLast"><a href="#6-takeLast" class="headerlink" title="6. takeLast"></a>6. takeLast</h2><ul><li>只处理后几个事件信号</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .takeLast(<span class="number">2</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="7-takeWhile"><a href="#7-takeWhile" class="headerlink" title="7. takeWhile"></a>7. takeWhile</h2><ul><li>当条件满足的时候进行处理</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .takeWhile(&#123; $<span class="number">0</span> &gt; <span class="number">3</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="8-takeUntil"><a href="#8-takeUntil" class="headerlink" title="8. takeUntil"></a>8. takeUntil</h2><ul><li>接收事件消息，直到另一个sequence发出事件消息的时候.停止接收消息,输出completed</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class="line">subject1.takeUntil(subject2)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">subject1.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"jun"</span>)</span><br><span class="line"></span><br><span class="line">subject2.onNext(<span class="string">"ya"</span>)<span class="comment">//停止接收消息</span></span><br><span class="line">        </span><br><span class="line">subject1.onNext(<span class="string">"tian"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"guo"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(quan)</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="9-skip"><a href="#9-skip" class="headerlink" title="9. skip"></a>9. skip</h2><ul><li>取消前几个事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .skip(<span class="number">3</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="10-skipWhile"><a href="#10-skipWhile" class="headerlink" title="10. skipWhile"></a>10. skipWhile</h2><ul><li>满足条件的事件消息都取消</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .skipWhile(&#123; $<span class="number">0</span> &lt; <span class="number">4</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="11-skipWhileWithIndex"><a href="#11-skipWhileWithIndex" class="headerlink" title="11. skipWhileWithIndex"></a>11. skipWhileWithIndex</h2><ul><li>满足条件的都被取消，传入的闭包同skipWhile有点区别而已</li><li><code>skipWhile</code>的(&lt;4)和<code>skipWhileWithIndex</code>的(&lt;=3)的效果是一样的</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .skipWhileWithIndex(&#123; (element, index) -&gt; Bool <span class="keyword">in</span></span><br><span class="line">            index &lt;= <span class="number">3</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="12-skipUntil"><a href="#12-skipUntil" class="headerlink" title="12. skipUntil"></a>12. skipUntil</h2><ul><li>直到某个sequence发出了事件消息，才开始接收当前sequence发出的事件消息</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let subject3 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject4 = PublishSubject&lt;String&gt;()</span><br><span class="line">subject3.skipUntil(subject4)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">subject3.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject4.onNext(<span class="string">"jun"</span>)</span><br><span class="line">        </span><br><span class="line">subject4.onNext(<span class="string">"ya"</span>)<span class="comment">//开始接收消息</span></span><br><span class="line">        </span><br><span class="line">subject3.onNext(<span class="string">"tian"</span>)</span><br><span class="line">subject4.onNext(<span class="string">"guo"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(tian)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h1 id="三-数学操作"><a href="#三-数学操作" class="headerlink" title="三. 数学操作"></a>三. 数学操作</h1><h2 id="1-toArray"><a href="#1-toArray" class="headerlink" title="1. toArray"></a>1. toArray</h2><ul><li>将sequence转换成一个array，并转换成单一事件信号，然后结束</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(start: <span class="number">1</span>, count: <span class="number">5</span>)</span><br><span class="line">        .toArray()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next([1, 2, 3, 4, 5])</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">```        </span><br><span class="line">        </span><br><span class="line"><span class="meta">## 2. reduce</span></span><br><span class="line">- 用一个初始值，对事件数据进行累计操作。reduce接受一个初始值，和一个操作符号</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">Observable.of(<span class="number">10</span>, <span class="number">12</span>, <span class="number">34</span>)</span><br><span class="line">       .reduce(<span class="number">0</span>, accumulator: +)</span><br><span class="line">       .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">       .addDisposableTo(bag)</span><br><span class="line">       </span><br><span class="line">  <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(56)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">```        </span><br><span class="line">        </span><br><span class="line"><span class="meta">## 3. concat</span></span><br><span class="line">- concat会把多个sequence和并为一个sequence，并且当前面一个sequence发出了completed事件，才会开始下一个sequence的事件。</span><br><span class="line">- 在第一sequence发出onCompleted完成之前，第二个sequence发出的事件都会被忽略</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">let subject1 = BehaviorSubject(value: <span class="string">"quan"</span>)</span><br><span class="line">let subject2 = BehaviorSubject(value: <span class="string">"jun"</span>)</span><br><span class="line">let variable = Variable(subject1)</span><br><span class="line">variable.asObservable()</span><br><span class="line">        .concat()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">subject1.onNext(<span class="string">"ya"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"jie"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"jun"</span>)  <span class="comment">//subject2不被输出</span></span><br><span class="line">        </span><br><span class="line">variable.value = subject2  <span class="comment">//subject1发出onCompleted()之前会继续输出subject1</span></span><br><span class="line">        </span><br><span class="line">subject1.onNext(<span class="string">"guo"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"tian"</span>)</span><br><span class="line">        </span><br><span class="line">subject1.onCompleted()  <span class="comment">//subject1结束,开始输出subject2,此时subject2的值接受最后一个("tian")</span></span><br><span class="line">        </span><br><span class="line">subject2.onNext(<span class="string">"love"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"to love"</span>) <span class="comment">//subject1将不再被输出</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">        next(quan)</span></span><br><span class="line"><span class="comment">        next(ya)</span></span><br><span class="line"><span class="comment">        next(jie)</span></span><br><span class="line"><span class="comment">        next(guo)</span></span><br><span class="line"><span class="comment">        next(tian)</span></span><br><span class="line"><span class="comment">        next(love)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h1 id="四-RxSwift的优点"><a href="#四-RxSwift的优点" class="headerlink" title="四. RxSwift的优点"></a>四. RxSwift的优点</h1><ul><li>Composable 可组合，在设计模式中有一种模式叫做组合模式，你可以方便的用不同的组合实现不同的类</li><li>Reusable 代码可重用，原因很简单，对应RxSwift，就是一堆Obserable</li><li>Declarative 响应式的，因为状态不可变，只有数据变化</li><li>Understandable and concise 简洁，容易理解。</li><li>Stable 稳定，因为RxSwift写出的代码，单元测试时分方便</li><li>Less stateful “无”状态性，因为对于响应式编程，你的应用程序就是一堆数据流</li><li>Without leaks 没有泄漏，因为资源管理非常简单</li></ul>]]></content>
      
      <categories>
          
          <category> RxSwift框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
            <tag> 响应式编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift的使用详解01</title>
      <link href="/2017/09/15/RxSwift%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A301"/>
      <content type="html"><![CDATA[<h1 id="一-RxSwift简介"><a href="#一-RxSwift简介" class="headerlink" title="一. RxSwift简介"></a>一. RxSwift简介</h1><blockquote><ul><li><h4 id="推荐-RxSwift官方文档"><a href="#推荐-RxSwift官方文档" class="headerlink" title="推荐: RxSwift官方文档"></a>推荐: <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift官方文档</a></h4></li><li><h4 id="中文-RxSwift官方文档的中文翻译"><a href="#中文-RxSwift官方文档的中文翻译" class="headerlink" title="中文: RxSwift官方文档的中文翻译"></a>中文: <a href="https://github.com/jhw-dev/RxSwift-CN" target="_blank" rel="noopener">RxSwift官方文档的中文翻译</a></h4></li></ul></blockquote><ul><li><h3 id="RxSwift是Swift函数响应式编程的一个开源库，由Github的ReactiveX组织开发、维护"><a href="#RxSwift是Swift函数响应式编程的一个开源库，由Github的ReactiveX组织开发、维护" class="headerlink" title="RxSwift是Swift函数响应式编程的一个开源库，由Github的ReactiveX组织开发、维护"></a><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>是Swift函数响应式编程的一个开源库，由Github的<a href="https://github.com/ReactiveX" target="_blank" rel="noopener">ReactiveX</a>组织开发、维护</h3></li><li><h3 id="其他语言像C-Java-和-JS-也有，Rx-Net、RxJava、rxjs"><a href="#其他语言像C-Java-和-JS-也有，Rx-Net、RxJava、rxjs" class="headerlink" title="其他语言像C#, Java 和 JS 也有，Rx.Net、RxJava、rxjs"></a>其他语言像C#, Java 和 JS 也有，Rx.Net、RxJava、<a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener">rxjs</a></h3></li><li><h3 id="RxSwift的目的是让数据-事件流和异步任务能够更方便的序列化处理，能够使用Swift进行响应式编程"><a href="#RxSwift的目的是让数据-事件流和异步任务能够更方便的序列化处理，能够使用Swift进行响应式编程" class="headerlink" title="RxSwift的目的是让数据/事件流和异步任务能够更方便的序列化处理，能够使用Swift进行响应式编程"></a>RxSwift的目的是让数据/事件流和异步任务能够更方便的序列化处理，能够使用Swift进行响应式编程</h3></li></ul><h3 id="1-RxSwift做了什么"><a href="#1-RxSwift做了什么" class="headerlink" title="1. RxSwift做了什么"></a>1. RxSwift做了什么</h3><ul><li>RxSwift把我们程序中每一个操作都看成一个事件</li><li>比如一个TextField中的文本改变，一个按钮被点击，或者一个网络请求结束等，每一个事件源就可以看成一个管道，也就是sequence</li><li>比如TextField，当我们改变里面的文本的时候，这个TextField就会不断的发出事件，从他的这个sequence中不断的流出，我们只需要监听这个sequence，每流出一个事件就做相应的处理。</li><li>同理，Button也是一个sequence，每点击一次就流出一个事件。</li></ul><h2 id="2-1-RxSwift的核心思想是-Observable"><a href="#2-1-RxSwift的核心思想是-Observable" class="headerlink" title="2.1 RxSwift的核心思想是 Observable"></a>2.1 RxSwift的核心思想是 Observable<element></element></h2><ul><li>sequence，Observable表示可监听或者可观察，也就是说RxSwift的核心思想是可监听的序列。</li><li><p>并且，Observable sequence可以接受异步信号，也就是说，信号是可以异步给监听者的</p><ul><li>Observable(ObservableType) 和 SequenceType类似</li><li>ObservableType.subscribe 和 SequenceType.generate类似</li><li>由于RxSwift支持异步获得信号，所以用ObservableType.subscribe，这和indexGenerator.next()类似</li></ul></li><li><p>其中SequenceType是Swift(2.3以前版本,之后的版本没有该协议)中的一个协议，比如Swift中的Array就遵循这个协议，通过这个协议，你可以这样的去操作一个Array</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">let array2 = array.filter(&#123;$<span class="number">0</span> &gt; <span class="number">1</span>&#125;).map(&#123;$<span class="number">0</span> * <span class="number">2</span>&#125;)<span class="comment">//4 6 8 10</span></span><br><span class="line">var indexGenerator = array2.generate()</span><br><span class="line">let fisrt = indexGenerator.next() <span class="comment">// 4</span></span><br><span class="line">let seoncd = indexGenerator.next() <span class="comment">//6</span></span><br></pre></td></tr></table></figure><h3 id="2-2-RxSwift中，ObservableType-subscribe的回调（新的信号到来）一共有三"><a href="#2-2-RxSwift中，ObservableType-subscribe的回调（新的信号到来）一共有三" class="headerlink" title="2.2  RxSwift中，ObservableType.subscribe的回调（新的信号到来）一共有三"></a>2.2  RxSwift中，ObservableType.subscribe的回调（新的信号到来）一共有三</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Event&lt;Element&gt;  &#123;</span><br><span class="line">    <span class="keyword">case</span> Next(Element)      <span class="comment">// 新的信号到来</span></span><br><span class="line">    <span class="keyword">case</span> Error(ErrorType)   <span class="comment">// 信号发生错误，序列不会再产生信号</span></span><br><span class="line">    <span class="keyword">case</span> Completed          <span class="comment">// 序列发送信号完成，不会再产生新的信号</span></span><br><span class="line">&#125;</span><br><span class="line">protocol ObserverType &#123;</span><br><span class="line">    func on(event: Event&lt;Element&gt;) <span class="comment">//监听所有的信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-取消监听"><a href="#2-3-取消监听" class="headerlink" title="2.3 取消监听"></a>2.3 取消监听</h3><blockquote><p>Observable分为两种</p></blockquote><ul><li>在有限的时间内会自动结束（Completed/Error）,比如一个网络请求当作一个序列，当网络请求完成的时候，Observable自动结束，资源会被释放</li><li>信号不会自己结束，最简单的比如一个Timer，每隔一段时间发送一个新的信号过来，这时候需要手动取消监听，来释放相应的资源</li><li>比如一个label.rx.text是一个Obserable，通常需要这样调用addDisposableTo(disposeBag)来让其在deinit，也就是所有者要释放的时候，自动取消监听<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Observable&lt;Element&gt; &#123;</span><br><span class="line">    func subscribe(observer: Observer&lt;Element&gt;) -&gt; Disposable //调用Disposable的方法来取消</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>当然，除了手动释放，RxSwift提供了一些操作符，比如 takeUntil来根据条件取消</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequence</span><br><span class="line">    .takeUntil(self.rx_deallocated) //当对象要释放的时候，取消监听</span><br><span class="line">    .subscribe &#123;</span><br><span class="line">        print($0)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="二-RxSwift简单体验"><a href="#二-RxSwift简单体验" class="headerlink" title="二. RxSwift简单体验"></a>二. RxSwift简单体验</h1><ul><li>首先创建deinit属性，也就是所有者要释放的时候，自动取消监听<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileprivate lazy var bag = DisposeBag()</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-RxSwift监听按钮的点击"><a href="#1-RxSwift监听按钮的点击" class="headerlink" title="1. RxSwift监听按钮的点击"></a>1. RxSwift监听按钮的点击</h2><ul><li>传统方式: </li><li><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button1.addTarget(<span class="keyword">self</span>, action: <span class="meta">#selector(btn1Click(_:)), for: .touchUpInside)</span></span><br></pre></td></tr></table></figure></li><li><p>RxSwift方式</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.rx.tap.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.button1.setTitle(<span class="string">"按钮1"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">    print(<span class="string">"button1"</span>)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">button2.rx.tap.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.textField2.text = <span class="string">"按钮2被点击了"</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h2 id="2-RxSwift监听UITextField的文字改变"><a href="#2-RxSwift监听UITextField的文字改变" class="headerlink" title="2. RxSwift监听UITextField的文字改变"></a>2. RxSwift监听UITextField的文字改变</h2><ul><li>传统做法,设置<code>textField2.delegate = self</code></li><li>RxSwift方式<blockquote><p>2-1. 用on方法实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe(&lt;<span class="meta">#T##on: (Event<span class="meta-string">&lt;Int&gt;</span>) -&gt; Void##(Event<span class="meta-string">&lt;Int&gt;</span>) -&gt; Void#&gt;)</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">textField1.rx.text.subscribe &#123; (event: Event&lt;String?&gt;) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//将UITextField文字改变的内容显示在Label中</span></span><br><span class="line">    <span class="keyword">self</span>.label1.text = event.element!    </span><br><span class="line">    print(event.element!!)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">textField2.rx.text.subscribe &#123; (event: Event&lt;String?&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event.element)<span class="comment">//报警告</span></span><br><span class="line">    <span class="comment">//输出: Optional(Optional("jun"))</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure><blockquote><p>2-2. 用onNext方法实现</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe(on: (Event&lt;Int&gt;) -&gt; Void)</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">textField1.rx.text.subscribe(onNext: &#123; (str: String?) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.label1.text = str!</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"><span class="meta">## 3. RxSwift改变Label中文字</span></span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">label1.rx.observe(String.self, <span class="string">"text"</span>).subscribe(onNext: &#123; (str: String?) <span class="keyword">in</span></span><br><span class="line">    print(str!)</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">label2.rx.observe(<span class="built_in">CGRect</span>.self, <span class="string">"frame"</span>).subscribe(onNext: &#123; (rect: <span class="built_in">CGRect</span>?) <span class="keyword">in</span></span><br><span class="line">    print(rect!.width)</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h2 id="4-RxSwift监听UIScrollView的滚动"><a href="#4-RxSwift监听UIScrollView的滚动" class="headerlink" title="4. RxSwift监听UIScrollView的滚动"></a>4. RxSwift监听UIScrollView的滚动</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scrollView.contentSize = <span class="built_in">CGSize</span>(width: <span class="number">1000</span>, height: <span class="number">0</span>)</span><br><span class="line">scrollView.rx.contentOffset</span><br><span class="line">            .subscribe(onNext: &#123; (point : <span class="built_in">CGPoint</span>) <span class="keyword">in</span></span><br><span class="line">                print(point)</span><br><span class="line">            &#125;).addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h1 id="三-RxSwift常见操作"><a href="#三-RxSwift常见操作" class="headerlink" title="三. RxSwift常见操作"></a>三. RxSwift常见操作</h1><ul><li>addDisposableTo(disposeBag)方法是让其deinit，也就是所有者要释放的时候，自动取消监听</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建bag</span><br><span class="line">let bag = DisposeBag()</span><br></pre></td></tr></table></figure><h2 id="1-never"><a href="#1-never" class="headerlink" title="1. never"></a>1. never</h2><ul><li>never就是创建一个sequence,但是不发出任何事件信号</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let neverSqu = Observable&lt;String&gt;.never()</span><br><span class="line">neverSqu.subscribe &#123; (_) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//该语句不会执行</span></span><br><span class="line">    print(<span class="string">"This will never be printed"</span>)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line"><span class="comment">//调用Disposable的方法来取消</span></span><br></pre></td></tr></table></figure><h2 id="2-empty"><a href="#2-empty" class="headerlink" title="2. empty"></a>2. empty</h2><ul><li>empty就是创建一个空的sequence,只能发出一个complected事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Int&gt;.empty().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//该语句只会执行一次</span></span><br><span class="line">    <span class="comment">//输出: completed</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h2 id="3-just"><a href="#3-just" class="headerlink" title="3. just"></a>3. just</h2><ul><li>just是创建一个sequence只能发出一种特定的事件，能正常结束</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Int&gt;.just(<span class="number">3</span>).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行两次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(3),语句结果</span></span><br><span class="line"><span class="comment">     2) completed, 结束事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">Observable.just(<span class="string">"jun"</span>).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行两次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(jun),语句结果</span></span><br><span class="line"><span class="comment">     2) completed, 结束事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">```    </span><br><span class="line">        </span><br><span class="line"><span class="meta">## 4.of</span></span><br><span class="line">- of是创建一个sequence能发出很多种事件信号</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">Observable.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"2"</span>, <span class="string">"5.3"</span>)</span><br><span class="line">    .subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">//会分别输出 "a", "b", "2", "5.3"</span></span><br><span class="line"></span><br><span class="line">Observable.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"2"</span>, <span class="string">"5.3"</span>).subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行4次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(a),语句结果</span></span><br><span class="line"><span class="comment">     2) next(b),语句结果</span></span><br><span class="line"><span class="comment">     3) next(2),语句结果</span></span><br><span class="line"><span class="comment">     4) next(3.5),语句结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;, onError: <span class="literal">nil</span>, onCompleted: <span class="literal">nil</span>, onDisposed: <span class="literal">nil</span>).addDisposableTo(bag)</span><br><span class="line">   <span class="comment">//每一个闭包都设置设置了 一个默认值,故可以省略</span></span><br></pre></td></tr></table></figure><h2 id="5-from"><a href="#5-from" class="headerlink" title="5. from"></a>5. from</h2><ul><li>from就是从数组中创建sequence</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Observable.from([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"2"</span>, <span class="string">"5.3"</span>]).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行5次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(a),语句结果</span></span><br><span class="line"><span class="comment">     2) next(b),语句结果</span></span><br><span class="line"><span class="comment">     3) next(2),语句结果</span></span><br><span class="line"><span class="comment">     4) next(3.5),语句结果</span></span><br><span class="line"><span class="comment">     5) completed, 结束事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">```        </span><br><span class="line"><span class="meta">## 6. create</span></span><br><span class="line">- 我们也可以自定义可观察的sequence，那就是使用create</span><br><span class="line">- create操作符传入一个观察者observer，然后调用observer的onNext，onCompleted和onError方法。返回一个可观察的obserable序列</span><br><span class="line"></span><br><span class="line">&gt; <span class="meta">#### 1) 自定义方法创建observable的creat</span></span><br><span class="line"><span class="meta">#### 6-1 无参创建creat</span></span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">fileprivate func myobserable() -&gt; Observable&lt;Any&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(&#123; (observal: AnyObserver&lt;Any&gt;) -&gt; Disposable <span class="keyword">in</span></span><br><span class="line">        observal.onNext(<span class="string">"abc"</span>)</span><br><span class="line">        observal.onNext(<span class="string">"12"</span>)</span><br><span class="line">        observal.onCompleted()</span><br><span class="line">        <span class="keyword">return</span> Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-添加参数创建creat"><a href="#6-2-添加参数创建creat" class="headerlink" title="6-2 添加参数创建creat"></a>6-2 添加参数创建creat</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func myJunst(element: String) -&gt; Observable&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(&#123; (observal: AnyObserver&lt;String&gt;) -&gt; Disposable <span class="keyword">in</span></span><br><span class="line">        observal.onNext(element)</span><br><span class="line">        observal.onCompleted()</span><br><span class="line">        <span class="keyword">return</span> Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-在函数内调用自定义方法"><a href="#2-在函数内调用自定义方法" class="headerlink" title="2) 在函数内调用自定义方法"></a>2) 在函数内调用自定义方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myobserable().subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line"><span class="comment">//该语句只会执行2次,分别输出"abc", "12"</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line">myJunst(element: <span class="string">"jun"</span>).subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line"><span class="comment">//该语句只会执行2次,分别输出"jun"</span></span><br></pre></td></tr></table></figure><h2 id="7-range-给定范围-依次显示"><a href="#7-range-给定范围-依次显示" class="headerlink" title="7. range(给定范围, 依次显示)"></a>7. range(给定范围, 依次显示)</h2><ul><li>range就是创建一个sequence，他会发出这个范围中的从开始到结束的所有事件</li><li>Observable<int>,必须指定数据类型</int></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Int&gt;.range(start: <span class="number">1</span>, count: <span class="number">4</span>).subscribe &#123; (event: Event&lt;Int&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行5次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(1),语句结果</span></span><br><span class="line"><span class="comment">     2) next(2),语句结果</span></span><br><span class="line"><span class="comment">     3) next(3),语句结果</span></span><br><span class="line"><span class="comment">     4) next(4),语句结果</span></span><br><span class="line"><span class="comment">     5) completed, 结束事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h2 id="8-repeatElement-重复执行"><a href="#8-repeatElement-重复执行" class="headerlink" title="8. repeatElement(重复执行)"></a>8. repeatElement(重复执行)</h2><p>创建一个sequence，发出特定的事件n次</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.repeatElement(<span class="string">"quanjun"</span>)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">//该语句只会执行3次,每次都输出"quanjun"</span></span><br></pre></td></tr></table></figure><h2 id="9-generate-类似于for循环"><a href="#9-generate-类似于for循环" class="headerlink" title="9.  generate(类似于for循环)"></a>9.  generate(类似于for循环)</h2><ul><li>generate是创建一个可观察sequence，当初始化的条件为true的时候，他就会发出所对应的事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let generate = Observable.generate(initialState: <span class="number">0</span>, condition: &#123; $<span class="number">0</span> &lt; <span class="number">5</span> &#125;, iterate: &#123; $<span class="number">0</span> + <span class="number">2</span> &#125;)</span><br><span class="line">generate.subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*1&gt; 输出顺序:</span></span><br><span class="line"><span class="comment">         next(0)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         2&gt; 以上代码可以理解为for循环处理逻辑</span></span><br><span class="line"><span class="comment">        for (Int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">            print(i)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br></pre></td></tr></table></figure><h2 id="10-error-发出错误信号"><a href="#10-error-发出错误信号" class="headerlink" title="10.  error(发出错误信号)"></a>10.  error(发出错误信号)</h2><ul><li>创建一个可观察序列，但不发出任何正常的事件，只发出error事件并结束</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> let error = <span class="built_in">NSError</span>(domain: <span class="string">"错误"</span>, code: <span class="number">10</span>, userInfo: <span class="literal">nil</span>) as Error</span><br><span class="line"> Observable&lt;Any&gt;.error(error)</span><br><span class="line">            .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">            .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//输出: error(Error Domain=错误 Code=10 "(null)")</span></span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"><span class="meta"># 四. RxSwift中Subjects</span></span><br><span class="line">- <span class="meta">### Subjects是什么?</span></span><br><span class="line">  - <span class="meta">##### Subjet是observable和Observer之间的桥梁，一个Subject既是一个Obserable也是一个Observer，他既可以发出事件，也可以监听事件</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">## 1. PublishSubject</span></span><br><span class="line">- <span class="meta">##### 当你订阅PublishSubject的时候，你只能接收到订阅他之后发生的事件。subject.onNext()发出onNext事件，对应的还有onError()和onCompleted()事件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">let pSubject = PublishSubject&lt;String&gt;()</span><br><span class="line">pSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"2--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">print(<span class="string">"1--------------"</span>)</span><br><span class="line">        </span><br><span class="line">pSubject.onNext(<span class="string">"T"</span>)</span><br><span class="line">pSubject.onNext(<span class="string">"Q"</span>)</span><br><span class="line">        </span><br><span class="line">pSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">         print(<span class="string">"3--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">pSubject.onNext(<span class="string">"J"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         1--------------</span></span><br><span class="line"><span class="comment">         2-- next(T)</span></span><br><span class="line"><span class="comment">         2-- next(Q)</span></span><br><span class="line"><span class="comment">         2-- next(J)</span></span><br><span class="line"><span class="comment">         3-- next(J)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="2-ReplaySubject"><a href="#2-ReplaySubject" class="headerlink" title="2. ReplaySubject"></a>2. ReplaySubject</h2><ul><li><h5 id="当你订阅ReplaySubject的时候，你可以接收到订阅他之后的事件，但也可以接受订阅他之前发出的事件，接受几个事件取决与bufferSize的大小"><a href="#当你订阅ReplaySubject的时候，你可以接收到订阅他之后的事件，但也可以接受订阅他之前发出的事件，接受几个事件取决与bufferSize的大小" class="headerlink" title="当你订阅ReplaySubject的时候，你可以接收到订阅他之后的事件，但也可以接受订阅他之前发出的事件，接受几个事件取决与bufferSize的大小"></a>当你订阅ReplaySubject的时候，你可以接收到订阅他之后的事件，但也可以接受订阅他之前发出的事件，接受几个事件取决与bufferSize的大小</h5></li><li><h5 id="createUnbounded-表示接受所有事件"><a href="#createUnbounded-表示接受所有事件" class="headerlink" title="createUnbounded()表示接受所有事件"></a><code>createUnbounded()</code>表示接受所有事件</h5></li><li><h5 id="create-bufferSize-4-表示可接受到的订阅他之前的事件的个数-但是订阅他之后的事件一定会触发"><a href="#create-bufferSize-4-表示可接受到的订阅他之前的事件的个数-但是订阅他之后的事件一定会触发" class="headerlink" title="create(bufferSize: 4) 表示可接受到的订阅他之前的事件的个数,但是订阅他之后的事件一定会触发"></a><code>create(bufferSize: 4)</code> 表示可接受到的订阅他之前的事件的个数,但是订阅他之后的事件一定会触发</h5></li></ul><h3 id="2-1-createUnbounded-表示接受所有事件"><a href="#2-1-createUnbounded-表示接受所有事件" class="headerlink" title="2-1. createUnbounded()表示接受所有事件"></a>2-1. <code>createUnbounded()</code>表示接受所有事件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let rSubject = ReplaySubject&lt;String&gt;.createUnbounded()</span><br><span class="line">rSubject.onNext(<span class="string">"T"</span>)</span><br><span class="line">rSubject.onNext(<span class="string">"Q"</span>)</span><br><span class="line">rSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">         print(<span class="string">"0--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">rSubject.onNext(<span class="string">"J"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">     0-- next(T)</span></span><br><span class="line"><span class="comment">     0-- next(Q)</span></span><br><span class="line"><span class="comment">     0-- next(J)</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="2-2-create-bufferSize-4-表示可接受到的订阅他之前的事件的个数"><a href="#2-2-create-bufferSize-4-表示可接受到的订阅他之前的事件的个数" class="headerlink" title="2-2. create(bufferSize: 4) 表示可接受到的订阅他之前的事件的个数"></a>2-2. <code>create(bufferSize: 4)</code> 表示可接受到的订阅他之前的事件的个数</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let rSubject1 = ReplaySubject&lt;String&gt;.create(bufferSize: <span class="number">1</span>)</span><br><span class="line">rSubject1.onNext(<span class="string">"T"</span>)</span><br><span class="line">rSubject1.onNext(<span class="string">"Q"</span>)</span><br><span class="line">rSubject1.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">"4--"</span>, event)</span><br><span class="line">        &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">rSubject1.onNext(<span class="string">"J"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">     4-- next(Q)</span></span><br><span class="line"><span class="comment">     4-- next(J)</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h2 id="3-BehaviorSubject"><a href="#3-BehaviorSubject" class="headerlink" title="3. BehaviorSubject"></a>3. BehaviorSubject</h2><ul><li><h5 id="当你订阅了BehaviorSubject，你会接受到订阅之前的最后一个事件-订阅之后的事件一定会触发"><a href="#当你订阅了BehaviorSubject，你会接受到订阅之前的最后一个事件-订阅之后的事件一定会触发" class="headerlink" title="当你订阅了BehaviorSubject，你会接受到订阅之前的最后一个事件,订阅之后的事件一定会触发"></a>当你订阅了BehaviorSubject，你会接受到订阅之前的最后一个事件,订阅之后的事件一定会触发</h5></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let bSubject = BehaviorSubject(value: <span class="string">"G"</span>)</span><br><span class="line">bSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"5--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">bSubject.onNext(<span class="string">"Y"</span>)</span><br><span class="line">bSubject.onNext(<span class="string">"Q"</span>)</span><br><span class="line">        </span><br><span class="line">bSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"6--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">bSubject.onNext(<span class="string">"J"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         5-- next(G)</span></span><br><span class="line"><span class="comment">         5-- next(Y)</span></span><br><span class="line"><span class="comment">         5-- next(Q)</span></span><br><span class="line"><span class="comment">         6-- next(Q)</span></span><br><span class="line"><span class="comment">         5-- next(J)</span></span><br><span class="line"><span class="comment">         6-- next(J)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="4-Variable"><a href="#4-Variable" class="headerlink" title="4. Variable"></a>4. Variable</h2><h5 id="Variable是BehaviorSubject一个包装箱，就像是一个箱子一样，使用的时候需要调用asObservable-拆箱，里面的value是一个BehaviorSubject，他不会发出error事件，但是会自动发出completed事件。"><a href="#Variable是BehaviorSubject一个包装箱，就像是一个箱子一样，使用的时候需要调用asObservable-拆箱，里面的value是一个BehaviorSubject，他不会发出error事件，但是会自动发出completed事件。" class="headerlink" title="Variable是BehaviorSubject一个包装箱，就像是一个箱子一样，使用的时候需要调用asObservable()拆箱，里面的value是一个BehaviorSubject，他不会发出error事件，但是会自动发出completed事件。"></a>Variable是BehaviorSubject一个包装箱，就像是一个箱子一样，使用的时候需要调用asObservable()拆箱，里面的value是一个BehaviorSubject，他不会发出error事件，但是会自动发出completed事件。</h5><ul><li>1&gt; 相当于对BehaviorSubject进行装箱</li><li>2&gt; 如果想将Variable当成Obserable, 让订阅者进行订阅时, 需要调用asObserable拆箱转成Obserable</li><li>3&gt; 如果Variable打算发出事件, 直接修改对象的value即可</li><li>4&gt; 当事件结束时,Variable会自动发出completed事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let variable = Variable(<span class="string">"S"</span>)</span><br><span class="line">variable.asObservable().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"7--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">variable.value = <span class="string">"D"</span></span><br><span class="line">variable.value = <span class="string">"Q"</span></span><br><span class="line">        </span><br><span class="line">variable.asObservable().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"8--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">variable.value = <span class="string">"j"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         7-- next(S)</span></span><br><span class="line"><span class="comment">         7-- next(D)</span></span><br><span class="line"><span class="comment">         7-- next(Q)</span></span><br><span class="line"><span class="comment">         8-- next(Q)</span></span><br><span class="line"><span class="comment">         7-- next(j)</span></span><br><span class="line"><span class="comment">         8-- next(j)</span></span><br><span class="line"><span class="comment">         7-- completed</span></span><br><span class="line"><span class="comment">         8-- completed</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h1 id="五-RxSwift细节理解"><a href="#五-RxSwift细节理解" class="headerlink" title="五. RxSwift细节理解"></a>五. RxSwift细节理解</h1><h2 id="1-变换操作"><a href="#1-变换操作" class="headerlink" title="1. 变换操作"></a>1. 变换操作</h2><h3 id="1-1-map"><a href="#1-1-map" class="headerlink" title="1-1.  map"></a>1-1.  map</h3><ul><li>通过传入一个函数闭包把原来的sequence转变为一个新的sequence的操作</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .map(&#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;)</span><br><span class="line">        .subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line"><span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment">    9</span></span><br><span class="line"><span class="comment">    16</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="1-2-flatMap"><a href="#1-2-flatMap" class="headerlink" title="1-2. flatMap"></a>1-2. flatMap</h3><ul><li>将一个sequence转换为一个sequences，当你接收一个sequence的事件，你还想接收其他sequence发出的事件的话可以使用flatMap，她会将每一个sequence事件进行处理以后，然后再以一个sequence形式发出事件</li></ul><blockquote><h4 id="首先创建一个struct"><a href="#首先创建一个struct" class="headerlink" title="首先创建一个struct"></a>首先创建一个struct</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    var score: Variable&lt;Double&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="flatMap执行代码"><a href="#flatMap执行代码" class="headerlink" title="flatMap执行代码"></a>flatMap执行代码</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let stu1 = Student(score: Variable(<span class="number">80</span>))</span><br><span class="line">let stu2 = Student(score: Variable(<span class="number">100</span>))</span><br><span class="line">        </span><br><span class="line">let student = Variable(stu1)</span><br><span class="line">student.asObservable().flatMap &#123; (stu: Student) -&gt; Observable&lt;Double&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> stu.score.asObservable()</span><br><span class="line">&#125;.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">student.value = stu2</span><br><span class="line">stu1.score.value = <span class="number">10</span></span><br><span class="line">stu2.score.value = <span class="number">20</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">         next(80.0)</span></span><br><span class="line"><span class="comment">         next(100.0)</span></span><br><span class="line"><span class="comment">         next(10.0)</span></span><br><span class="line"><span class="comment">         next(20.0)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h3 id="1-3-flatMapLatest"><a href="#1-3-flatMapLatest" class="headerlink" title="1-3. flatMapLatest"></a>1-3. flatMapLatest</h3><ul><li>flatMapLatest只会接收最新的value事件，将上例代码改为flatMapLatest</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let stu3 = Student(score: Variable(<span class="number">70</span>))</span><br><span class="line">let stu4 = Student(score: Variable(<span class="number">60</span>))</span><br><span class="line"></span><br><span class="line">let student1 = Variable(stu3)</span><br><span class="line">student1.asObservable().flatMapFirst &#123; (stu) -&gt; Observable&lt;Double&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> stu.score.asObservable()</span><br><span class="line">&#125;.subscribe &#123; (event: Event&lt;Double&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">student1.value = stu4</span><br><span class="line">stu3.score.value = <span class="number">10</span></span><br><span class="line">stu4.score.value = <span class="number">20</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">         next(70.0)</span></span><br><span class="line"><span class="comment">         next(10.0)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="2-释放资源"><a href="#2-释放资源" class="headerlink" title="2. 释放资源"></a>2. 释放资源</h2><ul><li>当监听一个事件序列的时候，有消息事件来了，我们做某些事情。但是这个事件序列不再发出消息了，我们的监听也就没有什么存在价值了，所以我们需要释放我们这些监听资源，其实也就是每种编程语言中的内存资源释放。</li><li>OC和Swift中也一样，在你不需要用某些变量的时候，你需要把这些变量所占用的内存空间释放掉。</li><li>释放某一个监听的时候我们可以手动调用释放方法<h3 id="2-1-dispose"><a href="#2-1-dispose" class="headerlink" title="2-1. dispose"></a>2-1. dispose</h3></li><li>相当于MRC中手动调用release操作</li><li>注意: 因为观察者已经销毁, 所有后面无法接受事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let testVariable = Variable(<span class="string">"jun"</span>)</span><br><span class="line">testVariable.asObservable().subscribe &#123; (event : Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.dispose()</span><br><span class="line"></span><br><span class="line">testVariable.value = <span class="string">"tian"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Dispose-Bags"><a href="#2-2-Dispose-Bags" class="headerlink" title="2-2. Dispose Bags"></a>2-2. Dispose Bags</h3><ul><li>除了上面手动的方法，还有一种是自动的方式</li><li>推荐大家使用这种方式，这种方式就好像iOS中的ARC方式似得，会自动去释放资源。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileprivate lazy var bag = DisposeBag()</span><br></pre></td></tr></table></figure></li></ul><blockquote><h4 id="在代码结尾调用-addDisposableTo-bag-方法"><a href="#在代码结尾调用-addDisposableTo-bag-方法" class="headerlink" title="在代码结尾调用.addDisposableTo(bag)方法"></a>在代码结尾调用<code>.addDisposableTo(bag)</code>方法</h4></blockquote><h2 id="3-UIBindingObserver"><a href="#3-UIBindingObserver" class="headerlink" title="3. UIBindingObserver"></a>3. UIBindingObserver</h2><ul><li><h5 id="UIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa-RxSwiftz中对UIKit的一个扩展库-给的扩展不够我们使用"><a href="#UIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa-RxSwiftz中对UIKit的一个扩展库-给的扩展不够我们使用" class="headerlink" title="UIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa(RxSwiftz中对UIKit的一个扩展库)给的扩展不够我们使用"></a>UIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa(RxSwiftz中对UIKit的一个扩展库)给的扩展不够我们使用</h5></li><li><h5 id="比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做："><a href="#比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做：" class="headerlink" title="比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做："></a>比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做：</h5></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Reactive where Base: <span class="built_in">UITextField</span> &#123;</span><br><span class="line">    var inputEnabled: <span class="built_in">UIBindingObserver</span>&lt;Base, Result&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIBindingObserver</span>(<span class="built_in">UIElement</span>: base) &#123; textFiled, result <span class="keyword">in</span></span><br><span class="line">            textFiled.isEnabled = result.isValid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="后续会继续更新相关方面知识-敬请期待"><a href="#后续会继续更新相关方面知识-敬请期待" class="headerlink" title="后续会继续更新相关方面知识,敬请期待"></a>后续会继续更新相关方面知识,敬请期待</h4></blockquote>]]></content>
      
      <categories>
          
          <category> RxSwift框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
            <tag> 响应式编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS之Scanner字符串扫描类</title>
      <link href="/2017/09/09/iOS%E4%B9%8BScanner%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%AB%E6%8F%8F%E7%B1%BB"/>
      <content type="html"><![CDATA[<blockquote><h3 id="注-本文主要语法为Swift4-0"><a href="#注-本文主要语法为Swift4-0" class="headerlink" title="注:  本文主要语法为Swift4.0"></a>注:  本文主要语法为Swift4.0</h3></blockquote><ul><li><h4 id="Scanner继承自NSObject，遵守NSCopying协议。是一个用于扫描指定字符串的抽象类"><a href="#Scanner继承自NSObject，遵守NSCopying协议。是一个用于扫描指定字符串的抽象类" class="headerlink" title="Scanner继承自NSObject，遵守NSCopying协议。是一个用于扫描指定字符串的抽象类"></a>Scanner继承自NSObject，遵守NSCopying协议。是一个用于扫描指定字符串的抽象类</h4></li><li><h4 id="可以创建Scanner时制定他的String属性，然后scanner会按照你的要求从头到尾扫描这个字符串的每个字符"><a href="#可以创建Scanner时制定他的String属性，然后scanner会按照你的要求从头到尾扫描这个字符串的每个字符" class="headerlink" title="可以创建Scanner时制定他的String属性，然后scanner会按照你的要求从头到尾扫描这个字符串的每个字符"></a>可以创建Scanner时制定他的String属性，然后scanner会按照你的要求从头到尾扫描这个字符串的每个字符</h4></li><li>扫描操作从上次扫描的位置开始，并且继续往后扫描直到指定的内容出现为止（如果有的话）</li></ul><a id="more"></a><h2 id="1-部分属性的相关解释"><a href="#1-部分属性的相关解释" class="headerlink" title="1. 部分属性的相关解释"></a>1. 部分属性的相关解释</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> open var string: String &#123; get &#125;</span><br><span class="line"> <span class="comment">// (只读)返回当前被扫描的字符串</span></span><br><span class="line"></span><br><span class="line">open var scanLocation: Int</span><br><span class="line"><span class="comment">// 当前扫描的位置，默认是从0开始的。通过设置这个属性值，可以自定义扫描的位置</span></span><br><span class="line"></span><br><span class="line">open var charactersToBeSkipped: CharacterSet?</span><br><span class="line"><span class="comment">// 这个集合是用来设置我们需要跳过扫描的一个字符集合</span></span><br><span class="line"></span><br><span class="line">open var caseSensitive: Bool</span><br><span class="line"><span class="comment">// 是否大小写敏感</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">public init(string: String)</span><br><span class="line"><span class="comment">// 用给定扫描字符串初始化</span></span><br></pre></td></tr></table></figure><h2 id="2-部分方法的相关解释"><a href="#2-部分方法的相关解释" class="headerlink" title="2. 部分方法的相关解释"></a>2. 部分方法的相关解释</h2><h3 id="2-1-以下方法的作用都是"><a href="#2-1-以下方法的作用都是" class="headerlink" title="2-1 以下方法的作用都是"></a>2-1 以下方法的作用都是</h3><ul><li>扫描该类型的字符串,并将扫描结果赋值给result</li><li>判断该字符串的第一个字符(默认第一个,可根据scanLocation属性设置)是否为该类型</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">open func scanInt32(_ result: UnsafeMutablePointer&lt;Int32&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanInt(_ result: UnsafeMutablePointer&lt;Int&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">open func scanInt64(_ result: UnsafeMutablePointer&lt;Int64&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">7.0</span>, *)</span><br><span class="line">open func scanUnsignedLongLong(_ result: UnsafeMutablePointer&lt;<span class="built_in">UInt64</span>&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">open func scanFloat(_ result: UnsafeMutablePointer&lt;Float&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">open func scanDouble(_ result: UnsafeMutablePointer&lt;Double&gt;?) -&gt; Bool</span><br></pre></td></tr></table></figure><h4 id="2-1-1-包含纯数字的字符串"><a href="#2-1-1-包含纯数字的字符串" class="headerlink" title="2-1-1 包含纯数字的字符串"></a>2-1-1 包含纯数字的字符串</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var int1: Int = <span class="number">0</span></span><br><span class="line">var int64: Int64 = <span class="number">0</span></span><br><span class="line">var int32: Int32 = <span class="number">0</span></span><br><span class="line">var float1: Float = <span class="number">0.0</span></span><br><span class="line">var double1: Double = <span class="number">0.0</span></span><br><span class="line"><span class="comment">//判断字符串包含的类型(输出结果为true)</span></span><br><span class="line">print(Scanner(string: <span class="string">"987"</span>).scanInt(&amp;int1))</span><br><span class="line">print(Scanner(string: <span class="string">"897"</span>).scanInt64(&amp;int64))</span><br><span class="line">print(Scanner(string: <span class="string">"99"</span>).scanInt32(&amp;int32))</span><br><span class="line">print(Scanner(string: <span class="string">"90.99"</span>).scanFloat(&amp;float1))</span><br><span class="line">print(Scanner(string: <span class="string">"98.09"</span>).scanDouble(&amp;double1))</span><br><span class="line"><span class="comment">//输出扫描后的结果</span></span><br><span class="line">int1 = <span class="number">98</span></span><br><span class="line">int64 = <span class="number">897</span></span><br><span class="line">int32 = <span class="number">99</span></span><br><span class="line"><span class="keyword">float</span> = <span class="number">90.99</span></span><br><span class="line"><span class="keyword">double</span> = <span class="number">98.09</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-非纯数字的字符串"><a href="#2-1-2-非纯数字的字符串" class="headerlink" title="2-1-2  非纯数字的字符串"></a>2-1-2  非纯数字的字符串</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var int1: Int = <span class="number">0</span></span><br><span class="line">let scanner = Scanner(string: <span class="string">"m998k23l"</span>)</span><br><span class="line">scanner.scanLocation = <span class="number">1</span></span><br><span class="line">print(scanner.scanInt(&amp;int1)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//int1 = 998</span></span><br><span class="line"></span><br><span class="line">var double1: Double = <span class="number">0.0</span></span><br><span class="line">let scanner = Scanner(string: <span class="string">"ms9.98k45l"</span>)</span><br><span class="line">scanner.scanLocation = <span class="number">1</span></span><br><span class="line">print(scanner.scanDouble(&amp;double1)) <span class="literal">false</span></span><br><span class="line"><span class="comment">//double1 = 0.0</span></span><br></pre></td></tr></table></figure><h3 id="2-2-以下方法的作用都是"><a href="#2-2-以下方法的作用都是" class="headerlink" title="2-2 以下方法的作用都是"></a>2-2 以下方法的作用都是</h3><ul><li>扫描字符串前缀是否是”0x”或者”0X”,返回true或false</li><li>将0x(0X)字符后面符合十六进制数的字符串转化成十进制数(可运用到UIColor关于十六进制数的转化)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">open func scanHexInt32(_ result: UnsafeMutablePointer&lt;<span class="built_in">UInt32</span>&gt;?) -&gt; Bool <span class="comment">// Optionally prefixed with "0x" or "0X"</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanHexInt64(_ result: UnsafeMutablePointer&lt;<span class="built_in">UInt64</span>&gt;?) -&gt; Bool <span class="comment">// Optionally prefixed with "0x" or "0X"</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanHexFloat(_ result: UnsafeMutablePointer&lt;Float&gt;?) -&gt; Bool <span class="comment">// Corresponding to %a or %A formatting. Requires "0x" or "0X" prefix.</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanHexDouble(_ result: UnsafeMutablePointer&lt;Double&gt;?) -&gt; Bool <span class="comment">// Corresponding to %a or %A formatting. Requires "0x" or "0X" prefix.</span></span><br></pre></td></tr></table></figure><h4 id="2-2-1-代码示例"><a href="#2-2-1-代码示例" class="headerlink" title="2-2-1 代码示例"></a>2-2-1 代码示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(Scanner(string: <span class="string">"xdd"</span>).scanHexInt64(&amp;uint64))  <span class="comment">//false</span></span><br><span class="line">print(Scanner(string: <span class="string">"0xdd"</span>).scanHexInt64(&amp;uint64))  <span class="comment">//true</span></span><br><span class="line">print(uint64) <span class="comment">//221</span></span><br><span class="line">print(Scanner(string: <span class="string">"0xax"</span>).scanHexInt32(&amp;uint32))  <span class="comment">//true</span></span><br><span class="line">print(uint32)  <span class="comment">// 10</span></span><br><span class="line">print(Scanner(string: <span class="string">"0X991"</span>).scanHexFloat(&amp;float1))  <span class="comment">//true</span></span><br><span class="line">print(float1)  <span class="comment">//2449.0</span></span><br><span class="line">print(Scanner(string: <span class="string">"0X99"</span>).scanHexDouble(&amp;double1))  <span class="comment">//true</span></span><br><span class="line">print(double1)  <span class="comment">//153.0</span></span><br></pre></td></tr></table></figure><h3 id="2-3-从给定的字符串中找到相同的字符"><a href="#2-3-从给定的字符串中找到相同的字符" class="headerlink" title="2-3 从给定的字符串中找到相同的字符"></a>2-3 从给定的字符串中找到相同的字符</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open func scanString(_ string: String, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br></pre></td></tr></table></figure><blockquote><p>代码示例</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var sstring: <span class="built_in">NSString</span>?</span><br><span class="line">let scan = Scanner(string: <span class="string">"32jingki"</span>)</span><br><span class="line"><span class="keyword">while</span> !scan.isAtEnd&#123; <span class="comment">// 判断是否扫描到最后</span></span><br><span class="line">    scan.scanLocation += <span class="number">1</span></span><br><span class="line">    print(scan.scanLocation)</span><br><span class="line">    scan.scanString(<span class="string">"i"</span>, into: &amp;sstring)</span><br><span class="line">    print(sstring)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Scanner的其他方法"><a href="#2-4-Scanner的其他方法" class="headerlink" title="2-4 Scanner的其他方法"></a>2-4 Scanner的其他方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">open func scanCharacters(from set: CharacterSet, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br><span class="line"><span class="comment">////从scan中扫描出string放入result中，如果不需要存储string，则result传NULL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">open func scanUpTo(_ string: String, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br><span class="line"><span class="comment">//从scan中扫描出string之外的数据放入result中，如果不需要存储string，则result传NULL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">open func scanUpToCharacters(from set: CharacterSet, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br><span class="line"><span class="comment">//从scan中扫描出set之外的数据放入result中，如果不需要存储string，则result传NULL</span></span><br></pre></td></tr></table></figure><h2 id="2-5-关于使用Scanner处理UIColor十六进制数值的问题"><a href="#2-5-关于使用Scanner处理UIColor十六进制数值的问题" class="headerlink" title="2-5  关于使用Scanner处理UIColor十六进制数值的问题"></a>2-5  关于使用Scanner处理UIColor十六进制数值的问题</h2><ul><li>可在UIColor的extension中添加扩展方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 十六进制颜色扩充</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">convenience init?(hex : String, alpha : <span class="built_in">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">//1.判断字符串长度是否符合</span></span><br><span class="line">    guard hex.characters.count &gt;= <span class="number">6</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.将字符串转成大写</span></span><br><span class="line">    var tempHex = hex.uppercased()</span><br><span class="line">    <span class="comment">//3.判断开头</span></span><br><span class="line">    <span class="keyword">if</span> tempHex.hasPrefix(<span class="string">"0x"</span>) || tempHex.hasPrefix(<span class="string">"##"</span>) || tempHex.hasPrefix(<span class="string">"0X"</span>) &#123;</span><br><span class="line">        <span class="comment">//去掉开头</span></span><br><span class="line">        tempHex = tempHex.dropFirst(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> tempHex.hasPrefix(<span class="string">"#"</span>) &#123;</span><br><span class="line">        tempHex = tempHex.dropFirst()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.分别截取RGB</span></span><br><span class="line">    var range = <span class="built_in">NSRange</span>(location: <span class="number">0</span>, length: <span class="number">2</span>)</span><br><span class="line">    let rHex = (tempHex as <span class="built_in">NSString</span>).substring(with: range)</span><br><span class="line">    range.location = <span class="number">2</span></span><br><span class="line">    let gHex = (tempHex as <span class="built_in">NSString</span>).substring(with: range)</span><br><span class="line">    range.location = <span class="number">4</span></span><br><span class="line">    let bHex = (tempHex as <span class="built_in">NSString</span>).substring(with: range)</span><br><span class="line">    <span class="comment">//5.将字符串转化成数字  emoji也是十六进制表示(此处也可用Float类型)</span></span><br><span class="line">    var r : <span class="built_in">UInt32</span> = <span class="number">0</span>, g : <span class="built_in">UInt32</span> = <span class="number">0</span>, b : <span class="built_in">UInt32</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">//创建扫描器,将字符串的扫描结果赋值给:r,g,b</span></span><br><span class="line">    Scanner(string: rHex).scanHexInt32(&amp;r)</span><br><span class="line">    Scanner(string: gHex).scanHexInt32(&amp;g)</span><br><span class="line">    Scanner(string: bHex).scanHexInt32(&amp;b)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.init(r : <span class="built_in">CGFloat</span>(r), g : <span class="built_in">CGFloat</span>(g), b : <span class="built_in">CGFloat</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**RGB三原色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">convenience init(r : <span class="built_in">CGFloat</span>, g : <span class="built_in">CGFloat</span>, b : <span class="built_in">CGFloat</span>, alpha : <span class="built_in">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.init(red: r / <span class="number">255.0</span>, green: g / <span class="number">255.0</span>, blue: b / <span class="number">255.0</span>, alpha: alpha)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Scanner </tag>
            
            <tag> iOS扫描器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>升级Swift4.0遇到的坑</title>
      <link href="/2017/08/25/%E5%8D%87%E7%BA%A7Swift4.0%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91"/>
      <content type="html"><![CDATA[<ul><li>并不是所有库都能做到及时支持Swift4.0，更何况是在现在连Xcode9也还是beta的状态</li><li>所以我们仅能做到将自己的业务代码（主工程代码）部分升级到Swift4.0，然后同时保留各种pod库在Swift3.2版本。</li><li>没办法，谁叫Swift4.0也还无法做到API兼容呢（但愿能在Swift5之前实现吧）。</li><li>至于我说的同时使用两个版本的Swift，这是没问题的，Xcode9支持在项目中同时使用Swift3.2和Swift4.0。</li></ul><a id="more"></a><h2 id="一-修改Swift版本"><a href="#一-修改Swift版本" class="headerlink" title="一. 修改Swift版本"></a>一. 修改Swift版本</h2><h4 id="1-如下图指定主工程的Swift版本为4-0"><a href="#1-如下图指定主工程的Swift版本为4-0" class="headerlink" title="1. 如下图指定主工程的Swift版本为4.0"></a>1. 如下图指定主工程的Swift版本为4.0</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-1a9aeacc47b262a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Xcode图示.png"></p><h4 id="2-修改pod库"><a href="#2-修改pod库" class="headerlink" title="2. 修改pod库"></a>2. 修改pod库</h4><ul><li>在Podfile文件的最下方加入如下代码，指定pod库的Swift版本为3.2(这样会使得所有的第三方pod库的Swift版本都为3.2)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">post_install do |installer|</span><br><span class="line">  installer.pods_project.targets.each do |target|</span><br><span class="line">    target.build_configurations.each do |config|</span><br><span class="line">      config.build_settings[&apos;SWIFT_VERSION&apos;] = &apos;3.2&apos;</span><br><span class="line">    end </span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="二-主工程中的代码修改"><a href="#二-主工程中的代码修改" class="headerlink" title="二. 主工程中的代码修改"></a>二. 主工程中的代码修改</h2><h3 id="1-列举一下Swift3-2到Swift4-0的改变-只是我项目中遇到的-："><a href="#1-列举一下Swift3-2到Swift4-0的改变-只是我项目中遇到的-：" class="headerlink" title="1. 列举一下Swift3.2到Swift4.0的改变(只是我项目中遇到的)："></a>1. 列举一下Swift3.2到Swift4.0的改变(只是我项目中遇到的)：</h3><ul><li>1). Swift4.0中对于扩展的属性(包括实例属性、static属性、class属性)，都只能使用get方法，不可使用set方法</li><li>2). Swift4.0中不再允许复写扩展中的方法(包括实例方法、static方法、class方法)<ul><li>比如:自定义的协议方法在extension中实现,若某个类遵循了该协议,其子类便不能重写该协议方法</li><li>解决的方法是: 在每个需要该协议的类里面都重新遵循该协议,实现协议方法</li><li>个人想到的办法,不知道有没有其他解决办法可以提供一下</li></ul></li><li>3). swift3使用#selector指定的方法，只有当方法权限为private时需要加@objc修饰符，现在Swift4.0全都要加@objc修饰符</li><li><p>4). 自定义的protocol协议中,有optional修饰的非必须实现的方法,需要用@objc修饰</p></li><li><p>5). 字体方面的一些重命名</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSFontAttributeName</span> --- .font </span><br><span class="line"><span class="comment">//或者NSAttributedStringKey.font</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSForegroundColorAttributeName</span> --- .foregroundColor</span><br><span class="line"><span class="comment">//NSAttributedStringKey.foregroundColor</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSStrikethroughStyleAttributeName</span> --- .strikethroughStyle</span><br><span class="line"><span class="comment">//NSAttributedStringKey.strikethroughStyle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串类型的,添加rawValue</span></span><br><span class="line"><span class="built_in">NSAttributedStringKey</span>.font.rawValue</span><br><span class="line"></span><br><span class="line"><span class="comment">//等等等等..........</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大部分类似以下,涉及富文本的方法均已改为了NSAttributedStringKey类型</span></span><br><span class="line">addAttributes(_ attrs: [<span class="built_in">NSAttributedStringKey</span> : Any] = [:], range: <span class="built_in">NSRange</span>)</span><br></pre></td></tr></table></figure><h2 id="三-项目中遇到的一些的报错问题"><a href="#三-项目中遇到的一些的报错问题" class="headerlink" title="三. 项目中遇到的一些的报错问题"></a>三. 项目中遇到的一些的报错问题</h2><h3 id="3-1-“Closure-cannot-implicitly-capture-a-mutating-self-parameter”错误"><a href="#3-1-“Closure-cannot-implicitly-capture-a-mutating-self-parameter”错误" class="headerlink" title="3-1. “Closure cannot implicitly capture a mutating self parameter”错误"></a>3-1. “Closure cannot implicitly capture a mutating self parameter”错误</h3><blockquote><p>在struct中，如果我们在闭包中使用self，就会得到Closure cannot implicitly capture a mutating self parameter的错误提示。比如：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> RecordModel &#123;</span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line">    var action: (() -&gt; ())?</span><br><span class="line">    var height = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.action = &#123; </span><br><span class="line">        <span class="keyword">self</span>.height = <span class="number">20</span> </span><br><span class="line">        <span class="comment">//Closure cannot implicitly capture a mutating self parameter报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="并且由于RecordModel的类型是struct，我们也没发在action闭包里添加截获列表。那么是不是就必须使用class了？答案是否定的。有两种方式可以解决这个问题。"><a href="#并且由于RecordModel的类型是struct，我们也没发在action闭包里添加截获列表。那么是不是就必须使用class了？答案是否定的。有两种方式可以解决这个问题。" class="headerlink" title="++并且由于RecordModel的类型是struct，我们也没发在action闭包里添加截获列表。那么是不是就必须使用class了？答案是否定的。有两种方式可以解决这个问题。++"></a>++并且由于RecordModel的类型是struct，我们也没发在action闭包里添加截获列表。那么是不是就必须使用class了？答案是否定的。有两种方式可以解决这个问题。++</h5></blockquote><h4 id="方案一：为closure增加一个inout类型的参数"><a href="#方案一：为closure增加一个inout类型的参数" class="headerlink" title="方案一：为closure增加一个inout类型的参数"></a>方案一：为closure增加一个inout类型的参数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> RecordModel &#123;</span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line">    var action: ((_ inSelf: <span class="keyword">inout</span> RecordModel) -&gt; ())?</span><br><span class="line">    var height = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.action = &#123; (inSelf) <span class="keyword">in</span></span><br><span class="line">        inSelf.height = <span class="number">20</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure-闭包-中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。"><a href="#根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure-闭包-中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。" class="headerlink" title="根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure(闭包)中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。"></a><em>根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure(闭包)中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。</em></h5></blockquote><h4 id="方案二：使用UnsafeMutablePointer"><a href="#方案二：使用UnsafeMutablePointer" class="headerlink" title="方案二：使用UnsafeMutablePointer"></a>方案二：使用UnsafeMutablePointer<pointee></pointee></h4><ul><li><h5 id="这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。"><a href="#这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。" class="headerlink" title="==这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。=="></a>==这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。==</h5></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> RecordModel &#123;</span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line">    var action: (() -&gt; ())?</span><br><span class="line">    var height = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    let selfPointer = UnsafeMutablePointer(&amp;<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.action = &#123; </span><br><span class="line">        selfPointer.pointee.height = <span class="number">20</span> </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>==Closure cannot implicitly capture a mutating self parameter错误的原因是在进出closure(闭包)之后，self的一致性没办法得到保证，所以编译器默认不允许在struct的closure(闭包)中使用self。如果我们确定这么做是安全的，就可以通过上面的两种方式解决这个问题。其中，方法二的性能更好一些。==</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><h4 id="这里可以记一下指针和swift变量之间的关系："><a href="#这里可以记一下指针和swift变量之间的关系：" class="headerlink" title="这里可以记一下指针和swift变量之间的关系："></a>这里可以记一下指针和swift变量之间的关系：</h4><ul><li>UnsafePointer对应let</li><li>UnsafeMutablePointer对应var</li><li>AutoreleasingUnsafeMutablePointer对应unowned UnsafeMutablePointer，用于inout的参数类型</li><li>UnsafeRawPointer对应let Any，raw系列都是对应相应的Any类型</li><li>UnsafeBufferPointer是non-owning的类型（unowned），用于collection的elements, buffer系列均如此</li></ul></blockquote><h3 id="3-2-Declarations-from-extensions-cannot-be-overridden-yet-错误"><a href="#3-2-Declarations-from-extensions-cannot-be-overridden-yet-错误" class="headerlink" title="3-2. Declarations from extensions cannot be overridden yet 错误"></a>3-2. Declarations from extensions cannot be overridden yet 错误</h3><p>==这个错误大致是因为,协议方法是在extension里面的,不能被重写==</p><blockquote><p>解决办法:(仅供参考,如有更好的建议还望多多指教)</p><ul><li>小编想到的解决办法就是在每一个需要此协议的类里面,重新遵循代理,实现该协议方法</li></ul></blockquote><h3 id="3-3-“Method-‘initialize-’-defines-Objective-C-class-method-‘initialize’-which-is-not-permitted-by-Swift”"><a href="#3-3-“Method-‘initialize-’-defines-Objective-C-class-method-‘initialize’-which-is-not-permitted-by-Swift”" class="headerlink" title="3-3. “Method ‘initialize()’ defines Objective-C class method ‘initialize’, which is not permitted by Swift”"></a>3-3. “Method ‘initialize()’ defines Objective-C class method ‘initialize’, which is not permitted by Swift”</h3><p>==报错原因: 在于已经废弃的initialize方法,示例如下==</p><blockquote><ul><li>方法交叉(Method Swizzling)<ul><li>有时为了方便，也有可能是解决某些框架内的 bug，或者别无他法时，需要修改一个已经存在类的方法的行为。方法交叉可以让你交换两个方法的实现，相当于是用你写的方法来重载原有方法，并且还能够是原有方法的行为保持不变。</li></ul></li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">    public override <span class="keyword">class</span> func initialize() &#123;<span class="comment">//此处报错</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//此处省略100行代码</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>initialize该方法已经被Swift4.0废弃</li><li>在Swift3.0还勉强可以使用,但是会有警告;但是在4.0已经被完全废弃</li></ul><blockquote><p>==替代方法:==</p></blockquote><blockquote><ul><li><strong>在 app delegate 中实现方法交叉</strong></li><li>像上面通过类扩展进行方法交叉，而是简单地在 app delegate 的 application(_:didFinishLaunchingWithOptions:) 方法调用时调用该方法</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extension UIViewController &#123;</span><br><span class="line">    public override class func initializeOnceMethod() &#123;</span><br><span class="line">        </span><br><span class="line">    //此处省略100行代码</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在AppDelegate的方法中调用:</span><br><span class="line">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool &#123;</span><br><span class="line">    //此处省略100行代码</span><br><span class="line">    UIViewController.initializeOnceMethod()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-‘dispatch-once’-is-unavailable-in-Swift-Use-lazily-initialized-globals-instead"><a href="#3-4-‘dispatch-once’-is-unavailable-in-Swift-Use-lazily-initialized-globals-instead" class="headerlink" title="3-4. ‘dispatch_once’ is unavailable in Swift: Use lazily initialized globals instead"></a>3-4. ‘dispatch_once’ is unavailable in Swift: Use lazily initialized globals instead</h3><blockquote><p>报错原因: dispatch_once在Swift4.0也已经被废弃</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UITableView</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> once&#123;</span><br><span class="line">        <span class="keyword">static</span> var onceTaken:Int = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once.onceTaken) &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//在这里dispatch_once就会报错</span></span><br><span class="line">        <span class="comment">//此处省略1000000行代码    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="解决方法-通过给DispatchQueue添加扩展实现"><a href="#解决方法-通过给DispatchQueue添加扩展实现" class="headerlink" title="解决方法: 通过给DispatchQueue添加扩展实现"></a>解决方法: 通过给DispatchQueue添加扩展实现</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extension DispatchQueue &#123;</span><br><span class="line">    private <span class="keyword">static</span> var _onceTracker = [String]()</span><br><span class="line">    public <span class="keyword">class</span> func once(token: String, block: () -&gt; ()) &#123;</span><br><span class="line">        objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line">        defer &#123;</span><br><span class="line">            objc_sync_exit(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _onceTracker.contains(token) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        _onceTracker.append(token)</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func async(block: @escaping ()-&gt;()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.async(execute: block)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func after(time: DispatchTime, block: @escaping ()-&gt;()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.asyncAfter(deadline: time, execute: block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用字符串token作为once的ID，执行once的时候加了一个锁，避免多线程下的token判断不准确的问题。<br>使用的时候可以传token</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.once(token: <span class="string">"tableViewOnce"</span>) &#123;</span><br><span class="line">    print( <span class="string">"Do This Once!"</span> )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>或者使用UUID也可以：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private let _onceToken = <span class="built_in">NSUUID</span>().uuidString</span><br><span class="line">  </span><br><span class="line">DispatchQueue.once(token: _onceToken) &#123;  </span><br><span class="line">    print( <span class="string">"Do This Once!"</span> )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>后续又遇到别的问题会继续更新</li><li>文章中如有解释不足之处,还望多多指教</li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> 入坑指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift4.0 </tag>
            
            <tag> Error </tag>
            
            <tag> 入坑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript基本语法01</title>
      <link href="/2017/08/09/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%9501"/>
      <content type="html"><![CDATA[<blockquote><p>JavaScript 是一门高端的、动态的、弱类型的编程语言，适合面向对象和函数式的编程风格。</p></blockquote><blockquote><p>JavaScript 语法源自 Java，一等函数（first-class function）来自于Scheme，基于原型（prototype-based）的继承来自于Self。</p></blockquote><a id="more"></a><h1 id="一、类型、值和变量"><a href="#一、类型、值和变量" class="headerlink" title="一、类型、值和变量"></a>一、类型、值和变量</h1><h2 id="1、数字"><a href="#1、数字" class="headerlink" title="1、数字"></a>1、数字</h2><ul><li>JavaScript 中不区分整数值和浮点数值，所有数字均用浮点数值表示</li><li>JS采用IEEE754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是±1.7976031348623157×10308，最小值是±5×10-324</li><li>按照JS中的数字格式，能够表示的整数范围是-9007199254740992~9007199254740992（即 -253~253）</li><li>需要注意的是，JS中实际的操作（比如数组索引，位操作符）则是基于32位整数。</li></ul><h3 id="1-1、数字展示格式"><a href="#1-1、数字展示格式" class="headerlink" title="1.1、数字展示格式"></a>1.1、数字展示格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">100000</span><br><span class="line">3.1415</span><br><span class="line">.333333</span><br><span class="line">9.02e10    //9.02 * 10的10次方</span><br><span class="line">1.4E-8     //1.4 * 10的-8次方</span><br></pre></td></tr></table></figure><h3 id="1-2、JavaScript中的算术运算符"><a href="#1-2、JavaScript中的算术运算符" class="headerlink" title="1.2、JavaScript中的算术运算符"></a>1.2、JavaScript中的算术运算符</h3><ul><li>JavaScript用Math对象实现复杂的运算<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2,3)   //8；2的3次幂</span><br><span class="line">Math.round(.6)  //1.0；四舍五入</span><br><span class="line">Math.ceil(.6)   //1.0；向上取整</span><br><span class="line">Math.floor(.6)  //0.0；向下取整</span><br><span class="line">Math.abs(-5)    //5；求绝对值</span><br><span class="line">Math.max(x,y,z) //返回最大值</span><br><span class="line">Math.min(x,y,z) //返回最小值</span><br><span class="line">Math.random()   //生成一个大于等于0小于1.0的伪随机数</span><br><span class="line">Math.PI         //π；圆周率</span><br><span class="line">Math.E          //e；自然对数的底数</span><br><span class="line">Math.sqrt(3)    //3的平方根</span><br><span class="line">Math.pow(3,1/3) //3的立方根</span><br><span class="line">Math.sin(0)     //三角函数。Math.cos(),Math.tan(),Math.sin(30/180*Math.PI) </span><br><span class="line">Math.log(10)    //10的自然对数</span><br><span class="line">Math.log(100)/Math.LN10 //以10为底100的对数</span><br><span class="line">Math.log(512)/Math.LN2 //以2为底512的对数</span><br><span class="line">Math.exp(3)     //e的3次幂</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3、日期和时间"><a href="#1-3、日期和时间" class="headerlink" title="1.3、日期和时间"></a>1.3、日期和时间</h3><ul><li>Date()构造函数，用于创建表示日期和时间的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var then=new Date(2017,0,1);          //2017年1月1日</span><br><span class="line">var later=new Date(2017,0,1,17,10,30);//2017年1月1日 17:10:30</span><br><span class="line">var now=new Date();   //当前日期和时间</span><br><span class="line">var elapsed=now-then; //日期减法，计算时间间隔的毫秒数</span><br><span class="line">later.getFullYear();  //获取年份</span><br><span class="line">later.getMonth();     //获取月份，从0开始计数，一月份是0</span><br><span class="line">later.getDate();      //获取日期，从1开始计数，一号是1</span><br><span class="line">later.getDay();       //星期几，0是星期日，5是星期五</span><br><span class="line">later.getHours();     //获取小时</span><br><span class="line">later.getMinutes();   //获取分钟</span><br><span class="line">later.getSeconds();   //获取秒</span><br><span class="line">later.getUTCHours();  //获取使用UTC表示的小时的时间</span><br></pre></td></tr></table></figure><h1 id="二、文本字符串"><a href="#二、文本字符串" class="headerlink" title="二、文本字符串"></a>二、文本字符串</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line">var jsString = <span class="string">"Hello,JavaScript"</span>;</span><br><span class="line"><span class="comment">//字符串长度</span></span><br><span class="line">var s0 = jsString.length;  <span class="comment">//16,</span></span><br><span class="line"><span class="comment">// 第一个字符</span></span><br><span class="line">var s1 = jsString.charAt(<span class="number">0</span>) ; <span class="comment">//"H",</span></span><br><span class="line"><span class="comment">// 最后一个字符</span></span><br><span class="line">var s2 = jsString.charAt(s0 - <span class="number">1</span>)  <span class="comment">//"t",</span></span><br><span class="line"><span class="comment">//第2~4个字符</span></span><br><span class="line">var s3 = jsString.substring(<span class="number">1</span>, <span class="number">4</span>) <span class="comment">//"ell",</span></span><br><span class="line"><span class="comment">//第2~4个字符</span></span><br><span class="line">var s4 = jsString.slice(<span class="number">1</span>, <span class="number">4</span>)  <span class="comment">//"ell"</span></span><br><span class="line"><span class="comment">// 最后三个字符</span></span><br><span class="line">var s5 = jsString.slice(<span class="number">-3</span>)  <span class="comment">//"ipt"</span></span><br><span class="line"><span class="comment">// 字符"a"首次出现的位置</span></span><br><span class="line">var s6 = jsString.indexOf(<span class="string">"a"</span>)  <span class="comment">//7</span></span><br><span class="line"><span class="comment">// 字符"a"最后一次出现的位置</span></span><br><span class="line">var s7 = jsString.lastIndexOf(<span class="string">"a"</span>)  <span class="comment">//9</span></span><br><span class="line"><span class="comment">// 字符"a"第二次出现的位置</span></span><br><span class="line">var s8 = jsString.indexOf(<span class="string">"a"</span>, <span class="number">2</span>)  <span class="comment">//7</span></span><br><span class="line"><span class="comment">// 字符串分割成数组</span></span><br><span class="line">var s9 = jsString.split(<span class="string">","</span>)    <span class="comment">//["Hello", "JavaScript"]</span></span><br><span class="line"><span class="comment">// 全文字符替换</span></span><br><span class="line">var s10 = jsString.replace(<span class="string">"e"</span>, <span class="string">"E"</span>)  <span class="comment">//"HEllo,JavaScript"</span></span><br><span class="line"><span class="comment">// 全文转换为大写</span></span><br><span class="line">var s11 = jsString.toUpperCase()  <span class="comment">//"HELLO,JAVASCRIPT"</span></span><br><span class="line"><span class="comment">// 全文转换成小写</span></span><br><span class="line">var s12 = jsString.toLowerCase()  <span class="comment">//"hello,javascript"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试输出结果</span></span><br><span class="line">var sArr = [s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]</span><br><span class="line"><span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; sArr.length; i++) &#123;</span><br><span class="line">    console.log(sArr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、JavaScript之数组"><a href="#三、JavaScript之数组" class="headerlink" title="三、JavaScript之数组"></a>三、JavaScript之数组</h1><ul><li>数组是值的有序集合</li><li>JavaScript数组事务类型的:数组元素可以使任何类型, 同一数组中的不同元素也可以是不同类型</li><li>数组的元素也可以是对象或者其他数组</li><li>JavaScript数组可能是稀疏的: 数组元素的索引不一定是连续的,之间可能有空缺</li><li>稀疏数组的length比任何元素的索引都要大</li></ul><h2 id="1-创建数组-直接量创建"><a href="#1-创建数组-直接量创建" class="headerlink" title="1.创建数组(直接量创建)"></a>1.创建数组(直接量创建)</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.1: 简单数组</span></span><br><span class="line">var empty = [];   <span class="comment">//空数组</span></span><br><span class="line">var pram = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]  <span class="comment">//有三个数值的数组</span></span><br><span class="line">var misc = [<span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">"a"</span>] <span class="comment">//三个不同元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2: 数组中的直接量不一定是常量,也可能是表达式</span></span><br><span class="line">var base = <span class="number">1024</span></span><br><span class="line">var baseArr = [base, base + <span class="number">1</span>, base + <span class="number">2</span>, base + <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.3: 包含对象或数组</span></span><br><span class="line">var array3 = [[<span class="number">1</span>, &#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;], [<span class="number">2</span>, &#123;x: <span class="number">3</span>, y: <span class="number">4</span>&#125;]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.4: 忽略中间量中的某个值,省略的元素将被赋予undefined</span></span><br><span class="line">var undef1 = [<span class="number">1</span>, ,<span class="number">3</span>] <span class="comment">//三个元素,中间的为undefined</span></span><br><span class="line">var undef2 = [, ,] <span class="comment">//2个元素都是undefined</span></span><br><span class="line"><span class="comment">//注: 数组直接量的语法允许游客选的结尾的逗号,故[, ,]只有2个元素</span></span><br></pre></td></tr></table></figure><h2 id="2-Array-创建数组"><a href="#2-Array-创建数组" class="headerlink" title="2. Array()创建数组"></a>2. Array()创建数组</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空数组</span></span><br><span class="line">var a = new Array()</span><br><span class="line"><span class="comment">//指定数组长度</span></span><br><span class="line">var a1 = new  Array(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//显示创建</span></span><br><span class="line">var a2 = new  Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"a"</span>)</span><br></pre></td></tr></table></figure><h2 id="3-数组操作"><a href="#3-数组操作" class="headerlink" title="3. 数组操作"></a>3. 数组操作</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 读写数组元素</span></span><br><span class="line"><span class="comment">//注: 1.数组是对象的特殊形式,故JavaScript的数组不存在越界报错的情况,只会取到undefined</span></span><br><span class="line">var value = a2[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 数组的长度</span></span><br><span class="line"><span class="comment">//length属性为可读可写</span></span><br><span class="line">var arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">var arrLength = arr.length  <span class="comment">//6</span></span><br><span class="line">arr.length = <span class="number">4</span>   <span class="comment">//数组变为[1, 2, 3, 4]</span></span><br><span class="line">arr.length = <span class="number">0</span>  <span class="comment">// 删除所有元素,为[]</span></span><br><span class="line">arr.length = <span class="number">5</span>  <span class="comment">// 长度为5,但是没有元素,相当于new Array(5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 数组元素的添加和删除</span></span><br><span class="line"><span class="comment">//5.1: 索引值添加</span></span><br><span class="line">var a0 = []</span><br><span class="line">a0[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">a0[<span class="number">1</span>] = <span class="string">"one"</span></span><br><span class="line"><span class="comment">//a0为[3, "one"]</span></span><br></pre></td></tr></table></figure><h2 id="6-数组的方法"><a href="#6-数组的方法" class="headerlink" title="6. 数组的方法"></a>6. 数组的方法</h2><ul><li>主要介绍ECMAScript中的方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.1: join()</span></span><br><span class="line"><span class="comment">/*注:</span></span><br><span class="line"><span class="comment">0.不改变原数组</span></span><br><span class="line"><span class="comment">1.将数组所有的元素都转化成字符串,并连接在一起,返回生成后的字符串(如不指定分隔符默认使用逗号)</span></span><br><span class="line"><span class="comment">2.join是String.split()的逆向操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">var arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">var join1 = arr0.join() <span class="comment">// "1,2,3,4"</span></span><br><span class="line">var join2 = arr0.join(<span class="string">""</span>) <span class="comment">//"1234"</span></span><br><span class="line">var join3 = arr0.join(<span class="string">"-"</span>)  <span class="comment">//"1-2-3-4"</span></span><br><span class="line">console.log(join1,join2,join3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.2: reverse()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0.改变原数组</span></span><br><span class="line"><span class="comment">1.将数组中的元素颠倒顺序*/</span></span><br><span class="line">arr0.reverse()  <span class="comment">//现在arr0为[4, 3, 2, 1]</span></span><br><span class="line">console.log(arr0)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.3: sort()排序</span></span><br><span class="line"><span class="comment">/*注:</span></span><br><span class="line"><span class="comment">0.改变原数组</span></span><br><span class="line"><span class="comment">1.不带参数时,以字母表顺序排序</span></span><br><span class="line"><span class="comment">2.如果数组包含undefined,则会被排到数组的末尾</span></span><br><span class="line"><span class="comment">3.字母排序区分大小写,A &lt; a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">var arr1 = new Array(<span class="string">"tian"</span>, <span class="string">"quan"</span>, <span class="string">"jun"</span>)</span><br><span class="line">arr1.sort() <span class="comment">//arr1 = ["jun", "quan", "tian"]</span></span><br><span class="line">console.log(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件比较</span></span><br><span class="line">var  arr2 = new Array(<span class="string">"ant"</span>, <span class="string">"Bug"</span>, <span class="string">"cat"</span>, <span class="string">"Dog"</span>)</span><br><span class="line">arr2.sort()  <span class="comment">//["Bug", "Dog", "ant", "cat"]</span></span><br><span class="line">console.log(arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不区分大小写排序</span></span><br><span class="line">arr2.sort(function (s, t) &#123;</span><br><span class="line">    var a = s.toLowerCase()</span><br><span class="line">    var b = t.toLowerCase()</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2)</span><br><span class="line"><span class="comment">//["ant", "Bug", "cat", "Dog"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.4: concat()创建并返回一个新数组</span></span><br><span class="line"><span class="comment">//0.不改变原数组</span></span><br><span class="line">var arr4 = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">var concat1 = arr4.concat() <span class="comment">//[0, 2, 3]</span></span><br><span class="line">var concat2 = arr4.concat(<span class="number">1</span>, <span class="number">4</span>)  <span class="comment">//[0, 2, 3, 1, 4]</span></span><br><span class="line">var concat3 = arr4.concat([<span class="number">1</span>, <span class="number">4</span>]) <span class="comment">//[0, 2, 3, 1, 4]</span></span><br><span class="line">var concat4 = arr4.concat([<span class="number">1</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]) <span class="comment">//[0, 2, 3, 1, 4, 5, 6]</span></span><br><span class="line">var concat5 = arr4.concat(<span class="number">1</span>, [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]) <span class="comment">//[0, 2, 3, 1, 4, [5, 6]]</span></span><br><span class="line">var concatArr = [concat1, concat2, concat3, concat4, concat5]</span><br><span class="line">console.log(concatArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.5: slice()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意:</span></span><br><span class="line"><span class="comment">* 1.返回数组的部分数组</span></span><br><span class="line"><span class="comment">* 2.不改变原数组</span></span><br><span class="line"><span class="comment">* 3.两个参数,分别表示始末位置,含左不含右</span></span><br><span class="line"><span class="comment">* 4. 1表示第一个元素,-1表示倒数第一个元素</span></span><br><span class="line"><span class="comment">* 5.只有一个参数,默认以此参数开始,到最后一个元素结束</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var slice1 = arr3.slice(<span class="number">0</span>,<span class="number">2</span>) <span class="comment">//[1, 2]</span></span><br><span class="line">var slice2 = arr3.slice(<span class="number">3</span>) <span class="comment">//[4, 5]</span></span><br><span class="line">var slice3 = arr3.slice(<span class="number">1</span>,<span class="number">-2</span>) <span class="comment">//[2, 3]</span></span><br><span class="line">var slice4 = arr3.slice(<span class="number">-3</span>,<span class="number">-2</span>)  <span class="comment">//[3]</span></span><br><span class="line">var sliceArr = [slice1, slice2, slice3, slice4]</span><br><span class="line">console.log(sliceArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.6: splice()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.在数组中插入或删除元素的通用方法</span></span><br><span class="line"><span class="comment">* 2.会修改原数组,会改变数组的索引值</span></span><br><span class="line"><span class="comment">* 3.两个参数,参数一:起始位置;参数二:处理元素的个数(可省略)</span></span><br><span class="line"><span class="comment">* 4.若省略第二个参数,默认从起始位置到最后</span></span><br><span class="line"><span class="comment">* 5.如果没有元素就返回空数组</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var m = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">var splice1 = m.splice(<span class="number">4</span>)  <span class="comment">//返回[5, 6, 7], m 是[1, 2, 3, 4]</span></span><br><span class="line">console.log(m)</span><br><span class="line">var splice2 = m.splice(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">//返回[2, 3], m 是[1, 4]</span></span><br><span class="line">console.log(m)</span><br><span class="line">var splice3 = m.splice(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">//返回[4], m 是[1]</span></span><br><span class="line">console.log(m)</span><br><span class="line">var spliceArr = [splice1, splice2, splice3]</span><br><span class="line">console.log(spliceArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.7: push()和pop()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方法将数组当成栈使用</span></span><br><span class="line"><span class="comment">* 1.push方法在尾部添加一个或者多个元素,返回新的数组长度</span></span><br><span class="line"><span class="comment">* 2.pop删除数组的最后一个元素,减小数组的长度,返回删除的值</span></span><br><span class="line"><span class="comment">* 3.改变原数组的值和长度</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var m0 = []</span><br><span class="line">var pp1 = m0.push(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">//[1, 2], 返回2</span></span><br><span class="line">var pp2 = m0.pop()       <span class="comment">//[1], 返回2</span></span><br><span class="line">var pp3 = m0.push(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment">//[1, 3, 4], 返回3</span></span><br><span class="line">var pp4 = m0.pop()       <span class="comment">//[1, 3],  返回4</span></span><br><span class="line">var pp5 = m0.push([<span class="number">9</span>,<span class="number">0</span>]) <span class="comment">//[1, 3, [9, 0]], 返回3</span></span><br><span class="line">var pp6 = m0.pop()       <span class="comment">//[1, 3], 返回[9, 0]</span></span><br><span class="line">var pp7 = m0.pop()       <span class="comment">//[1], 返回3</span></span><br><span class="line">var ppArr = [pp1, pp2, pp3, pp4, pp5, pp6, pp7]</span><br><span class="line">console.log(ppArr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.8: unshift()和shift()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.unshift在头部添加一个或者多个元素,返回长度</span></span><br><span class="line"><span class="comment">* 2.shift删除数组的第一个元素,返回删除的元素</span></span><br><span class="line"><span class="comment">* 3.改变原数组,改变原数组的索引</span></span><br><span class="line"><span class="comment">* 4.unshift插入多个元素时,试一次性插入的</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var sh = []</span><br><span class="line">var sh1 = sh.unshift(<span class="number">1</span>)  <span class="comment">//sh: [1], 返回: 1</span></span><br><span class="line">var sh2 = sh.unshift(<span class="number">22</span>) <span class="comment">//sh: [1, 22], 返回: 2</span></span><br><span class="line">var sh3 = sh.shift()     <span class="comment">//sh: [22], 返回: 22</span></span><br><span class="line">var sh4 = sh.unshift(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]) <span class="comment">//sh: [3, [4, 5], 1], 返回:  3</span></span><br><span class="line">var sh5 = sh.shift()      <span class="comment">//sh: [[4, 5], 1], 返回: 3</span></span><br><span class="line">var sh6 = sh.shift()      <span class="comment">//sh: [1], 返回: [4, 5]</span></span><br><span class="line">var shiftArr = [sh1, sh2, sh3, sh4, sh5, sh6]</span><br><span class="line">console.log(shiftArr)</span><br><span class="line"><span class="comment">//注: unshift插入多个元素时,试一次性插入的,例如:</span></span><br><span class="line">sh.unshift(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 结果: [3, 4]</span></span><br><span class="line">sh.unshift(<span class="number">3</span>)</span><br><span class="line">sh.unshift(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//结果: [4, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.9: toString()和toLocalString()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.toString()将数组元素转化成字符串后,用都好链接输出</span></span><br><span class="line"><span class="comment">* 2.toString()和join()不加参数的返回的值是一样的</span></span><br><span class="line"><span class="comment">* 3.toLocalString()是toString()的本地化版本</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var str0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString() <span class="comment">//返回: "1,2,3"</span></span><br><span class="line">var str1 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].toString()  <span class="comment">//返回: "a,b,c"</span></span><br><span class="line">var str2 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="string">"c"</span>]].toString()  <span class="comment">//返回: "1,2,c"</span></span><br><span class="line">var str3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toLocaleString()  <span class="comment">//返回: "1,2,3"</span></span><br><span class="line">var strArr = [str0, str1, str2, str3, str4]</span><br><span class="line">console.log(strArr)</span><br></pre></td></tr></table></figure><h3 id="7-ECMAScript5中数组的方法"><a href="#7-ECMAScript5中数组的方法" class="headerlink" title="7. ECMAScript5中数组的方法"></a>7. ECMAScript5中数组的方法</h3><ul><li>1.ECMAScript5定义了九个新的数组方法</li><li>2.大多数ECMAScript5数组方法的第一个参数是一个函数</li><li>2.第二个参数是可选的,如果有,则调用的函数被看作是第二个参数的方法</li><li>3.也就是说在调用函数时,传递进去的第二个参数作为它的this关键字的值来使用</li><li>4.ECMAScript5中的数组方法不会修改他们调用的原始数组</li><li>5.传递给这些方法的函数是可以改变这些数组的</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.1: forEach()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.方法从头到尾遍历数组,为每个元素调用指定的函数</span></span><br><span class="line"><span class="comment">* 2.forEach使用三个参数调用该函数:数组元素,元素索引, 数组本身</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var data1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">var sum = <span class="number">0</span></span><br><span class="line">data1.forEach(function (value) &#123;</span><br><span class="line">    sum += value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每个元素本身自加1</span></span><br><span class="line">data1.forEach(function (value, i, arr) &#123;</span><br><span class="line">    arr[i] = value + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.2: map()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.返回一个新数组,不改变原数组</span></span><br><span class="line"><span class="comment">* 2.原数组若是稀疏数组,返回也是稀疏数组</span></span><br><span class="line"><span class="comment">* 3.具有相同的长度,相同的缺失元素</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var arr2 = data1.map(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [4, 9, 16, 25, 36]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.3: filter()逻辑判定,过滤数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.返回原数组的一个子集</span></span><br><span class="line"><span class="comment">* 2.返回原数组符合条件的元素,组成新数组</span></span><br><span class="line"><span class="comment">* 3.会将稀疏数组压缩,返回的是稠密数组</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var arr3 = data1.filter(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">var data2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var arr4 = data2.filter(function (i) &#123;</span><br><span class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[2, 4]</span></span><br><span class="line"></span><br><span class="line">var data3 = [<span class="number">1</span>, <span class="number">2</span>, , , null, <span class="number">5</span>]</span><br><span class="line">var arr5 = data3.filter(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== undefined &amp;&amp; x != null</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr5)</span><br><span class="line"><span class="comment">//[1, 2, 5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.4: every()和some()数组的逻辑判定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.对数组元素应用指定的函数进行判定</span></span><br><span class="line"><span class="comment">* 2.返回trur或者false</span></span><br><span class="line"><span class="comment">* 2.every()都为true返回true,否则返回false</span></span><br><span class="line"><span class="comment">* 3.some()都为false,返回false;有一个为true,返回true</span></span><br><span class="line"><span class="comment">* 4.一旦该方法确定了返回值,就会停止遍历数组</span></span><br><span class="line"><span class="comment">* 5.空数组,every()返回true,some()返回false</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var data4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var sum1 = data4.every(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//sum1 = true</span></span><br><span class="line">var sum2 = data4.every(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//sum2 = false</span></span><br><span class="line"></span><br><span class="line">var sum3 = data4.some(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//sum3 = true</span></span><br><span class="line">var sum4 = data4.some(isNaN)</span><br><span class="line"><span class="comment">//sum4 = false, data4不包含非整数值元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.5: reduce()和reduceRigh()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 作用: 将数组元素进行组合生成单个值</span></span><br><span class="line"><span class="comment">* 1.reduce()需要两个参数;参数一:执行操作的函数;参数二:传递给函数的初始值</span></span><br><span class="line"><span class="comment">* 2.reduceRight()是倒叙操作,功能与reduce相同</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var data5 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var sn0 = data5.reduce(function (x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"></span><br><span class="line">var sn1 = data5.reduce(function (x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line">&#125;, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//120</span></span><br><span class="line"></span><br><span class="line">var sn2 = data5.reduce(function (x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.6: indexOf()和lastIndexOf()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.搜索整个数组中具有给定值的元素,返回找到的第一个元素的索引,如果没有找到就返回-1</span></span><br><span class="line"><span class="comment">* 2.indexOf(),从前向后搜索,lastIndexOf()从后向前搜索</span></span><br><span class="line"><span class="comment">* 3.参数一:元素值; 参数二: 搜索的起始位置(可省略,默认从头开始)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var data6 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">var index1 = data6.indexOf(<span class="number">1</span>) <span class="comment">//1, data6[1] = 1</span></span><br><span class="line">var index2 = data6.indexOf(<span class="number">3</span>) <span class="comment">//-1, 没有值为3的元素</span></span><br><span class="line">var index3 = data6.lastIndexOf(<span class="number">1</span>) <span class="comment">//3, data6[3] = 1</span></span><br><span class="line">var index4 = data6.indexOf(<span class="number">2</span>, <span class="number">1</span>)<span class="comment">//2, data6[2] = 2</span></span><br><span class="line">var index5 = data6.lastIndexOf(<span class="number">2</span>, <span class="number">-1</span>)<span class="comment">//2, data6[2] = 2</span></span><br></pre></td></tr></table></figure><h2 id="8-判定一个位置对象是否为数组"><a href="#8-判定一个位置对象是否为数组" class="headerlink" title="8. 判定一个位置对象是否为数组"></a>8. 判定一个位置对象是否为数组</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var data = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// var isA = data.isArray()</span></span><br><span class="line">console.log(data.isArray())</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift4.0新特性之String、Array和Dictionary</title>
      <link href="/2017/07/19/Swift4.0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BString%E3%80%81Array%E5%92%8CDictionary"/>
      <content type="html"><![CDATA[<blockquote><ul><li>推荐: <a href="https://www.cnswift.org" target="_blank" rel="noopener">Swift 编程语言</a></li><li>原文链接: <a href="https://www.raywenderlich.com/163857/whats-new-swift-4" target="_blank" rel="noopener">What’s New in Swift 4?</a></li><li>Guards翻译组: <a href="http://www.jianshu.com/p/3bedf1de5cb3" target="_blank" rel="noopener">中文地址</a></li></ul></blockquote><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><hr><h4 id="Swift-4是苹果计划在2017年秋季推出的最新版本，值得关注的是其提供了与Swift-3代码很好的兼容性，并最大限度的保持了ABI稳定性"><a href="#Swift-4是苹果计划在2017年秋季推出的最新版本，值得关注的是其提供了与Swift-3代码很好的兼容性，并最大限度的保持了ABI稳定性" class="headerlink" title="Swift 4是苹果计划在2017年秋季推出的最新版本，值得关注的是其提供了与Swift 3代码很好的兼容性，并最大限度的保持了ABI稳定性."></a>Swift 4是苹果计划在2017年秋季推出的最新版本，值得关注的是其提供了与Swift 3代码很好的兼容性，并最大限度的保持了ABI稳定性.</h4><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><blockquote><p>字符串已经像之前的2.0版一样, 改为了Collection类型 。此变化消除了字符串对字符数组的依赖</p></blockquote><h3 id="0-创建空字符串的两种方式-可用isEmpty判断是否为空"><a href="#0-创建空字符串的两种方式-可用isEmpty判断是否为空" class="headerlink" title="0.创建空字符串的两种方式,可用isEmpty判断是否为空"></a>0.创建空字符串的两种方式,可用isEmpty判断是否为空</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let SwiftString = &quot;Hello&quot;</span><br><span class="line">var emptyString = &quot;&quot;               // empty string literal</span><br><span class="line">var anotherEmptyString = String()</span><br></pre></td></tr></table></figure><h3 id="1-字符和字符串"><a href="#1-字符和字符串" class="headerlink" title="1.字符和字符串"></a>1.字符和字符串</h3><h4 id="1-1-遍历字符串"><a href="#1-1-遍历字符串" class="headerlink" title="1.1 遍历字符串"></a>1.1 遍历字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for char in SwiftString &#123;</span><br><span class="line">    print(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2通过-Character类型创建单个字符"><a href="#1-2通过-Character类型创建单个字符" class="headerlink" title="1.2通过 Character类型创建单个字符"></a>1.2通过 Character类型创建单个字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let char : Character = &quot;H&quot;</span><br></pre></td></tr></table></figure><h4 id="1-3-String值可以通过传入-Character来构造："><a href="#1-3-String值可以通过传入-Character来构造：" class="headerlink" title="1.3 String值可以通过传入 Character来构造："></a>1.3 String值可以通过传入 Character来构造：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let charArr : [Character] = [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</span><br><span class="line">print(String(char)) // H</span><br><span class="line">print(String(charArr)) // Hello</span><br></pre></td></tr></table></figure><h4 id="1-4-拼接字符串"><a href="#1-4-拼接字符串" class="headerlink" title="1.4 拼接字符串"></a>1.4 拼接字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//方式一:</span><br><span class="line">let addString = String(charArr) + String(char) //HelloH</span><br><span class="line">//方式二:</span><br><span class="line">var addString2 = &quot;Why&quot;</span><br><span class="line">addString2 += String(charArr) //&quot;WhyHello&quot;</span><br></pre></td></tr></table></figure><h3 id="2-字符串个数"><a href="#2-字符串个数" class="headerlink" title="2.字符串个数"></a>2.字符串个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let count1 = SwiftString.count //5(类型: String.CharacterView.IndexDistance)</span><br><span class="line">let count2 = SwiftString.characters.count // 5(Int型)</span><br><span class="line">count1:</span><br></pre></td></tr></table></figure><h3 id="3-是否为空"><a href="#3-是否为空" class="headerlink" title="3.是否为空"></a>3.是否为空</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let isStr = SwiftString.isEmpty //false</span><br></pre></td></tr></table></figure><h3 id="4-去掉某一个或几个字符"><a href="#4-去掉某一个或几个字符" class="headerlink" title="4.去掉某一个或几个字符"></a>4.去掉某一个或几个字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let text1 = SwiftString.dropFirst()//&quot;ello&quot;</span><br><span class="line">let text2 = SwiftString.dropLast()//&quot;Hell&quot;</span><br><span class="line">let text3 = SwiftString.dropFirst(2)//&quot;llo&quot;</span><br><span class="line">let text4 = SwiftString.dropLast(2)//&quot;Hel&quot;</span><br><span class="line">//注:以上皆为String.SubSequence类型</span><br><span class="line">let text5 = String(text1) //&quot;ello&quot;---text5为String类型</span><br></pre></td></tr></table></figure><h3 id="5-倒叙"><a href="#5-倒叙" class="headerlink" title="5.倒叙"></a>5.倒叙</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let text6 = String(SwiftString.reversed()) //&quot;olleH&quot;</span><br></pre></td></tr></table></figure><h3 id="6-字符串分割数组"><a href="#6-字符串分割数组" class="headerlink" title="6.字符串分割数组"></a>6.字符串分割数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let swiftString2 = &quot;one two three&quot;</span><br><span class="line">let StrArr = swiftString2.split(separator: &quot; &quot;) //[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span><br><span class="line">//let StrArr: [String.SubSequence]</span><br></pre></td></tr></table></figure><h3 id="7-删除不符合ASCII编码的字符"><a href="#7-删除不符合ASCII编码的字符" class="headerlink" title="7.删除不符合ASCII编码的字符"></a>7.删除不符合ASCII编码的字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let swiftString3 = &quot;quanjun 🐷,&quot;</span><br><span class="line">let qj = swiftString3.filter &#123; (char) -&gt; Bool in</span><br><span class="line">    return char.unicodeScalars.reduce(true, &#123; $0 &amp;&amp; $1.isASCII &#125;)</span><br><span class="line">&#125;</span><br><span class="line">print(qj)  //&quot;quanjun ,&quot;</span><br></pre></td></tr></table></figure><h3 id="8-字符串索引"><a href="#8-字符串索引" class="headerlink" title="8. 字符串索引"></a>8. 字符串索引</h3><ul><li>Swift 的字符串不能通过整数值索引</li><li>使用 index(before:) 和 index(after:) 方法来访问给定索引的前后。要访问给定索引更远的索引，你可以使用 index(_:offsetBy:) 方法而不是多次调用这两个方法。</li><li>Swift 4添加了Substring类型，用于引用String的子序列。</li><li>String和Substring都实现了StringProtocol，两者几乎具有相同的功能：</li></ul><h4 id="8-1-startIndex和endIndex"><a href="#8-1-startIndex和endIndex" class="headerlink" title="8.1 startIndex和endIndex"></a>8.1 startIndex和endIndex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let greeting = &quot;Guten Tag!&quot;</span><br><span class="line">//startIndex属性来访问 String中第一个 Character的位置</span><br><span class="line">print(greeting[greeting.startIndex])</span><br><span class="line">print(greeting[greeting.index(after: greeting.startIndex)])</span><br><span class="line">//endIndex属性就是 String中最后一个字符后的位置。endIndex属性并不是字符串下标脚本的合法实际参数</span><br><span class="line">//greeting[greeting.endIndex] //会报错</span><br><span class="line">print(greeting[greeting.index(before: greeting.endIndex)])</span><br><span class="line">//注: 如果 String为空，则 startIndex与 endIndex相等</span><br><span class="line"></span><br><span class="line">let index = greeting.index(greeting.startIndex, offsetBy: 2)</span><br><span class="line">print(greeting[index])</span><br><span class="line">let indesString = greeting[greeting.startIndex...index]  //&quot;Gut&quot;</span><br><span class="line">//注:indesString : Substring类型</span><br><span class="line">print(String(indesString)) //&quot;Gut&quot;</span><br></pre></td></tr></table></figure><h4 id="8-2使用-characters属性的-indices属性来创建所有能够用来访问字符串中独立字符的索引范围-Range。"><a href="#8-2使用-characters属性的-indices属性来创建所有能够用来访问字符串中独立字符的索引范围-Range。" class="headerlink" title="8.2使用 characters属性的 indices属性来创建所有能够用来访问字符串中独立字符的索引范围 Range。"></a>8.2使用 characters属性的 indices属性来创建所有能够用来访问字符串中独立字符的索引范围 Range。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for index in greeting.characters.indices &#123;</span><br><span class="line">    print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)//不换行输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-多行字符串"><a href="#9-多行字符串" class="headerlink" title="9.多行字符串"></a>9.多行字符串</h3><ul><li>注:你可以在多行字面量中使用单个双引号 “ 。要在多行字符串中包含 “”” ，你必须用反斜杠（ \ ）转义至少其中一个双引号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let rowsString = &quot;&quot;&quot;</span><br><span class="line">                我是一只小鸭子</span><br><span class="line">                咿呀咿呀哟</span><br><span class="line">                \&quot;&quot;&quot;</span><br><span class="line">                &quot;&quot;&quot;</span><br><span class="line">print(rowsString)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul><li>Swift 的 Array类型被桥接到了基础框架的 NSArray类上。</li><li>Swift 数组的类型完整写法是 Array<element>， Element是数组允许存入的值的类型。你同样可以简写数组的类型为 [Element]。</element></li></ul><h3 id="1-创建确定大小且元素都设定为相同默认值的数组。"><a href="#1-创建确定大小且元素都设定为相同默认值的数组。" class="headerlink" title="1. 创建确定大小且元素都设定为相同默认值的数组。"></a>1. 创建确定大小且元素都设定为相同默认值的数组。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*Array*/</span><br><span class="line">//默认值（叫做 repeating）和新数组元素的数量（叫做 count)</span><br><span class="line">var array1 = Array(repeating: 1, count: 2)</span><br><span class="line">var array2 = Array(repeating: 3, count: 2)</span><br></pre></td></tr></table></figure><h4 id="2-连接两个数组来创建数组-类型必须一致"><a href="#2-连接两个数组来创建数组-类型必须一致" class="headerlink" title="2. 连接两个数组来创建数组(类型必须一致)"></a>2. 连接两个数组来创建数组(类型必须一致)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array3 = array1 + array2</span><br><span class="line">print(array3) //[1, 1, 3, 3]</span><br></pre></td></tr></table></figure><h4 id="3-数组个数"><a href="#3-数组个数" class="headerlink" title="3. 数组个数"></a>3. 数组个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(array3.count)  //5</span><br></pre></td></tr></table></figure><h4 id="4-判断数组个数是否为0"><a href="#4-判断数组个数是否为0" class="headerlink" title="4. 判断数组个数是否为0"></a>4. 判断数组个数是否为0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(array3.isEmpty)  //false</span><br><span class="line">print(array3.count == 0)  //false</span><br></pre></td></tr></table></figure><h4 id="5-添加"><a href="#5-添加" class="headerlink" title="5. 添加"></a>5. 添加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array3.append(4) //[1, 1, 3, 3, 4]</span><br><span class="line">array3 += [5]  //[1, 1, 3, 3, 4, 5]</span><br><span class="line">array3 += [6, 5]  //[1, 1, 3, 3, 4, 5, 6, 5]</span><br></pre></td></tr></table></figure><h4 id="6-取值"><a href="#6-取值" class="headerlink" title="6. 取值"></a>6. 取值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(array3[0]) // 1</span><br><span class="line">array3[1] = 9 // [1, 9, 3, 3, 4, 5, 6, 5]</span><br><span class="line"></span><br><span class="line">//用下标改变一个范围的值，就算替换与范围长度不同的值的合集也行</span><br><span class="line">array3[2...4] = [0, 8] //[1, 9, 0, 8, 5, 6, 5]</span><br></pre></td></tr></table></figure><h4 id="7-遍历"><a href="#7-遍历" class="headerlink" title="7.遍历"></a>7.遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for item in array3 &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br><span class="line">//元组输出</span><br><span class="line">for (index, item) in array3.enumerated() &#123;</span><br><span class="line">    print(&quot;\(index)---\(item)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//倒叙输出</span><br><span class="line">for item in array3.reversed() &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//forEach遍历,如同for-in</span><br><span class="line">let arr = [1, 9, 3, 3, 4, 5, 6, 5]</span><br><span class="line">arr.forEach &#123; (x) in</span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-删除和插入"><a href="#8-删除和插入" class="headerlink" title="8. 删除和插入"></a>8. 删除和插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array3.remove(at: 1)  //[1, 0, 8, 5, 6, 5]</span><br><span class="line">array3.removeFirst()  //[0, 8, 5, 6, 5]</span><br><span class="line">array3.removeLast()   //[0, 8, 5, 6]</span><br><span class="line">array3.removeFirst(2) //[5,6]</span><br><span class="line">array3.removeLast(1)  //[5]</span><br><span class="line">array3.removeAll()    //[]</span><br></pre></td></tr></table></figure><h2 id="Dictionary-and-Set"><a href="#Dictionary-and-Set" class="headerlink" title="Dictionary and Set"></a>Dictionary and Set</h2><ul><li>至于Collection类型，Set和Dictionary并不那么最直观的</li><li>Swift 的 Dictionary桥接到了基础框架的 NSDictionary类。<h4 id="1-首先列表可以是从一系列键值对（元组）创建一个字典"><a href="#1-首先列表可以是从一系列键值对（元组）创建一个字典" class="headerlink" title="1.首先列表可以是从一系列键值对（元组）创建一个字典:"></a>1.首先列表可以是从一系列键值对（元组）创建一个字典:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dictionary</span></span><br><span class="line">let keyNames = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>]</span><br><span class="line">let valueNames = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//public init&lt;S&gt;(uniqueKeysWithValues keysAndValues: S) where S : Sequence, S.Element == (Key, Value)</span></span><br><span class="line"><span class="comment">//对于该方法的具体解释,可以点进去看一下官方的讲解</span></span><br><span class="line">let nameDic = Dictionary(uniqueKeysWithValues: zip(keyNames, valueNames))</span><br><span class="line">print(nameDic)</span><br><span class="line"><span class="comment">//["b": 2, "e": 6, "a": 1, "d": 5, "c": 4]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-在初始化Dictionary时-你现在可以使用你喜欢的方式来处理重复的键-同时避免覆盖键值对，且不会出现任何问题："><a href="#2-在初始化Dictionary时-你现在可以使用你喜欢的方式来处理重复的键-同时避免覆盖键值对，且不会出现任何问题：" class="headerlink" title="2.在初始化Dictionary时, 你现在可以使用你喜欢的方式来处理重复的键,同时避免覆盖键值对，且不会出现任何问题："></a>2.在初始化Dictionary时, 你现在可以使用你喜欢的方式来处理重复的键,同时避免覆盖键值对，且不会出现任何问题：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let keyNames2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]</span><br><span class="line"></span><br><span class="line">//public init&lt;S&gt;(_ keysAndValues: S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value) rethrows where S : Sequence, S.Element == (Key, Value)</span><br><span class="line">//对于该方法的具体解释,可以点进去看一下官方的讲解</span><br><span class="line">let nameDic2 = Dictionary(zip(keyNames2, repeatElement(1, count: keyNames2.count)), uniquingKeysWith: +)</span><br><span class="line">print(nameDic2)</span><br><span class="line">//[&quot;b&quot;: 2, &quot;a&quot;: 2, &quot;c&quot;: 1]</span><br></pre></td></tr></table></figure><h4 id="3-Dictionary-和-Set现在都可以将结果-通过filter函数-过滤到原始类型的新对象中："><a href="#3-Dictionary-和-Set现在都可以将结果-通过filter函数-过滤到原始类型的新对象中：" class="headerlink" title="3.Dictionary 和 Set现在都可以将结果 通过filter函数 过滤到原始类型的新对象中："></a>3.Dictionary 和 Set现在都可以将结果 通过filter函数 过滤到原始类型的新对象中：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let nameDic3 = nameDic.filter(&#123; $0.value &lt; 5 &#125;)</span><br><span class="line">print(nameDic3)</span><br><span class="line">//[&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;c&quot;: 4]</span><br></pre></td></tr></table></figure><h4 id="4-Dictionary为直接映射其值提供了一种非常有用的方法-："><a href="#4-Dictionary为直接映射其值提供了一种非常有用的方法-：" class="headerlink" title="4.Dictionary为直接映射其值提供了一种非常有用的方法:："></a>4.Dictionary为直接映射其值提供了一种非常有用的方法:：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将value值Int转化为字符串</span><br><span class="line">let nameDic4 = nameDic3.mapValues(&#123; &quot;\($0)&quot; &#125;)</span><br><span class="line">print(nameDic4)</span><br><span class="line">//[&quot;b&quot;: &quot;2&quot;, &quot;a&quot;: &quot;1&quot;, &quot;c&quot;: &quot;4&quot;]</span><br></pre></td></tr></table></figure><h4 id="5-在Dictionary上访问某个值时，常见的做法是使用nil-coalescing-operator给出默认值"><a href="#5-在Dictionary上访问某个值时，常见的做法是使用nil-coalescing-operator给出默认值" class="headerlink" title="5.在Dictionary上访问某个值时，常见的做法是使用nil-coalescing operator给出默认值"></a>5.在Dictionary上访问某个值时，常见的做法是使用nil-coalescing operator给出默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let nameDic5 = nameDic4[&quot;d&quot;, default : &quot;unknown&quot;]</span><br></pre></td></tr></table></figure><h4 id="6-我们可以从Sequence”中初始化Dictionary，并将其分组为bucket-："><a href="#6-我们可以从Sequence”中初始化Dictionary，并将其分组为bucket-：" class="headerlink" title="6.我们可以从Sequence”中初始化Dictionary，并将其分组为bucket:："></a>6.我们可以从Sequence”中初始化Dictionary，并将其分组为bucket:：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//注: 当通过特定模式对数据进行分组时，这相当方便。</span><br><span class="line">let name2 = [&quot;Proxima&quot;, &quot;Centauri A&quot;, &quot;Centauri B&quot;, &quot;Barnard&quot;, &quot;Wolf&quot;]</span><br><span class="line">let nameDic6 = Dictionary(grouping: name2, by: &#123; $0.first! &#125;)</span><br><span class="line">print(nameDic6)</span><br><span class="line">//[&quot;B&quot;: [&quot;Barnard&quot;], &quot;W&quot;: [&quot;Wolf&quot;], &quot;P&quot;: [&quot;Proxima&quot;], &quot;C&quot;: [&quot;Centauri A&quot;, &quot;Centauri B&quot;]]</span><br></pre></td></tr></table></figure><blockquote><p>涉及Zip的用法,详见<a href="http://www.jianshu.com/p/8c39bbacceb2" target="_blank" rel="noopener">Swift语法之Zip详解</a></p></blockquote><h4 id="7-预留空间"><a href="#7-预留空间" class="headerlink" title="7.预留空间"></a>7.预留空间</h4><ul><li>Sequence和Dictionary现在都具有明确保留容量的能力</li><li>在这些类型上，Reallocation可能是一项代价高昂的任务。</li><li>如果你知道需要存储的数据量时, 使用reserveCapacity(_:)可以提高性能且便捷<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name3 : [String : Int] = [ : ]</span><br><span class="line">print(name3.capacity) // 0</span><br><span class="line">name3.reserveCapacity(10) //储备 10元素的能力</span><br><span class="line">print(name3.capacity) // 12</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift4.0 </tag>
            
            <tag> String </tag>
            
            <tag> Array </tag>
            
            <tag> Dictionary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift版-H5页面实现长按保存图片</title>
      <link href="/2017/07/10/Swift%E7%89%88-H5%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0%E9%95%BF%E6%8C%89%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87"/>
      <content type="html"><![CDATA[<ul><li>刚开始拿到需求的第一反应是:H5页面还可以保存图片??</li><li>随即想了一下,好像微信里好多H5页面都有这样的功能</li><li>然后查阅了一下相关资料,有咨询了前端大神发现两行核心代码</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取长按所在点</span></span><br><span class="line">let urlString = <span class="string">"document.elementFromPoint(\(touchPoint.x), \(touchPoint.y)).src"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据该点的参数获取对应图片的链接</span></span><br><span class="line">let saveUrl = webView.stringByEvaluatingJavaScriptFromString(urlString)</span><br></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h3 id="下面来一起啊看一下完整的代码步骤"><a href="#下面来一起啊看一下完整的代码步骤" class="headerlink" title="下面来一起啊看一下完整的代码步骤"></a>下面来一起啊看一下完整的代码步骤</h3><blockquote><h4 id="首先给UiWebView加一个长按手势"><a href="#首先给UiWebView加一个长按手势" class="headerlink" title="首先给UiWebView加一个长按手势"></a>首先给UiWebView加一个长按手势</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加长按手势</span></span><br><span class="line">let longPressGes = <span class="built_in">UILongPressGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="meta">#selector(longPressedGesture(_:)))</span></span><br><span class="line"><span class="comment">//一定要遵循代理</span></span><br><span class="line">longPressGes.delegate = <span class="keyword">self</span></span><br><span class="line">webView.addGestureRecognizer(longPressGes)</span><br></pre></td></tr></table></figure><blockquote><h4 id="实现代理方法"><a href="#实现代理方法" class="headerlink" title="实现代理方法"></a>实现代理方法</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//不实现该代理方法,长按无效</span></span><br><span class="line">func gestureRecognizer(gestureRecognizer: <span class="built_in">UIGestureRecognizer</span>, shouldRecognizeSimultaneouslyWithGestureRecognizer otherGestureRecognizer: <span class="built_in">UIGestureRecognizer</span>) -&gt; Bool &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="接着在手势响应方法里面实现相应的功能"><a href="#接着在手势响应方法里面实现相应的功能" class="headerlink" title="接着在手势响应方法里面实现相应的功能"></a>接着在手势响应方法里面实现相应的功能</h4></blockquote><ul><li>注意:<ul><li>一定要判断手势的state属性</li><li>判断saveUrl是否是一个nil值</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@objc func longPressedGesture(recognizer: UILongPressGestureRecognizer)&#123;</span><br><span class="line">    if recognizer.state != .Began &#123; return &#125;</span><br><span class="line">        </span><br><span class="line">    let touchPoint = recognizer.locationInView(webView)</span><br><span class="line">    </span><br><span class="line">    //核心代码</span><br><span class="line">    let urlString = &quot;document.elementFromPoint(\(touchPoint.x), \(touchPoint.y)).src&quot;</span><br><span class="line">    if let saveUrl = webView.stringByEvaluatingJavaScriptFromString(urlString) &#123;</span><br><span class="line">        //判断图片的链接是否为空,长度是否为o</span><br><span class="line">        if saveUrl.characters.count == 0 &#123; return &#125;</span><br><span class="line">        addAlertAction(saveUrl)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="调用保存图片功能按钮"><a href="#调用保存图片功能按钮" class="headerlink" title="调用保存图片功能按钮"></a>调用保存图片功能按钮</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func addAlertAction(imageStr: String)&#123;</span><br><span class="line">    let alertV = <span class="built_in">UIAlertController</span>()</span><br><span class="line">    let saveAction = <span class="built_in">UIAlertAction</span>(title: <span class="string">"保存图片"</span>, style: .Default) &#123; (alertV) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.saveImageToPhoto(imageStr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取消保存不作处理</span></span><br><span class="line">    let cancelAction = <span class="built_in">UIAlertAction</span>(title: <span class="string">"取消"</span>, style: .Cancel, handler: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">    alertV.addAction(saveAction)</span><br><span class="line">    alertV.addAction(cancelAction)</span><br><span class="line">    controller.presentViewController(alertV, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="使用SDWebImage保存图片"><a href="#使用SDWebImage保存图片" class="headerlink" title="使用SDWebImage保存图片"></a>使用SDWebImage保存图片</h4></blockquote><ul><li>注意使用SDWebImage的缓存机制</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fileprivate func saveImageToPhoto(imageStr: String)&#123;</span><br><span class="line">    guard let imageUrl = <span class="built_in">NSURL</span>(string: imageStr) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">    let sdManager = SDWebImageManager.sharedManager()</span><br><span class="line">        </span><br><span class="line">    var image : <span class="built_in">UIImage</span>!</span><br><span class="line">    <span class="keyword">if</span> sdManager.diskImageExistsForURL(imageUrl) &#123;</span><br><span class="line">        <span class="comment">//先判断缓存中的图片</span></span><br><span class="line">        image = sdManager.imageCache.imageFromDiskCacheForKey(imageUrl.absoluteString)</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//缓存没有在进行下载</span></span><br><span class="line">        let data = <span class="built_in">NSData</span>(contentsOfURL: imageUrl)</span><br><span class="line">        image = <span class="built_in">UIImage</span>(data: data!)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保存图片到相册中</span></span><br><span class="line">    <span class="built_in">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>, <span class="meta">#selector(self.image(_:didFinishSavingWithError:contextInfo:)), nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="最后是一个保存成功与否的回调方法"><a href="#最后是一个保存成功与否的回调方法" class="headerlink" title="最后是一个保存成功与否的回调方法"></a>最后是一个保存成功与否的回调方法</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func image(image: <span class="built_in">UIImage</span>, didFinishSavingWithError: <span class="built_in">NSError</span>?, contextInfo: AnyObject) &#123;</span><br><span class="line">    <span class="keyword">if</span> didFinishSavingWithError != <span class="literal">nil</span> &#123;</span><br><span class="line">        MBProgressHUD.show(string: <span class="string">"请开启访问相册权限后使用此功能"</span>, inView: <span class="keyword">self</span>.view)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MBProgressHUD.show(string: <span class="string">"图片保存成功"</span>, inView: <span class="keyword">self</span>.view)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 以上如有不妥之处还望多多指正 </p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> JavaScript </tag>
            
            <tag> WebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5学习笔记之音视频标签</title>
      <link href="/2017/06/16/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%87%E7%AD%BE"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><img src="http://upload-images.jianshu.io/upload_images/647982-0d0c0be17835a633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="一-video标签"><a href="#一-video标签" class="headerlink" title="一. video标签"></a>一. video标签</h2><h3 id="1-作用-播放视频"><a href="#1-作用-播放视频" class="headerlink" title="1. 作用: 播放视频"></a>1. 作用: 播放视频</h3><h3 id="2-video标签格式1"><a href="#2-video标签格式1" class="headerlink" title="2. video标签格式1:"></a>2. video标签格式1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src=&quot;&quot;&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h3 id="3-video标签的属性"><a href="#3-video标签的属性" class="headerlink" title="3. video标签的属性"></a>3. video标签的属性</h3><ul><li>src: 告诉video标签需要播放的视频地址</li><li>autoplay: 告诉video标签是否需要自动播放视频</li><li>controls:告诉video标签是否需要显示控制条</li><li>poster: 告诉video标签视频没有播放之前显示的占位图片</li><li>loop: 告诉video标签循环播放视频. 一般用于做广告视频</li><li>preload: 告诉video标签预加载视频, 但是需要注意preload和autoplay相冲, 如果设置了autoplay属性, 那么preload属性就会失效</li><li>muted:告诉video标签视频静音</li><li>width/height: 和img标签中的一模一样</li></ul><h3 id="4-video标签格式2"><a href="#4-video标签格式2" class="headerlink" title="4. video标签格式2"></a>4. video标签格式2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line">  &lt;source src=&quot;&quot; type=&quot;&quot;&gt;&lt;/source&gt;</span><br><span class="line">  &lt;source src=&quot;&quot; type=&quot;&quot;&gt;&lt;/source&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><ul><li><p>第二种格式存在的意义</p><ul><li>由于视频数据非常非常的重要, 所以五大浏览器厂商都不愿意支持别人的视频格式, 所以导致了没有一种视频格式是所有浏览器都支持的这个时候W3C为了解决这个问题, 所以推出了第二个video标签的格式</li><li>video标签的第二种格式存在的意义就是为了解决浏览器适配问题. video 元素支持三种视频格式, 我们可以把这三种格式都通过source标签指定给video标签, 那么以后当浏览器播放视频时它就会从这三种中选择一种自己支持的格式来播放</li></ul></li><li><p>注意点:</p><ul><li>当前通过video标签的第二种格式虽然能够指定所有浏览器都支持的视频格式, 但是想让所有浏览器都通过video标签播放视频还有一个前提条件, 就是浏览器必须支持HTML5标签, 否则同样无法播放</li><li>在过去的一些浏览器是不支持HTML5标签的, 所以为了让过去的一些浏览器也能够通过video标签来播放视频, 那么我们以后可以通过一个JS的框架叫做html5media来实现</li></ul></li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;video width=&quot;200&quot; height=&quot;100&quot; poster=&quot;http://www.youname.com/images/first.png&quot; autoplay=&quot;autoplay&quot; preload=&quot;none&quot; controls=&quot;controls&quot;&gt;</span><br><span class="line">    &lt;!--楚乔传,好像是第4集--&gt;</span><br><span class="line">    &lt;source src=&quot;https://v.qq.com/x/cover/dhzimk1qzznf301/t0024jjys1q.html?ptag=baidu.aladdin.tv&quot; &gt;</span><br><span class="line">    &lt;source src=&quot;http://www.youname.com/images/first.ogg&quot; /&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h2 id="二-audio标签"><a href="#二-audio标签" class="headerlink" title="二.audio标签"></a>二.audio标签</h2><h3 id="1-作用-播放音频"><a href="#1-作用-播放音频" class="headerlink" title="1. 作用: 播放音频"></a>1. 作用: 播放音频</h3><h3 id="2-格式"><a href="#2-格式" class="headerlink" title="2. 格式:"></a>2. 格式:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio src=&quot;&quot;&gt;</span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"></span><br><span class="line">&lt;audio&gt;</span><br><span class="line">&lt;source src=&quot;&quot; type=&quot;&quot;&gt;</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure><h3 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3. 注意点:"></a>3. 注意点:</h3><ul><li>audio标签的使用和video标签的使用基本一样</li><li>video中能够使用的属性在audio标签中大部分都能够使用, 并且功能都一样</li><li>只不过有3个属性不能用,<code>height/width/poster</code></li></ul><h2 id="三-详情和概要标签"><a href="#三-详情和概要标签" class="headerlink" title="三.详情和概要标签"></a>三.详情和概要标签</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用:"></a>1. 作用:</h3><ul><li>利用summary标签来描述概要信息, 利用details标签来描述详情信息</li><li>默认情况下是折叠展示, 想看见详情必须点击</li></ul><h3 id="2-格式-1"><a href="#2-格式-1" class="headerlink" title="2. 格式:"></a>2. 格式:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;概要信息&lt;/summary&gt;</span><br><span class="line">    详情信息</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--详情和概要标签--&gt;</span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;概要信息&lt;/summary&gt;</span><br><span class="line">    这里是详情: 是假的呢举案说法南石道街开发病那都是独守空房技能速度加快非农数据的看法山东矿机第三方看似简单妇女节看电视呢房间看电视开始的减肥纳斯达克今年初vdsfw的看法今年圣诞节开放男</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-3bd310e521eed10e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_9.png"></p><h2 id="四-marquee标签"><a href="#四-marquee标签" class="headerlink" title="四. marquee标签"></a>四. marquee标签</h2><h3 id="1-作用-跑马灯效果"><a href="#1-作用-跑马灯效果" class="headerlink" title="1. 作用: 跑马灯效果"></a>1. 作用: 跑马灯效果</h3><h3 id="2-格式-2"><a href="#2-格式-2" class="headerlink" title="2. 格式:"></a>2. 格式:</h3><p><code>&lt;marquee&gt;内容&lt;/marquee&gt;</code></p><h3 id="3-属性"><a href="#3-属性" class="headerlink" title="3. 属性:"></a>3. 属性:</h3><ul><li>direction: 设置滚动方向 left/right/up/down</li><li>scrollamount: 设置滚动速度, 值越大就越快</li><li>loop: 设置滚动次数, 默认是-1, 也就是无限滚动</li><li>behavior: 设置滚动类型 slide滚动到边界就停止, alternate滚动到边界就弹回</li></ul><h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4. 注意点:"></a>4. 注意点:</h3><ul><li>marquee标签不是W3C推荐的标签, 在W3C官方文档中也无法查询这个标签, 但是各大浏览器对这个标签的支持非常好</li></ul><h4 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5. 示例代码"></a>5. 示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--跑马灯-marquee标签--&gt;</span><br><span class="line">&lt;marquee direction=&quot;left&quot; scrollamount=&quot;5&quot;&gt;跑马灯&lt;/marquee&gt;</span><br><span class="line">&lt;marquee direction=&quot;right&quot; scrollamount=&quot;3&quot;&gt;marquee&lt;/marquee&gt;</span><br><span class="line">&lt;marquee direction=&quot;up&quot; scrollamount=&quot;1&quot;&gt;标签&lt;/marquee&gt;</span><br><span class="line">&lt;marquee direction=&quot;down&quot; scrollamount=&quot;1&quot;&gt;down&lt;/marquee&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-6bc10b374b5e362e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_10.png"></p><blockquote><p>注: 实际的效果中,这三个是一直在滚动的,只是图片看不到效果,自己亲自实践感受下吧!</p></blockquote><h2 id="五-HTML中被废弃的标签"><a href="#五-HTML中被废弃的标签" class="headerlink" title="五. HTML中被废弃的标签"></a>五. HTML中被废弃的标签</h2><blockquote><p>由于HTML现在只负责语义而不负责样式.但是HTML一开始有一部分标签连样式也包揽了, 所以这部分标签都被废弃了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b、u、i、s </span><br><span class="line">- 以上标签自己带有样式, 有浓厚的样式作用, 今后一般都只作为CSS钩子使用</span><br><span class="line">- 原则: 不到万不得已,切记不要使用如上标签. 大家可以到BAT的网站查看源代码, 几乎看不到以上标签</span><br></pre></td></tr></table></figure><ul><li>b(Bold)作用: 将文本字体加粗<ul><li>格式:<code>&lt;b&gt;将文本字体加粗&lt;/b&gt;</code></li></ul></li><li>u(Underlined)作用: 为文本添加下划线<ul><li>格式: <code>&lt;u&gt;为文本添加下划线&lt;/u&gt;</code></li></ul></li><li>i(Italic)作用: 显示斜体文本效果<ul><li>格式: <code>&lt;i&gt;显示斜体文本效果&lt;/i&gt;</code></li></ul></li><li>s(Strikethrough)作用: 为文本添加删除线<ul><li>格式: <code>&lt;s&gt;为文本添加删除线&lt;/s&gt;</code></li></ul></li></ul><blockquote><p>为了弥补 b、u、i、s标签的不足, W3C又推出了一组新的标签, 这些标签在显示上看似和buis没什么区别, 但是在语义上却有重大区别</p></blockquote><ul><li>strong作用: 着重内容<ul><li>格式:<code>&lt;strong&gt;着重内容&lt;/strong&gt;</code></li></ul></li><li>ins(Inserted)作用: 新插入的文本<ul><li>格式:<code>&lt;ins&gt;新插入的文本&lt;/ins&gt;</code></li></ul></li><li>em(Emphasized)作用:强调内容<ul><li>格式:<code>&lt;em&gt;强调内容&lt;/em&gt;</code></li></ul></li><li>del(Deleted)作用: 已删除的文本<ul><li>格式:<code>&lt;del&gt;已删除的文本&lt;/del&gt;</code></li></ul></li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--新增标签--&gt;</span><br><span class="line">&lt;strong&gt;着重内容&lt;/strong&gt;</span><br><span class="line">&lt;ins&gt;新插入的内容&lt;/ins&gt;</span><br><span class="line">&lt;em&gt;强调的内容&lt;/em&gt;</span><br><span class="line">&lt;del&gt;已经删除的内容&lt;/del&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-595238b7fcc8c71f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_11.png"></p><blockquote><ul><li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040" target="_blank" rel="noopener">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5标签 </tag>
            
            <tag> CSS </tag>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5学习笔记之表单标签</title>
      <link href="/2017/06/15/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><img src="http://upload-images.jianshu.io/upload_images/647982-9f6f2cfcfdf04c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li><p>1.作用: </p><ul><li>用于收集用户信息, 让用户填写、选择相关信息</li></ul></li><li><p>2.格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    所有的表单内容，都要写在form标签里面</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>3.注意事项:</p><ul><li>所有的表单内容，都要写在form标签里面<br>form标签中有两个比较重要的属性action和method</li></ul></li></ul><h2 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h2><ul><li><p>如果说td是表格最核心的标签, 那么input就是表单最核心的标签. nput标签有一个type属性, 这个属性有很多类型的取值, 取值的不同就决定了input标签的功能和外观不同</p><h3 id="1-输入框"><a href="#1-输入框" class="headerlink" title="1.输入框"></a>1.输入框</h3><h4 id="1-1-明文输入框"><a href="#1-1-明文输入框" class="headerlink" title="1.1 明文输入框"></a>1.1 明文输入框</h4></li><li><p>作用: 用户可以在输入框内输入内容</p></li><li>账号: <code>&lt;input type=&quot;text&quot;/&gt;</code><h4 id="1-2-暗文输入框"><a href="#1-2-暗文输入框" class="headerlink" title="1.2 暗文输入框"></a>1.2 暗文输入框</h4></li><li>作用: 用户可以在输入框内输入内容</li><li>密码: <code>&lt;input type=&quot;password&quot;/&gt;</code><h4 id="1-3-给输入框设置默认值"><a href="#1-3-给输入框设置默认值" class="headerlink" title="1.3 给输入框设置默认值"></a>1.3 给输入框设置默认值</h4></li><li>账号: <code>&lt;input type=&quot;text&quot;  value=&quot;tqj&quot;/&gt;</code></li><li>密码: <code>&lt;input type=&quot;password&quot; value=&quot;0929&quot;/&gt;</code><h4 id="1-4-规定输入字段中的字符的最大长度"><a href="#1-4-规定输入字段中的字符的最大长度" class="headerlink" title="1.4 规定输入字段中的字符的最大长度"></a>1.4 规定输入字段中的字符的最大长度</h4></li><li>账号: <code>&lt;input type=&quot;text&quot; name=&quot;fullname&quot; maxlength=&quot;8&quot; /&gt;</code></li></ul><h4 id="1-5-代码"><a href="#1-5-代码" class="headerlink" title="1.5 代码"></a>1.5 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;!--明文输入框--&gt;</span><br><span class="line">    &lt;p&gt;账号: &lt;input type=&quot;text&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;!--暗文输入框--&gt;</span><br><span class="line">    &lt;p&gt;密码: &lt;input type=&quot;password&quot; /&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--p标签换行--&gt;</span><br><span class="line">    &lt;p&gt;账号: &lt;input type=&quot;text&quot; value=&quot;tqj&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;密码: &lt;input type=&quot;password&quot; value=&quot;0929&quot; /&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;p&gt;最大长度: &lt;input type=&quot;text&quot; maxlength=&quot;5&quot;/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-39cbc042f6cfbdb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_22.png"></p><h3 id="2-单选框-radio"><a href="#2-单选框-radio" class="headerlink" title="2. 单选框(radio)"></a>2. 单选框(radio)</h3><ul><li>作用: 用户只能从众多选项中选择其中一个</li><li>单选按钮，天生是不互斥的，如果想互斥，必须要有相同的name属性</li></ul><h3 id="3-多选框-checkbox"><a href="#3-多选框-checkbox" class="headerlink" title="3. 多选框(checkbox)"></a>3. 多选框(checkbox)</h3><ul><li>作用: 用户只能从众多选项中选择多个</li><li>复选框，最好也是有相同的name（虽然他不需要互斥，但是也要有相同的name）</li></ul><h3 id="4-label标签"><a href="#4-label标签" class="headerlink" title="4. label标签"></a>4. label标签</h3><ul><li>作用: label标签不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性</li><li>注意事项:<br>表单元素要有一个id，然后label标签就有一个for属性，for属性和id相同就表示绑定了<br>所有表单元素都可以通过label绑定</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--单选框--&gt;</span><br><span class="line">&lt;!--checked属性,为默认值--&gt;</span><br><span class="line">&lt;label for=&quot;sex&quot;&gt;性别: &lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked /&gt; &lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; &lt;label for=&quot;sex&quot;&gt;女&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; &lt;label for=&quot;sex&quot;&gt;妖&lt;/label&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--多选框--&gt;</span><br><span class="line">&lt;label for=&quot;课程&quot;&gt;课程: &lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;课程&quot; checked /&gt; &lt;label for=&quot;课程&quot;&gt;HTML5 &lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;课程&quot; checked /&gt; &lt;label for=&quot;课程&quot;&gt;Swift &lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;课程&quot; /&gt; &lt;label for=&quot;课程&quot;&gt;OC &lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;课程&quot; /&gt; &lt;label for=&quot;课程&quot;&gt;CSS &lt;/label&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-141c73672aca00ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_1.png"></p><h3 id="5-按钮"><a href="#5-按钮" class="headerlink" title="5. 按钮"></a>5. 按钮</h3><h4 id="5-1-普通按钮"><a href="#5-1-普通按钮" class="headerlink" title="5.1 普通按钮"></a>5.1 普通按钮</h4><ul><li>作用: 定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）<br><code>&lt;input type=&quot;button&quot; value=&quot;点我丫&quot; /&gt;</code></li></ul><h4 id="5-2-图片按钮"><a href="#5-2-图片按钮" class="headerlink" title="5.2 图片按钮"></a>5.2 图片按钮</h4><ul><li>作用:定义图像形式的提交按钮<br><code>&lt;input type=&quot;image&quot; src=&quot;1.png&quot; /&gt;</code></li></ul><h4 id="5-3-还原按钮"><a href="#5-3-还原按钮" class="headerlink" title="5.3 还原按钮"></a>5.3 还原按钮</h4><ul><li>作用: 定义还原按钮。还原按钮会清除表单中的所有数据<br><code>&lt;input type=&quot;reset&quot; /&gt;</code></li><li>注意事项:<br>这个按钮不需要写value自动就有“还原”文字<br>reset只对form表单中表单项有效果</li></ul><h4 id="5-4-提交按钮"><a href="#5-4-提交按钮" class="headerlink" title="5.4 提交按钮"></a>5.4 提交按钮</h4><ul><li>作用:定义提交按钮。提交按钮会把表单数据发送到action属性指定的页面<br><code>&lt;input type=&quot;submit&quot; /&gt;</code></li><li>注意事项:<ul><li>这个按钮不需要写value自动就有“提交”文字</li><li>要想通过submit提交数据到服务器, 被提交的表单项都必须设置name属性</li><li>默认明文传输(GET)不安全, 可以将method属性设置为POST改为非明文传输(学到Ajax再理解)</li></ul></li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--按钮--&gt;</span><br><span class="line">&lt;!--普通按钮--&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;点我有奖&quot;&gt;</span><br><span class="line">&lt;!--图片按钮--&gt;</span><br><span class="line">&lt;input type=&quot;image&quot; src=&quot;http://note.youdao.com/favicon.ico&quot;&gt;</span><br><span class="line">&lt;!--还原按钮--&gt;</span><br><span class="line">&lt;input type=&quot;reset&quot;&gt;</span><br><span class="line">&lt;!--提交按钮--&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-df3952d22685cb6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_3.png"></p><h3 id="6-隐藏域"><a href="#6-隐藏域" class="headerlink" title="6. 隐藏域"></a>6. 隐藏域</h3><ul><li>作用: 定义隐藏的输入字段<input type="hidden"></li><li>暂时不用掌握, 在Ajax中对数据的CRUD操作有非常大的作用</li></ul><h3 id="7-取色器和日期选择器"><a href="#7-取色器和日期选择器" class="headerlink" title="7.取色器和日期选择器"></a>7.取色器和日期选择器</h3><ul><li>取色器: <code>&lt;input type=&quot;color&quot;&gt;</code></li><li>日期选色器: <code>&lt;input type=&quot;date&quot;&gt;</code></li><li>HTML5中input类型增加了很多type类型, 例如color、date但是都不兼容, 后面讲到浏览器兼容时会重点讲解<blockquote><ul><li>亲自测试,在Mac电脑的Safari浏览器不兼容,只能用谷歌浏览器</li></ul></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--取色器--&gt;</span><br><span class="line">&lt;label&gt;颜色: &lt;/label&gt; &lt;input type=&quot;color&quot;&gt;</span><br><span class="line">&lt;!--换行--&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--日期选色器--&gt;</span><br><span class="line">&lt;label&gt;时间: &lt;/label&gt; &lt;input type=&quot;date&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-af39ca426f317aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_5.png"></p><h3 id="8-数据列表"><a href="#8-数据列表" class="headerlink" title="8. 数据列表"></a>8. 数据列表</h3><ul><li><p>作用: 给输入框绑定待选项</p></li><li><p>格式:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  &lt;option&gt;待选项内容&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure><ul><li><p>如何给输入框绑定待选列表</p><ul><li>搞一个输入框</li><li>搞一个datalist列表</li><li>给datalist列表标签添加一个id</li><li>给输入框添加一个list属性,将datalist的id对应的值赋值给list属性即可</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--数据列表--&gt;</span><br><span class="line">请选择车型: &lt;input type=&quot;text&quot; list=&quot;cars&quot;&gt;</span><br><span class="line">&lt;datalist id=&quot;cars&quot;&gt;</span><br><span class="line">    &lt;option&gt;奔驰&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;宝马&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;奥迪&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;别克&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;奔腾&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;奔跑&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-5e9e1c3b75a16426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_6.png"></p><ul><li>当输入某一个字符时,会自动根据datalist列表查询,并显示对应的列表,如图:</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-4973010e14b7d6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_7.png"></p><h2 id="三-多行文本框-文本域"><a href="#三-多行文本框-文本域" class="headerlink" title="三. 多行文本框(文本域)"></a>三. 多行文本框(文本域)</h2><ul><li><p>作用: textarea标签用于在表单中定义多行的文本输入控件</p><ul><li>cols属性表示columns“列”, 规定文本区内的可见宽度</li><li>rows属性表示rows“行”, 规定文本区内的可见高度</li></ul></li><li><p>格式:<br><code>&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;</code>默认<code>&lt;/textarea&gt;</code></p></li><li><p>注意点:</p><ul><li>可以通过cols和rows来指定输入框的宽度和高度</li><li>默认情况下输入框是可以手动拉伸的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--禁止手动拉伸--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  textarea&#123;</span><br><span class="line">      resize: none;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="四-下拉列表"><a href="#四-下拉列表" class="headerlink" title="四. 下拉列表"></a>四. 下拉列表</h2><ul><li>作用: select标签和ul、ol、dl一样，都是组标签. 用于创建表单中的待选列表<ul><li>和radio、checkbox一样select也可以设置默认值, 通过selected属性设置(本身默认是第一个选项)</li></ul></li><li>给下拉列表添加分组</li></ul><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--给下拉表添加分组--&gt;</span><br><span class="line">&lt;select&gt;</span><br><span class="line">    &lt;optgroup label=&quot;杭州市&quot;&gt;</span><br><span class="line">        &lt;option&gt;江干区&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;西湖区&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;滨江区&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;下城区&lt;/option&gt;</span><br><span class="line">    &lt;/optgroup&gt;</span><br><span class="line">    &lt;optgroup label=&quot;烟台市&quot;&gt;</span><br><span class="line">        &lt;option&gt;莱山区&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;芝罘区&lt;/option&gt;</span><br><span class="line">    &lt;/optgroup&gt;</span><br><span class="line">    &lt;option selected&gt;北京市&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-c9638bcbcf8e60f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_8.png"></p><blockquote><ul><li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040" target="_blank" rel="noopener">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5标签 </tag>
            
            <tag> CSS </tag>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5学习笔记之表格标签</title>
      <link href="/2017/06/15/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h3 id="一-表格标签"><a href="#一-表格标签" class="headerlink" title="一.表格标签"></a>一.表格标签</h3><p><img src="http://upload-images.jianshu.io/upload_images/647982-151e7c132c68a833.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用:"></a>1.作用:</h3><ul><li>以表格形式将数据显示出来, 当数据量非常大的时候, 表格这种展现形式被认为是最为清晰的一种展现形式</li></ul><h3 id="2-格式"><a href="#2-格式" class="headerlink" title="2.格式:"></a>2.格式:</h3><ul><li>table定义表格</li><li>tr定义行</li><li>td定义单元格</li></ul><h3 id="3-表格中的属性"><a href="#3-表格中的属性" class="headerlink" title="3.表格中的属性"></a>3.表格中的属性</h3><ul><li><p>border: 默认情况下表格的边框宽度为0看不到, 通过border属性给表格指定边框宽度</p></li><li><p>width: 默认情况下表格的宽度是由内容自动计算出来的, 可以通过width属性指定表格的宽度</p></li><li><p>height:默认情况下表格的高度是由内容自动计算出来的, 可以通过height属性指定表格的高度</p></li><li><p>cellspacing: 外边距. 默认情况下单元格之间有2个像素的间隙, 可以通过cellpadding指定表格之间的间隙</p></li><li><p>cellpadding: 内边距. 默认情况下单元格边缘距离内容有1个像素的内边距, 可以通过cellpadding属性指定单元格边缘和内容之间的内边距</p></li><li><p>align: 规定表格相对周围元素的对齐方式, 它的取值有center、left、right</p><ul><li>给table设置align属性, 是让表格在浏览器中居左/居右/居中</li><li>给tr设置align属性, 是让当前行中所有内容居左/居右/居中</li><li>给td设置align属性,是让当前单元格中所有内容居左/居右/居中</li><li>该属性仅仅作为了解, 企业开发中用css代替, 因为HTML仅仅用于说明语义</li><li>如果td中设置了align属性, tr中也设置了align属性, 那么单元格中的内容会按照td中设置的来对齐</li></ul></li><li><p>valign: 规定表格相对周围元素的对齐方式, 它的取值有center、left、right</p><ul><li>给table设置valign属性, 无效<br>给tr设置valign属性, 是让当前行中所有内容居上/居中/居下</li><li>给td设置valign属性,是让当前单元格中所有内容居上/居中/居下</li><li>如果td中设置了valign属性, tr中也设置了valign属性, 那么单元格中的内容会按照td中设置的来对齐</li></ul></li><li><p>bgcolor:规定表格的背景颜色</p><ul><li>给table设置bgcolor属性, 是给整个表格设置背景颜色</li><li>给tr设置bgcolor属性, 是给当前行设置背景颜色</li><li>给td设置bgcolor属性, 是给当前单元格设置背景颜色</li><li>该属性仅仅作为了解, 企业开发中用css代替, 因为HTML仅仅用于说明语义</li></ul></li></ul><h4 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1) 示例代码"></a>1) 示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--表格标签--&gt;</span><br><span class="line">&lt;!--先定义一个表格, 然后通过tr告诉浏览器这个表格中一共有多少行, 然后再通过td告诉浏览器这一行中一共有多少个元素(一共有多少列)--&gt;</span><br><span class="line">&lt;table border=&quot;1&quot; width=&quot;500&quot; cellpadding=&quot;5&quot; cellspacing=&quot;10&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h4 id="2-展示样式"><a href="#2-展示样式" class="headerlink" title="2) 展示样式"></a>2) 展示样式</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-cac6e5756352e691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_17.png"></p><h3 id="4-表格中的其它标签"><a href="#4-表格中的其它标签" class="headerlink" title="4.表格中的其它标签"></a>4.表格中的其它标签</h3><ul><li><p>表单中有两种类型的单元格, 一种是标准单元格td, 一种是表头单元格th</p></li><li><p>th标签: 给每一列设置标题, 单元格中的内容会自动加粗，居中</p></li><li><p>caption标签:给整个表格设置标题</p><ul><li>一定要嵌套在talbe标签内部才有效</li></ul></li></ul><h4 id="1-示例代码-1"><a href="#1-示例代码-1" class="headerlink" title="1) 示例代码"></a>1) 示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;table bgcolor=&quot;#5f9ea0&quot; cellspacing=&quot;1px&quot; width=&quot;1000&quot; align=&quot;center&quot;&gt;</span><br><span class="line">    &lt;caption&gt;</span><br><span class="line">        &lt;h2&gt;这周代码量排行榜&lt;/h2&gt;</span><br><span class="line">    &lt;/caption&gt;</span><br><span class="line">    &lt;tr bgcolor=&quot;#8a2be2&quot;&gt;</span><br><span class="line">        &lt;th&gt;排名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;关键词&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;趋势&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;今日搜索&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;最近一天&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;最近一天相关链接&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr bgcolor=&quot;#f0ffff&quot; align=&quot;center&quot;&gt;</span><br><span class="line">        &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;穷爸爸富爸爸&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;上涨&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;456&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;234214&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot;&gt;杭州&lt;/a&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr bgcolor=&quot;#f0ffff&quot; align=&quot;center&quot;&gt;</span><br><span class="line">        &lt;td&gt;2&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;穷爸爸富爸爸&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;上涨&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;234&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;3423542&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot;&gt;杭州&lt;/a&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br></pre></td></tr></table></figure><h4 id="2-展示样式-1"><a href="#2-展示样式-1" class="headerlink" title="2) 展示样式"></a>2) 展示样式</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-70f5e09e43e7df60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_19.png"></p><h3 id="5-表格的结构"><a href="#5-表格的结构" class="headerlink" title="5.表格的结构"></a>5.表格的结构</h3><ul><li><p>thead标签:用来存放当前列的表头, 如果没有加css页面默认将表头中的高度设置变小</p></li><li><p>tbody标签:一般用来存放页面中的主体数据, 如果不写会自动加上</p></li><li><p>tfoot标签:用来存放表格的页脚（脚注或表注), 如果没有加css页面默认将表头中的高度设置变小, 一般不会出现</p></li></ul><h4 id="1-示例代码-2"><a href="#1-示例代码-2" class="headerlink" title="1) 示例代码"></a>1) 示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;table bgcolor=&quot;#7fffd4&quot; width=&quot;800&quot; cellspacing=&quot;2&quot; align=&quot;center&quot;&gt;</span><br><span class="line">    &lt;caption&gt;我是表格标题&lt;/caption&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">    &lt;tr align=&quot;center&quot;&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">    &lt;tr align=&quot;center&quot;&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">    &lt;tfoot&gt;</span><br><span class="line">    &lt;tr align=&quot;center&quot;&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/tfoot&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h4 id="2-展示样式-2"><a href="#2-展示样式-2" class="headerlink" title="2) 展示样式"></a>2) 展示样式</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-00a3d46f21a7cce7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_20.png"></p><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h3><ul><li>表格结构的意义主要是用于SEO, 便于搜索引擎指定哪部分的内容是需要抓取的重要内容, 一般情况下搜索引擎会优先抓取tbody中的内容</li><li>由于有一部分浏览器对talbe的这种结构支持不是很好, 所以在企业开发中一般都不用严格的按照这种结构来编写</li></ul><blockquote><ul><li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040" target="_blank" rel="noopener">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5标签 </tag>
            
            <tag> CSS </tag>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5学习笔记之基础标签</title>
      <link href="/2017/06/15/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A0%87%E7%AD%BE"/>
      <content type="html"><![CDATA[<h2 id="一-列表标签"><a href="#一-列表标签" class="headerlink" title="一.列表标签"></a>一.列表标签</h2><h3 id="1-无序列表-unordered-list"><a href="#1-无序列表-unordered-list" class="headerlink" title="1.无序列表(unordered list)"></a>1.无序列表(unordered list)</h3><ul><li>无序 : 没有先后之分</li></ul><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1) 作用:"></a>1) 作用:</h4><ul><li>给一堆内容添加无序列表语义(一个没有先后顺序整体), 列表中的条目是不分先后</li></ul><h4 id="2-格式"><a href="#2-格式" class="headerlink" title="2) 格式:"></a>2) 格式:</h4><ul><li>li 英文是 list item, 翻译为列表项</li></ul><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    &lt;h4&gt;中国城市列举(CN)&lt;/h4&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;北京&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;上海&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;广州&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;杭州&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-6170aa7da4bd362f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_4.png"></p><h4 id="3-ul应用场景"><a href="#3-ul应用场景" class="headerlink" title="3) ul应用场景:"></a>3) ul应用场景:</h4><ul><li>导航条</li><li>商品列表等</li><li>新闻列表</li><li><h4 id="4-注意"><a href="#4-注意" class="headerlink" title="4) 注意:"></a>4) 注意:</h4></li><li>其实ul还有一个type属性, 可以修改先导符号的样式, 取值有disc、square、circle几种<ul><li>但是由于样式将来都是通过css来完成, 所以这里就不给大家介绍了</li></ul></li><li>ul是一个组标签, 一定是一坨一坨的出现, 也就是说li标签不能单独存在, 必须包裹在ul里面</li><li>由于ul和li是一个整体, 所以ul里面不推荐包裹其它标签, 永远记住ul里面最好只写li标签</li><li>虽然ul中推荐只能写li标签, 但是li标签是一个容器标签, li标签中可以添加任意标签, 甚至可以添加ul标签</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4&gt;课程安排&lt;/h4&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        上午</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;HTML5&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;CSS&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        下午</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;OC&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;Swift&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-3e921651c9eb3c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_5.png"></p><h3 id="2-有序列表-ordered-list"><a href="#2-有序列表-ordered-list" class="headerlink" title="2.有序列表(ordered list)"></a>2.有序列表(ordered list)</h3><h4 id="1-作用-给一堆内容添加有序列表语义-一个有顺序整体-列表中的条目有先后之分"><a href="#1-作用-给一堆内容添加有序列表语义-一个有顺序整体-列表中的条目有先后之分" class="headerlink" title="1) 作用: 给一堆内容添加有序列表语义(一个有顺序整体), 列表中的条目有先后之分"></a>1) 作用: 给一堆内容添加有序列表语义(一个有顺序整体), 列表中的条目有先后之分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4&gt;中国房价排行榜&lt;/h4&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;北京&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;上海&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;杭州&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;广州&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;深圳&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-13f9b32478195bac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_6.png"></p><h4 id="2-ol应用场景"><a href="#2-ol应用场景" class="headerlink" title="2) ol应用场景:"></a>2) ol应用场景:</h4><ul><li>xxx排行榜</li><li>其实ol应用场景并不多, 因为能用ol做的用ul都能做</li><li>ul的常见属性start、type属性, 可以修改先导符号的样式和序号</li></ul><h2 id="二-定义列表-definition-list"><a href="#二-定义列表-definition-list" class="headerlink" title="二.定义列表(definition list)"></a>二.定义列表(definition list)</h2><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1) 作用:"></a>1) 作用:</h4><ul><li><p>给一堆内容添加列表语义, 通过dt罗列出列表的条目, 然后再通过dd给每个条目进行相应的描述</p><h4 id="2-格式-1"><a href="#2-格式-1" class="headerlink" title="2) 格式:"></a>2) 格式:</h4></li><li><p>dt英文definition title, 翻译为定义标题</p></li><li>dd英文definition description, 翻译为定义描述信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;北京&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;国家的首都&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;杭州&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;坑爹,房价上涨最快的地方&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br><span class="line"></span><br><span class="line">![Snip20170614_7.png](http://upload-images.jianshu.io/upload_images/4122543-2d304b7b5f58b8c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br></pre></td></tr></table></figure><h4 id="3-dl应用场景"><a href="#3-dl应用场景" class="headerlink" title="3) dl应用场景:"></a>3) dl应用场景:</h4><ul><li>网站底部相关信息<ul><li>但凡看到一堆内容都是用于描述某一个内容的时候就要想到dl</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-4429f20791990a71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_9.png"></p><h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4) 注意事项:"></a>4) 注意事项:</h4><ul><li>dl是一个<code>组标签</code>, 一定是一坨一坨的出现, 也就是说<code>dt</code>和<code>dd</code>标签不能单独存在, 必须包裹在<code>dl</code>里面</li><li>由于<code>dl</code>和<code>dt</code>、<code>dd</code>是一个整体, 所以<code>dl</code>里面不推荐包裹其它标签</li><li><code>dd</code>和<code>dt</code>和<code>li</code>标签一样是容器标签, 里面可以添加任意标签</li><li>定义列表非常灵活, 可以给一个<code>dt</code>配置多个<code>dd</code>, 但是最好不要出现多个<code>dt</code>对应一个<code>dd</code>, <code>dd</code>的语义是描述离它最近的一个<code>dt</code>, 所以其它<code>dt</code>相当于没有描述, 而定义列表存在的意义就是既可以列出每一个条目又可以对每一个条目进行描述</li><li>定义列表非常灵活, 可以将多个<code>dt+dd</code>组合拆分为多个<code>dl</code></li></ul><h2 id="三-H系列标签-Header-1-Header-6"><a href="#三-H系列标签-Header-1-Header-6" class="headerlink" title="三.H系列标签(Header 1~Header 6)"></a>三.H系列标签(Header 1~Header 6)</h2><h4 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1.作用:"></a>1.作用:</h4><ul><li>用于给文本添加标题语义</li><li>格式:</li><li><h1>xxxxxx</h1><h4 id="2-注意点"><a href="#2-注意点" class="headerlink" title="2.注意点:"></a>2.注意点:</h4></li><li>H标签是用来给文本添加标题语义的, 而不是用来修改文本的样式的</li><li>H标签一共有6个, 从H1~H6, 最多就只能到6, 超过6则无效</li><li>被H系列标签包裹的内容会独占一行</li><li>在H系列的标签中, H1最大, H6最小</li><li>在企业开发中, 一定要慎用H系列的标签, 特别是H1标签. 在企业开发中一般情况下一个界面中只能出现一个H1标签(和SEO有关)</li></ul><h2 id="四-P标签-Paragraph"><a href="#四-P标签-Paragraph" class="headerlink" title="四.P标签(Paragraph)"></a>四.P标签(Paragraph)</h2><h4 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1.作用:"></a>1.作用:</h4><ul><li>告诉浏览器哪些文字是一个段落</li><li>格式:</li><li><p>xxxxxxxx</p><h4 id="2-注意点-1"><a href="#2-注意点-1" class="headerlink" title="2.注意点:"></a>2.注意点:</h4></li><li>在浏览器中会单独占一行</li></ul><h2 id="五-Hr标签-Horizontal-Rule"><a href="#五-Hr标签-Horizontal-Rule" class="headerlink" title="五.Hr标签(Horizontal Rule)"></a>五.Hr标签(Horizontal Rule)</h2><h4 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1.作用:"></a>1.作用:</h4><ul><li>在浏览器上显示一条分割线</li><li>格式:</li><li><hr><h4 id="2-注意点-2"><a href="#2-注意点-2" class="headerlink" title="2.注意点:"></a>2.注意点:</h4></li><li>在浏览器中会单独占一行</li><li>通过我的观察发现HR标签可以写/也可以不写<ul><li>如果不写/那么就是按照HTML的规范来编写</li><li>如果写上/那么就是按照XHTML的规范来编写.</li></ul></li><li>由于hr标签是用来修改样式的, 所以不推荐使用. 今后开发中添加水平线一般都使用CSS盒子来做</li></ul><h2 id="六-HTML注释-Annotation"><a href="#六-HTML注释-Annotation" class="headerlink" title="六.HTML注释(Annotation)"></a>六.HTML注释(Annotation)</h2><h4 id="1-什么是注释"><a href="#1-什么是注释" class="headerlink" title="1.什么是注释?"></a>1.什么是注释?</h4><h4 id="1-注释格式"><a href="#1-注释格式" class="headerlink" title="1.注释格式"></a>1.注释格式</h4><p><code>&lt;!--被注释的内容--&gt;</code></p><h4 id="2-注意点-3"><a href="#2-注意点-3" class="headerlink" title="2.注意点:"></a>2.注意点:</h4><ul><li>被注释的内容不会在浏览器中显示, 注释是写给我们自己看的<ul><li>注释不能嵌套使用</li></ul></li></ul><p><code>&lt;!--&lt;!--被注释的内容--&gt;--&gt;</code></p><h4 id="3-快捷键-ctrl"><a href="#3-快捷键-ctrl" class="headerlink" title="3.快捷键: ctrl + /"></a>3.快捷键: <code>ctrl + /</code></h4><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;标题1&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;标题2&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;标题3&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;标题4&lt;/h4&gt;</span><br><span class="line">&lt;h5&gt;标题5&lt;/h5&gt;</span><br><span class="line">&lt;h6&gt;标题6&lt;/h6&gt;</span><br><span class="line">&lt;h7&gt;我是假的,标题7&lt;/h7&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--我是注释--&gt;</span><br><span class="line">&lt;hr /&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;告诉浏览器哪些文字是一个段落&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--下面是分割线--&gt;</span><br><span class="line">&lt;hr /&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-1ebb54835bf8f28b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_10.png"></p><h2 id="七-img标签-image"><a href="#七-img标签-image" class="headerlink" title="七.img标签(image)"></a>七.img标签(image)</h2><h3 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1) 作用:"></a>1) 作用:</h3><ul><li>在网页上插入一张图片</li></ul><h3 id="2-格式-2"><a href="#2-格式-2" class="headerlink" title="2) 格式:"></a>2) 格式:</h3><ul><li><code>![image](http://note.youdao.com/favicon.ico)</code></li></ul><h3 id="3-标签的属性"><a href="#3-标签的属性" class="headerlink" title="3) 标签的属性"></a>3) 标签的属性</h3><ul><li>写在标签中K=”V”这种格式的文本我们称之为标签属性</li></ul><table><thead><tr><th>属性名称</th><th>作用</th></tr></thead><tbody><tr><td>src(source)</td><td>告诉浏览器需要插入的图片路径, 以便于浏览器到该路径下找到需要插入的图片</td></tr><tr><td>alt(alternate)</td><td>规定图像的替代文本, 只有在src指定的路径下找不到图片,才会显示alt指定的文本</td></tr><tr><td>title</td><td>悬停文本(介绍这张图片, 只有在鼠标移动到图片上时才会显示)</td></tr><tr><td>height</td><td>设置图片显示的高度</td></tr><tr><td>width</td><td>设置图片显示的宽度</td></tr></tbody></table><h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4) 注意点:"></a>4) 注意点:</h3><ul><li>img标签添加的图片默认不是占一整行空间<br>如果想让图片等比拉伸,只写高度或者宽度即可</li></ul><h3 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5) 示例代码"></a>5) 示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--图片标签--&gt;</span><br><span class="line">![](http://note.youdao.com/favicon.ico)</span><br><span class="line">![有道云笔记](http://note.youdao.com/favicon.ico)</span><br><span class="line">![有道云笔记](http://note.youdao.com/favicon.ico)</span><br><span class="line">![有道云笔记](http://note.youdao.com/favicon.ico)</span><br><span class="line">![有道云笔记](http://note.youdao.com/favicon.ico)</span><br><span class="line">![有道云笔记](http://note.youdao.com/favicon.ico)</span><br><span class="line">&lt;img src=&quot;&quot; alt=&quot;找不到图片&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5) 运行结果"></a>5) 运行结果</h3><p><img src="http://upload-images.jianshu.io/upload_images/4122543-9ff009b644bc64cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_12.png"></p><h2 id="八-br标签-Break"><a href="#八-br标签-Break" class="headerlink" title="八.br标签(Break)"></a>八.br标签(Break)</h2><h3 id="1-作用-6"><a href="#1-作用-6" class="headerlink" title="1) 作用:"></a>1) 作用:</h3><ul><li>让内容换行<h3 id="2-格式-3"><a href="#2-格式-3" class="headerlink" title="2) 格式:"></a>2) 格式:</h3></li><li><code>&lt;br/&gt;</code><h3 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3) 注意点:"></a>3) 注意点:</h3></li><li>br的意思是不另起一个段落进行换行, 而网页中99.99%需要换行时都是因为另起了一个段落, 所以应该用p来做</li></ul><h2 id="九-a标签-anchor"><a href="#九-a标签-anchor" class="headerlink" title="九.a标签(anchor)"></a>九.a标签(anchor)</h2><h3 id="1-格式"><a href="#1-格式" class="headerlink" title="1) 格式:"></a>1) 格式:</h3><ul><li><code>&lt;a href=&quot;http://www.jianshu.com/u/5bd5e9ed569e&quot;&gt;我的简书&lt;/a&gt;</code><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2) 作用:"></a>2) 作用:</h3></li><li>用于从一个页面链接到另一个页面<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3) 注意事项:"></a>3) 注意事项:</h3></li><li>在a标签之间一定要写上文字, 如果没有, 那么在页面上找不到这个标签<br>a标签也叫做超级链接或超链接<h3 id="4-a标签的属性"><a href="#4-a标签的属性" class="headerlink" title="4) a标签的属性"></a>4) a标签的属性</h3></li></ul><table><thead><tr><th>属性名称</th><th>作用</th></tr></thead><tbody><tr><td>href(hypertext reference)</td><td>指定跳转的目标地址</td></tr><tr><td>target</td><td>告诉浏览器是否保留原始界面, _blank保留, _self不保留</td></tr><tr><td>title</td><td>悬停文本(介绍这个链接, 只有在鼠标移动到超链接上时才会显示)</td></tr></tbody></table><h4 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4) 代码示例"></a>4) 代码示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--a标签--&gt;</span><br><span class="line">&lt;a href=&quot;http://www.jianshu.com/u/5bd5e9ed569e&quot;&gt;我的简书&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;http://www.jianshu.com/u/5bd5e9ed569e&quot; title=&quot;我的简书&quot;&gt;我的简书&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;http://www.jianshu.com/u/5bd5e9ed569e&quot; title=&quot;我的简书&quot; target=&quot;_blank&quot;&gt;我的简书&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-b60bbd6bcf56af2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_13.png"></p><h3 id="5-base标签和a标签结合使用"><a href="#5-base标签和a标签结合使用" class="headerlink" title="5) base标签和a标签结合使用"></a>5) base标签和a标签结合使用</h3><ul><li>如果每个a标签都想在新页面中打开,那么逐个设置a标签的<code>target</code>属性比较麻烦, 这时我们可以使用base和a标签结合的方式,一次性设置有a标签都在新页面中打开<ul><li>格式: <code>&lt;base target=&quot;_blank&quot; /&gt;</code></li></ul></li><li>注意事项:<ul><li><code>base</code>必须嵌套在<code>head</code>标签里面</li><li>如果标签上指定了<code>target</code>,<code>base</code>中也指定了<code>target</code>,那么会按照标签上指定的来执行<h3 id="6-a标签其它用法"><a href="#6-a标签其它用法" class="headerlink" title="6) a标签其它用法"></a>6) a标签其它用法</h3></li></ul></li><li>假链接(本质是跳转到当前页面)<ul><li>格式<code>&lt;a href=&quot;#&quot;&gt;我的简书&lt;/a&gt;</code></li><li>格式<code>&lt;a href=&quot;javascript:&quot;&gt;我的简书&lt;/a&gt;</code><ul><li>跳转到当前页面指定位置(锚点链接)</li><li>1.格式<code>&lt;a href=&quot;#location&quot;&gt;</code>跳转到指定位置<code>&lt;/a&gt;</code></li><li>2.在页面的指定位置给任意标签添加一个id属性<ul><li>例如 <code>&lt;p id=&quot;location&quot;&gt;</code>这个是目标<code>&lt;/p&gt;</code></li></ul></li></ul></li><li>跳转到指定页面的指定位置<ul><li>格式: <code>&lt;a href=&quot;01-锚点链接.html#location&quot;&gt;跳转到指定位置&lt;/a&gt;</code></li><li>只需要在01-锚点链接.html页面添加一个id位置即可</li></ul></li><li>下载(极力不推荐使用)<ul><li>例如<code>&lt;a href=&quot;girl.zip&quot;&gt;</code>下载福利资源<code>&lt;a/&gt;</code></li></ul></li></ul></li></ul><blockquote><ul><li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040" target="_blank" rel="noopener">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5标签 </tag>
            
            <tag> CSS </tag>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5基本介绍</title>
      <link href="/2017/06/15/HTML5%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"/>
      <content type="html"><![CDATA[<h2 id="一-网页固定格式"><a href="#一-网页固定格式" class="headerlink" title="一.网页固定格式"></a>一.网页固定格式</h2><h3 id="1-编写网页的步骤"><a href="#1-编写网页的步骤" class="headerlink" title="1.编写网页的步骤:"></a>1.编写网页的步骤:</h3><ul><li>新建一个文本文档</li><li>利用记事本打开</li><li>编写THML代码</li><li>保存并且修改纯文本文档的扩展名为.html</li><li>利用浏览器打开编写好的文件</li></ul><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h2 id="一-网页固定格式-1"><a href="#一-网页固定格式-1" class="headerlink" title="一.网页固定格式"></a>一.网页固定格式</h2><h3 id="1-编写网页的步骤-1"><a href="#1-编写网页的步骤-1" class="headerlink" title="1.编写网页的步骤:"></a>1.编写网页的步骤:</h3><ul><li>新建一个文本文档</li><li>利用记事本打开</li><li>编写THML代码</li><li>保存并且修改纯文本文档的扩展名为.html</li><li>利用浏览器打开编写好的文件</li></ul><blockquote><p>一款强大的编辑软件  <a href="http://www.sdifen.com/?s=webstorm+&amp;submit=搜索" target="_blank" rel="noopener">Webstorm</a>或者 <a href="http://www.pc6.com/mac/112553.html" target="_blank" rel="noopener">WebStorm</a></p></blockquote><h4 id="1-1-WebStorm常见快捷键"><a href="#1-1-WebStorm常见快捷键" class="headerlink" title="1.1 WebStorm常见快捷键"></a>1.1 WebStorm常见快捷键</h4><ul><li><p>如何在WebStorm中利用快捷键创建一个新的.html的文件</p><ul><li>同时按下键盘上的Ctrl + Alt + Insert</li></ul></li><li><p>如何在WebStorm中让光标移动到当前行的末尾</p><ul><li>按下键盘上的End键即可</li></ul></li><li><p>如何在WebStorm中让光标移动到当前行的最前面</p><ul><li>按下键盘上的Home键即可</li></ul></li><li><p>如何在WebStorm中让光标在多行中闪烁</p><ul><li>按住键盘上的Alt键不放, 然后再按住鼠标的左键不放, 然后再拖动鼠标即可</li></ul></li><li><p>如何在WebStorm中快速的复制光标所在的那一行</p><ul><li>按下键盘上的Ctrl + D</li></ul></li><li><p>如何在WebStorm中快速的删除光标所在的那一行</p><ul><li>按下键盘上的Ctrl + X</li></ul></li><li><p>如何在WebStorm中让标签包裹一段内容, 也就是自动在一段内容前后加上标签</p><ul><li>按下键盘上的Ctrl + Alt + T, 然后按下回车, 然后输入对应的标签即可</li></ul></li></ul><h3 id="2-网页基本结构"><a href="#2-网页基本结构" class="headerlink" title="2.网页基本结构"></a>2.网页基本结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;音视频测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>通过观察我们发现, HTML基本结构中所有的标签都是成对出现的, 这些成对出现的标签中有一个带/有一个不带/, 那么这些不带/的标签我们称之为开始标签, 这些带/的我们称之为结束标签</li></ul><h2 id="二-网页标签"><a href="#二-网页标签" class="headerlink" title="二.网页标签"></a>二.网页标签</h2><h3 id="1-HTML标签"><a href="#1-HTML标签" class="headerlink" title="1.HTML标签"></a>1.HTML标签</h3><ul><li>作用: 用于告诉浏览器这是一个网页, 也就是说告诉浏览器我是一个HTML文档<blockquote><p>注意点: 其它所有的标签都必须写在html标签里面, 也就是写在html开始标签和结束标签中间</p></blockquote></li></ul><h3 id="2-head标签"><a href="#2-head标签" class="headerlink" title="2.head标签"></a>2.head标签</h3><ul><li>作用:<br>用于给网站添加一些配置信息</li><li>例如:<ul><li>指定网站的标题 / 指定网站的小图片</li><li>添加网站的SEO相关的信息(指定网站的关键字/指定网站的描述信息)</li><li>外挂一些外部的css/js文件</li><li>添加一些浏览器适配相关的内容<blockquote><p>注意点:<br>一般情况下, 写在head标签内部的内容都不会显示给用户查看, 也就是说一般情况下写在head标签内部的内容我们都看不到</p></blockquote></li></ul></li></ul><h3 id="3-title标签"><a href="#3-title标签" class="headerlink" title="3.title标签"></a>3.title标签</h3><ul><li>作用:<br>专门用于指定网站的标题, 并且这个指定的标题将来还会作为用户保存网站的默认标题<blockquote><p>注意点:<br>title标签必须写在head标签里面</p></blockquote></li></ul><h3 id="4-body标签"><a href="#4-body标签" class="headerlink" title="4.body标签"></a>4.body标签</h3><ul><li>作用:<br>专门用于定义HTML文档中需要显示给用户查看的内容(文字/图片/音频/视频)<blockquote><p>注意点:<br>虽然说有时候你可能将内容写到了别的地方在网页中也能看到, 但是千万不要这么干, 一定要将需要显示的内容写在body中<br>一对html标签中(一个html开始标签和一个html结束标签)只能有一对body标签</p></blockquote></li></ul><h3 id="5-meta标签"><a href="#5-meta标签" class="headerlink" title="5.meta标签"></a>5.meta标签</h3><ul><li>作用 : 在编写网页的时候指定字符集,可避免出现乱码现象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="GBK-GB2312-和UTF-8区别"><a href="#GBK-GB2312-和UTF-8区别" class="headerlink" title="GBK(GB2312)和UTF-8区别"></a>GBK(GB2312)和UTF-8区别</h4><ul><li>GBK(GB2312)里面存储的字符比较少, 仅仅存储了汉字和一些常用外文<br>体积比较小</li><li>UTF-8里面存储的世界上所有的文字,提交比较大<blockquote><h4 id="个人推荐-所有一律都写UTF-8"><a href="#个人推荐-所有一律都写UTF-8" class="headerlink" title="个人推荐:所有一律都写UTF-8"></a>个人推荐:所有一律都写UTF-8</h4></blockquote></li></ul><h2 id="3-HTML标签分类"><a href="#3-HTML标签分类" class="headerlink" title="3.HTML标签分类"></a>3.HTML标签分类</h2><h3 id="1-单标签"><a href="#1-单标签" class="headerlink" title="1.单标签"></a>1.单标签</h3><ul><li>只有开始标签没有结束标签, 也就是由一个&lt;&gt;组成的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-双标签"><a href="#2-双标签" class="headerlink" title="2.双标签"></a>2.双标签</h3><ul><li>有开始标签和结束标签, 也就是由一个&lt;&gt;和一个&lt;/&gt;组成的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-HTML标签关系分类"><a href="#4-HTML标签关系分类" class="headerlink" title="4.HTML标签关系分类"></a>4.HTML标签关系分类</h2><h3 id="1-并列关系-兄弟-平级"><a href="#1-并列关系-兄弟-平级" class="headerlink" title="1.并列关系(兄弟/平级)"></a>1.并列关系(兄弟/平级)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="2-嵌套关系-父子-上下级"><a href="#2-嵌套关系-父子-上下级" class="headerlink" title="2.嵌套关系(父子/上下级)"></a>2.嵌套关系(父子/上下级)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">      &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">      &lt;title&gt;音视频测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><blockquote><ul><li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040" target="_blank" rel="noopener">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5标签 </tag>
            
            <tag> CSS </tag>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift项目创建桥接文件</title>
      <link href="/2017/06/15/Swift%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%A1%A5%E6%8E%A5%E6%96%87%E4%BB%B6"/>
      <content type="html"><![CDATA[<h2 id="一-创建具体步骤参考"><a href="#一-创建具体步骤参考" class="headerlink" title="一.创建具体步骤参考"></a>一.创建具体步骤参考</h2><p><a href="http://www.jianshu.com/p/aa27548ce9e1" target="_blank" rel="noopener">Object-C 和 swift桥接文件</a></p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h2 id="二-报错"><a href="#二-报错" class="headerlink" title="二.报错"></a>二.报错</h2><blockquote><p>如出现 xxx file not found 的错误</p></blockquote><h3 id="参考解决-文中解释比较详细"><a href="#参考解决-文中解释比较详细" class="headerlink" title="参考解决(文中解释比较详细)"></a>参考解决(文中解释比较详细)</h3><p><a href="http://www.cnblogs.com/XYQ-208910/p/6252744.html" target="_blank" rel="noopener"><a href="http://www.cnblogs.com/XYQ-208910/p/6252744.html" target="_blank" rel="noopener">Swift: 在Swift中桥接OC文件（自己创建的类文件、第三方库文件）</a></a></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 桥接 </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift仿网易新闻首页左右滑动切换页面</title>
      <link href="/2017/06/12/Swift%E4%BB%BF%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BB%E9%A6%96%E9%A1%B5%E5%B7%A6%E5%8F%B3%E6%BB%91%E5%8A%A8%E5%88%87%E6%8D%A2%E9%A1%B5%E9%9D%A2"/>
      <content type="html"><![CDATA[<blockquote><p>顶部标题左右滑动切换控制器是一种非常用的左右滚动切换效果,几乎每一个APP都有用到,在这里介绍一下我自己封装的一个Swift版本的简单框架;代码中注释相对详细,故文中没有做过多的解释;废话不多少,直接上效果图:</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-91d007e59b3a6ce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图1.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-047cf052039633e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图2.png"></p><h2 id="一-框架介绍"><a href="#一-框架介绍" class="headerlink" title="一.框架介绍"></a>一.框架介绍</h2><h2 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a><a href="https://github.com/coderQuanjun/TJPageView" target="_blank" rel="noopener">github地址</a></h2><p><img src="http://upload-images.jianshu.io/upload_images/4122543-7f8bb034a432d133.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170612_18.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TJTitleStyle.swift  //控制框架所有显示样式的参数值</span><br><span class="line"></span><br><span class="line">TJTitleView.swift //顶部标题的处理view</span><br><span class="line"></span><br><span class="line">TJContentView.swift //处理所有控制器的view</span><br><span class="line"></span><br><span class="line">TJPageView.swift  //控制整体框架的总试图View</span><br></pre></td></tr></table></figure><h3 id="TJTitleStyle-swift"><a href="#TJTitleStyle-swift" class="headerlink" title="TJTitleStyle.swift"></a>TJTitleStyle.swift</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/// 是否是滚动的Title</span><br><span class="line">var isScrollEnable : Bool = false</span><br><span class="line">/// 普通Title颜色</span><br><span class="line">var normalColor : UIColor = UIColor(r: 0, g: 0, b: 0)</span><br><span class="line">/// 选中Title颜色</span><br><span class="line">var selectedColor : UIColor = UIColor(r: 255, g: 127, b: 0)</span><br><span class="line">/// Title字体大小</span><br><span class="line">var font : UIFont = UIFont.systemFont(ofSize: 14.0)</span><br><span class="line">/// 滚动Title的字体间距</span><br><span class="line">var titleMargin : CGFloat = 20</span><br><span class="line">/// title的高度</span><br><span class="line">var titleHeight : CGFloat = 44</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// 是否显示底部滚动条</span><br><span class="line">var isShowBottomLine : Bool = false</span><br><span class="line">/// 底部滚动条的颜色</span><br><span class="line">var bottomLineColor : UIColor = UIColor.orange</span><br><span class="line">/// 底部滚动条的高度</span><br><span class="line">var bottomLineH : CGFloat = 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// 是否进行缩放</span><br><span class="line">var isNeedScale : Bool = false</span><br><span class="line">var scaleRange : CGFloat = 1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// 是否显示遮盖</span><br><span class="line">var isShowCover : Bool = false</span><br><span class="line">/// 遮盖背景颜色</span><br><span class="line">var coverBgColor : UIColor = UIColor.lightGray</span><br><span class="line">/// 文字&amp;遮盖间隙</span><br><span class="line">var coverMargin : CGFloat = 5</span><br><span class="line">/// 遮盖的高度</span><br><span class="line">var coverH : CGFloat = 25</span><br><span class="line">/// 设置圆角大小</span><br><span class="line">var coverRadius : CGFloat = 12</span><br></pre></td></tr></table></figure><h3 id="TJPageCollectionLayout-swift自定义布局"><a href="#TJPageCollectionLayout-swift自定义布局" class="headerlink" title="TJPageCollectionLayout.swift自定义布局"></a>TJPageCollectionLayout.swift自定义布局</h3><blockquote><p>代码如下,注释比较详尽,不做赘述</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//    在该方法中设定一些必要的layout的结构和初始需要的参数</span><br><span class="line">override func prepare() &#123;</span><br><span class="line">    super.prepare()</span><br><span class="line">    </span><br><span class="line">    //0.计算item的宽度和高度</span><br><span class="line">    let itemW = ((collectionView?.bounds.width)! - sectionInset.left - sectionInset.right - minimumInteritemSpacing * CGFloat(cols - 1)) / CGFloat(cols)</span><br><span class="line">    let itemH = ((collectionView?.bounds.height)! - sectionInset.top - sectionInset.bottom - minimumLineSpacing * CGFloat(rows - 1)) / CGFloat(rows)</span><br><span class="line">    </span><br><span class="line">    //1.获取一共多少个组</span><br><span class="line">    let sectionCount = collectionView!.numberOfSections</span><br><span class="line">    </span><br><span class="line">    //2.获取每个组中有多少个item</span><br><span class="line">    var prePageCount : Int = 0    //页数</span><br><span class="line">    for i in 0..&lt;sectionCount &#123;</span><br><span class="line">        let itemCount = collectionView!.numberOfItems(inSection: i)</span><br><span class="line">        for j in 0..&lt;itemCount &#123;</span><br><span class="line">            //2.1获取cell对应的indexPath</span><br><span class="line">            let indexpath = IndexPath(item: j, section: i)</span><br><span class="line">            //2.2根据indexPath创建UICollectionViewLayoutAttributes</span><br><span class="line">            let attr = UICollectionViewLayoutAttributes(forCellWith: indexpath)</span><br><span class="line">            // 2.3.计算j在该组中第几页</span><br><span class="line">            let page = j / (cols * rows)</span><br><span class="line">            let index = j % (cols * rows)</span><br><span class="line">            //2.4设置attrs的frame</span><br><span class="line">            let itemY = sectionInset.top + (itemH + minimumLineSpacing) * CGFloat(index / cols)</span><br><span class="line">            let itemX = CGFloat(prePageCount + page) * collectionView!.bounds.width +  sectionInset.left + (itemW + minimumInteritemSpacing) * CGFloat(index % cols)</span><br><span class="line">            attr.frame = CGRect(x: itemX, y: itemY, width: itemW, height: itemH)</span><br><span class="line">            </span><br><span class="line">            //2.5加入到数组中</span><br><span class="line">            cellAttrs.append(attr)</span><br><span class="line">        &#125;</span><br><span class="line">        prePageCount += (itemCount - 1) / (cols * rows) + 1</span><br><span class="line">    &#125;</span><br><span class="line">    //计算最大宽度</span><br><span class="line">    maxWidth = CGFloat(prePageCount) * collectionView!.bounds.width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TJPageCollectionView-swift"><a href="#TJPageCollectionView-swift" class="headerlink" title="TJPageCollectionView.swift"></a>TJPageCollectionView.swift</h3><blockquote><p>创建collectionView显示布局内容,设置代理方法和对外暴露的方法</p></blockquote><h4 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protocol TJPageCollectionViewDateSource : class &#123;</span><br><span class="line">   //返回section的个数</span><br><span class="line">    func numberOfSections(in pageCollectionView : TJPageCollectionView) -&gt; Int</span><br><span class="line">    </span><br><span class="line">    //返回每个section中item的个数</span><br><span class="line">    func pageCollectionView(_ collectionView : TJPageCollectionView, numberOfItemsInSection section : Int) -&gt; Int</span><br><span class="line">    </span><br><span class="line">    //cell</span><br><span class="line">    func pageCollectionView(_ pageCollectionView : TJPageCollectionView, _ collectionView : UICollectionView, cellForItemAt indexPath : IndexPath) -&gt; UICollectionViewCell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol TJPageCollectionViewDelegate : class &#123;</span><br><span class="line">    //cell点击事件处理</span><br><span class="line">    func pageCollectionView(_ pageCollectionView : TJPageCollectionView, didSelectorItemAt indexPath : IndexPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-首页左右滑动调用方法"><a href="#二-首页左右滑动调用方法" class="headerlink" title="二.首页左右滑动调用方法"></a>二.首页左右滑动调用方法</h2><h4 id="1-设置显示样式"><a href="#1-设置显示样式" class="headerlink" title="1.设置显示样式"></a>1.设置显示样式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let style  = TJTitleStyle()</span><br><span class="line">//是否可以滚动</span><br><span class="line">style.isScrollEnable = true</span><br><span class="line">//是否显示下划线</span><br><span class="line">style.isShowBottomLine = true</span><br><span class="line">//是否显示遮挡试图view</span><br><span class="line">style.isShowCover = true</span><br></pre></td></tr></table></figure><h4 id="2-初始化方法"><a href="#2-初始化方法" class="headerlink" title="2.初始化方法"></a>2.初始化方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**初始化方法</span></span><br><span class="line"><span class="comment">* frame    : 坐标</span></span><br><span class="line"><span class="comment">* titles   : 标题数组</span></span><br><span class="line"><span class="comment">* style    : 样式</span></span><br><span class="line"><span class="comment">* childVcs : 自控制器数组</span></span><br><span class="line"><span class="comment">* parentVc : 父控制器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">let pageView = TJPageView(frame: frame, titles: titles, style: style, childVcs: childVcs, parentVc: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">view.addSubview(pageView)</span><br></pre></td></tr></table></figure><h2 id="三-底部类似表情键盘布局调用方法"><a href="#三-底部类似表情键盘布局调用方法" class="headerlink" title="三.底部类似表情键盘布局调用方法"></a>三.底部类似表情键盘布局调用方法</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 1.设置显示样式</span><br><span class="line">let style = TJTitleStyle()</span><br><span class="line">style.isShowBottomLine = true</span><br><span class="line">        </span><br><span class="line">//2.设置cell布局Layout</span><br><span class="line">let layout = TJPageCollectionLayout()</span><br><span class="line">layout.cols = 7 // 列</span><br><span class="line">layout.rows = 3 // 行</span><br><span class="line">layout.minimumLineSpacing = 0</span><br><span class="line">layout.minimumInteritemSpacing = 0</span><br><span class="line">layout.sectionInset = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)</span><br><span class="line">        </span><br><span class="line">//3.创建collectionView</span><br><span class="line">let pageCollection = TJPageCollectionView(frame: CGRect(x: 0, y: UIScreen.main.bounds.height - 250, width: UIScreen.main.bounds.width, height: 250), style: style, titles: [&quot;普通&quot;, &quot;粉丝&quot;], isTitleInTop: false, layout: layout)</span><br><span class="line">pageCollection.delegate = self</span><br><span class="line">pageCollection.dataSource = self</span><br><span class="line"></span><br><span class="line">//4.注册cell</span><br><span class="line">pageCollection.register(nib: UINib(nibName: &quot;EmoticonViewCell&quot;, bundle: nil), identifier: kEmoticonCellID)</span><br><span class="line"></span><br><span class="line">//5.添加到视图中</span><br><span class="line">view.addSubview(pageCollection)</span><br></pre></td></tr></table></figure><h3 id="2-遵循协议"><a href="#2-遵循协议" class="headerlink" title="2.遵循协议"></a>2.遵循协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//MARK: TJCollectionViewDateSource</span><br><span class="line">extension NextViewController : TJPageCollectionViewDateSource&#123;</span><br><span class="line">    func numberOfSections(in pageCollectionView: TJPageCollectionView) -&gt; Int &#123;</span><br><span class="line">        return 5</span><br><span class="line">    &#125;</span><br><span class="line">    func pageCollectionView(_ collectionView: TJPageCollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        return 40</span><br><span class="line">    &#125;</span><br><span class="line">    func pageCollectionView(_ pageCollectionView: TJPageCollectionView, _ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;</span><br><span class="line">        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: kEmoticonCellID, for: indexPath) as! EmoticonViewCell</span><br><span class="line">        </span><br><span class="line">        return cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//MARK: TJPageCollectionViewDelegate</span><br><span class="line">extension NextViewController : TJPageCollectionViewDelegate&#123;</span><br><span class="line">    func pageCollectionView(_ pageCollectionView: TJPageCollectionView, didSelectorItemAt indexPath: IndexPath) &#123;</span><br><span class="line">        print(indexPath)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="框架代码中可能还有不足之处-还望大神多多指教"><a href="#框架代码中可能还有不足之处-还望大神多多指教" class="headerlink" title="框架代码中可能还有不足之处,还望大神多多指教."></a>框架代码中可能还有不足之处,还望大神多多指教.</h3></blockquote><blockquote><h3 id="菜鸟一枚-多多交流"><a href="#菜鸟一枚-多多交流" class="headerlink" title="菜鸟一枚,多多交流."></a>菜鸟一枚,多多交流.</h3></blockquote><h2 id="github地址-1"><a href="#github地址-1" class="headerlink" title="github地址"></a><a href="https://github.com/coderQuanjun/TJPageView" target="_blank" rel="noopener">github地址</a></h2>]]></content>
      
      <categories>
          
          <category> Swiftk框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS9之UIStackView的使用</title>
      <link href="/2017/06/10/iOS9%E4%B9%8BUIStackView%E7%9A%84%E4%BD%BF%E7%94%A8"/>
      <content type="html"><![CDATA[<p>苹果在iOS9新增了一个简易的布局控件UIStackView,它是一个基于 Auto Layout 的抽象层从而使布局属性的创建简单化,它可以将一组 UIView 视图进行垂直或水平方向的排列。</p><ul><li>UIStackView 既可以用代码编写也可以在 Interface Builder 中设计(简易xib更方便适用)。</li><li>你可以在一个主 UIStackView 中嵌套 UIStackView 从而让视图精确放置到相应的位置</li></ul><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><blockquote><p>下面就具体介绍一下UIStackView的一些方法和属性</p></blockquote><h2 id="一-方法"><a href="#一-方法" class="headerlink" title="一.方法"></a>一.方法</h2><h3 id="1-初始化数组"><a href="#1-初始化数组" class="headerlink" title="1.初始化数组"></a>1.初始化数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//OC中</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithArrangedSubviews:(NSArray&lt;__kindof UIView *&gt; *)views;</span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line"></span><br><span class="line">let stackView1 = UIStackView(arrangedSubviews: subViews)</span><br></pre></td></tr></table></figure><h3 id="2-添加子视图"><a href="#2-添加子视图" class="headerlink" title="2.添加子视图"></a>2.添加子视图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//OC</span><br><span class="line"></span><br><span class="line">- (void)addArrangedSubview:(UIView *)view;</span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line"></span><br><span class="line">stackView.addArrangedSubview(UIView)</span><br></pre></td></tr></table></figure><h3 id="3-移除子视图"><a href="#3-移除子视图" class="headerlink" title="3.移除子视图"></a>3.移除子视图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//OC</span><br><span class="line"></span><br><span class="line">- (void)removeArrangedSubview:(UIView *)view;</span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line"></span><br><span class="line">stackView1.removeArrangedSubview(UIView)</span><br></pre></td></tr></table></figure><h3 id="4-根据下标插入子视图"><a href="#4-根据下标插入子视图" class="headerlink" title="4.根据下标插入子视图"></a>4.根据下标插入子视图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//OC</span><br><span class="line"></span><br><span class="line">- (void)insertArrangedSubview:(UIView *)view atIndex:(NSUInteger)stackIndex;</span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line"></span><br><span class="line">stackView1.insertArrangedSubview(UIView, atIndex: Int)</span><br></pre></td></tr></table></figure><h2 id="二-属性"><a href="#二-属性" class="headerlink" title="二.属性"></a>二.属性</h2><h3 id="1-布局方向"><a href="#1-布局方向" class="headerlink" title="1.布局方向"></a>1.布局方向</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">stackView.axis = .Horizontal</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************/</span></span><br><span class="line"></span><br><span class="line">Horizontal -&gt; <span class="built_in">UILayoutConstraintAxisHorizontal</span></span><br><span class="line"></span><br><span class="line">水平方向布局</span><br><span class="line"></span><br><span class="line">Vertical  -&gt; <span class="built_in">UILayoutConstraintAxisVertical</span></span><br><span class="line"></span><br><span class="line">垂直方向布局</span><br></pre></td></tr></table></figure><h3 id="2-内容物填充样式"><a href="#2-内容物填充样式" class="headerlink" title="2.内容物填充样式"></a>2.内容物填充样式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">stackView.distribution = .FillEqually</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************/</span></span><br><span class="line"></span><br><span class="line">Fill -&gt; <span class="built_in">UIStackViewDistributionFill</span></span><br><span class="line"></span><br><span class="line">填充整个<span class="built_in">UIStackView</span>，并且根据内部子视图尺寸对子视图尺寸进行动态调整。</span><br><span class="line"></span><br><span class="line">Fill Equally -&gt; <span class="built_in">UIStackViewDistributionFillEqually</span></span><br><span class="line"></span><br><span class="line">根据视图大小平均分配<span class="built_in">UIStackView</span>尺寸，等比例填充<span class="built_in">UIStackView</span>，过程中会根据分配的大小改变子视图尺寸。</span><br><span class="line"></span><br><span class="line">Fill Proportionally -&gt; <span class="built_in">UIStackViewDistributionFillProportionally</span></span><br><span class="line"></span><br><span class="line">根据之前的比例填充<span class="built_in">UIStackView</span>。</span><br><span class="line"></span><br><span class="line">Equal Spacing -&gt; <span class="built_in">UIStackViewDistributionEqualSpacing</span></span><br><span class="line"></span><br><span class="line">填充整个<span class="built_in">UIStackView</span>，子视图没有占满<span class="built_in">UIStackView</span>将会用空白平均填充子视图中间的间距，超出<span class="built_in">UIStackView</span>将会根据arrangedSubviews数组下标压缩子视图。</span><br><span class="line"></span><br><span class="line">Equal Centering -&gt; <span class="built_in">UIStackViewDistributionEqualCentering</span></span><br><span class="line"></span><br><span class="line">平均分配子视图得到每个视图的中心点，使用这个中心点来布局每个子视图，并且保持spacing距离，超出将会重新布局子视图，并压缩部分子视图。</span><br></pre></td></tr></table></figure><h3 id="3-视图填充样式"><a href="#3-视图填充样式" class="headerlink" title="3.视图填充样式"></a>3.视图填充样式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">stackView.alignment = .Fill</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************/</span></span><br><span class="line"></span><br><span class="line">Fill -&gt; <span class="built_in">UIStackViewAlignmentFill</span></span><br><span class="line"></span><br><span class="line">视图纵向填充</span><br><span class="line"></span><br><span class="line">Top -&gt; <span class="built_in">UIStackViewAlignmentTop</span></span><br><span class="line"></span><br><span class="line">视图向上对其(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">Center -&gt; <span class="built_in">UIStackViewAlignmentCenter</span></span><br><span class="line"></span><br><span class="line">视图居中对其</span><br><span class="line"></span><br><span class="line">Bottom -&gt; <span class="built_in">UIStackViewAlignmentBottom</span></span><br><span class="line"></span><br><span class="line">视图向下对其(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">First Baseline -&gt; <span class="built_in">UIStackViewAlignmentFirstBaseline</span></span><br><span class="line"></span><br><span class="line">根据上方基线布局所有子视图的y值(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">Last Baseline -&gt; <span class="built_in">UIStackViewAlignmentLastBaseline</span></span><br><span class="line"></span><br><span class="line">根据下方基线布局所有子视图的y值(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">trailing -&gt; <span class="built_in">UIStackViewAlignmentTrailing</span></span><br><span class="line"></span><br><span class="line">视图向左对齐(适用于Vertical模式)</span><br><span class="line"></span><br><span class="line">leading -&gt; <span class="built_in">UIStackViewAlignmentLeading</span></span><br><span class="line"></span><br><span class="line">视图向右对齐(适用于Vertical模式)</span><br></pre></td></tr></table></figure><h3 id="4-子控件之间最小距离"><a href="#4-子控件之间最小距离" class="headerlink" title="4.子控件之间最小距离"></a>4.子控件之间最小距离</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">stackView.spacing = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************/</span></span><br><span class="line"></span><br><span class="line">spacing -&gt; <span class="built_in">CGFloat</span> spacing</span><br></pre></td></tr></table></figure><h3 id="5-基线相对布局"><a href="#5-基线相对布局" class="headerlink" title="5.基线相对布局"></a>5.基线相对布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public var baselineRelativeArrangement: Bool</span><br></pre></td></tr></table></figure><blockquote><p>如果YES，则从顶视图的最后基线到底视图的顶部测量两个视图之间的垂直间距。</p></blockquote><h3 id="6-边界相对布局"><a href="#6-边界相对布局" class="headerlink" title="6.边界相对布局"></a>6.边界相对布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public var layoutMarginsRelativeArrangement: Bool</span><br></pre></td></tr></table></figure><blockquote><p>决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距，选中 Layout Margins Relative 将相对于标准边界空白来调整subview位置</p></blockquote><p>##Xib创建</p><ul><li>择UIStackView控件直接拖到XIB中。可以选择Horizontal和Vertical两个方向的UIStackView，也可以在拖到XIB中之后手动修改。</li><li>父视图可以将UIStackView作为子视图来进行多层UIStackView嵌套，这也是苹果推荐的做法。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-477dcb03e40d295a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图片1.png"></p><blockquote><ul><li>打开右侧设置面板来设置UIStackView的一些对应属性，达到更好的布局效果。</li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-002b7b5799b9aeee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图片2.png"></p><blockquote><ul><li>除了上面的方法也可以在XIB中直接选择多个View，然后点击右下方的Stack按钮，系统会自动推断布局方式,平均分配空间布局，帮我们自动布局子视图，我们可以在系统布局之后在手动进行调整。</li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-304660a3ee85070d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图片3.png"></p><blockquote><p>作为一枚小菜鸟,不足之处还望大家多多指正,互相学起,共同进步!</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> UIStackView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NSMutableAttributedString富文本</title>
      <link href="/2017/05/19/NSMutableAttributedString%E5%AF%8C%E6%96%87%E6%9C%AC"/>
      <content type="html"><![CDATA[<p>在iOS开发中，常常会有一段文字显示不同的颜色和字体，或者给某几个文字加删除线或下划线的需求。以及一些直播界面中包含图片和字体的弹幕效果，大部分都是由NSMuttableAttstring（带属性的字符串）实现的。</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h2 id="一、简易使用方法"><a href="#一、简易使用方法" class="headerlink" title="一、简易使用方法"></a>一、简易使用方法</h2><blockquote><p>1、示例代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func addAttributeString() -&gt; NSMutableAttributedString&#123;</span><br><span class="line">    </span><br><span class="line">    let time = &quot;还剩 19 时 30 分 40 秒 开售&quot;</span><br><span class="line">    let timeAtt = NSMutableAttributedString(string: time)</span><br><span class="line">    </span><br><span class="line">    //字典中存放一些属性名和属性值</span><br><span class="line">    let timeDic = [NSFontAttributeName : UIFont.systemFont(ofSize: 18), NSForegroundColorAttributeName : UIColor.red, NSBackgroundColorAttributeName : UIColor.orange]</span><br><span class="line">    </span><br><span class="line">    //为某一范围内的文字设置多个属性</span><br><span class="line">    timeAtt.setAttributes(timeDic, range: NSMakeRange(2, 4))</span><br><span class="line">    //为某一范围内的文字添加单个属性</span><br><span class="line">    timeAtt.addAttribute(NSFontAttributeName, value: UIFont.systemFont(ofSize: 18), range: NSMakeRange(8, 4))</span><br><span class="line">    //为某一范围内的文字添加多个属性</span><br><span class="line">    timeAtt.addAttributes(timeDic, range: NSMakeRange(8, 4))</span><br><span class="line">    //为某一范围内的文字移除某个属性</span><br><span class="line">    timeAtt.removeAttribute(NSFontAttributeName, range: NSMakeRange(8, 4))</span><br><span class="line">    </span><br><span class="line">    return timeAtt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符串处理</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//拼接字符串</span><br><span class="line">timeAtt.append(NSAttributedString)</span><br><span class="line"></span><br><span class="line">//插入字符串</span><br><span class="line">timeAtt.insert(NSAttributedString, at: Int)</span><br><span class="line"></span><br><span class="line">//替换</span><br><span class="line">timeAtt.replaceCharacters(in: NSRange, with: NSAttributedString)</span><br><span class="line">timeAtt.replaceCharacters(in: NSRange, with: String)</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">timeAtt.removeAttribute(String, range: NSRange)</span><br></pre></td></tr></table></figure><blockquote><p>2、常见属性及说明</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">NSFontAttributeName                设置字体属性，默认值：字体：Helvetica(Neue) 字号：12</span><br><span class="line"></span><br><span class="line">NSForegroundColorAttributeNam      设置字体颜色，取值为 UIColor对象，默认值为黑色</span><br><span class="line"></span><br><span class="line">NSBackgroundColorAttributeName     设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色</span><br><span class="line"></span><br><span class="line">NSLigatureAttributeName            设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符</span><br><span class="line"></span><br><span class="line">NSKernAttributeName                设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄</span><br><span class="line"></span><br><span class="line">NSStrikethroughStyleAttributeName  设置删除线，取值为 NSNumber 对象（整数）</span><br><span class="line"></span><br><span class="line">NSStrikethroughColorAttributeName  设置删除线颜色，取值为 UIColor 对象，默认值为黑色</span><br><span class="line"></span><br><span class="line">NSUnderlineStyleAttributeName      设置下划线，取值为NSNumber对象（整数），枚举常量NSUnderlineStyle中的值，与删除线类似</span><br><span class="line"></span><br><span class="line">NSUnderlineColorAttributeName      设置下划线颜色，取值为 UIColor 对象，默认值为黑色</span><br><span class="line"></span><br><span class="line">NSStrokeWidthAttributeName         设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果</span><br><span class="line"></span><br><span class="line">NSStrokeColorAttributeName         填充部分颜色，不是字体颜色，取值为 UIColor 对象</span><br><span class="line"></span><br><span class="line">NSShadowAttributeName              设置阴影属性，取值为 NSShadow 对象</span><br><span class="line"></span><br><span class="line">NSTextEffectAttributeName          设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：</span><br><span class="line"></span><br><span class="line">NSBaselineOffsetAttributeName      设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏</span><br><span class="line"></span><br><span class="line">NSObliquenessAttributeName         设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾</span><br><span class="line"></span><br><span class="line">NSExpansionAttributeName           设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本</span><br><span class="line"></span><br><span class="line">NSWritingDirectionAttributeName    设置文字书写方向，从左向右书写或者从右向左书写</span><br><span class="line"></span><br><span class="line">NSVerticalGlyphFormAttributeName   设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本</span><br><span class="line"></span><br><span class="line">NSLinkAttributeName                设置链接属性，点击后调用浏览器打开指定URL地址</span><br><span class="line"></span><br><span class="line">NSAttachmentAttributeName          设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排</span><br><span class="line"></span><br><span class="line">NSParagraphStyleAttributeName      设置文本段落排版格式，取值为 NSParagraphStyle 对象</span><br></pre></td></tr></table></figure><blockquote><h2 id="更多方法和属性说明详见苹果官方说明文档"><a href="#更多方法和属性说明详见苹果官方说明文档" class="headerlink" title="更多方法和属性说明详见苹果官方说明文档"></a><a href="https://developer.apple.com/reference/foundation/nsmutableattributedstring#//apple_ref/doc/uid/TP40003689" target="_blank" rel="noopener">更多方法和属性说明详见苹果官方说明文档</a></h2></blockquote><h2 id="二实现图文混排"><a href="#二实现图文混排" class="headerlink" title="二实现图文混排"></a>二实现图文混排</h2><blockquote><p>效果如图</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/2092665-fa45440126fc57c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><p>实例代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//1,富文本字符串</span><br><span class="line">let attText = NSMutableAttributedString(string: &quot;你好不好&quot;)</span><br><span class="line">attText.setAttributes([NSForegroundColorAttributeName : UIColor.orange], range: NSMakeRange(0, 4))</span><br><span class="line">        </span><br><span class="line">//2,图片处理</span><br><span class="line">let attachment = NSTextAttachment()</span><br><span class="line">attachment.image = UIImage(named: &quot;tt1&quot;)</span><br><span class="line">        </span><br><span class="line">//3,计算文字高度</span><br><span class="line">let lineHeight = label.font.lineHeight</span><br><span class="line">        </span><br><span class="line">//4,设置图片的显示大小</span><br><span class="line">attachment.bounds = CGRect(x: 0, y: 0, width: lineHeight, height: lineHeight)</span><br><span class="line">//5,图片转成富文本</span><br><span class="line">let picAtt = NSAttributedString(attachment: attachment)</span><br><span class="line">        </span><br><span class="line">//6,插入到原字符串中</span><br><span class="line">attText.insert(picAtt, at: 2)</span><br></pre></td></tr></table></figure><blockquote><p>菜鸟一枚,文中如有不妥之处还望多多指正;互相学习共同进步!</p></blockquote><blockquote><p>喜欢的朋友可以点下喜欢,并关注下!</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 富文本 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift函数式编程之Map&amp;Reduce&amp;Filter</title>
      <link href="/2017/05/19/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8BMap&amp;Reduce&amp;Filter"/>
      <content type="html"><![CDATA[<ul><li>什么是函数式编程呢?<ul><li>函数式编程其实是一种编程思想, 代码写出来只是它的表现形式.</li><li>在面向对象的编程思想中, 我们将要解决的一个个问题, 抽象成一个个类, 通过给类定义属性和方法, 让类帮助我们解决需要处理的问题.(其实面向对象也叫命令式编程, 就像给对象下一个个命令)</li><li>而在函数式编程中, 我们则通过函数描述我们要解决的问题, 以及解决问题需要怎样的方案.</li><li>函数本身可以作为变量, 作为参数, 作为返回值(这样说有一点抽象, 下面的解决方案中就是将函数作为函数的参数)</li></ul></li></ul><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h3 id="1-Map的介绍"><a href="#1-Map的介绍" class="headerlink" title="1. Map的介绍"></a>1. Map的介绍</h3><blockquote><p>map用于将每个数组元素通过某个方法进行转换</p></blockquote><ul><li>Map在此处并非地图的意思, 它的含义是映射<ul><li>将一个元素映射成另外一种元素(类似于字典中的Key/Value映射)</li><li>其实Swift系统本身是有映射的函数, 可以将一个集合映射成另外一个集合</li><li>map 方法接受一个闭包作为参数， 然后它会遍历整个数组，并对数组中每一个元素执行闭包中定义的操作。然后再返回一个操作后的数组；相当于对数组中的所有元素做了一个映射</li></ul></li></ul><blockquote><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析:"></a>示例分析:</h3></blockquote><h4 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">let arr2 = arr.map(&#123; $<span class="number">0</span> * <span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">//[3, 6, 9, 12, 15, 18]</span></span><br><span class="line">let arr3 = arr.flatMap(&#123; $<span class="number">0</span> + <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">//[3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h3 id="2-flatMap"><a href="#2-flatMap" class="headerlink" title="2. flatMap"></a>2. flatMap</h3><ul><li>我们对同样的数组使用 flatMap 进行处理， 得到了同样的结果。 那 flatMap 和 map 到底有什么区别呢？</li></ul><h4 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let numbersCompound = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]];</span><br><span class="line">var res = numbersCompound.map &#123; $<span class="number">0.</span>map&#123; $<span class="number">0</span> + <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="comment">// [[3, 4, 5], [6, 7, 8]]</span></span><br><span class="line">var flatRes = numbersCompound.flatMap &#123; $<span class="number">0.</span>map&#123; $<span class="number">0</span> + <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="comment">// [3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><ul><li>flatMap 依然会遍历数组的元素，并对这些元素执行闭包中定义的操作。 但唯一不同的是，它对最终的结果进行了所谓的 “降维” 操作。 本来原始数组是一个二维的， 但经过 flatMap 之后，它变成一维的了。</li></ul><blockquote><p>下面咱们再来看一下 flatMap 的定义, 还是抛去 @noescape, rethrows 这些无关逻辑的关键字：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func flatMap(transform: (Self.Generator.Element) throws -&gt; T?) -&gt; [T]</span><br><span class="line">func flatMap(transform: (Self.Generator.Element) -&gt; S) -&gt; [S.Generator.Element]</span><br></pre></td></tr></table></figure><ul><li>和 map 不同， flatMap 有两个重载。 参照我们刚才的示例， 我们调用的其实是第二个重载：flatMap 的闭包接受的是数组的元素，但返回的是一个 SequenceType 类型，也就是另外一个数组<blockquote><p>下面让我们来看看flatMap 的另一种重载情况</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func flatMap</span><br><span class="line">(transform: (Self.Generator.Element) -&gt; T?) -&gt; [T]</span><br></pre></td></tr></table></figure><ul><li>从定义中我们看出， 它的闭包接收的是 Self.Generator.Element 类型， 返回的是一个 T? 。 我们都知道，在 Swift 中类型后面跟随一个 ?， 代表的是 Optional 值。 也就是说这个重载中接收的闭包返回的是一个 Optional 值。 更进一步来说，就是闭包可以返回 nil。</li></ul><h4 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let optionalArray: [String?] = [<span class="string">"AA"</span>, <span class="literal">nil</span>, <span class="string">"BB"</span>, <span class="string">"CC"</span>];</span><br><span class="line">print（optionalArray）</span><br><span class="line"><span class="comment">//[Optional("AA"), nil, Optional("BB"), Optional("CC")]</span></span><br><span class="line"></span><br><span class="line">var optionalResult = optionalArray.flatMap&#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// ["AA", "BB", "CC"]</span></span><br></pre></td></tr></table></figure><ul><li>flatMap 的返回结果中， 成功的将原数组中的 nil 值过滤掉了。 再仔细观察，你会发现更多。 使用 flatMap 调用之后， 数组中的所有元素都被解包了</li></ul><h4 id="关于-0的解释"><a href="#关于-0的解释" class="headerlink" title="关于$0的解释"></a>关于$0的解释</h4><ul><li>$0代表传入的元素本身，而不是下标</li><li>$0.0代表传入的元组的第一个值，如果元组被命名过了，则可以直接带名字</li><li>$0.age代表传入的模型的age属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元组类型</span></span><br><span class="line">let a1 = [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">6</span>),(<span class="number">6</span>,<span class="number">7</span>)]</span><br><span class="line">let a2 = a1.map(&#123; $<span class="number">0.0</span> * <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//模型类型</span></span><br><span class="line">let ageArr = modelArr.map(&#123; $<span class="number">0.</span>age &#125;)</span><br><span class="line">let nameArr = modelArr.map(&#123; $<span class="number">0.</span>name &#125;)</span><br></pre></td></tr></table></figure><h3 id="3-zip的使用"><a href="#3-zip的使用" class="headerlink" title="3. zip的使用"></a>3. zip的使用</h3><blockquote><p>3-1. zip 是将两个序列的元素，一一对应合并成元组，生成一个新序列。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3, 4]</span><br><span class="line">let b = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line">let c = zip(a, b).map &#123; $0 &#125;</span><br><span class="line">// c = [(1, &quot;a&quot;), (2, &quot;b&quot;), (3, &quot;c&quot;), (4, &quot;d&quot;)]</span><br></pre></td></tr></table></figure></p></blockquote><p>生成的序列，如同原始两个序列的相互咬合，因此函数的名字为 zip。zip 的英文有拉链的意思。生成的序列 count 为原始序列的最小值。</p><blockquote><p>3-2. zip 生成的序列通常会进行下一步处理。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func loadColors(colors: [UIColor]) &#123;</span><br><span class="line">    zip(self.colorButtons, colors).forEach &#123; (bt, color) in</span><br><span class="line">        bt.color = color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>上面这段的语句，为颜色按钮分别赋予颜色值。相当于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func loadColors(colors: [UIColor]) &#123;</span><br><span class="line">    let minCount = min(colors.count, self.colorButtons.count)</span><br><span class="line">    for i in 0 ..&lt; minCount &#123;</span><br><span class="line">        self.colorButtons[i].color = colors[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再举一段代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let colors = [UIColor.red, UIColor.blue, UIColor.white]</span><br><span class="line">let buttons = zip(0 ..&lt; colors.count, colors).map &#123; (i, color) in</span><br><span class="line">    let button = ColorButton(color: color)</span><br><span class="line">    button.tag = i</span><br><span class="line">    return button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码，创建了颜色按钮，并用索引设置了对应的 tag。</p><p>最后</p><blockquote><p>3-3. 这些简单的函数，配合起来可以达到一些高级的功能。比如:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br><span class="line">let b = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</span><br><span class="line">let c = zip(a, b).flapMap &#123; [$0, $1] &#125;</span><br><span class="line">// c = [&quot;a&quot;, &quot;A&quot;, &quot;b&quot;, &quot;B&quot;, &quot;c&quot;, &quot;C&quot;, &quot;d&quot;, &quot;D&quot;]</span><br></pre></td></tr></table></figure><p>这里将两个序列的元素，间隔地插入，合并成一个序列。</p><blockquote><p>3-4. zip和速记+来通过添加两个冲突的值来解析重复的键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let keyNames2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]</span><br><span class="line">let dict = Dictionary(zip(keyNames2, repeatElement(1, count: keyNames2.count)), uniquingKeysWith: +)</span><br><span class="line">//[&quot;b&quot;: 2, &quot;a&quot;: 2, &quot;c&quot;: 1]</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="二、Filter的使用"><a href="#二、Filter的使用" class="headerlink" title="二、Filter的使用"></a>二、Filter的使用</h2><blockquote><p>filter用于选择数组元素中满足某种条件的元素</p></blockquote><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">let arr2 = arr.filter(&#123; $<span class="number">0</span> &lt; <span class="number">5</span> &#125;)</span><br><span class="line"><span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h2 id="三、Reduce的使用"><a href="#三、Reduce的使用" class="headerlink" title="三、Reduce的使用"></a>三、Reduce的使用</h2><blockquote><p>reduce方法把数组元素组合计算为一个值</p><ul><li>先看一段传统代码</li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let moneyArray = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">10</span>] </span><br><span class="line">var sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> money <span class="keyword">in</span> moneyArray &#123;</span><br><span class="line">    sum = sum + money</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再看看数字相乘</span></span><br><span class="line">var product = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> money <span class="keyword">in</span> moneyArray &#123;</span><br><span class="line">    product = product * money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Swift中reduct在Array类中的定义为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(initial: T, combine: (T, Int) throws -&gt; T)</span><br></pre></td></tr></table></figure></li><li><p>接收两个参数，一个为类型U的初始值，另一个为把类型为U的元素和类型为T的元素组合成一个类型为U的值的函数。最终结果整个数组就变成了一个类型为U的值。</p></li></ul><h4 id="reduce简化代码"><a href="#reduce简化代码" class="headerlink" title="reduce简化代码"></a>reduce简化代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = moneyArray.reduce(0,&#123;$0 + $1&#125;)</span><br><span class="line"></span><br><span class="line">//Swift中操作符可用着函数，可简化成：</span><br><span class="line">sum = moneyArray.reduce(0,+)</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是combine函数的两参数类型不同，$0为计算结果类型，$1为数组元素类型</p></blockquote><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><blockquote><p>1、需要说明的是数据比较大的时候，高阶函数会比传统实现更快，因为它可以并行执行（如运行在多核上），除非真的需要更高定制版本的map，reduce和filter，否则可以一直使用它们以获得更快的执行速度。</p></blockquote><blockquote><p>2、我确信当你使用map，filter，reduct的代码质量会更好。但也需要在合适的场景中使用它们，不要指望用它们来解决任何问题。没有放之四海而皆准的真理。</p></blockquote><blockquote><p>详情参考<a href="http://blog.csdn.net/fish_yan_/article/details/51785441" target="_blank" rel="noopener">http://blog.csdn.net/fish_yan_/article/details/51785441</a><br>详情参考<a href="http://www.cocoachina.com/swift/20150619/12173.html" target="_blank" rel="noopener">http://www.cocoachina.com/swift/20150619/12173.html</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift3.0基本语法03</title>
      <link href="/2016/12/30/Swift3.0%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%9503"/>
      <content type="html"><![CDATA[<h2 id="willSet和didSet"><a href="#willSet和didSet" class="headerlink" title="willSet和didSet"></a>willSet和didSet</h2><ul><li>属性观察器控制和响应属性的变化，当属性被设置的时候回调用属性观察器，主要有以下几个特点：<ul><li>属性改变之前触发willSet方法，属性改变之后触发didSet方法</li><li>在给属性添加观察者之前必须要明确申明属性的类型，否则编译器会报错</li><li>属性初始化时，willSet和didSet都不会调用，只有在设置属性值时才会调用</li><li>当设置的值和原来的值一样时，willSet和didSet也会被调用</li><li>willSet有一个newValue参数，didSet有一个oldvalue参数<br><excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a></excerpt></li></ul></li></ul><blockquote><p>代码如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var age:Int = 18&#123;</span><br><span class="line">    didSet&#123;</span><br><span class="line">        print(&quot;didSet   \(oldValue)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    willSet&#123;</span><br><span class="line">        print(&quot;willSet  \(newValue)&quot;)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  age重新赋值并打印     */</span><br><span class="line">age = 10;</span><br><span class="line">print(&quot;   \(age)&quot;)</span><br><span class="line">/*输出</span><br><span class="line">willSet 10</span><br><span class="line">didSet  18</span><br><span class="line">10</span><br><span class="line">*/</span><br><span class="line">age = 100</span><br><span class="line">print(&quot;   \(age)&quot;)</span><br><span class="line">/*输出</span><br><span class="line">willSet 100</span><br><span class="line">didSet  10</span><br><span class="line">100</span><br><span class="line">*/</span><br><span class="line">age = 200</span><br><span class="line">print(&quot;   \(age)&quot;)</span><br><span class="line">/*输出</span><br><span class="line">willSet 200</span><br><span class="line">didSet  100</span><br><span class="line">200</span><br><span class="line">*/</span><br><span class="line">age = 18</span><br><span class="line">print(&quot;    \(age)&quot;)</span><br><span class="line">/*输出</span><br><span class="line">willSet 18</span><br><span class="line">didSet  200</span><br><span class="line">18</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><blockquote><p>实例应用</p><ul><li>cell内部,模型赋值</li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> HomeViewCell: <span class="built_in">UICollectionViewCell</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: 控件属性</span></span><br><span class="line">    @IBOutlet <span class="keyword">weak</span> var albumImageView: <span class="built_in">UIImageView</span>!</span><br><span class="line">    @IBOutlet <span class="keyword">weak</span> var liveImageView: <span class="built_in">UIImageView</span>!</span><br><span class="line">    @IBOutlet <span class="keyword">weak</span> var nickNameLabel: <span class="built_in">UILabel</span>!</span><br><span class="line">    @IBOutlet <span class="keyword">weak</span> var onlinePeopleLabel: <span class="built_in">UIButton</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: 定义属性</span></span><br><span class="line">    var anchorModel : AnchorModel?&#123;</span><br><span class="line">        didSet&#123;</span><br><span class="line">            albumImageView.setImage(anchorModel!.isEvenIndex ? anchorModel?.pic74 : anchorModel?.pic51, <span class="string">"home_pic_default"</span>)</span><br><span class="line">            liveImageView.isHidden = anchorModel?.live == <span class="number">0</span></span><br><span class="line">            nickNameLabel.text = anchorModel?.name</span><br><span class="line">            onlinePeopleLabel.setTitle(<span class="string">"\(anchorModel?.focus ?? 0)"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swift中的set和get方法"><a href="#Swift中的set和get方法" class="headerlink" title="Swift中的set和get方法"></a>Swift中的set和get方法</h2><ul><li>OC中我们常重写set和get方法来改变UI，Swift中重写set和get方法是下面这种。<ul><li>先定义一个变量，当调用set方法的时候，系统会有一个newValue，将newVaule赋值给我们定义的变量，然后从get方法里面返回去。</li><li>Swift中一般重写比较少</li></ul></li></ul><blockquote><p>代码示例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//定义一个变量</span><br><span class="line">var _tittle: String?</span><br><span class="line"></span><br><span class="line">    var tittle: String?&#123;</span><br><span class="line"></span><br><span class="line">        get&#123;</span><br><span class="line">            return  _tittle + &quot;123&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            _tittle = newValue + &quot;789&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>## </p><blockquote><p>Swift3.0语法其他相关文章</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift基本语法02</title>
      <link href="/2016/12/28/Swift3.0%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%9502"/>
      <content type="html"><![CDATA[<blockquote><p>上一篇介绍了Swift的常量/变量和循环,详情见: <a href="http://www.jianshu.com/p/35696abdaf0f" target="_blank" rel="noopener">Swift3.0基本语法01</a></p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h2 id="一、字符串的介绍"><a href="#一、字符串的介绍" class="headerlink" title="一、字符串的介绍"></a>一、字符串的介绍</h2><ul><li>字符串在任何的开发中使用都是非常频繁的<ul><li>OC和Swift中字符串的区别<ul><li>在OC中字符串类型时NSString,在Swift中字符串类型是String</li><li>OC中字符串@””,Swift中字符串””</li></ul></li><li>使用 String 的原因<ul><li>String 是一个结构体，性能更高</li><li>NSString 是一个 OC 对象，性能略差</li><li>String 支持直接遍历</li><li>Swift 提供了 String 和 NSString 之间的无缝转换<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1&gt; 定义不可变字符串 : 使用let修饰</span></span><br><span class="line"><span class="comment">// let str : String = "hello swift"</span></span><br><span class="line">let str = <span class="string">"Hello Swift"</span></span><br><span class="line"><span class="comment">// str = "hello Objective-C"</span></span><br><span class="line"><span class="comment">// 2&gt; 定义可变字符串 : 使用var修饰</span></span><br><span class="line">var strM = <span class="string">"Hello World"</span></span><br><span class="line">strM = <span class="string">"Hello China"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>##二、 字符串的使用</p><ul><li>获取字符串的长度<ul><li>获取字符集合,再获取集合的count属性</li></ul></li></ul><blockquote><p>let length = str.characters.count</p></blockquote><ul><li>字符串拼接<ul><li>两个字符串的拼接</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str1 = <span class="string">"字符串"</span></span><br><span class="line">let str2 = <span class="string">"拼接"</span></span><br><span class="line"><span class="comment">// OC拼接方式 NSString stringwithFormat:@"%@%@", str1, str2</span></span><br><span class="line">let str3 = str1 + str2</span><br></pre></td></tr></table></figure><ul><li>字符串和其他数据类型的拼接</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let name = <span class="string">"tqj"</span></span><br><span class="line">let age = <span class="number">19</span></span><br><span class="line">let height = <span class="number">1.87</span></span><br><span class="line"></span><br><span class="line">let infoStr = <span class="string">"my nams is \(name), age is \(age), height is \(height)"</span></span><br></pre></td></tr></table></figure><ul><li>字符串的格式化::比如时间:01:02</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let min = <span class="number">3</span></span><br><span class="line">let second = <span class="number">4</span></span><br><span class="line">let timeStr = String(format: <span class="string">"%02d:%02d"</span>, min, second)</span><br></pre></td></tr></table></figure><h4 id="字符串的判断"><a href="#字符串的判断" class="headerlink" title="字符串的判断"></a>字符串的判断</h4><blockquote><p>判断字符串是否为空</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str = <span class="string">"1"</span></span><br><span class="line"><span class="comment">//输出false</span></span><br><span class="line">print(str.isEmpty)</span><br><span class="line"></span><br><span class="line">let str = <span class="string">""</span></span><br><span class="line"><span class="comment">//输出为true</span></span><br><span class="line">print(str.isEmpty)</span><br></pre></td></tr></table></figure><blockquote><p>其他判断和操作(Swift3.0特性)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//判断是否包含某字符</span><br><span class="line">let str = &quot;Hello, playground&quot;</span><br><span class="line">let is1 = str.contains(&quot;ell&quot;)</span><br><span class="line">//输出true</span><br><span class="line">print(is1)</span><br><span class="line"></span><br><span class="line">//指定字符串的替换</span><br><span class="line">let str2 = str.replacingOccurrences(of: &quot;Hello&quot;, with: &quot;HELLO&quot;)</span><br><span class="line">print(str2)   </span><br><span class="line">//输出HELLO, playground</span><br><span class="line"></span><br><span class="line">//转为大写</span><br><span class="line">let s1 = str.localizedUppercase</span><br><span class="line">//转为小写</span><br><span class="line">let s2 = str.localizedLowercase</span><br></pre></td></tr></table></figure><h4 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h4><ul><li>Swift中提供了特殊的截取方式<ul><li>该方式非常麻烦</li><li>Index创建较为麻烦</li></ul></li><li>简单的方式是将String转成NSString来使用<ul><li>在标识符后加:as NSString即可</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let urlString = <span class="string">"www.520it.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.1.方式一:</span></span><br><span class="line"><span class="comment">// 将String类型转成NSString类型,再进行截取: as NSString</span></span><br><span class="line">let header1 = (urlString as <span class="built_in">NSString</span>).substring(to: <span class="number">3</span>)</span><br><span class="line">let range1 = <span class="built_in">NSMakeRange</span>(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">let middle1 = (urlString as <span class="built_in">NSString</span>).substring(with: range1)</span><br><span class="line">let footer1 = (urlString as <span class="built_in">NSString</span>).substring(from: <span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li>swift截取方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 4.2.方式二:</span><br><span class="line">let headerIndex = urlString.index(urlString.startIndex, offsetBy: 3)</span><br><span class="line">let header2 = urlString.substring(to: headerIndex)</span><br><span class="line"></span><br><span class="line">let startIndex = urlString.index(urlString.startIndex, offsetBy: 4)</span><br><span class="line">let endIndex = urlString.index(urlString.startIndex, offsetBy: 9)</span><br><span class="line">let range = Range(startIndex..&lt;endIndex)</span><br><span class="line">let middle2 = urlString.substring(with: range)</span><br><span class="line"></span><br><span class="line">let footerIndex = urlString.index(urlString.endIndex, offsetBy: -3)</span><br><span class="line">let footer2 = urlString.substring(from: footerIndex)</span><br></pre></td></tr></table></figure><h2 id="三、数组的使用"><a href="#三、数组的使用" class="headerlink" title="三、数组的使用"></a>三、数组的使用</h2><h3 id="数组的介绍"><a href="#数组的介绍" class="headerlink" title="数组的介绍"></a>数组的介绍</h3><ul><li>数组（Array）是一串有序的由相同类型元素构成的集合<ul><li>数组中的集合元素是有序的，可以重复出现</li><li>Swift中的数组<ul><li>swift数组类型是Array，是一个泛型集合<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3></li></ul></li></ul></li><li>数组分成:可变数组和不可变数组<ul><li>使用let修饰的数组是不可变数组</li><li>使用var修饰的数组是可变数组<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1&gt; 定义不可变数组</span></span><br><span class="line">let array : [Any] = [<span class="string">"why"</span>, <span class="number">18</span>, <span class="number">1.88</span>]</span><br><span class="line"><span class="comment">// 2&gt; 定义可变数组: 使用var修饰</span></span><br><span class="line">var arrayM = [Any]()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="对数组的基本操作"><a href="#对数组的基本操作" class="headerlink" title="对数组的基本操作"></a>对数组的基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 增删改查</span><br><span class="line">// 2.1.添加元素</span><br><span class="line">arrayM.append(&quot;why&quot;)</span><br><span class="line">// 2.2.删除元素</span><br><span class="line">arrayM.remove(at: 0)</span><br><span class="line">// 2.3.修改元素</span><br><span class="line">arrayM[0] = &quot;yz&quot;</span><br><span class="line">// 2.4.获取元素</span><br><span class="line">let item = arrayM[1]</span><br></pre></td></tr></table></figure><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 3.1.获取数组的长度</span><br><span class="line">let count = array.count</span><br><span class="line"></span><br><span class="line">// 3.2.对数组进行遍历(可以获取到下标值)</span><br><span class="line">for i in 0..&lt; count &#123;</span><br><span class="line">    print(array[i])</span><br><span class="line">&#125;</span><br><span class="line">// 3.3.对数组进行遍历(设置遍历区间)</span><br><span class="line">for item in array &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br><span class="line">// 3.3.对数组进行遍历(不需要获取下标值)</span><br><span class="line">for item in array[0..&lt;2] &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br><span class="line">// 3.5.对数组进行遍历(既获取下标值,又获取元素)</span><br><span class="line">for (index, item) in array.enumerated() &#123;</span><br><span class="line">    print(index)</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的合并"><a href="#数组的合并" class="headerlink" title="数组的合并"></a>数组的合并</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个数组中存放的是相同的元素,那么在swift中可以对两个数组进行相加,直接合并</span></span><br><span class="line">let array1 = [<span class="string">"why"</span>, <span class="string">"yz"</span>]</span><br><span class="line">let array2 = [<span class="string">"lmj"</span>, <span class="string">"lnj"</span>]</span><br><span class="line">let array3 = [<span class="number">12</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">let resultArray = array1 + array2</span><br><span class="line"><span class="comment">// let result = array1 + array3 错误写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不建议一个数组中存放多种类型的数据</span></span><br><span class="line">var array3 = [<span class="number">2</span>, <span class="number">3</span>, <span class="string">"why"</span>]</span><br><span class="line">var array4 = [<span class="string">"yz"</span>, <span class="number">23</span>]</span><br><span class="line">array3 + array4</span><br></pre></td></tr></table></figure><h2 id="四、字典"><a href="#四、字典" class="headerlink" title="四、字典"></a>四、字典</h2><h3 id="字典的介绍"><a href="#字典的介绍" class="headerlink" title="字典的介绍"></a>字典的介绍</h3><ul><li>字典允许按照某个键来访问元素<ul><li>字典是由两部分集合构成的，一个是键（key）集合，一个是值（value）集合</li><li>键集合是不能有重复元素的，而值集合是可以重复的，键和值是成对出现的</li><li>Swift中的字典<ul><li>Swift字典类型是Dictionary，也是一个泛型集合<h3 id="字典的初始化"><a href="#字典的初始化" class="headerlink" title="字典的初始化"></a>字典的初始化</h3></li></ul></li></ul></li><li>Swift中的可变和不可变字典<ul><li>使用let修饰的数组是不可变字典</li><li>使用var修饰的数组是可变字典<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个可变字典</span></span><br><span class="line">var dict1 : [String : Any] = [String : Any]()</span><br><span class="line"><span class="comment">// 定义一个不可变字典</span></span><br><span class="line">let dict2 : [String : Any] = [<span class="string">"name"</span> : <span class="string">"why"</span>, <span class="string">"age"</span> : <span class="number">18</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="字典的基本使用"><a href="#字典的基本使用" class="headerlink" title="字典的基本使用"></a>字典的基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 2.1.添加元素</span><br><span class="line">dictM[&quot;name&quot;] = &quot;why&quot;</span><br><span class="line">dictM[&quot;age&quot;] = 18</span><br><span class="line">dictM[&quot;height&quot;] = 1.88</span><br><span class="line"></span><br><span class="line">// 2.2.删除元素</span><br><span class="line">dictM.removeValue(forKey: &quot;height&quot;)</span><br><span class="line">dictM</span><br><span class="line">// 2.3.修改元素</span><br><span class="line">dictM[&quot;name&quot;] = &quot;lmj&quot;</span><br><span class="line">dictM.updateValue(&quot;lnj&quot;, forKey: &quot;name&quot;)</span><br><span class="line">dictM</span><br><span class="line">// 2.4.查找元素</span><br><span class="line">dictM[&quot;age&quot;]</span><br></pre></td></tr></table></figure><h3 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.1.遍历字典中所有的key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict.keys &#123;</span><br><span class="line">    print(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2.遍历字典中所有的value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict.values &#123;</span><br><span class="line">    print(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3.遍历字典中所有的key/value</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict &#123;</span><br><span class="line">    print(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典的合并"><a href="#字典的合并" class="headerlink" title="字典的合并"></a>字典的合并</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var dict1 : [String : Any] = [<span class="string">"name"</span> : <span class="string">"why"</span>, <span class="string">"age"</span> : <span class="number">18</span>]</span><br><span class="line">let dict2 : [String : Any] = [<span class="string">"height"</span> : <span class="number">1.88</span>, <span class="string">"phoneNum"</span> : <span class="string">"+86 110"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//let resultDict = dict1 + dict2字典不可以相加合并，只能遍历</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict2 &#123;</span><br><span class="line">    dict1[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、元组的使用"><a href="#五、元组的使用" class="headerlink" title="五、元组的使用"></a>五、元组的使用</h2><h3 id="元组的介绍"><a href="#元组的介绍" class="headerlink" title="元组的介绍"></a>元组的介绍</h3><ul><li>元组是Swift中特有的,OC中并没有相关类型</li><li>它是什么呢?<ul><li>它是一种数据结构，在数学中应用广泛<br>  类似于数组或者字典</li><li>可以用于定义一组数据</li><li>组成元组类型的数据可以称为“元素”<h3 id="元组的定义"><a href="#元组的定义" class="headerlink" title="元组的定义"></a>元组的定义</h3></li></ul></li><li>元组的常见写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 3.使用元组保存信息(取出数据时,更加方便)</span><br><span class="line">// 3.1.写法一:</span><br><span class="line">let infoTuple0 = (&quot;why&quot;, 18, 1.88)</span><br><span class="line">let tupleName = infoTuple0.0</span><br><span class="line">let tupleAge = infoTuple0.1</span><br><span class="line">infoTuple0.0</span><br><span class="line">infoTuple0.1</span><br><span class="line">infoTuple0.2</span><br><span class="line"></span><br><span class="line">// 3.2.写法二:</span><br><span class="line">let infoTuple1 = (name : &quot;why&quot;,age : 18, height : 1.88)</span><br><span class="line">infoTuple1.age</span><br><span class="line">infoTuple1.name</span><br><span class="line">infoTuple1.height</span><br><span class="line"></span><br><span class="line">// 3.3.写法三:</span><br><span class="line">let (name, age, height) = (&quot;why&quot;, 18, 1.88)</span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line">height</span><br></pre></td></tr></table></figure><h2 id="六、可选类型"><a href="#六、可选类型" class="headerlink" title="六、可选类型"></a>六、可选类型</h2><h3 id="可选类型的介绍"><a href="#可选类型的介绍" class="headerlink" title="可选类型的介绍"></a>可选类型的介绍</h3><ul><li>注意:<ul><li>可选类型时swift中较理解的一个知识点</li><li>暂时先了解,多利用Xcode的提示来使用</li><li>随着学习的深入,慢慢理解其中的原理和好处</li></ul></li><li>概念:<ul><li>在OC开发中,如果一个变量暂停不使用,可以赋值为0(基本属性类型)或者赋值为空(对象类型)</li><li>在swift开发中,nil也是一个特殊的类型.因为和真实的类型不匹配是不能赋值的(swift是强类型语言)</li><li>但是开发中赋值nil,在所难免.因此推出了可选类型</li></ul></li><li>可选类型的取值:<ul><li>空值</li><li>有值<h3 id="定义可选类型"><a href="#定义可选类型" class="headerlink" title="定义可选类型"></a>定义可选类型</h3></li></ul></li><li>定义一个可选类型有两种写法<ul><li>最基本的写法</li><li>语法糖(常用)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 错误写法</span><br><span class="line">// let string : String = nil</span><br><span class="line">// 正确写法:</span><br><span class="line">// 注意:name的类型是一个可选类型,但是该可选类型中可以存放字符串.</span><br><span class="line">// 写法一:定义可选类型</span><br><span class="line">let name : Optional&lt;String&gt; = nil</span><br><span class="line">// 写法二:定义可选类型,语法糖(常用)</span><br><span class="line">let name : String? = nil</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="可选类型的使用"><a href="#可选类型的使用" class="headerlink" title="可选类型的使用"></a>可选类型的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 演练一:给可选类型赋值</span><br><span class="line">// 定义可选类型</span><br><span class="line">var string : Optional&lt;String&gt; = nil</span><br><span class="line">// 给可选类型赋值</span><br><span class="line">// 错误写法:因此该可选类型中只能存放字符串</span><br><span class="line">string = 123</span><br><span class="line">// 正确写法:</span><br><span class="line">string = &quot;Hello world&quot;</span><br><span class="line">// 打印结果</span><br><span class="line">print(string)</span><br><span class="line">// 结果:Optional(&quot;Hello world&quot;)\n</span><br><span class="line">// 因为打印出来的是可选类型,所有会带Optional</span><br><span class="line">// 演练二:取出可选类型的值</span><br><span class="line">// 取出可选类型的真实值(解包)</span><br><span class="line">print(string!)</span><br><span class="line">// 结果:Hello world\n</span><br><span class="line">// 注意:如果可选类型为nil,强制取出其中的值(解包),会出错</span><br><span class="line">string = nil</span><br><span class="line">print(string!) // 报错</span><br><span class="line">// 正确写法:</span><br><span class="line">if string != nil &#123;</span><br><span class="line">    print(string!)</span><br><span class="line">&#125;</span><br><span class="line">// 简单写法:为了让在if语句中可以方便使用string</span><br><span class="line">// 可选绑定</span><br><span class="line">if let str = string &#123;</span><br><span class="line">    print(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="真实应用场景"><a href="#真实应用场景" class="headerlink" title="真实应用场景"></a>真实应用场景</h4><ul><li>目的:让代码更加严谨<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1.将字符串类型转成Int类型</span><br><span class="line">let str = &quot;123&quot;</span><br><span class="line">let result : Int? = Int(str) // nil/Int</span><br><span class="line">// 2.根据文件名称,读取路径</span><br><span class="line">let path : String? = Bundle.main.path(forResource: &quot;123.plist&quot;, ofType: nil)</span><br><span class="line">// 3.根据string,创建URL</span><br><span class="line">let url = URL(string: &quot;http://www.520it.com/小码哥&quot;)</span><br><span class="line">// 4.从字典中取内容</span><br><span class="line">let dict : [String : Any] = [&quot;name&quot; : &quot;why&quot;, &quot;age&quot; : 18]</span><br><span class="line">dict[&quot;name&quot;]</span><br><span class="line">dict[&quot;height&quot;]</span><br></pre></td></tr></table></figure></li></ul><h2 id="七、类型转化"><a href="#七、类型转化" class="headerlink" title="七、类型转化"></a>七、类型转化</h2><h3 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h3><ul><li>常见的类型转化符号<ul><li>as : 将实例转成某一种类型<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义数组</span></span><br><span class="line">let array : [AnyObject] = [<span class="number">12</span>, <span class="string">"why"</span>, <span class="number">1.88</span>]</span><br><span class="line"><span class="comment">// 2.取出第二个元素</span></span><br><span class="line">let objc = array[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 3.将objc转成真正的类型来使用</span></span><br><span class="line"><span class="comment">// 3.1.as? 将AnyObject转成可选类型,通过判断可选类型是否有值,来决定是否转化成功了</span></span><br><span class="line">let age = objc as? Int</span><br><span class="line">print(age) <span class="comment">// 结果:Optional(12)</span></span><br><span class="line"><span class="comment">// 3.2.as! 将AnyObject转成具体的类型,但是注意:如果不是该类型,那么程序会崩溃</span></span><br><span class="line">let age1 = objc as! Int</span><br><span class="line">print(age1) <span class="comment">// 结果:12</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="八、try-throw-代码实践"><a href="#八、try-throw-代码实践" class="headerlink" title="八、try throw 代码实践"></a>八、try throw 代码实践</h2><blockquote><p>throw catch 是 Xcode 7.0 对错误处理的一个非常大的变化</p><ul><li>代码示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 2. 反序列化</span><br><span class="line">// 1.获取json文件路径</span><br><span class="line">        let jsonPath = NSBundle.mainBundle().pathForResource(&quot;MainVCSettings.json&quot;, ofType: nil)</span><br><span class="line">        // 2.加载json数据</span><br><span class="line">        let jsonData = NSData(contentsOfFile: jsonPath!)</span><br><span class="line">        // 3.序列化json</span><br><span class="line">        do&#123;//解析成功</span><br><span class="line">             // throw是Xcode7最明显的一个变化, Xcode7之前都是通过传入error指针捕获异常, Xocode7开始通过try/catch捕获异常</span><br><span class="line">            let dictArray = try NSJSONSerialization.JSONObjectWithData(jsonData!, options: NSJSONReadingOptions.MutableContainers)</span><br><span class="line"></span><br><span class="line">            // 遍历字典时候需要明确指明数组中的数据类型</span><br><span class="line">            for dict in dictArray  as! [[String:String]]</span><br><span class="line">            &#123;</span><br><span class="line">                 // 由于addChildVC方法参数不能为nil, 但是字典中取出来的值可能是nil, 所以需要加上!</span><br><span class="line">                addChildViewController(dict[&quot;vcName&quot;]!, title: dict[&quot;title&quot;]!, imageName: dict[&quot;imageName&quot;]!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch&#123;//解析失败</span><br><span class="line">            print(error)</span><br><span class="line">            addChildViewController(&quot;HomeTableViewController&quot;, title: &quot;首页&quot;, imageName: &quot;tabbar_home&quot;)</span><br><span class="line">            addChildViewController(&quot;MessageTableViewController&quot;, title: &quot;消息&quot;, imageName: &quot;tabbar_message_center&quot;)</span><br><span class="line">            addChildViewController(&quot;DiscoverTableViewController&quot;, title: &quot;发现&quot;, imageName: &quot;tabbar_discover&quot;)</span><br><span class="line">            addChildViewController(&quot;ProfileTableViewController&quot;, title: &quot;我&quot;, imageName: &quot;tabbar_profile&quot;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li>如果能确保代码执行正确，可以强行 try!<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let array = try! NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions.MutableContainers)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>不过需要注意的是，一旦解析错误，程序会直接崩溃！</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> Swift3.0 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift3.0之基本语法01</title>
      <link href="/2016/12/25/Swift3.0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%9501"/>
      <content type="html"><![CDATA[<h2 id="常量-amp-变量"><a href="#常量-amp-变量" class="headerlink" title="常量&amp;变量"></a>常量&amp;变量</h2><ul><li>在Swift中规定：在定义一个标识符时必须明确说明该标识符是一个常量还是变量</li><li>使用let来定义常量，定义之后不可以修改</li><li>使用var来定义变量，定义之后可以修改</li></ul><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h3 id="变量的基本使用"><a href="#变量的基本使用" class="headerlink" title="变量的基本使用"></a>变量的基本使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line">let a : Int = <span class="number">10</span></span><br><span class="line"><span class="comment">// 错误写法,当一个标识符定义为常量时是不可以修改的</span></span><br><span class="line"><span class="comment">// a = 20</span></span><br><span class="line">var b : Int = <span class="number">20</span></span><br><span class="line"><span class="comment">//因为b定义为变量,因此是可以修改的</span></span><br><span class="line">b = <span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="常量和变量的使用注意"><a href="#常量和变量的使用注意" class="headerlink" title="常量和变量的使用注意:"></a>常量和变量的使用注意:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 常量使用注意：</span></span><br><span class="line"><span class="comment">    1&gt; 优先使用常量</span></span><br><span class="line"><span class="comment">    2&gt; 常量的本质</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 1.注意一：在开发中let/var在选择时优先使用常量，防止不小被修改掉（let）</span></span><br><span class="line"><span class="comment">// 如果一个标识符不需要修改，但是声明称了变量，那么编译器会报警告</span></span><br><span class="line"><span class="comment">// 2.常量的本质：</span></span><br><span class="line"><span class="comment">// 含义：指向的内存地址不可以修改，但是可以通过内存地址，找到对应的对象，之后修改对象内部的属性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> OC中创建对象：</span></span><br><span class="line"><span class="comment">    UIView *view = [[UIView alloc] init];</span></span><br><span class="line"><span class="comment">    view = [[UIView alloc] init];</span></span><br><span class="line"><span class="comment"> Swift中创建对象：</span></span><br><span class="line"><span class="comment">    var view : UIView = UIView()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 变量的做法</span></span><br><span class="line"><span class="comment">    var view : UIView = UIView()</span></span><br><span class="line"><span class="comment">    view = UIView()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 创建常量View</span></span><br><span class="line">let view = <span class="built_in">UIView</span>()</span><br><span class="line"><span class="comment">// view = UIView() 错误做法</span></span><br><span class="line">view.alpha = <span class="number">0.5</span></span><br><span class="line"><span class="comment">// Swift中创建结构体：结构体类型()</span></span><br><span class="line">view.frame = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="comment">// Swift中调用方法，统一使用点语法</span></span><br><span class="line">view.backgroundColor = <span class="built_in">UIColor</span>.red</span><br></pre></td></tr></table></figure><h3 id="创建对象补充"><a href="#创建对象补充" class="headerlink" title="创建对象补充"></a>创建对象补充</h3><ul><li>创建UIView对象，并且在UIView中添加UIButton</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"><span class="comment">// 1.创建UIView对象</span></span><br><span class="line"><span class="comment">// OC : [[UIView alloc] initWithFrame:CGRect]</span></span><br><span class="line">let viewRect = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">let view : <span class="built_in">UIView</span> = <span class="built_in">UIView</span>(frame: viewRect)</span><br><span class="line"><span class="comment">// 2.设置UIView的属性</span></span><br><span class="line">view.backgroundColor = <span class="built_in">UIColor</span>.orange</span><br><span class="line"><span class="comment">// 3.创建UIButton</span></span><br><span class="line">let btn : <span class="built_in">UIButton</span> = <span class="built_in">UIButton</span>(type: .custom)</span><br><span class="line"><span class="comment">// 4.设置UIButton的属性</span></span><br><span class="line">btn.frame = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line">btn.backgroundColor = <span class="built_in">UIColor</span>.purple</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Swift中枚举类型：</span></span><br><span class="line"><span class="comment"> 1&gt; 如果可以根据上下文推导出类型可以直接.具体的类型</span></span><br><span class="line"><span class="comment"> 2&gt; 如果根据上下文推导不出具体的类型，则需要：类型.具体的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">btn.setTitle(<span class="string">"按钮"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">btn.setTitleColor(<span class="built_in">UIColor</span>.white, <span class="keyword">for</span>: .normal)</span><br><span class="line"><span class="comment">// 5.将btn添加到UIView中</span></span><br><span class="line">view.addSubview(btn)</span><br></pre></td></tr></table></figure><h2 id="Swift中数据类型"><a href="#Swift中数据类型" class="headerlink" title="Swift中数据类型"></a>Swift中数据类型</h2><h3 id="Swift类型的介绍"><a href="#Swift类型的介绍" class="headerlink" title="Swift类型的介绍"></a>Swift类型的介绍</h3><ul><li>Swift中的数据类型也有:整型/浮点型/对象类型/结构体类型等等<ul><li>先了解整型和浮点型</li><li>整型<ul><li>有符号<ul><li>Int8 : 有符号8位整型</li><li>Int16 : 有符号16位整型</li><li>Int32 : 有符号32位整型</li><li>Int64 : 有符号64位整型</li><li>Int ： 和平台相关(默认,相当于OC的NSInteger)</li></ul></li><li>无符号<ul><li>UInt8 : 无符号8位整型</li><li>UInt16 : 无符号16位整型</li><li>UInt32 : 无符号32位整型</li><li>UInt64 : 无符号64位整型</li><li>UInt : 和平台相关(常用,相当于OC的NSUInteger)(默认)</li></ul></li></ul></li><li>浮点型<ul><li>Float : 32位浮点型</li><li>Double : 64浮点型(默认)</li></ul></li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个Int类型的变量m,并且赋值为10</span></span><br><span class="line">var m : Int = <span class="number">10</span></span><br><span class="line"><span class="comment">// 定义一个Double类型的常量n,并且赋值为3.14</span></span><br><span class="line">let n : Double = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><h3 id="Swift中的类型推导"><a href="#Swift中的类型推导" class="headerlink" title="Swift中的类型推导"></a>Swift中的类型推导</h3><ul><li>Swift是强类型的语言<ul><li>Swift中任何一个标识符都有明确的类型</li><li>注意:<ul><li>如果定义一个标识符时有直接进行赋值,那么标识符后面的类型可以省略.</li><li>因为Swift有类型推导,会自动根据后面的赋值来决定前面的标识符的数据类型</li><li>可以通过option+鼠标左键来查看变量的数据类型</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">let m = 20</span><br><span class="line">let n = 30.5</span><br><span class="line">// 错误写法 :</span><br><span class="line">// Swift中没有隐式转化，不会自动将一个Int类型转成Double类型，因此不同类型之间不能进行运算</span><br><span class="line">// let result = m + n</span><br><span class="line">// 正确做法</span><br><span class="line">// 1&gt; 将Int类型转成Double ： Double(标识符)</span><br><span class="line">// 2&gt; 将Double类型转成Int ： Int(标识符)</span><br><span class="line">let result1 = Double(m) + n</span><br><span class="line">let result2 = m + Int(n)</span><br></pre></td></tr></table></figure><h2 id="逻辑分支"><a href="#逻辑分支" class="headerlink" title="逻辑分支"></a>逻辑分支</h2><h3 id="一-分支的介绍"><a href="#一-分支的介绍" class="headerlink" title="一. 分支的介绍"></a>一. 分支的介绍</h3><ul><li>分支即if/switch/三目运算符等判断语句</li><li>通过分支语句可以控制程序的执行流程</li></ul><h3 id="二-if分支语句"><a href="#二-if分支语句" class="headerlink" title="二. if分支语句"></a>二. if分支语句</h3><ul><li>和OC中if语句有一定的区别<ul><li>判断句可以不加()</li><li>在Swift的判断句中必须有明确的真假<ul><li>不再有非0即真</li><li>必须有明确的Bool值</li><li>Bool有两个取值:false/true</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 演练一:</span><br><span class="line">let a = 10</span><br><span class="line">// 错误写法:</span><br><span class="line">//if a &#123;</span><br><span class="line">//    print(&quot;a&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">// 正确写法</span><br><span class="line">if a &gt; 9 &#123;</span><br><span class="line">    print(a)</span><br><span class="line">&#125;</span><br><span class="line">// 演练二:</span><br><span class="line">let score = 87</span><br><span class="line">if score &lt; 60 &#123;</span><br><span class="line">    print(&quot;不及格&quot;)</span><br><span class="line">&#125; else if score &lt;= 70 &#123;</span><br><span class="line">    print(&quot;及格&quot;)</span><br><span class="line">&#125; else if score &lt;= 80 &#123;</span><br><span class="line">    print(&quot;良好&quot;)</span><br><span class="line">&#125; else if score &lt;= 90 &#123;</span><br><span class="line">    print(&quot;优秀&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;完美&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-guard的使用"><a href="#三-guard的使用" class="headerlink" title="三.guard的使用"></a>三.guard的使用</h3><ul><li>guard是Swift2.0新增的语法<ul><li>它与if语句非常类似，它设计的目的是提高程序的可读性</li><li>guard语句必须带有else语句，它的语法如下：<ul><li>当条件表达式为true时候跳过else语句中的内容，执行语句组内容</li><li>条件表达式为false时候执行else语句中的内容，跳转语句一般是return、break、continue和throw</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">guard 条件表达式 else &#123;</span><br><span class="line">    // 条换语句</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br><span class="line">语句组</span><br><span class="line">//---例子---</span><br><span class="line">    var age = 18</span><br><span class="line">func online(age : Int) -&gt; Void &#123;</span><br><span class="line">    guard age &gt;= 18 else &#123;</span><br><span class="line">        print(&quot;回家去&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;可以上网&quot;)</span><br><span class="line">&#125;</span><br><span class="line">online(age)</span><br></pre></td></tr></table></figure><h3 id="四-switch分支"><a href="#四-switch分支" class="headerlink" title="四.switch分支"></a>四.switch分支</h3><h5 id="switch的介绍"><a href="#switch的介绍" class="headerlink" title="switch的介绍"></a>switch的介绍</h5><ul><li>Switch作为选择结构中必不可少的语句也被加入到了Swift中<ul><li>只要有过编程经验的人对Switch语句都不会感到陌生</li><li>但苹果对Switch进行了大大的增强，使其拥有其他语言中没有的特性<h5 id="switch的简单使用"><a href="#switch的简单使用" class="headerlink" title="switch的简单使用"></a>switch的简单使用</h5></li></ul></li><li>基本用法和OC用法一致<ul><li>不同之处:<ul><li>switch后可以不跟()</li><li>case后可以不跟break(默认会有break)</li></ul></li><li>例子:</li></ul></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;     let sex = 0</span><br><span class="line">&gt;     switch sex &#123;</span><br><span class="line">&gt;     case 0 :</span><br><span class="line">&gt;         print(&quot;男&quot;)</span><br><span class="line">&gt;     case 1 :</span><br><span class="line">&gt;         print(&quot;女&quot;)</span><br><span class="line">&gt;     default :</span><br><span class="line">&gt;         print(&quot;其他&quot;)</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>简单使用补充:</p><ul><li>一个case判断中,可以判断多个值</li><li>多个值以,隔开<blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;     let sex = <span class="number">0</span></span><br><span class="line">&gt;     <span class="keyword">switch</span> sex &#123;</span><br><span class="line">&gt;     <span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:</span><br><span class="line">&gt;         print(<span class="string">"正常人"</span>)</span><br><span class="line">&gt;     <span class="keyword">default</span>:</span><br><span class="line">&gt;         print(<span class="string">"其他"</span>)</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>简单使用补充:</p><ul><li>如果希望出现之前的case穿透,则可以使用关键字fallthrough</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let sex = 0</span><br><span class="line">switch sex &#123;</span><br><span class="line">case 0:</span><br><span class="line">    fallthrough</span><br><span class="line">case 1:</span><br><span class="line">    print(&quot;正常人&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;其他&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="switch支持区间判断"><a href="#switch支持区间判断" class="headerlink" title="switch支持区间判断"></a>switch支持区间判断</h5><ul><li>什么是区间?<ul><li>通常我们指的是数字区间:0~10,100~200<br>swift中的区间常见有两种</li><li>半开半闭区间:0..&lt;10 表示:0~9,不包括10<br>  闭区间:0…10 表示:0~10</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let score = 88</span><br><span class="line">switch score &#123;</span><br><span class="line">case 0..&lt;60:</span><br><span class="line">    print(&quot;不及格&quot;)</span><br><span class="line">case 60..&lt;80:</span><br><span class="line">    print(&quot;几个&quot;)</span><br><span class="line">case 80..&lt;90:</span><br><span class="line">    print(&quot;良好&quot;)</span><br><span class="line">case 90..&lt;100:</span><br><span class="line">    print(&quot;优秀&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;满分&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环使用"><a href="#循环使用" class="headerlink" title="循环使用"></a>循环使用</h2><h3 id="循环的介绍"><a href="#循环的介绍" class="headerlink" title="循环的介绍"></a>循环的介绍</h3><ul><li>在开发中经常会需要循环</li><li>常见的循环有:for/while/do while.</li><li>这里我们只介绍for/while,因为for/while最常见<h3 id="for循环的写法"><a href="#for循环的写法" class="headerlink" title="for循环的写法"></a>for循环的写法</h3></li><li>区间for循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in 0..&lt;10 &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line">for i in 0...10 &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line">//特殊写法:如果在for循环中不需要用到下标i</span><br><span class="line">for _ in 0..&lt;10 &#123;</span><br><span class="line">print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><a href="http://www.jianshu.com/p/0f75c23773b5" target="_blank" rel="noopener">Swift中遍历方法for in 和 forEach的区别</a></p></blockquote><h3 id="while和do-while循环"><a href="#while和do-while循环" class="headerlink" title="while和do while循环"></a>while和do while循环</h3><ul><li>while循环<ul><li>while的判断句必须有正确的真假,没有非0即真</li><li>while后面的()可以省略<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 0</span><br><span class="line">while a &lt; 10 &#123;</span><br><span class="line">    a++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//--do while循环:使用repeat关键字来代替了do--</span><br><span class="line">    let b = 0</span><br><span class="line">repeat &#123;</span><br><span class="line">    print(b)</span><br><span class="line">    b++</span><br><span class="line">&#125; while b &lt; 20</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS之NSDate的Category</title>
      <link href="/2016/11/25/iOS%E4%B9%8BNSDate%E7%9A%84Category"/>
      <content type="html"><![CDATA[<h4 id="判断日期是是否是今年？今天？"><a href="#判断日期是是否是今年？今天？" class="headerlink" title="判断日期是是否是今年？今天？"></a>判断日期是是否是今年？今天？</h4><a id="more"></a><h5 id="NSDate-Extension-h"><a href="#NSDate-Extension-h" class="headerlink" title="NSDate+Extension.h"></a>NSDate+Extension.h</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较from和self的时间差值</span></span><br><span class="line">- (<span class="built_in">NSDateComponents</span> *)deltaFrom:(<span class="built_in">NSDate</span> *)from;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//是否为今年</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isThisYear;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为今天</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isToday;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为昨天</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isYesterday;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为明天</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isTomorrow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h5 id="NSDate-Extension-m"><a href="#NSDate-Extension-m" class="headerlink" title="NSDate+Extension.m"></a>NSDate+Extension.m</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSDate+Extension.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSDate</span> (<span class="title">Extension</span>)</span></span><br><span class="line">- (<span class="built_in">NSDateComponents</span> *)deltaFrom:(<span class="built_in">NSDate</span> *)from</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 日历</span></span><br><span class="line">    <span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较时间</span></span><br><span class="line">    <span class="built_in">NSCalendarUnit</span> unit = <span class="built_in">NSCalendarUnitDay</span> | <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitYear</span> | <span class="built_in">NSCalendarUnitHour</span> | <span class="built_in">NSCalendarUnitMinute</span> | <span class="built_in">NSCalendarUnitSecond</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [calendar components:unit fromDate:from toDate:<span class="keyword">self</span> options:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isThisYear</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 日历</span></span><br><span class="line">    <span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> nowYear = [calendar component:<span class="built_in">NSCalendarUnitYear</span> fromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    <span class="built_in">NSInteger</span> selfYear = [calendar component:<span class="built_in">NSCalendarUnitYear</span> fromDate:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nowYear == selfYear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isToday</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *fmt = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    fmt.dateFormat = <span class="string">@"yyyy-MM-dd"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *nowString = [fmt stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    <span class="built_in">NSString</span> *selfString = [fmt stringFromDate:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [nowString isEqualToString:selfString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isYesterday</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2014-12-31 23:59:59 -&gt; 2014-12-31</span></span><br><span class="line">    <span class="comment">// 2015-01-01 00:00:01 -&gt; 2015-01-01</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 日期格式化类</span></span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *fmt = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    fmt.dateFormat = <span class="string">@"yyyy-MM-dd"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDate</span> *nowDate = [fmt dateFromString:[fmt stringFromDate:[<span class="built_in">NSDate</span> date]]];</span><br><span class="line">    <span class="built_in">NSDate</span> *selfDate = [fmt dateFromString:[fmt stringFromDate:<span class="keyword">self</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    <span class="built_in">NSDateComponents</span> *cmps = [calendar components:<span class="built_in">NSCalendarUnitDay</span> | <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitYear</span> fromDate:selfDate toDate:nowDate options:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cmps.year == <span class="number">0</span></span><br><span class="line">    &amp;&amp; cmps.month == <span class="number">0</span></span><br><span class="line">    &amp;&amp; cmps.day == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isTomorrow&#123;</span><br><span class="line">     <span class="built_in">NSDateFormatter</span> *fmt = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    fmt.dateFormat = <span class="string">@"yyyy-MM-dd"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDate</span> *nowDate = [fmt dateFromString:[fmt stringFromDate:[<span class="built_in">NSDate</span> date]]];</span><br><span class="line">    <span class="built_in">NSDate</span> *selfDate = [fmt dateFromString:[fmt stringFromDate:<span class="keyword">self</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    <span class="built_in">NSDateComponents</span> *cmps = [calendar components:<span class="built_in">NSCalendarUnitDay</span> | <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitYear</span> fromDate:nowDate toDate:selfDate options:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cmps.year == <span class="number">0</span></span><br><span class="line">    &amp;&amp; cmps.month == <span class="number">0</span></span><br><span class="line">    &amp;&amp; cmps.day == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="简单使用TopicModel"><a href="#简单使用TopicModel" class="headerlink" title="简单使用TopicModel"></a>简单使用TopicModel</h3><h5 id="import-“TopicModel-m”文件中"><a href="#import-“TopicModel-m”文件中" class="headerlink" title="#import “TopicModel.m”文件中"></a>#import “TopicModel.m”文件中</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)create_time</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 日期格式化类</span></span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *fmt = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    <span class="comment">// 设置日期格式(y:年,M:月,d:日,H:时,m:分,s:秒)</span></span><br><span class="line">    fmt.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">    <span class="comment">// 帖子的创建时间</span></span><br><span class="line">    <span class="built_in">NSDate</span> *create = [fmt dateFromString:_create_time];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (create.isThisYear) &#123; <span class="comment">// 今年</span></span><br><span class="line">        <span class="keyword">if</span> (create.isToday) &#123; <span class="comment">// 今天</span></span><br><span class="line">            <span class="built_in">NSDateComponents</span> *cmps = [[<span class="built_in">NSDate</span> date] deltaFrom:create];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cmps.hour &gt;= <span class="number">1</span>) &#123; <span class="comment">// 时间差距 &gt;= 1小时</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%zd小时前"</span>, cmps.hour];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmps.minute &gt;= <span class="number">1</span>) &#123; <span class="comment">// 1小时 &gt; 时间差距 &gt;= 1分钟</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%zd分钟前"</span>, cmps.minute];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1分钟 &gt; 时间差距</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">@"刚刚"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (create.isYesterday) &#123; <span class="comment">// 昨天</span></span><br><span class="line">            fmt.dateFormat = <span class="string">@"昨天 HH:mm:ss"</span>;</span><br><span class="line">            <span class="keyword">return</span> [fmt stringFromDate:create];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(creat.isTomorrow)&#123;</span><br><span class="line">            fmt.dateFormat = <span class="string">@"明天 HH:mm:ss"</span>;</span><br><span class="line">            <span class="keyword">return</span> [fmt stringFromDate:create];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 其他</span></span><br><span class="line">            fmt.dateFormat = <span class="string">@"MM-dd HH:mm:ss"</span>;</span><br><span class="line">            <span class="keyword">return</span> [fmt stringFromDate:create];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非今年</span></span><br><span class="line">        <span class="keyword">return</span> _create_time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> Category </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS之UIMenuController的简单使用</title>
      <link href="/2016/11/22/iOS%E4%B9%8BUIMenuController%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"/>
      <content type="html"><![CDATA[<h2 id="UIMenuController须知"><a href="#UIMenuController须知" class="headerlink" title="UIMenuController须知"></a>UIMenuController须知</h2><ul><li>默认情况下, 有以下控件已经支持UIMenuController<ul><li>UITextField</li><li>UITextView</li><li>UIWebView<br><excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a></excerpt></li></ul></li></ul><h2 id="让其他控件也支持UIMenuController-比如UILabel"><a href="#让其他控件也支持UIMenuController-比如UILabel" class="headerlink" title="让其他控件也支持UIMenuController(比如UILabel)"></a>让其他控件也支持UIMenuController(比如UILabel)</h2><ol><li>自定义UILabel</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUp &#123; </span><br><span class="line">  <span class="comment">// 1.设置label可以交互 </span></span><br><span class="line">  <span class="keyword">self</span>.userInteractionEnabled = <span class="literal">YES</span>;  </span><br><span class="line">  <span class="comment">// 2.添加点击手势 </span></span><br><span class="line">  [<span class="keyword">self</span> addGestureRecognizer:[[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(lableClick)]];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)lableClick &#123; </span><br><span class="line">  <span class="comment">// 3.设置label为第一响应者,只有成为响应者才能够将MenuController显示在其上面 </span></span><br><span class="line">  [<span class="keyword">self</span> becomeFirstResponder]; </span><br><span class="line">  <span class="comment">// 4.初始化UIMenuController </span></span><br><span class="line">  <span class="built_in">UIMenuController</span> *menuController = [<span class="built_in">UIMenuController</span> sharedMenuController];  </span><br><span class="line">  <span class="comment">// 5.设置UIMenuController显示的位置 </span></span><br><span class="line">  <span class="comment">// targetRect : 将要显示所在label的frame; </span></span><br><span class="line">  <span class="comment">// view : targetRect所在的坐标系参照物(父view或self)</span></span><br><span class="line">  [menuController setTargetRect:<span class="keyword">self</span>.frame inView:<span class="keyword">self</span>.superview];</span><br><span class="line">  <span class="comment">// [menuController setTargetRect:self.bounds inView:self];作用同上  </span></span><br><span class="line">  <span class="comment">// 6.显示UIMenuController </span></span><br><span class="line">  [menuController setMenuVisible:<span class="literal">YES</span> animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在UILable内重写2个方法</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 让label有资格成为第一响应者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * label能执行哪些操作(比如copy, paste等等)</span></span><br><span class="line"><span class="comment"> * @return  YES:支持这种操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(cut:) || action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:) || action == <span class="keyword">@selector</span>(paste:)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.实现各种操作方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cut:(<span class="built_in">UIMenuController</span> *)menu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将自己的文字复制到粘贴板</span></span><br><span class="line">    <span class="built_in">UIPasteboard</span> *board = [<span class="built_in">UIPasteboard</span> generalPasteboard];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空文字</span></span><br><span class="line">    <span class="keyword">self</span>.text = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="keyword">copy</span>:(<span class="built_in">UIMenuController</span> *)menu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将自己的文字复制到粘贴板</span></span><br><span class="line">    <span class="built_in">UIPasteboard</span> *board = [<span class="built_in">UIPasteboard</span> generalPasteboard];</span><br><span class="line">    board.string = <span class="keyword">self</span>.text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)paste:(<span class="built_in">UIMenuController</span> *)menu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将粘贴板的文字 复制 到自己身上</span></span><br><span class="line">    <span class="built_in">UIPasteboard</span> *board = [<span class="built_in">UIPasteboard</span> generalPasteboard];</span><br><span class="line">    <span class="keyword">self</span>.text = board.string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="自定义UIMenuController内部的Item-在cell中"><a href="#自定义UIMenuController内部的Item-在cell中" class="headerlink" title="自定义UIMenuController内部的Item(在cell中)"></a>自定义UIMenuController内部的Item(在cell中)</h2><ul><li>由于手动添加的MenuItem默认触发控制器中的方法,所以将MenuController的显示/隐藏,添加MenuItem写到控制器</li></ul><ol><li>添加item</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123; </span><br><span class="line">  <span class="comment">// 点击cell弹出UIMenuController </span></span><br><span class="line">  <span class="comment">// 1.如果menuController已经在显示,就隐藏他</span></span><br><span class="line">  <span class="comment">// 注意,如果有一个cell正在显示menuController,这时再点击另外一个cell,上一个cell的menuController会消失,当前点击cell会显示,这是因为上一个cell不再是第一响应者了,menuController会自动释放 </span></span><br><span class="line">  <span class="built_in">UIMenuController</span> *menuController = [<span class="built_in">UIMenuController</span> sharedMenuController]; </span><br><span class="line">  <span class="keyword">if</span> (menuController.isMenuVisible) &#123; </span><br><span class="line">    [menuController setMenuVisible:<span class="literal">NO</span> animated:<span class="literal">YES</span>];  </span><br><span class="line">  &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 2.显示MenuController </span></span><br><span class="line">    <span class="comment">// 先设置cell为第一响应者,同时不要忘记在cell中重写canBecomeFirstResponder和canPerformAction:withSender: </span></span><br><span class="line">    JCMTopicCommentCell *cell = [tableView cellForRowAtIndexPath:indexPath]; </span><br><span class="line">    [cell becomeFirstResponder]; </span><br><span class="line">    <span class="comment">// 添加menuItem </span></span><br><span class="line">    <span class="built_in">UIMenuItem</span> *item01 = [[<span class="built_in">UIMenuItem</span> alloc]initWithTitle:<span class="string">@"赞"</span> action:<span class="keyword">@selector</span>(zanClick:)]; </span><br><span class="line">    <span class="built_in">UIMenuItem</span> *item02 = [[<span class="built_in">UIMenuItem</span> alloc]initWithTitle:<span class="string">@"回复"</span> action:<span class="keyword">@selector</span>(responseClick:)]; </span><br><span class="line">    <span class="built_in">UIMenuItem</span> *item03 = [[<span class="built_in">UIMenuItem</span> alloc]initWithTitle:<span class="string">@"举报"</span> action:<span class="keyword">@selector</span>(reportClick:)]; </span><br><span class="line">    menuController.menuItems = @[item01,item02,item03]; </span><br><span class="line">    <span class="comment">// 设置menuControoler显示位置 </span></span><br><span class="line">     <span class="built_in">CGRect</span> showRect = <span class="built_in">CGRectMake</span>(cell.x, cell.y + cell.height/<span class="number">2</span>, cell.width, cell.height); </span><br><span class="line">     [menuController setTargetRect:showRect inView:cell.superview]; </span><br><span class="line">    <span class="comment">// 显示menuController [menuController setMenuVisible:YES animated:YES];  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>cell中实现两个方法</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 让label有资格成为第一响应者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * label能执行哪些操作(比如copy, paste等等)</span></span><br><span class="line"><span class="comment"> * @return  YES:支持这种操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(cut:) || action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:) || action == <span class="keyword">@selector</span>(paste:)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>处理方法的实现</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - MenuControllerClick</span></span><br><span class="line"><span class="comment">// MenuController手动添加的item的方法实现必须放在controller中</span></span><br><span class="line">- (<span class="keyword">void</span>)zanClick:(<span class="built_in">UIMenuController</span> *)menu &#123; </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.tableView indexPathForSelectedRow]; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="keyword">self</span> commentInIndexPath:indexPath].content);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)responseClick:(<span class="built_in">UIMenuController</span> *)menu &#123; </span><br><span class="line">  <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.tableView indexPathForSelectedRow]; </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="keyword">self</span> commentInIndexPath:indexPath].content);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)reportClick:(<span class="built_in">UIMenuController</span> *)menu &#123; </span><br><span class="line">  <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.tableView indexPathForSelectedRow]; </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="keyword">self</span> commentInIndexPath:indexPath].content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> UIMenuController </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS之UITableView设置全屏分隔线</title>
      <link href="/2016/11/20/iOS%E4%B9%8BUITableView%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E5%88%86%E9%9A%94%E7%BA%BF"/>
      <content type="html"><![CDATA[<h2 id="UICollectionView基础"><a href="#UICollectionView基础" class="headerlink" title="UICollectionView基础"></a>UICollectionView基础</h2><h4 id="首先系统的分隔线有以下几种"><a href="#首先系统的分隔线有以下几种" class="headerlink" title="首先系统的分隔线有以下几种"></a>首先系统的分隔线有以下几种</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tableView.separatorStyle = UITableViewCellSeparatorStyleNone;</span><br><span class="line"></span><br><span class="line">-UITableViewCellSeparatorStyleNone //隐藏系统分隔线</span><br><span class="line">-UITableViewCellSeparatorStyleSingleLine //单分隔线</span><br><span class="line">-UITableViewCellSeparatorStyleSingleLineEtched //被侵蚀的单分隔线</span><br></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h4 id="自定义分隔线（首先要隐藏系统的分隔线）"><a href="#自定义分隔线（首先要隐藏系统的分隔线）" class="headerlink" title="自定义分隔线（首先要隐藏系统的分隔线）"></a>自定义分隔线（首先要隐藏系统的分隔线）</h4><ol><li>通过xib或者代码在cell底部添加一条高度为1的UIView或者UILable分隔线。</li><li>通过drawRect：方法自绘一条分割线</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 自绘分割线</span><br><span class="line">- (void)drawRect:(CGRect)rect&#123;</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line">    CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor);</span><br><span class="line">    CGContextFillRect(context, rect);</span><br><span class="line"></span><br><span class="line">    CGContextSetStrokeColorWithColor(context, [UIColor colorWithRed:0xE2/255.0f green:0xE2/255.0f blue:0xE2/255.0f alpha:1].CGColor);</span><br><span class="line">    CGContextStrokeRect(context, CGRectMake(0, rect.size.height - 1, rect.size.width, 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.重写cell的setFrame：方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFrame:(CGRect)frame&#123;</span><br><span class="line">    frame.size.height -= 1;//设置分隔线</span><br><span class="line">    </span><br><span class="line">    //设置cell的左右间距</span><br><span class="line">    frame.origin.x = 5;//左间距为5</span><br><span class="line">    frame.size.width = [UIScreen mainScreen].bounds.size.width - 2 * frame.origin.x;</span><br><span class="line">    </span><br><span class="line">    // 给cellframe赋值</span><br><span class="line">    [super setFrame:frame];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.利用系统属性设置(separatorInset, layoutMargins)设置</p><ul><li><p>对tableView的separatorInset, layoutMargins属性的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidLoad &#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line">  //1.调整(iOS7以上)表格分隔线边距</span><br><span class="line">  if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) &#123;</span><br><span class="line">      self.tableView.separatorInset = UIEdgeInsetsZero;</span><br><span class="line">  &#125;</span><br><span class="line">  //2.调整(iOS8以上)view边距(或者在cell中设置preservesSuperviewLayoutMargins,二者等效)</span><br><span class="line">  if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) &#123;</span><br><span class="line">      self.tableView.layoutMargins = UIEdgeInsetsZero;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对cell的LayoutMargins属性的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//对cell的设置可以写在cellForRowAtIndexPath里,也可以写在willDisplayCell方法里</span><br><span class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    static NSString *ID = @&quot;cell&quot;;</span><br><span class="line">    FSDiscoverSpecialCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];</span><br><span class="line">    if (cell == nil) &#123;</span><br><span class="line">        cell = [[FSDiscoverSpecialCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //2.调整(iOS8以上)tableView边距(与上面第2步等效,二选一即可)</span><br><span class="line">    if ([cell respondsToSelector:@selector(setPreservesSuperviewLayoutMargins:)]) &#123;</span><br><span class="line">        cell.preservesSuperviewLayoutMargins = NO;</span><br><span class="line">    &#125;</span><br><span class="line">   //3.调整(iOS8以上)view边距</span><br><span class="line">    if ([cell respondsToSelector:@selector(setLayoutMargins:)]) &#123;</span><br><span class="line">        [cell setLayoutMargins:UIEdgeInsetsZero];</span><br><span class="line">    &#125;</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三种方法优缺点比较："><a href="#三种方法优缺点比较：" class="headerlink" title="三种方法优缺点比较："></a>三种方法优缺点比较：</h2><ul><li><p>方法1一般使用系统的cell，或者对cell没有特殊要求的情况下使用系统的分隔线；</p></li><li><p>方法2是比较好用的,但是有些情况下系统自带的cell就足够用了,仅仅为了分隔线却还必须再自定义cell,添加一个view,设置背景颜色和frame,又显得麻烦;</p></li><li><p>方法3比较取巧,但是也需要自定义cell,在某些情况下不允许改变tableView的背景色,使用场景有限;</p></li><li><p>方法4不需要自定义cell,对系统(iOS7,iOS8以上)做个简单判断即可.</p></li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS之UICollectionView自定义布局</title>
      <link href="/2016/11/15/iOS%E4%B9%8BUICollectionView%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80"/>
      <content type="html"><![CDATA[<h2 id="UICollectionView基础"><a href="#UICollectionView基础" class="headerlink" title="UICollectionView基础"></a>UICollectionView基础</h2><ul><li>UICollectionViewFlowLayout：视图布局对象（流水布局：一行排满，自动排到下行），继承自UICollectionViewLayout。UICollectionViewLayout内有一个collectionView属性，所有的视图布局对象都继承自UICollectionViewLayout。</li><li>若我们要自定义布局对象，我们一般继承UICollectionViewFlowLayout，然后重写里面的一些方法就可以了。</li><li>需要实现三个协议；UICollectionViewDataSource（数据源）、UICollectionViewDelegateFlowLayout（视图布局），自定义布局需要实现UICollectionViewDataSource、UICollectionViewDelegate两个协议即可。</li></ul><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><h4 id="一、自定义线性布局"><a href="#一、自定义线性布局" class="headerlink" title="一、自定义线性布局"></a>一、自定义线性布局</h4><ul><li><strong>首先要继承与流水布局UICollectionViewFlowLayout</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LineCollectionViewLayout</span> : <span class="title">UICollectionViewFlowLayout</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li><strong>重写相应的方法</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"LineCollectionViewLayout.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LineCollectionViewLayout</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来做布局的初始化操作（不建议在init方法中进行布局的初始化操作）</span></span><br><span class="line"><span class="comment"> - 注意：一定要调用[super prepareLayout]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)prepareLayout&#123;</span><br><span class="line">    [<span class="keyword">super</span> prepareLayout];</span><br><span class="line">    <span class="comment">// 水平滚动</span></span><br><span class="line">    <span class="keyword">self</span>.scrollDirection = <span class="built_in">UICollectionViewScrollDirectionHorizontal</span>;</span><br><span class="line">    <span class="comment">// 设置内边距</span></span><br><span class="line">    <span class="built_in">CGFloat</span> inset = (<span class="keyword">self</span>.collectionView.frame.size.width - <span class="keyword">self</span>.itemSize.width) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">self</span>.sectionInset = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, inset, <span class="number">0</span>, inset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法的返回值是一个数组（数组里面存放着rect范围内所有元素的布局属性）</span></span><br><span class="line"><span class="comment"> * 这个数组中存放的都是UICollectionViewLayoutAttributes对象</span></span><br><span class="line"><span class="comment"> * 这个方法的返回值决定了rect范围内所有元素的排布（frame）*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> UICollectionViewLayoutAttributes *attrs;</span></span><br><span class="line"><span class="comment"> 1.一个cell对应一个UICollectionViewLayoutAttributes对象</span></span><br><span class="line"><span class="comment"> 2.UICollectionViewLayoutAttributes对象决定了cell的frame</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)layoutAttributesForElementsInRect:(<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    <span class="comment">// 获得super已经计算好的布局属性</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array = [<span class="keyword">super</span> layoutAttributesForElementsInRect:rect];</span><br><span class="line">    <span class="comment">// 计算collectionView最中心点的x值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> centerX = <span class="keyword">self</span>.collectionView.contentOffset.x + <span class="keyword">self</span>.collectionView.frame.size.width * <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 在原有布局属性的基础上，进行微调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UICollectionViewLayoutAttributes</span> *attrs <span class="keyword">in</span> array) &#123;</span><br><span class="line">        <span class="comment">// cell的中心点x 和 collectionView最中心点的x值 的间距</span></span><br><span class="line">        <span class="built_in">CGFloat</span> delta = ABS(attrs.center.x - centerX);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据间距值 计算 cell的缩放比例</span></span><br><span class="line">        <span class="built_in">CGFloat</span> scale = <span class="number">1</span> - delta / <span class="keyword">self</span>.collectionView.frame.size.width;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置缩放比例</span></span><br><span class="line">        attrs.transform = <span class="built_in">CGAffineTransformMakeScale</span>(scale, scale);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当collectionView的显示范围发生改变的时候，是否需要重新刷新布局</span></span><br><span class="line"><span class="comment"> * 一旦重新刷新布局，就会重新调用下面的方法：</span></span><br><span class="line"><span class="comment"> 1.prepareLayout</span></span><br><span class="line"><span class="comment"> 2.layoutAttributesForElementsInRect:方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class="built_in">CGRect</span>)newBounds&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法的返回值，就决定了collectionView停止滚动时的偏移量</span></span><br><span class="line"><span class="comment"> * proposedContentOffset：原本情况下，collectionView停止滚动时最终的偏移量</span></span><br><span class="line"><span class="comment"> * velocity：滚动速率，通过这个参数可以了解滚动的方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)targetContentOffsetForProposedContentOffset:(<span class="built_in">CGPoint</span>)proposedContentOffset withScrollingVelocity:(<span class="built_in">CGPoint</span>)velocity&#123;</span><br><span class="line">    <span class="comment">// 计算出最终显示的矩形框</span></span><br><span class="line">    <span class="built_in">CGRect</span> rect;</span><br><span class="line">    rect.origin.y = <span class="number">0</span>;</span><br><span class="line">    rect.origin.x = proposedContentOffset.x;</span><br><span class="line">    rect.size = <span class="keyword">self</span>.collectionView.frame.size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得super已经计算好的布局属性</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array = [<span class="keyword">super</span> layoutAttributesForElementsInRect:rect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算collectionView最中心点的x值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> centerX = proposedContentOffset.x + <span class="keyword">self</span>.collectionView.frame.size.width * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存放最小的间距值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> minDelta = MAXFLOAT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UICollectionViewLayoutAttributes</span> *attrs <span class="keyword">in</span> array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ABS(minDelta) &gt; ABS(attrs.center.x - centerX)) &#123;</span><br><span class="line">            minDelta = attrs.center.x - centerX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改原有的偏移量</span></span><br><span class="line">    proposedContentOffset.x += minDelta;</span><br><span class="line">    <span class="keyword">return</span> proposedContentOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="自定义环形布局"><a href="#自定义环形布局" class="headerlink" title="自定义环形布局"></a>自定义环形布局</h4><ul><li><strong>同样要继承与流水布局UICollectionViewFlowLayout</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CircleCollectionViewLayout</span> : <span class="title">UICollectionViewFlowLayout</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li><strong>重写相应的方法</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CircleCollectionViewLayout.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CircleCollectionViewLayout</span>()</span></span><br><span class="line"><span class="comment">/** 布局属性 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *attrsArray;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CircleCollectionViewLayout</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 懒加载 */</span></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)attrsArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_attrsArray) &#123;</span><br><span class="line">        _attrsArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _attrsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)prepareLayout</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> prepareLayout];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.attrsArray removeAllObjects];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> count = [<span class="keyword">self</span>.collectionView numberOfItemsInSection:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">NSIndexPath</span> *indexPath = [<span class="built_in">NSIndexPath</span> indexPathForItem:i inSection:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">UICollectionViewLayoutAttributes</span> *attrs = [<span class="keyword">self</span> layoutAttributesForItemAtIndexPath:indexPath];</span><br><span class="line">        [<span class="keyword">self</span>.attrsArray addObject:attrs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)layoutAttributesForElementsInRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.attrsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法需要返回indexPath位置对应cell的布局属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> *)layoutAttributesForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> count = [<span class="keyword">self</span>.collectionView numberOfItemsInSection:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> radius = <span class="number">70</span>;</span><br><span class="line">    <span class="comment">// 圆心的位置</span></span><br><span class="line">    <span class="built_in">CGFloat</span> oX = <span class="keyword">self</span>.collectionView.frame.size.width * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> oY = <span class="keyword">self</span>.collectionView.frame.size.height * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UICollectionViewLayoutAttributes</span> *attrs = [<span class="built_in">UICollectionViewLayoutAttributes</span> layoutAttributesForCellWithIndexPath:indexPath];</span><br><span class="line">    </span><br><span class="line">    attrs.size = <span class="built_in">CGSizeMake</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">        attrs.center = <span class="built_in">CGPointMake</span>(oX, oY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> angle = (<span class="number">2</span> * M_PI / count) * indexPath.item;</span><br><span class="line">        <span class="built_in">CGFloat</span> centerX = oX + radius * sin(angle);</span><br><span class="line">        <span class="built_in">CGFloat</span> centerY = oY + radius * cos(angle);</span><br><span class="line">        attrs.center = <span class="built_in">CGPointMake</span>(centerX, centerY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> attrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="对自定义布局的使用"><a href="#对自定义布局的使用" class="headerlink" title="对自定义布局的使用"></a>对自定义布局的使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 创建布局</span></span><br><span class="line">    CircleCollectionViewLayout *layout = [[CircleCollectionViewLayout alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建CollectionView</span></span><br><span class="line">    <span class="built_in">CGFloat</span> collectionW = <span class="keyword">self</span>.view.frame.size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> collectionH = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">150</span>, collectionW, collectionH);</span><br><span class="line">    <span class="built_in">UICollectionView</span> *collectionView = [[<span class="built_in">UICollectionView</span> alloc] initWithFrame:frame collectionViewLayout:layout];</span><br><span class="line">    collectionView.dataSource = <span class="keyword">self</span>;</span><br><span class="line">    collectionView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:collectionView];</span><br><span class="line">    <span class="keyword">self</span>.collectionView = collectionView;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    [collectionView registerNib:[<span class="built_in">UINib</span> nibWithNibName:<span class="built_in">NSStringFromClass</span>([PhotoCell <span class="keyword">class</span>]) bundle:<span class="literal">nil</span>] forCellWithReuseIdentifier:photoId];</span><br><span class="line"> ```   </span><br><span class="line">- ****增加 touchesBegan：方法，通过点击让两种布局相互转换****</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.collectionView.collectionViewLayout isKindOfClass:[LineCollectionViewLayout <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.collectionView setCollectionViewLayout:[[CircleCollectionViewLayout alloc] init] animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LineCollectionViewLayout *layout = [[LineCollectionViewLayout alloc] init];</span><br><span class="line">        layout.itemSize = <span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">        [<span class="keyword">self</span>.collectionView setCollectionViewLayout:layout animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac破解版软件大全</title>
      <link href="/2016/10/10/Mac%E7%A0%B4%E8%A7%A3%E7%89%88%E8%BD%AF%E4%BB%B6%E5%A4%A7%E5%85%A8"/>
      <content type="html"><![CDATA[<blockquote><p>转自<a href="http://www.sdifenzhou.com/page/6/" target="_blank" rel="noopener">史蒂芬周的博客</a></p></blockquote><blockquote><p>转自<a href="http://www.pc6.com/mac/soft/" target="_blank" rel="noopener">苹果网 PC6 </a></p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>]]></content>
      
      
        <tags>
            
            <tag> Mac 工具 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
