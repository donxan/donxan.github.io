<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ReactiveCocoa使用详解01</title>
      <link href="/2018/03/19/ReactiveCocoa%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A301/"/>
      <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>（简称为RAC）,是由<code>Github</code>开源的一个应用于iOS和OS开发的函数式响应式编程框架，它提供了一系列用来组合和转换值流的 API</p><a id="more"></a><h2 id="一-什么是响应式变成思想"><a href="#一-什么是响应式变成思想" class="headerlink" title="一. 什么是响应式变成思想?"></a>一. 什么是响应式变成思想?</h2><p>学习一个框架之前, 首先要了解这个框架的编程思想, 这里在介绍响应式编程思想之前, 先介绍一下之前接触过的编程思想</p><h3 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1.面向对象"></a>1.面向对象</h3><ul><li>万物皆对象<ul><li>是一类以对象作为基本程序结构单位的程序设计语言</li><li>典型的面向对象的编程语言有<code>C++</code>, <code>C#</code>, <code>Java</code>等</li></ul></li></ul><h3 id="2-面向过程"><a href="#2-面向过程" class="headerlink" title="2. 面向过程"></a>2. 面向过程</h3><ul><li>一种以过程为中心的编程思想</li><li>C语言就是一门面向过程的语言</li></ul><h3 id="3-链式编程思想"><a href="#3-链式编程思想" class="headerlink" title="3. 链式编程思想"></a>3. 链式编程思想</h3><ul><li>是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好</li><li>链式编程特点：方法的返回值是block, block必须有返回值（本身对象），block参数（需要操作的值）</li><li>典型框架：masonry框架。 </li></ul><h3 id="4-函数式编程思想"><a href="#4-函数式编程思想" class="headerlink" title="4. 函数式编程思想"></a>4. 函数式编程思想</h3><ul><li>万物皆是流<ul><li>不需要考虑调用顺序，只需要知道考虑结果</li><li>类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果</li><li>代表：KVO运用</li></ul></li></ul><h3 id="5-函数式编程思想"><a href="#5-函数式编程思想" class="headerlink" title="5. 函数式编程思想"></a>5. 函数式编程思想</h3><ul><li>是把操作尽量写成一系列嵌套的函数或者方法调用</li><li>特点: 每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）</li><li>代表：ReactiveCocoa</li></ul><h3 id="6-ReactiveCocoa编程思想"><a href="#6-ReactiveCocoa编程思想" class="headerlink" title="6. ReactiveCocoa编程思想"></a>6. <code>ReactiveCocoa</code>编程思想</h3><ul><li>函数式编程 <code>Functional Programming</code></li><li>响应式编程 <code>Reactive Programming</code></li></ul><p>所以, <code>ReactiveCocoa</code>被描述为函数响应式编程（FRP）框架, 下面具体介绍一下<code>RAC</code>的一些常见类</p><h2 id="二-RACSiganl-信号类"><a href="#二-RACSiganl-信号类" class="headerlink" title="二. RACSiganl 信号类"></a>二. RACSiganl 信号类</h2><ul><li><code>ReactiveCocoa</code> 中最核心的概念之一就是信号<code>RACStream</code>。<code>RACStream</code>中有两个子类——<code>RACSignal</code> 和 <code>RACSequence</code>; 这里我们就主要说一下<code>RACSignal</code>; </li><li>在<code>ReactiveCocoa</code>整个库中，<code>RACSignal</code>占据着比较重要的位置，而<code>RACSignal</code>的变换操作更是整个<code>RACStream</code>流操作核心之一</li><li>下面让我们俩看一下<code>RACSignal</code>被订阅的完整过程</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test2 &#123;</span><br><span class="line">    <span class="comment">//创建信号</span></span><br><span class="line">    RACSignal *single = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"a"</span>];</span><br><span class="line">        [subscriber sendNext:<span class="string">@"b"</span>];</span><br><span class="line">        <span class="comment">//发送完成</span></span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清空数据</span></span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="comment">//当订阅者被消耗的时候就会执行</span></span><br><span class="line">            <span class="comment">//当订阅者发送完成,或者error的时候也会执行</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"RACDisposable的block"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    RACDisposable *disposable = [single subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error: %@"</span>, error);</span><br><span class="line">    &#125; completed:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"completed"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    [disposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在此之前先看一下<code>RACSignal</code>的一些子类<ul><li><code>RACDynamicSignal</code>: 动态信号，使用一个 <code>block</code> 来实现订阅行为，我们在使用 <code>RACSignal</code> 的 <code>+createSignal:</code> 方法时创建的就是该类的实例</li><li><code>RACEmptySignal</code>：空信号，用来实现 <code>RACSignal</code> 的 <code>+empty</code> 方法；</li><li><code>RACReturnSignal</code>：一元信号，用来实现 <code>RACSignal</code> 的 <code>+return:</code>方法；</li><li><code>RACErrorSignal</code>：错误信号，用来实现 <code>RACSignal</code> 的 <code>+error:</code> 方法；</li><li><code>RACChannelTerminal</code>：通道终端，代表 <code>RACChannel</code> 的一个终端，用来实现双向绑定</li></ul></li></ul><blockquote><p><code>RACSignal</code>在创建信号的时候，底层会调用<code>RACDynamicSignal</code>的<code>createSignal</code>的方法, 如下:</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"><span class="keyword">return</span> [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的block是一个 <code>id&lt;RACSubscriber&gt;</code> 类型的<code>subscriber</code>, 而这个<code>RACSubscriber</code>, 我们可以点进去看一些底层实现,  协议方法如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RACSubscriber</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Sends the next value to subscribers.</span></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Sends the error to subscribers.</span></span><br><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Sends completed to subscribers.</span></span><br><span class="line">- (<span class="keyword">void</span>)sendCompleted;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Sends the subscriber a disposable that represents one of its subscriptions.</span></span><br><span class="line">- (<span class="keyword">void</span>)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br></pre></td></tr></table></figure><ul><li>RACSignal底层实现：<ul><li>1.创建信号，首先把<code>didSubscribe</code>保存到信号中，还不会触发。</li><li>2.当信号被订阅，也就是调用<code>signal</code>的<code>subscribeNext:nextBlock</code><ul><li>2.1 <code>subscribeNext</code>内部会创建订阅者<code>subscriber</code>，并且把<code>nextBlock</code>保存到<code>subscriber</code>中。</li><li>2.2 <code>subscribeNext</code>内部会调用<code>siganl的didSubscribe</code></li><li>2.3 当信号订阅完成, 不在发送数据的时候, 最好调用完成发送的<code>[subscriber sendCompleted];</code></li><li>订阅完成的时候, 内部会自动调用<code>[RACDisposable disposable]</code>取消订阅信号</li></ul></li><li>3.<code>siganl</code>的<code>didSubscribe</code>中调用<code>[subscriber sendNext:@1];</code><ul><li>3.1 <code>sendNext</code>底层其实就是执行<code>subscriber</code>的<code>nextBlock</code></li></ul></li></ul></li></ul><h2 id="三-信号提供者-RACSubject"><a href="#三-信号提供者-RACSubject" class="headerlink" title="三. 信号提供者: RACSubject"></a>三. 信号提供者: <code>RACSubject</code></h2><ul><li>信号提供者，自己可以充当信号，又能发送信号</li><li>先订阅, 在发送信号</li><li>使用场景:通常用来代替代理/通知</li></ul><h3 id="1-RACSubject简单使用"><a href="#1-RACSubject简单使用" class="headerlink" title="1. RACSubject简单使用"></a>1. <code>RACSubject</code>简单使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setRacSubject1 &#123;</span><br><span class="line">    <span class="comment">//先订阅, 在发送信号</span></span><br><span class="line">    <span class="comment">//1. 创建信号</span></span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 订阅</span></span><br><span class="line">    <span class="comment">//内部创建RACSubscriber</span></span><br><span class="line">    [subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者--%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者---%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 发送信号</span></span><br><span class="line">    <span class="comment">//遍历所有的订阅者, 执行nextBlock</span></span><br><span class="line">    [subject sendNext:@<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 打印结果</span></span><br><span class="line"><span class="comment">     2018-03-17 20:18:19.782119+0800 ReactiveObjc[23883:1420936] 第一个订阅者--2</span></span><br><span class="line"><span class="comment">     2018-03-17 20:18:19.784715+0800 ReactiveObjc[23883:1420936] 第二个订阅者---2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RACSubject:底层实现和RACSignal不一样 <ul><li>1.调用<code>subscribeNext</code>订阅信号，只是把订阅者保存起来，并且订阅者的<code>nextBlock</code>已经赋值了。</li><li>2.调用<code>sendNext</code>发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的<code>nextBlock</code> </li></ul></li></ul><h3 id="2-RACReplaySubject简单使用"><a href="#2-RACReplaySubject简单使用" class="headerlink" title="2. RACReplaySubject简单使用"></a>2. <code>RACReplaySubject</code>简单使用</h3><ul><li>重复提供信号类，RACSubject的子类</li><li>先发送信号，再订阅信号；</li><li>使用场景<ul><li><ol><li>如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li></ol></li><li><ol><li>可以设置<code>capacity</code>数量来限制缓存的<code>value</code>的数量，即只缓充最新的几个值</li></ol></li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setReplaySubject &#123;</span><br><span class="line">    <span class="comment">//创建信号</span></span><br><span class="line">    RACReplaySubject *replySub = [RACReplaySubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [replySub sendNext:@<span class="number">23</span>];</span><br><span class="line">    [replySub sendNext:@<span class="number">34</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    <span class="comment">// 遍历值，让一个订阅者去发送多个值</span></span><br><span class="line">    <span class="comment">// 只要订阅一次，之前所有发送的值都能获取到.</span></span><br><span class="line">    [replySub subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     2018-03-19 12:01:14.112253+0800 ReactiveObjc[5130:446958] 23</span></span><br><span class="line"><span class="comment">     2018-03-19 12:01:14.112511+0800 ReactiveObjc[5130:446958] 34</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>RACReplaySubject</code>的底层实现<ul><li><ol><li>订阅信号时，内部保存了订阅者，和订阅者响应block</li></ol></li><li><ol><li>当发送信号的，遍历订阅者，调用订阅者的nextBlock</li></ol></li><li><ol><li>发送的信号会保存起来，当订阅者订阅信号的时，会将之前保存的信号，一个一个作用于新的订阅者，保存信号的容量由<code>capacity</code>决定，这也是有别于RACSubject的</li></ol></li></ul></li></ul><h3 id="3-替代代理-通知"><a href="#3-替代代理-通知" class="headerlink" title="3. 替代代理/通知"></a>3. 替代代理/通知</h3><ul><li>这里我们设想一个反向传值的场景, vc里面有一个自定义的view, 当点击该<code>View</code>的时候, 更换vc的背景颜色</li><li>通常我们的做法是使用代理/通知/block</li></ul><h4 id="3-1-下面看一下代理的简单使用"><a href="#3-1-下面看一下代理的简单使用" class="headerlink" title="3-1. 下面看一下代理的简单使用"></a>3-1. 下面看一下代理的简单使用</h4><p> 在自定义View中设置协议</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">SubjectView</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SubjectDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)viewWithTap:(SubjectView *)subView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubjectView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;SubjectDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在vc中, 遵循代理, 并实现代理方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 代理方法</span></span><br><span class="line">-(<span class="keyword">void</span>)viewWithTap:(SubjectView *)subView&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成代理, 点击了view"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithRed:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> green:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> blue:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> alpha:<span class="number">1.0</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-RACSubject代替代理"><a href="#3-1-RACSubject代替代理" class="headerlink" title="3-1. RACSubject代替代理"></a>3-1. <code>RACSubject</code>代替代理</h4><p>在自定义<code>SubjectView.h</code>文件中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveObjC.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubjectView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSubject *subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在自定义<code>SubjectView.m</code>文件中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SubjectView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubjectView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [_subject sendNext:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>下面看一下在vc中的操作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupSubjectView &#123;</span><br><span class="line">    SubjectView *subV = [[SubjectView alloc]init];</span><br><span class="line">    subV.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    subV.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    [subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"完成代理, 点击了view"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithRed:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> green:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> blue:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> alpha:<span class="number">1.0</span>];</span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor = color;</span><br><span class="line">    &#125;];</span><br><span class="line">    subV.subject = subject;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:subV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>相关ReactiveObjc的知识点, 后期会持续更新…</li><li>推荐文章: <a href="http://www.cocoachina.com/ios/20160729/17236.html" target="_blank" rel="noopener">iOS ReactiveCocoa 最全常用API整理</a></li></ul>]]></content>
      
      <categories>
          
          <category> ReactiveCocoa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式 </tag>
            
            <tag> 响应式 </tag>
            
            <tag> RACSingle </tag>
            
            <tag> RACSubject </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS神技之动态更换APP的Icon图</title>
      <link href="/2018/03/16/iOS%E7%A5%9E%E6%8A%80%E4%B9%8B%E5%8A%A8%E6%80%81%E6%9B%B4%E6%8D%A2APP%E7%9A%84Icon%E5%9B%BE/"/>
      <content type="html"><![CDATA[<ul><li>在iOS10.3系统发布之前, 众所周知, 在App Store上架的APP如果要更换Icon图, 只能更新版本替换; </li><li>这次苹果却在iOS10.3系统中加入了了更换应用图标的新功能，当应用安装后，开发者可以为应用提供多个应用图标选择。</li><li>用户可以自由的在这些图标之间切换，并及时生效。</li><li>这是因为 10.3 里引入了一个新的 API，它允许在 App 运行的时候，通过代码为 app 更换 icon</li></ul><a id="more"></a><h2 id="一-项目配置"><a href="#一-项目配置" class="headerlink" title="一. 项目配置"></a>一. 项目配置</h2><ul><li>虽然提供了更换的功能，但更换的 icon 是有限制的</li><li>它只能更换项目中提前添加配置好的Icon图</li><li><p>具体可参考demo–<a href="https://github.com/CoderTitan/ChangeIcon" target="_blank" rel="noopener">github项目地址</a></p></li><li><p>这里先看个效果</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4122543-66b9c476748f1937.gif?imageMogr2/auto-orient/strip" alt="更换icon.gif"></p><h3 id="1-备选Icon"><a href="#1-备选Icon" class="headerlink" title="1. 备选Icon"></a>1. 备选Icon</h3><ul><li>首先你需要将备选的Icon图添加到项目中,</li><li>注意: <ul><li>图片不要放到<code>Assets.xcassets</code>, 而应该直接放到工程中, 不然可能导致更换Icon时, 找不到图片, 更换失败</li><li>在<code>info.plist</code> 的配置中，图片的文件名应该尽量不带 @2x/@3x 后缀扩展名，而让它自动选择</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4122543-49f0f45c2657a229.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Snip20180315_1.png"></p><h3 id="2-配置info-plist文件"><a href="#2-配置info-plist文件" class="headerlink" title="2. 配置info.plist文件"></a>2. 配置<code>info.plist</code>文件</h3><ul><li>在<code>info.plist</code>文件中，添加对应的<code>CFBundleAlternateIcons</code>的信息</li><li>这里也可以查看<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009247" target="_blank" rel="noopener">官方的相关介绍</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4122543-8886cf5e071a1c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Snip20180315_2.png"></p><blockquote><p><code>Source Code</code>添加方式如下</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">      &lt;key&gt;CFBundleAlternateIcons&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;天天特价&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;天天特价&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;key&gt;UIPrerenderedIcon&lt;/key&gt;</span><br><span class="line">&lt;<span class="literal">false</span>/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;key&gt;小房子&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;小房子&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;key&gt;UIPrerenderedIcon&lt;/key&gt;</span><br><span class="line">&lt;<span class="literal">false</span>/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;key&gt;小猫&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;小猫&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;key&gt;UIPrerenderedIcon&lt;/key&gt;</span><br><span class="line">&lt;<span class="literal">false</span>/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;key&gt;邮件信息&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;邮件信息&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;key&gt;UIPrerenderedIcon&lt;/key&gt;</span><br><span class="line">&lt;<span class="literal">false</span>/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure><ul><li>注意事项:<ul><li>虽然文档中写着<code>「You must declare your app&#39;s primary and alternate icons using the CFBundleIcons key of your app&#39;s Info.plist file. 」</code>，但经测试，<code>CFBundlePrimaryIcon</code> 可以省略掉。在工程配置 <code>App Icons and Launch Image</code> - <code>App Icons Source</code> 中使用 <code>asset catalog</code>（默认配置），删除 <code>CFBundlePrimaryIcon</code> 的配置也是没有问题的。</li><li>省略这个配置的好处是，避免处理 <code>App icon</code> 的尺寸。现在的工程中，大家一般都使用 <code>asset catalog</code> 进行 icon 的配置，而一个 icon 对应有很多尺寸的文件。省略 <code>CFBundlePrimaryIcon</code> 就可以沿用 <code>Asset</code> 中的配置。</li><li>如果想设置回默认 icon，在 <code>setAlternateIconName</code> 中传入 nil 即可</li></ul></li></ul><h2 id="二-API调用"><a href="#二-API调用" class="headerlink" title="二. API调用"></a>二. API调用</h2><p>下面我们看一下系统提供的三个API, 这里产看<a href="https://developer.apple.com/documentation/uikit/uiapplication/2806818-setalternateiconname" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var supportsAlternateIcons: Bool</span><br><span class="line"><span class="comment">//一个布尔值，指示是否允许应用程序更改其图标</span></span><br><span class="line"></span><br><span class="line">var alternateIconName: String?</span><br><span class="line"><span class="comment">//可选图标的名称，在app的Info.plist文件中声明的CFBundleAlternateIcons中设置。</span></span><br><span class="line"><span class="comment">//如果要显示应用程序的主图标alternateIconName 传nil即可，主图标使用CFBundlePrimaryIcon声明，CFBundleAlternateIcons与CFBundlePrimaryIcon两个key都是CFBundleIcons的子条目</span></span><br><span class="line"></span><br><span class="line">func setAlternateIconName(_ alternateIconName: String?, </span><br><span class="line">        completionHandler: ((Error?) -&gt; Void)? = <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//更改应用程序的图标</span></span><br><span class="line"><span class="comment">//completionHandler: 当有结果的时候的回调</span></span><br><span class="line"><span class="comment">//成功改变图标的的时候，error为nil，如果发生错误，error描述发生什么了。并且alternateIconName的值保持不变</span></span><br></pre></td></tr></table></figure><p>具体的实现代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="meta">#available(iOS 10.3, *) &#123;</span></span><br><span class="line">    <span class="comment">//判断是否支持替换图标, false: 不支持</span></span><br><span class="line">    guard <span class="built_in">UIApplication</span>.shared.supportsAlternateIcons <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果支持, 替换icon</span></span><br><span class="line">    <span class="built_in">UIApplication</span>.shared.setAlternateIconName(imageStr) &#123; (error) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">            print(error ?? <span class="string">"更换icon发生错误"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            print(<span class="string">"更换成功"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-消除alert弹窗"><a href="#三-消除alert弹窗" class="headerlink" title="三. 消除alert弹窗"></a>三. 消除alert弹窗</h2><p><img src="https://upload-images.jianshu.io/upload_images/4122543-8ffa3280a84c46ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Snip20180315_3.png"></p><ul><li>动态更换App图标会有弹框, 有时候这个弹框看上去可能会很别扭, 但是这个弹框是系统直接调用弹出的, 我们又如何消除呢</li><li>通过层级关系可以看到这个弹框就是一个<code>UIAlertController</code>, 并且是通过<code>presentViewController:animated:completion:</code>方法弹出的</li><li>所以可以考虑使用<code>runtime</code>, 拦截并替换该方法, 让更换icon的时候, 不弹</li><li>下面看一下具体代码:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">extension NoAlertChangeViewController &#123;</span><br><span class="line">    fileprivate func runtimeReplaceAlert() &#123;</span><br><span class="line">        DispatchQueue.once(token: <span class="string">"UIAlertController"</span>) &#123;</span><br><span class="line">            let originalSelector = <span class="meta">#selector(present(_:animated:completion:))</span></span><br><span class="line">            let swizzledSelector = <span class="meta">#selector(noAlert_present(_:animated:completion:))</span></span><br><span class="line">            </span><br><span class="line">            let originalMethod = class_getInstanceMethod(NoAlertChangeViewController.self, originalSelector)</span><br><span class="line">            let swizzledMethod = class_getInstanceMethod(NoAlertChangeViewController.self, swizzledSelector)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//交换实现的方法</span></span><br><span class="line">            method_exchangeImplementations(originalMethod!, swizzledMethod!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc fileprivate func noAlert_present(_ viewControllerToPresent: <span class="built_in">UIViewController</span>, animated flag: Bool, completion: (() -&gt; Swift.Void)? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否是alert弹窗</span></span><br><span class="line">        <span class="keyword">if</span> viewControllerToPresent.isKind(of: <span class="built_in">UIAlertController</span>.self) &#123;</span><br><span class="line">            print(<span class="string">"title: \(String(describing: (viewControllerToPresent as? UIAlertController)?.title))"</span>)</span><br><span class="line">            print(<span class="string">"message: \(String(describing: (viewControllerToPresent as? UIAlertController)?.message))"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 换图标时的提示框的title和message都是nil，由此可特殊处理</span></span><br><span class="line">            let alertController = viewControllerToPresent as? <span class="built_in">UIAlertController</span></span><br><span class="line">            <span class="keyword">if</span> alertController?.title == <span class="literal">nil</span> &amp;&amp; alertController?.message == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">//是更换icon的提示</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//其他的弹框提示正常处理</span></span><br><span class="line">                noAlert_present(viewControllerToPresent, animated: flag, completion: completion)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        noAlert_present(viewControllerToPresent, animated: flag, completion: completion)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里用到了<code>DispatchQueue.once</code>, 这个<code>once</code>是我对<code>DispatchQueue</code>加了一个扩展</li><li>在Swift4.0以后, <code>static dispatch_once_t onceToken;</code>这个已经不能用了</li><li>关于这方面的详细介绍, 大家可以看看我的这篇文章–<a href="https://www.titanjun.top/2017/08/25/%E5%8D%87%E7%BA%A7Swift4.0%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/" target="_blank" rel="noopener">升级Swift4.0遇到的坑</a></li><li></li></ul><h2 id="四-支持不同尺寸的Icon"><a href="#四-支持不同尺寸的Icon" class="headerlink" title="四. 支持不同尺寸的Icon"></a>四. 支持不同尺寸的Icon</h2><ul><li>一个标准的Icon图集, 需要十几种尺寸, 比如: 20, 29, 40, 60等</li><li>对于 <code>info.plist</code> 中的每个 <code>icon</code> 配置，<code>CFBundleIconFiles</code> 的值是一个数组，我们可以在其中填入这十几种规格的图片名称。经测试:<ul><li>文件的命名没有强制的规则，可以随意取，</li><li>数组中的文件名也不关心先后顺序。</li></ul></li><li>总之把对应的文件名填进去即可，它会自动选择合适分辨率的文件（比如在 setting 中显示 icon 时，它会找到提供的数组中分辨率为 29pt 的那个文件）。</li><li>具体相关官方文档可参考, <a href="https://developer.apple.com/ios/human-interface-guidelines/overview/themes/#app-icon-sizes" target="_blank" rel="noopener">官方介绍</a></li><li>首先, 针对不同的尺寸, 我们要有不同的命名, 具体参考下图</li></ul><p><img src="http://img.blog.csdn.net/20180316194726671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2htaWx5Q29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="不同尺寸图片配置图"></p><ul><li>文件扩展名，如@2x,@3x，要么统一不写，那么系统会自动寻找合适的尺寸。</li><li>要写就需要把每张icon的扩展名写上，和上图的格式一样</li><li>代码中调用图片名, 更不需要加上尺寸:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="meta">#available(iOS 10.3, *) &#123;</span></span><br><span class="line">    <span class="comment">//判断是否支持替换图标, false: 不支持</span></span><br><span class="line">    guard <span class="built_in">UIApplication</span>.shared.supportsAlternateIcons <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果支持, 替换icon</span></span><br><span class="line">    <span class="built_in">UIApplication</span>.shared.setAlternateIconName(<span class="string">"Sunday"</span>) &#123; (error) <span class="keyword">in</span></span><br><span class="line">        <span class="comment">//点击弹框的确认按钮后的回调</span></span><br><span class="line">        <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">            print(error ?? <span class="string">"更换icon发生错误"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            print(<span class="string">"更换成功"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体可参考demo–<a href="https://github.com/CoderTitan/ChangeIcon" target="_blank" rel="noopener">github项目地址</a></li></ul>]]></content>
      
      <categories>
          
          <category> 入坑指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AppIcon </tag>
            
            <tag> iOS 10.3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SwiftLint代码规范属性说明(三)</title>
      <link href="/2018/03/10/SwiftLint%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E(%E4%B8%89)/"/>
      <content type="html"><![CDATA[<ul><li>这篇文章是继前两篇文章的继续更新</li><li><a href="https://www.titanjun.top/2018/02/07/Xcode%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B9%8BSwiftLint%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">Xcode代码规范之SwiftLint配置</a>–这篇文章对SwiftLint进行了简单介绍和针对Xcode的相关配置</li><li><a href="https://www.titanjun.top/2018/03/03/SwiftLint%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E(%E4%B8%80" target="_blank" rel="noopener">SwiftLint代码规范属性说明(一)</a>/)–这里介绍了上半部分的相关属性的介绍</li><li>下面来具体介绍一下SwiftLint的其他的代码规则的相关说明</li></ul><a id="more"></a><h3 id="规则101-switch-case-alignment"><a href="#规则101-switch-case-alignment" class="headerlink" title="规则101: switch_case_alignment"></a>规则101: switch_case_alignment</h3><p>switch-case语句中switch和case应该垂直对齐</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>switch_case_alignment</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应该是这样</span></span><br><span class="line"><span class="keyword">switch</span> someBool &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>: <span class="comment">// case 1</span></span><br><span class="line">    print('red')</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> let .someEnum(val) = someFunc() &#123;</span><br><span class="line">        print('blue')</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//而不是这样</span></span><br><span class="line"><span class="keyword">switch</span> someBool &#123;</span><br><span class="line">    ↓<span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">         print('red')</span><br><span class="line">    ↓<span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">         print('blue')</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则102-switch-case-on-newline"><a href="#规则102-switch-case-on-newline" class="headerlink" title="规则102: switch_case_on_newline"></a>规则102: switch_case_on_newline</h3><p>在switch语法里， case应该总是在一个新行上面</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>switch_case_on_newline</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// swiftlint表示会触发warning</span></span><br><span class="line">    <span class="keyword">switch</span> type &#123;</span><br><span class="line">    <span class="keyword">case</span> .value1: print(<span class="string">"1"</span>)...................在同一行错</span><br><span class="line">    <span class="keyword">case</span> .value2: print(<span class="string">"2"</span>)...................在同一行错</span><br><span class="line">    <span class="keyword">default</span>: print(<span class="string">"3"</span>)...................在同一行错</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 不会触发warning</span></span><br><span class="line">    <span class="keyword">switch</span> type &#123;</span><br><span class="line">    <span class="keyword">case</span> .value1:</span><br><span class="line">        print(<span class="string">"1"</span>)</span><br><span class="line">    <span class="keyword">case</span> .value2:</span><br><span class="line">        print(<span class="string">"2"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        print(<span class="string">"3"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="规则103-syntactic-sugar"><a href="#规则103-syntactic-sugar" class="headerlink" title="规则103: syntactic_sugar"></a>规则103: syntactic_sugar</h3><p>swiftlint推荐使用速记语法糖， 例如 [Int] 代替 Array, 强烈建议推荐使用</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>syntactic_sugar</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 触发warning</span></span><br><span class="line">    let myArray: Array&lt;Int&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    print(myArray)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 正确写法，不会触发warning</span></span><br><span class="line">    let myArray: [Int] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    print(myArray)</span><br></pre></td></tr></table></figure><h3 id="规则104-todo"><a href="#规则104-todo" class="headerlink" title="规则104: todo"></a>规则104: todo</h3><p>TODO 和 FIXME 应该避免使用， 使用“notaTODO 和 notaFIXME”代替。另外， 和 MARK 标记不同的是， “notaTODO 和 notaFIXME”没有空格要求</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>todo</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><h3 id="规则105-trailing-closure"><a href="#规则105-trailing-closure" class="headerlink" title="规则105: trailing_closure"></a>规则105: trailing_closure</h3><p>关于闭包中{}的使用, 推荐使用尾随闭包的语法</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>trailing_closure</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐使用</span></span><br><span class="line">foo.map &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">foo.reduce(<span class="number">0</span>) &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐使用</span></span><br><span class="line">foo.map(&#123; $<span class="number">0</span> + <span class="number">1</span> &#125;)</span><br><span class="line">↓foo.reduce(<span class="number">0</span>, combine: &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="规则106-trailing-comma"><a href="#规则106-trailing-comma" class="headerlink" title="规则106: trailing_comma"></a>规则106: trailing_comma</h3><p>…<br>这个属性主要针对数组和字典最后一个元素, 不建议在最后一个元素会面加逗号</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>trailing_comma</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 数组这样写是没有任何问题的, 但是最后一个元素3后面加了一个逗号“,”尽管这样不会报错，但是这会让程序的可读性变差</span></span><br><span class="line">let ages = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,]</span><br><span class="line">let person = [<span class="string">"XingYun"</span>: <span class="number">98</span>, <span class="string">"JinGang"</span>: <span class="number">128</span>, <span class="string">"LangKe"</span>: <span class="number">18</span>,]</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 使用swiftlint的trailing_comma规则后，就会报warning， 所以正确的写法不应该加上这个“,”</span></span><br><span class="line">let ages = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">let person = [<span class="string">"XingYun"</span>: <span class="number">98</span>, <span class="string">"JinGang"</span>: <span class="number">128</span>, <span class="string">"LangKe"</span>: <span class="number">18</span>]</span><br></pre></td></tr></table></figure><h3 id="规则107-trailing-newline"><a href="#规则107-trailing-newline" class="headerlink" title="规则107: trailing_newline"></a>规则107: trailing_newline</h3><p>文件（属性、方法）结束的的时候（“}”之前）， 应该有一个空格新行，但这里要注意的是</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>trailing_newline</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 空一行，不会触发警告</span></span><br><span class="line">nonTriggeringExamples: [</span><br><span class="line">    <span class="string">"let a = 0\n"</span></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 下面会触发警告</span></span><br><span class="line">triggeringExamples: [</span><br><span class="line">    <span class="string">"let a = 0"</span>,   <span class="comment">/// 不空行，会触发警告（实际上，我试过，不会触发警告）</span></span><br><span class="line">    <span class="string">"let a = 0\n\n"</span>   <span class="comment">/// 空两行， 会触发警告（实际上，我试过，会触发警告，但是触发的是vertical_whitespace警告而不是trailing_newline）</span></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 说说这里，它要求改正为都空一行，虽然这样code看起来很轻松，但如果定义变量或常量太多，就太分散了（值得说的是，就算不空行也不会触发trailing_newline, 应该刚才也已经说了，这个属性只是说“应该”，而不是必须）</span></span><br><span class="line">corrections: [</span><br><span class="line">    <span class="string">"let a = 0"</span>: <span class="string">"let a = 0\n"</span>,</span><br><span class="line">    <span class="string">"let b = 0\n\n"</span>: <span class="string">"let b = 0\n"</span>,</span><br><span class="line">    <span class="string">"let c = 0\n\n\n\n"</span>: <span class="string">"let c = 0\n"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="规则108-trailing-semicolon"><a href="#规则108-trailing-semicolon" class="headerlink" title="规则108: trailing_semicolon"></a>规则108: trailing_semicolon</h3><p>尽管在变量或常量赋值之后加不加分号在swift中没有硬性的要求，但是为了使code style更swift化，所以尽量或者绝对不要加“;”</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>trailing_semicolon</td><td>启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><h3 id="规则109-trailing-whitespace"><a href="#规则109-trailing-whitespace" class="headerlink" title="规则109: trailing_whitespace"></a>规则109: trailing_whitespace</h3><p>函数方法结束后,不建议添加空格行, 和vertical_whitespace貌似有冲突</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>trailing_whitespace</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 下面这个例子不会触发警告，但是一旦其中有一个空行就会触发警告trailing_whitespace, 这和vertical_whitespace实质上有些冲突，vertical_whitespace要求两行code之间不超过1行，要么没有空行，要么只有1行，而trailing_whitespace要求没有空行！！！</span></span><br><span class="line"><span class="keyword">class</span> ViewController: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    let a = <span class="number">0</span></span><br><span class="line">    let b = <span class="number">1</span></span><br><span class="line">    let c = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">func chenlong() -&gt; Void &#123;</span><br><span class="line">    let a = <span class="number">0</span></span><br><span class="line">    print(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则110-type-body-length"><a href="#规则110-type-body-length" class="headerlink" title="规则110: type_body_length"></a>规则110: type_body_length</h3><p>类型体长度。类型体长度不应该跨越太多行， 超过200行给warning，超过350行给error。一般是大括号或者括号内, 比如定义一个enum或struct</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>type_body_length</td><td>启用</td><td>no</td><td>metrics</td></tr></tbody></table><h3 id="规则111-type-name"><a href="#规则111-type-name" class="headerlink" title="规则111: type_name"></a>规则111: type_name</h3><p>…<br>类型名， 类型名应该只包含字母数字字符， 并且以大写字母开头，长度在3-40个字符</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>type_name</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><h3 id="规则112-unneeded-break-in-switch"><a href="#规则112-unneeded-break-in-switch" class="headerlink" title="规则112: unneeded_break_in_switch"></a>规则112: unneeded_break_in_switch</h3><p>在switch-case语句中, 有方法调用或操作时,避免使用break语句</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>unneeded_break_in_switch</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">case</span> .bar:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">case</span> .bar:</span><br><span class="line">    something()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">case</span> .bar:</span><br><span class="line"><span class="comment">//这里已经有方法调用了</span></span><br><span class="line">    something()</span><br><span class="line">    ↓<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则113-unneeded-parentheses-in-closure-argument"><a href="#规则113-unneeded-parentheses-in-closure-argument" class="headerlink" title="规则113: unneeded_parentheses_in_closure_argument"></a>规则113: unneeded_parentheses_in_closure_argument</h3><p>…<br>在定义或使用闭包时,闭包参数不建议使用括号()</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>unneeded_parentheses_in_closure_argument</td><td>未启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议</span></span><br><span class="line">let foo = &#123; (bar: Int) <span class="keyword">in</span> &#125;</span><br><span class="line">let foo = &#123; bar, _  <span class="keyword">in</span> &#125;</span><br><span class="line">let foo = &#123; bar <span class="keyword">in</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议</span></span><br><span class="line">call(arg: &#123; ↓(bar) <span class="keyword">in</span> &#125;)</span><br><span class="line">call(arg: &#123; ↓(bar, _) <span class="keyword">in</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="规则114-unused-closure-parameter"><a href="#规则114-unused-closure-parameter" class="headerlink" title="规则114: unused_closure_parameter"></a>规则114: unused_closure_parameter</h3><p>swiftlint建议最好把不使用的闭包参数使用 “_”代替</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>unused_closure_parameter</td><td>启用</td><td>yes</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; number <span class="keyword">in</span></span><br><span class="line"> number + <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; _ <span class="keyword">in</span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; ↓number <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; ↓number <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">return</span> numberWithSuffix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则115-unused-enumerated"><a href="#规则115-unused-enumerated" class="headerlink" title="规则115: unused_enumerated"></a>规则115: unused_enumerated</h3><p>在for遍历数组时, 如有未使用的索引,不建议使用.enumerated()</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>unused_enumerated</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">for</span> (idx, foo) <span class="keyword">in</span> bar.enumerated() &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (_, foo) <span class="keyword">in</span> bar.enumerated().something() &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (_, foo) <span class="keyword">in</span> bar.something() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line"><span class="keyword">for</span> (↓_, foo) <span class="keyword">in</span> bar.enumerated() &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (↓_, foo) <span class="keyword">in</span> abc.bar.enumerated() &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (↓_, foo) <span class="keyword">in</span> abc.something().enumerated() &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (idx, ↓_) <span class="keyword">in</span> bar.enumerated() &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="规则116-unused-optional-binding"><a href="#规则116-unused-optional-binding" class="headerlink" title="规则116: unused_optional_binding"></a>规则116: unused_optional_binding</h3><p>在使用if判断某变量是否为nil的时候, 不建议使用下划线(_)</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>unused_optional_binding</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">if</span> let bar = Foo.optionalValue &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line"><span class="keyword">if</span> let ↓_ = Foo.optionalValue &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> let a = Foo.optionalValue, let ↓_ = Foo.optionalValue2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则117-valid-ibinspectable"><a href="#规则117-valid-ibinspectable" class="headerlink" title="规则117: valid_ibinspectable"></a>规则117: valid_ibinspectable</h3><p>@IBInspectable在swiftlint中的使用需要注意， 第一必须是变量， 第二必须要有指定的类型，如果指定的类型是可选类型或者隐式类型，则目前官方只支持以下几种类型：</p><p>String, NSString, UIColor, NSColor, UIImage, NSImage.</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>valid_ibinspectable</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 指定为变量var， 类型为String？和String！</span></span><br><span class="line">@IBInspectable private var yyy: String?</span><br><span class="line">@IBInspectable private var zzz: String!</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果写成这样，编译能通过，但是会触发警告, 因为swiftlint暂不支持Int可选和隐式类型:</span></span><br><span class="line">@IBInspectable private var dddl: Int!</span><br><span class="line">@IBInspectable private var eeel: Int?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果指定的类型不是可选类型， 就应该初始化，否则系统不允许，会报错所在的类没有初始化</span></span><br><span class="line">对：</span><br><span class="line">@IBInspectable private var counts: Int = <span class="number">0</span></span><br><span class="line">系统报错：</span><br><span class="line">@IBInspectable private var counts: Int</span><br></pre></td></tr></table></figure><h3 id="规则118-vertical-parameter-alignment"><a href="#规则118-vertical-parameter-alignment" class="headerlink" title="规则118: vertical_parameter_alignment"></a>规则118: vertical_parameter_alignment</h3><p>垂直方向上的参数对齐。当函数参数有多行的时候， 函数参数在垂直方向上应该对齐（参数换行的时候左边对齐）</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>vertical_parameter_alignment</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">func validateFunction(_ file: File, kind: SwiftDeclarationKind,</span><br><span class="line">                      dictionary: [String: SourceKitRepresentable]) &#123; &#125;</span><br><span class="line">                      </span><br><span class="line">func validateFunction(_ file: File, kind: SwiftDeclarationKind,</span><br><span class="line">                      dictionary: [String: SourceKitRepresentable])</span><br><span class="line">                      -&gt; [StyleViolation]</span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">func validateFunction(_ file: File, kind: SwiftDeclarationKind,</span><br><span class="line">                  ↓dictionary: [String: SourceKitRepresentable]) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="规则119-vertical-parameter-alignment-on-call"><a href="#规则119-vertical-parameter-alignment-on-call" class="headerlink" title="规则119: vertical_parameter_alignment_on_call"></a>规则119: vertical_parameter_alignment_on_call</h3><p>当调用多个参数的函数时,如果参数多行显示,则应该垂直对齐</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>vertical_parameter_alignment_on_call</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar</span><br><span class="line">    param3: <span class="literal">false</span>, param4: <span class="literal">true</span>)</span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar)</span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar</span><br><span class="line">    param3: <span class="literal">false</span>,</span><br><span class="line">    param4: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar</span><br><span class="line">                ↓param3: <span class="literal">false</span>, param4: <span class="literal">true</span>)</span><br><span class="line">                </span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar</span><br><span class="line"> ↓param3: <span class="literal">false</span>, param4: <span class="literal">true</span>)</span><br><span class="line"> </span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar</span><br><span class="line">       ↓param3: <span class="literal">false</span>,</span><br><span class="line">       ↓param4: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="规则120-vertical-whitespace"><a href="#规则120-vertical-whitespace" class="headerlink" title="规则120: vertical_whitespace"></a>规则120: vertical_whitespace</h3><p>垂直方向上的空格行，限制为一行（注释除外）</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>vertical_whitespace</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 没有空格， nonTriggerWarning</span></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    let aaa = <span class="number">0</span></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/// 有一行空格, nonTriggerWarning</span></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    let aaa = <span class="number">0</span></span><br><span class="line">    ...........................<span class="number">.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &gt;=2行，就会触发警告</span></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    let aaa = <span class="number">0</span></span><br><span class="line">   ............................<span class="number">.1</span></span><br><span class="line">   ............................<span class="number">.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则121-void-return"><a href="#规则121-void-return" class="headerlink" title="规则121: void_return"></a>规则121: void_return</h3><p>多余的返回值为空， 在函数声明的时候，返回值为空是多余的。定义常量或者变量的时候可以</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>void_return</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 这个属性要求这样写， 返回值为空省略</span></span><br><span class="line">func XingYun() &#123;</span><br><span class="line">    print(<span class="string">"titan"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这个属性要求别这样写，否则会有warning（但是我在swift 3.0上测试并没有触发warning）</span></span><br><span class="line">func XingYun() -&gt; Void &#123;</span><br><span class="line">    print(<span class="string">"titan"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则122-weak-delegate"><a href="#规则122-weak-delegate" class="headerlink" title="规则122: weak_delegate"></a>规则122: weak_delegate</h3><p>代理应该写成weak类型（弱代理）来避免循环引用</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>weak_delegate</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 1.1 编译通过</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    var chenlong: <span class="built_in">NSObjectProtocol</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 1.2 编译通过，但是触发swiftlint的 weak_delegate警告， 原因是变量名 myDelegate 中有 delegate 关键字，这属于名字滥用</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    var myDelegate: <span class="built_in">NSObjectProtocol</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 1.3 编译通过， 不会触发警告， 原因是在 var 关键字前面加了 weak</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    <span class="keyword">weak</span> var myDelegate: <span class="built_in">NSObjectProtocol</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2.1 编译通过，但是触发 weak_delegate 警告，原因是 scrollDelegate 中 Delegate 放在了最后， 被理解成了代理</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    var scrollDelegate: <span class="built_in">UIScrollViewDelegate</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2.2 编译通过， 既然变量名被理解成了代理， 那为了类似防止循环引用， 应该加关键字 weak</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    <span class="keyword">weak</span> var scrollDelegate: <span class="built_in">UIScrollViewDelegate</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 编译通过， 不会触发警告， 因为delegate放在了前面， 没有被理解成代理</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    var delegateScroll: <span class="built_in">UIScrollViewDelegate</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则123-xctfail-message"><a href="#规则123-xctfail-message" class="headerlink" title="规则123: xctfail_message"></a>规则123: xctfail_message</h3><p>单元测试中,XCTFail调用应该包括声明描述</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>xctfail_message</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><h3 id="规则124-yoda-condition"><a href="#规则124-yoda-condition" class="headerlink" title="规则124: yoda_condition"></a>规则124: yoda_condition</h3><p>执行判断语句时, 变量名应该放在运算符的左边</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>yoda_condition</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">if</span> foo == <span class="number">42</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> foo &lt;= <span class="number">42.42</span> &#123;&#125;</span><br><span class="line">guard foo &gt;= <span class="number">42</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">guard foo != <span class="string">"str str"</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">↓<span class="keyword">if</span> <span class="number">42</span> == foo &#123;&#125;</span><br><span class="line">↓<span class="keyword">if</span> <span class="number">42.42</span> &gt;= foo &#123;&#125;</span><br><span class="line">↓guard <span class="number">42</span> &lt;= foo <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">↓guard <span class="string">"str str"</span> != foo <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">↓<span class="keyword">while</span> <span class="number">10</span> &gt; foo &#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>文中如有不足之处请多指教</p></blockquote><blockquote><p>持续更新中…..</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> SwiftLint </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SwiftLint代码规范属性说明(二)</title>
      <link href="/2018/03/10/SwiftLint%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E(%E4%BA%8C)/"/>
      <content type="html"><![CDATA[<ul><li>这篇文章是继前两篇文章的继续更新</li><li><a href="https://www.titanjun.top/2018/02/07/Xcode%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B9%8BSwiftLint%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">Xcode代码规范之SwiftLint配置</a>–这篇文章对SwiftLint进行了简单介绍和针对Xcode的相关配置</li><li><a href="https://www.titanjun.top/2018/03/03/SwiftLint%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E(%E4%B8%80" target="_blank" rel="noopener">SwiftLint代码规范属性说明(一)</a>/)–这里介绍了上半部分的相关属性的介绍</li><li>下面来具体介绍一下SwiftLint的其他的代码规则的相关说明</li></ul><a id="more"></a><h3 id="规则51-legacy-cggeometry-functions"><a href="#规则51-legacy-cggeometry-functions" class="headerlink" title="规则51: legacy_cggeometry_functions"></a>规则51: legacy_cggeometry_functions</h3><p>当获取某个视图的宽、高、最小X、最大X值等等， swiftlint推荐使用swift的标准语法， 尽量不要使用从Objective-C中的遗留版本， 尽量语法swift化</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>legacy_cggeometry_functions</td><td>启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 这样不推荐使用</span></span><br><span class="line"><span class="built_in">CGRectGetWidth</span>(someView.frame)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 推荐使用下面的形式</span></span><br><span class="line">rect.width</span><br><span class="line">rect.height</span><br><span class="line">rect.minX</span><br><span class="line">rect.midX</span><br><span class="line">rect...................</span><br></pre></td></tr></table></figure><h3 id="规则52-legacy-constant"><a href="#规则52-legacy-constant" class="headerlink" title="规则52: legacy_constant"></a>规则52: legacy_constant</h3><p>和属性<code>legacy_cggeometry_functions</code>一样， 结构范围常数尽量分开、明确、具体， 不要使用OC的遗留整体常数</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>legacy_constant</td><td>启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 规范的写法，不会触发warning</span></span><br><span class="line"><span class="built_in">CGPoint</span>.zero</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 不规范的写法， 会触发warning</span></span><br><span class="line"><span class="built_in">CGPointZero</span></span><br><span class="line"><span class="built_in">CGRectZero</span></span><br></pre></td></tr></table></figure><h3 id="规则53-legacy-constructor"><a href="#规则53-legacy-constructor" class="headerlink" title="规则53: legacy_constructor"></a>规则53: legacy_constructor</h3><p>swiftlint要求系统自带构造器， 使用swift语法化， 不要使用OC版本的构造器</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>legacy_constructor</td><td>启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// swift语法，相信之后系统也会强制规定使用</span></span><br><span class="line"><span class="built_in">CGPoint</span>（x: <span class="number">10</span>， y: <span class="number">20</span>）</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 错误的构造器语法</span></span><br><span class="line"><span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h3 id="规则54-legacy-nsgeometry-functions"><a href="#规则54-legacy-nsgeometry-functions" class="headerlink" title="规则54: legacy_nsgeometry_functions"></a>规则54: legacy_nsgeometry_functions</h3><p>ns类几何函数， 和前面的几个属性一样， 使用swift点语法函数， 不使用以前的版本。</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>legacy_nsgeometry_functions</td><td>启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 正确</span></span><br><span class="line">view.width/height/minX</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 错误</span></span><br><span class="line"><span class="built_in">NSWidth</span>(view.frame)</span><br></pre></td></tr></table></figure><h3 id="规则55-let-var-whitespace"><a href="#规则55-let-var-whitespace" class="headerlink" title="规则55: let_var_whitespace"></a>规则55: let_var_whitespace</h3><p>let和var语句应该用空白行与其他语句分开</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>let_var_whitespace</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐这样写</span></span><br><span class="line">let a = <span class="number">0</span></span><br><span class="line">var x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">var x = <span class="number">1</span></span><br><span class="line">x = <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="规则56-line-length"><a href="#规则56-line-length" class="headerlink" title="规则56: line_length"></a>规则56: line_length</h3><p>行的字符长度属性。这个强烈不推荐使用。官方的规定是超过120字符就给warning， 超过200个字符就直接报error！！！我们又不是写底层脚本的，所以建议这种方式禁用！！</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>line_length</td><td>启用</td><td>no</td><td>metrics</td></tr></tbody></table><h3 id="规则57-literal-expression-end-indentation"><a href="#规则57-literal-expression-end-indentation" class="headerlink" title="规则57: literal_expression_end_indentation"></a>规则57: literal_expression_end_indentation</h3><p>字典和数组的开头和结尾要有相同的缩进格式</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>literal_expression_end_indentation</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><h3 id="规则58-mark"><a href="#规则58-mark" class="headerlink" title="规则58: mark"></a>规则58: mark</h3><p>标记方法或者属性。这个推荐使用， 可以统一方法标记的格式， 有利于review查找某个方法或者属性的时候更清晰。使用也非常简单： “MARK”前空一格，”MARK:”后空一格。</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>mark</td><td>启用</td><td>yes</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="comment">// MARK: good</span></span><br><span class="line"><span class="comment">// MARK: - good</span></span><br><span class="line"><span class="comment">// MARK: -</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line"><span class="comment">//MARK: bad</span></span><br><span class="line"><span class="comment">// MARK:bad</span></span><br><span class="line"><span class="comment">//MARK:bad</span></span><br><span class="line"><span class="comment">//  MARK: bad</span></span><br><span class="line"><span class="comment">// MARK:  bad</span></span><br><span class="line"><span class="comment">// MARK: -bad</span></span><br></pre></td></tr></table></figure><h3 id="规则59-multiline-arguments"><a href="#规则59-multiline-arguments" class="headerlink" title="规则59: multiline_arguments"></a>规则59: multiline_arguments</h3><p>调用函数和方法时, 其参数应该在同一行上，或者每行一个</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>multiline_arguments</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不建议以下写法</span></span><br><span class="line">foo(<span class="number">0</span>, param1: <span class="number">1</span>, param2: <span class="literal">true</span>,</span><br><span class="line">    param3: [<span class="number">3</span>])</span><br><span class="line">    </span><br><span class="line">foo(</span><br><span class="line">    <span class="number">0</span>, param1: <span class="number">1</span>,</span><br><span class="line">    param2: <span class="literal">true</span>, param3: [<span class="number">3</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="规则60-multiline-parameters"><a href="#规则60-multiline-parameters" class="headerlink" title="规则60: multiline_parameters"></a>规则60: multiline_parameters</h3><p>声明函数和方法时, 其参数应该在同一行上，或者每行一个</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>multiline_parameters</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//不建议以下写法</span><br><span class="line">protocol Foo &#123;</span><br><span class="line">   func foo(param1: Int,</span><br><span class="line">             param2: Bool, param3: [String]) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol Foo &#123;</span><br><span class="line">   func foo(param1: Int, param2: Bool,</span><br><span class="line">             param3: [String]) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则61-multiple-closures-with-trailing-closure"><a href="#规则61-multiple-closures-with-trailing-closure" class="headerlink" title="规则61: multiple_closures_with_trailing_closure"></a>规则61: multiple_closures_with_trailing_closure</h3><p>当函数有多个闭包时, 不建议使用尾随闭包语法</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>multiple_closures_with_trailing_closure</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">foo.something(param1: &#123; $<span class="number">0</span> &#125;) &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIView</span>.animate(withDuration: <span class="number">1.0</span>, animations: &#123;</span><br><span class="line">    someView.alpha = <span class="number">0.0</span></span><br><span class="line">&#125;) &#123; _ <span class="keyword">in</span></span><br><span class="line">    someView.removeFromSuperview()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则62-nesting"><a href="#规则62-nesting" class="headerlink" title="规则62: nesting"></a>规则62: nesting</h3><p>嵌套。类型嵌套至多一级结构， 函数语句嵌套至多五级结构。</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>nesting</td><td>启用</td><td>no</td><td>metrics</td></tr></tbody></table><h3 id="规则63-nimble-operator"><a href="#规则63-nimble-operator" class="headerlink" title="规则63: nimble_operator"></a>规则63: nimble_operator</h3><p>快捷操作符。和自由匹配函数相比， 更喜欢快捷操作符， 比如：&gt;=、 ==、 &lt;=、 &lt;等等。</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>nimble_operator</td><td>未启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 会触发warning</span></span><br><span class="line">(person.voice).toNot(equal(<span class="string">"Hello world"</span>))     <span class="comment">// 判断字符串相同</span></span><br><span class="line"><span class="number">10.</span>to(beGreaterThan(<span class="number">5</span>))     <span class="comment">// 10比5大</span></span><br><span class="line"><span class="number">99.</span>to(beLessThan(<span class="number">100</span>))       <span class="comment">// 99比100小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为以下</span></span><br><span class="line">(person.voice) != <span class="string">"Hello world"</span>   <span class="comment">// 判断字符串相同</span></span><br><span class="line"><span class="number">10</span> &gt; <span class="number">5</span>                <span class="comment">// 10比5大</span></span><br><span class="line"><span class="number">99</span> &lt; <span class="number">100</span>              <span class="comment">// 99比100小</span></span><br></pre></td></tr></table></figure><h3 id="规则64-no-extension-access-modifier"><a href="#规则64-no-extension-access-modifier" class="headerlink" title="规则64: no_extension_access_modifier"></a>规则64: no_extension_access_modifier</h3><p>在extension扩展前面,不建议使用(fileprivate, public)等修饰符</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>no_extension_access_modifier</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line">private extension String &#123;&#125;</span><br><span class="line">public extension String &#123;&#125;</span><br><span class="line">open extension String &#123;&#125;</span><br><span class="line">internal extension String &#123;&#125;</span><br><span class="line">fileprivate extension String &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="规则65-no-grouping-extension"><a href="#规则65-no-grouping-extension" class="headerlink" title="规则65: no_grouping_extension"></a>规则65: no_grouping_extension</h3><p>只有class和protocol可以使用extension,其他类型不可使用</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>no_grouping_extension</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line"><span class="keyword">enum</span> Fruit &#123;&#125;</span><br><span class="line">extension Fruit &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension Tea: Error &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> Tea &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Ham &#123; <span class="keyword">class</span> Spam &#123;&#125;&#125;</span><br><span class="line">extension Ham.Spam &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension External &#123; <span class="keyword">struct</span> Gotcha &#123;&#125;&#125;</span><br><span class="line">extension External.Gotcha &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="规则66-notification-center-detachment"><a href="#规则66-notification-center-detachment" class="headerlink" title="规则66: notification_center_detachment"></a>规则66: notification_center_detachment</h3><p>对象移除通知只能在deinit移除self,函数中不能removeObserver(self)</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>notification_center_detachment</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123; </span><br><span class="line">   deinit &#123;</span><br><span class="line">       NotificationCenter.default.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123; </span><br><span class="line">   func bar() &#123;</span><br><span class="line">       NotificationCenter.default.removeObserver(otherObject)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123; </span><br><span class="line">   func bar() &#123;</span><br><span class="line">       NotificationCenter.default.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则67-number-separator"><a href="#规则67-number-separator" class="headerlink" title="规则67: number_separator"></a>规则67: number_separator</h3><p>数字分割线。当在大量的小数中， 应该使用下划线来作为千分位分割线</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>number_separator</td><td>未启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 推荐使用这种形式</span></span><br><span class="line">let xxx = <span class="number">1</span>_000_000_000<span class="number">.000</span>_1</span><br><span class="line">print(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 不推荐使用这种形式（在swift </span></span><br><span class="line">let xxx = <span class="number">1000000000.0001</span></span><br><span class="line">print(xxx)</span><br></pre></td></tr></table></figure><h3 id="规则68-object-literal"><a href="#规则68-object-literal" class="headerlink" title="规则68: object_literal"></a>规则68: object_literal</h3><p>swiftlint表示比起图片和颜色初始化，更喜欢对象初始化。因为swift初始化可以用表情，图片，颜色等，这不符合项目中的一些习惯用法</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>object_literal</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">let image = <span class="meta">#imageLiteral(resourceName: <span class="meta-string">"image.jpg"</span>)</span></span><br><span class="line">let color = <span class="meta">#colorLiteral(red: 0.9607843161, green: 0.7058823705, blue: 0.200000003, alpha: 1)</span></span><br><span class="line">let image = <span class="built_in">UIImage</span>(named: aVariable)</span><br><span class="line">let image = <span class="built_in">UIImage</span>(named: <span class="string">"interpolated \(variable)"</span>)</span><br><span class="line">let color = <span class="built_in">UIColor</span>(red: value, green: value, blue: value, alpha: <span class="number">1</span>)</span><br><span class="line">let image = <span class="built_in">NSImage</span>(named: aVariable)</span><br><span class="line">let image = <span class="built_in">NSImage</span>(named: <span class="string">"interpolated \(variable)"</span>)</span><br><span class="line">let color = <span class="built_in">NSColor</span>(red: value, green: value, blue: value, alpha: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">let image = ↓<span class="built_in">UIImage</span>(named: <span class="string">"foo"</span>)</span><br><span class="line">let color = ↓<span class="built_in">UIColor</span>(red: <span class="number">0.3</span>, green: <span class="number">0.3</span>, blue: <span class="number">0.3</span>, alpha: <span class="number">1</span>)</span><br><span class="line">let color = ↓<span class="built_in">UIColor</span>(red: <span class="number">100</span> / <span class="number">255.0</span>, green: <span class="number">50</span> / <span class="number">255.0</span>, blue: <span class="number">0</span>, alpha: <span class="number">1</span>)</span><br><span class="line">let color = ↓<span class="built_in">UIColor</span>(white: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="规则69-opening-brace"><a href="#规则69-opening-brace" class="headerlink" title="规则69: opening_brace"></a>规则69: opening_brace</h3><p>花括号之前应该有一个空格,且与声明在同一行</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>opening_brace</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">func abc() &#123;</span><br><span class="line">&#125;</span><br><span class="line">[].map() &#123; $<span class="number">0</span> &#125;</span><br><span class="line">[].map(&#123; &#125;)</span><br><span class="line"><span class="keyword">if</span> let a = b &#123; &#125;</span><br><span class="line"><span class="keyword">while</span> a == b &#123; &#125;</span><br><span class="line">guard let a = b <span class="keyword">else</span> &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="规则70-operator-usage-whitespace"><a href="#规则70-operator-usage-whitespace" class="headerlink" title="规则70: operator_usage_whitespace"></a>规则70: operator_usage_whitespace</h3><p>操作符使用规则， 操作符两边应该有空格。比如 “+” “-” “？？”</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>operator_usage_whitespace</td><td>未启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">let foo = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line">let foo = <span class="number">1</span> &gt; <span class="number">2</span></span><br><span class="line">let foo = !<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line">let foo = <span class="number">1</span>+<span class="number">2</span></span><br><span class="line">let foo = <span class="number">1</span>   + <span class="number">2</span></span><br><span class="line">let foo = <span class="number">1</span>   +    <span class="number">2</span></span><br><span class="line">let foo = <span class="number">1</span> +    <span class="number">2</span></span><br><span class="line">let foo=<span class="number">1</span>+<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="规则71-operator-whitespace"><a href="#规则71-operator-whitespace" class="headerlink" title="规则71: operator_whitespace"></a>规则71: operator_whitespace</h3><p>空格/空白操作符。当定义空格操作符的时候，被定义的名字或类型两边应该各有一个单行空格操作符</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>operator_whitespace</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发警告</span></span><br><span class="line"><span class="keyword">class</span> Something: Equatable &#123;</span><br><span class="line">    var text: String?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "=="和“(lhs: Something, rhs: Something)”之间应该有一个空格</span></span><br><span class="line">    <span class="keyword">static</span> func ==(lhs: Something, rhs: Something) -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.text == rhs.text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则72-overridden-super-call"><a href="#规则72-overridden-super-call" class="headerlink" title="规则72: overridden_super_call"></a>规则72: overridden_super_call</h3><p>一些重写的方法应该调用super.(父类的)方法</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>overridden_super_call</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 这样会触发警告</span></span><br><span class="line"> <span class="keyword">class</span> VCd: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">     override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">        <span class="comment">//没有调用父类</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/// 不会触发警告</span></span><br><span class="line">  <span class="keyword">class</span> VCd: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">     override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="规则73-override-in-extension"><a href="#规则73-override-in-extension" class="headerlink" title="规则73: override_in_extension"></a>规则73: override_in_extension</h3><p>在extension中,不能重写未声明的属性和未定义的方法</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>override_in_extension</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误写法</span></span><br><span class="line">extension Person &#123;</span><br><span class="line">  <span class="comment">//该属性之前未定义, 不能重写</span></span><br><span class="line">  override var age: Int &#123; <span class="keyword">return</span> <span class="number">42</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Person &#123;</span><br><span class="line">  <span class="comment">//该方法之前也为定义不能重写</span></span><br><span class="line">  override func celebrateBirthday() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则74-pattern-matching-keywords"><a href="#规则74-pattern-matching-keywords" class="headerlink" title="规则74: pattern_matching_keywords"></a>规则74: pattern_matching_keywords</h3><p>…<br>在switch-case语句中, 建议不要将case中的let和var等关键字放到元祖内</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>pattern_matching_keywords</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> let .foo(x, y): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .foo(let x), .bar(let x): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> (↓let x,  ↓let y): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .foo(↓let x, ↓let y): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> (.yamlParsing(↓let x), .yamlParsing(↓let y)): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> (↓var x,  ↓var y): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .foo(↓var x, ↓var y): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则76-prefixed-toplevel-constant"><a href="#规则76-prefixed-toplevel-constant" class="headerlink" title="规则76: prefixed_toplevel_constant"></a>规则76: prefixed_toplevel_constant</h3><p>类似全局常量,建议前缀以k开头</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>prefixed_toplevel_constant</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">private let kFoo = <span class="number">20.0</span></span><br><span class="line">public let kFoo = <span class="literal">false</span></span><br><span class="line">internal let kFoo = <span class="string">"Foo"</span></span><br><span class="line">let kFoo = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="规则77-private-action"><a href="#规则77-private-action" class="headerlink" title="规则77: private_action"></a>规则77: private_action</h3><p>IBActions修饰的方法,应该都是私有的</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>private_action</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">@IBAction private func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Foo &#123;</span><br><span class="line">@IBAction private func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">@IBAction fileprivate func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Foo &#123;</span><br><span class="line">@IBAction fileprivate func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">private extension Foo &#123;</span><br><span class="line">@IBAction func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">fileprivate extension Foo &#123;</span><br><span class="line">@IBAction func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则78-private-outlet"><a href="#规则78-private-outlet" class="headerlink" title="规则78: private_outlet"></a>规则78: private_outlet</h3><p>IBOutlets修饰的属性应该都是私有的</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>private_outlet</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  @IBOutlet private var label: <span class="built_in">UILabel</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  @IBOutlet private var label: <span class="built_in">UILabel</span>!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  @IBOutlet var label: <span class="built_in">UILabel</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  @IBOutlet var label: <span class="built_in">UILabel</span>!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则79-private-over-fileprivate"><a href="#规则79-private-over-fileprivate" class="headerlink" title="规则79: private_over_fileprivate"></a>规则79: private_over_fileprivate</h3><p>private比fileprivate的私有程度更高</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>private_over_fileprivate</td><td>启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><h3 id="规则80-private-unit-test"><a href="#规则80-private-unit-test" class="headerlink" title="规则80: private_unit_test"></a>规则80: private_unit_test</h3><p>私有的单元测试。被标记为private的单元测试不会被测试工具XCTest运行， 也就是说，被标记为private的单元测试会被静态跳过</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>private_unit_test</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private ↓<span class="keyword">class</span> FooTest: <span class="built_in">XCTestCase</span> &#123; ...............继承于测试用例类<span class="built_in">XCTestCase</span>, 被标记为private，所以触发warning</span><br><span class="line">     func test1() &#123;&#125;</span><br><span class="line">     internal func test2() &#123;&#125;</span><br><span class="line">     public func test3() &#123;&#125;</span><br><span class="line">     private func test4() &#123;&#125;.......另外注意这里，上面既然不会通过，那显然这里也不会通过，根本不会走这个func</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> internal <span class="keyword">class</span> FooTest: <span class="built_in">XCTestCase</span> &#123; ......开始通过测试，因为没有被标记为private</span><br><span class="line">     func test1() &#123;&#125;</span><br><span class="line">     internal func test2() &#123;&#125;</span><br><span class="line">     public func test3() &#123;&#125;</span><br><span class="line">     private ↓func test4() &#123;&#125;................不通过，因为被标记为private</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public <span class="keyword">class</span> FooTest: <span class="built_in">XCTestCase</span> &#123; ..........通过</span><br><span class="line">     func test1() &#123;&#125;</span><br><span class="line">     internal func test2() &#123;&#125;</span><br><span class="line">     public func test3() &#123;&#125;</span><br><span class="line">     private ↓func test4() &#123;&#125;.................不通过，因为被标记成private</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> FooTest: <span class="built_in">XCTestCase</span> &#123; ..........通过</span><br><span class="line">     func test1() &#123;&#125;</span><br><span class="line">     internal func test2() &#123;&#125;</span><br><span class="line">     public func test3() &#123;&#125;</span><br><span class="line">     private ↓func test4() &#123;&#125;.................不通过，因为被标记成private</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="规则81-prohibited-super-call"><a href="#规则81-prohibited-super-call" class="headerlink" title="规则81: prohibited_super_call"></a>规则81: prohibited_super_call</h3><p>一些方法不应该调用父类的方法</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>prohibited_super_call</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下方法不建议调用父类的方法</span></span><br><span class="line"><span class="keyword">class</span> VC: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">override func loadView() &#123;↓</span><br><span class="line"><span class="keyword">super</span>.loadView()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> VC: <span class="built_in">NSFileProviderExtension</span> &#123;</span><br><span class="line">override func providePlaceholder(at url: URL,completionHandler: @escaping (Error?) -&gt; Void) &#123;↓</span><br><span class="line"><span class="keyword">self</span>.method1()</span><br><span class="line"><span class="keyword">super</span>.providePlaceholder(at:url, completionHandler: completionHandler)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> VC: <span class="built_in">NSView</span> &#123;</span><br><span class="line">override func updateLayer() &#123;↓</span><br><span class="line"><span class="keyword">self</span>.method1()</span><br><span class="line"><span class="keyword">super</span>.updateLayer()</span><br><span class="line"><span class="keyword">self</span>.method2()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> VC: <span class="built_in">NSView</span> &#123;</span><br><span class="line">override func updateLayer() &#123;↓</span><br><span class="line">defer &#123;</span><br><span class="line"><span class="keyword">super</span>.updateLayer()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则82-protocol-property-accessors-order"><a href="#规则82-protocol-property-accessors-order" class="headerlink" title="规则82: protocol_property_accessors_order"></a>规则82: protocol_property_accessors_order</h3><p>在协议中声明属性时，访问者的顺序应该是get set</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>protocol_property_accessors_order</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议</span></span><br><span class="line">protocol Foo &#123;</span><br><span class="line">   var bar: String &#123; get set &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//不建议</span></span><br><span class="line">protocol Foo &#123;</span><br><span class="line">   var bar: String &#123; set get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则83-quick-discouraged-call"><a href="#规则83-quick-discouraged-call" class="headerlink" title="规则83: quick_discouraged_call"></a>规则83: quick_discouraged_call</h3><p>在单元测试中,不建议在describe和content比保重直接调用方法和类</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>quick_discouraged_call</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><h3 id="规则84-quick-discouraged-focused-test"><a href="#规则84-quick-discouraged-focused-test" class="headerlink" title="规则84: quick_discouraged_focused_test"></a>规则84: quick_discouraged_focused_test</h3><p>在单元测试中,不建议集中测试,否则可能不能运行成功</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>quick_discouraged_focused_test</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方示例, 不建议</span></span><br><span class="line"><span class="keyword">class</span> TotoTests: QuickSpec &#123;</span><br><span class="line">   override func spec() &#123;</span><br><span class="line">       ↓fdescribe(<span class="string">"foo"</span>) &#123; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则85-quick-discouraged-pending-test"><a href="#规则85-quick-discouraged-pending-test" class="headerlink" title="规则85: quick_discouraged_pending_test"></a>规则85: quick_discouraged_pending_test</h3><p>单元测试中阻止未进行的测试单元</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>quick_discouraged_pending_test</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><h3 id="规则86-redundant-discardable-let"><a href="#规则86-redundant-discardable-let" class="headerlink" title="规则86: redundant_discardable_let"></a>规则86: redundant_discardable_let</h3><p>不需要初始化方法返回结果时,建议使用: _ = Person(), 而不是:let _ = Person()</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>redundant_discardable_let</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line">_ = foo()</span><br><span class="line"><span class="keyword">if</span> let _ = foo() &#123; &#125;</span><br><span class="line">guard let _ = foo() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议</span></span><br><span class="line">let _ = foo()</span><br><span class="line"><span class="keyword">if</span> _ = foo() &#123; let _ = bar() &#125;</span><br></pre></td></tr></table></figure><h3 id="规则87-redundant-nil-coalescing"><a href="#规则87-redundant-nil-coalescing" class="headerlink" title="规则87: redundant_nil_coalescing"></a>规则87: redundant_nil_coalescing</h3><p>使用可能为为nil的可选值时,建议使用: str ?? “”, ??左右两侧要有一个空格</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>redundant_nil_coalescing</td><td>未启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">var myVar: Int?; myVar ?? <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">var myVar: Int? = <span class="literal">nil</span>; myVar  ?? <span class="literal">nil</span></span><br><span class="line">var myVar: Int? = <span class="literal">nil</span>; myVar??<span class="literal">nil</span></span><br></pre></td></tr></table></figure><h3 id="规则88-redundant-optional-initialization"><a href="#规则88-redundant-optional-initialization" class="headerlink" title="规则88: redundant_optional_initialization"></a>规则88: redundant_optional_initialization</h3><p>初始化nil变量是,不建议赋值nil</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>redundant_optional_initialization</td><td>启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">var myVar: Int?</span><br><span class="line">let myVar: Int? = <span class="literal">nil</span></span><br><span class="line">var myVar: Optional&lt;Int&gt;</span><br><span class="line">let myVar: Optional&lt;Int&gt; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">var myVar: Int?↓ = <span class="literal">nil</span></span><br><span class="line">var myVar: Optional&lt;Int&gt;↓ = <span class="literal">nil</span></span><br><span class="line">var myVar: Int?↓=<span class="literal">nil</span></span><br><span class="line">var myVar: Optional&lt;Int&gt;↓=<span class="literal">nil</span></span><br></pre></td></tr></table></figure><h3 id="规则89-redundant-string-enum-value"><a href="#规则89-redundant-string-enum-value" class="headerlink" title="规则89: redundant_string_enum_value"></a>规则89: redundant_string_enum_value</h3><p>在定义字符串枚举的时候, 当字符串枚举值等于枚举名称时，可以不用赋值</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>redundant_string_enum_value</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">enum</span> Numbers: String &#123;</span><br><span class="line"> <span class="keyword">case</span> one</span><br><span class="line"> <span class="keyword">case</span> two</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Numbers: Int &#123;</span><br><span class="line"> <span class="keyword">case</span> one = <span class="number">1</span></span><br><span class="line"> <span class="keyword">case</span> two = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line"><span class="keyword">enum</span> Numbers: String &#123;</span><br><span class="line"> <span class="keyword">case</span> one = ↓<span class="string">"one"</span></span><br><span class="line"> <span class="keyword">case</span> two = ↓<span class="string">"two"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Numbers: String &#123;</span><br><span class="line"> <span class="keyword">case</span> one = ↓<span class="string">"one"</span>, two = ↓<span class="string">"two"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则90-redundant-void-return"><a href="#规则90-redundant-void-return" class="headerlink" title="规则90: redundant_void_return"></a>规则90: redundant_void_return</h3><p>当函数返回值为Void时,建议不谢返回值, 定义常量或者变量的时候可以</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>redundant_void_return</td><td>启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">func foo() &#123;&#125;</span><br><span class="line">func foo() -&gt; Int &#123;&#125;</span><br><span class="line">func foo() -&gt; Int -&gt; Void &#123;&#125;</span><br><span class="line">func foo() -&gt; VoidResponse</span><br><span class="line">let foo: Int -&gt; Void</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">func foo()↓ -&gt; Void &#123;&#125;</span><br><span class="line">protocol Foo &#123;</span><br><span class="line"> func foo()↓ -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line">func foo()↓ -&gt; () &#123;&#125;</span><br><span class="line">protocol Foo &#123;</span><br><span class="line"> func foo()↓ -&gt; ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则91-required-enum-case"><a href="#规则91-required-enum-case" class="headerlink" title="规则91: required_enum_case"></a>规则91: required_enum_case</h3><p>定义的枚举,必须有与其对应的操作实现</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>required_enum_case</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><h3 id="规则92-return-arrow-whitespace"><a href="#规则92-return-arrow-whitespace" class="headerlink" title="规则92: return_arrow_whitespace"></a>规则92: return_arrow_whitespace</h3><p>swiftlint推荐返回箭头和返回类型应该被空格分开</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>return_arrow_whitespace</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">func abc() -&gt; Int &#123;&#125;</span><br><span class="line">func abc() -&gt; [Int] &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">func abc()↓-&gt;Int &#123;&#125;</span><br><span class="line">func abc()↓-&gt;[Int] &#123;&#125;</span><br><span class="line">func abc()↓-&gt;(Int, Int) &#123;&#125;</span><br><span class="line">func abc()↓-&gt; Int &#123;&#125;</span><br><span class="line">func abc()↓ -&gt;Int &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="规则93-shorthand-operator"><a href="#规则93-shorthand-operator" class="headerlink" title="规则93: shorthand_operator"></a>规则93: shorthand_operator</h3><p>在swiftlint中， 就是我们常用的简洁操作运算符，比如：+= ， -=， *=， /= 等等。在swiftlint中，在做一些赋值操作的时候，推荐使用简短操作符</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>shorthand_operator</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 不推荐使用</span></span><br><span class="line">var value = <span class="number">4</span></span><br><span class="line">value = value / <span class="number">2</span></span><br><span class="line">print(value)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 推荐使用</span></span><br><span class="line">var value = <span class="number">4</span></span><br><span class="line">value /= <span class="number">2</span></span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure><h3 id="规则94-single-test-class"><a href="#规则94-single-test-class" class="headerlink" title="规则94: single_test_class"></a>规则94: single_test_class</h3><p>单元测试中,测试文件应该包含一个QuickSpec或XCTestCase类</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>single_test_class</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><h3 id="规则95-sorted-first-last"><a href="#规则95-sorted-first-last" class="headerlink" title="规则95: sorted_first_last"></a>规则95: sorted_first_last</h3><p>在获取某数组中最大最小值时,建议使用min和max函数,而不是sorted().first和sorted().lase</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>sorted_first_last</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="规则96-aaa"><a href="#规则96-aaa" class="headerlink" title="规则96: aaa"></a>规则96: aaa</h3><p>…</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>aaa</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议</span></span><br><span class="line">let min = myList.min()</span><br><span class="line">let min = myList.min(by: &#123; $<span class="number">0</span> &lt; $<span class="number">1</span> &#125;)</span><br><span class="line">let min = myList.min(by: &gt;)</span><br><span class="line">let min = myList.max()</span><br><span class="line">let min = myList.max(by: &#123; $<span class="number">0</span> &lt; $<span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议</span></span><br><span class="line">myList.sorted().first</span><br><span class="line">myList.sorted(by: &#123; $<span class="number">0.</span>description &lt; $<span class="number">1.</span>description &#125;).first</span><br><span class="line">myList.sorted(by: &gt;).first</span><br><span class="line">myList.map &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;.sorted().first</span><br><span class="line">myList.sorted(by: someFunction).first</span><br></pre></td></tr></table></figure><h3 id="规则97-sorted-imports"><a href="#规则97-sorted-imports" class="headerlink" title="规则97: sorted_imports"></a>规则97: sorted_imports</h3><p>分类/有序导入。 这个属性有些奇怪， 要求导入的时候导入的类要按顺序导入</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>sorted_imports</td><td>未启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">import AAA</span><br><span class="line">import BBB</span><br><span class="line">import CCC</span><br><span class="line">import DDD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import Alamofire</span><br><span class="line">import API</span><br></pre></td></tr></table></figure><h3 id="规则98-statement-position"><a href="#规则98-statement-position" class="headerlink" title="规则98: statement_position"></a>规则98: statement_position</h3><p>陈述句位置， 这里主要指的是 else 和 catch 前面要加一个空格， 也不能大于1个空格， 否则就会触发警告</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>statement_position</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 没有空格，触发warning</span></span><br><span class="line">let number = <span class="string">"long"</span></span><br><span class="line"><span class="keyword">if</span> number.isEmpty &#123;</span><br><span class="line">    print(<span class="string">"为空"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;.............................注意这里</span><br><span class="line">    print(<span class="string">"不为空"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这里也会触发warning， 因为else if换行了</span></span><br><span class="line">let number = <span class="string">"long"</span></span><br><span class="line"><span class="keyword">if</span> number.isEmpty &#123;</span><br><span class="line">    print(<span class="string">"为空"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> number.contains(<span class="string">"long"</span>) &#123;............................注意这里</span><br><span class="line">    print(<span class="string">"不为空"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"s"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 正确的写法</span></span><br><span class="line">let number = <span class="string">"long"</span></span><br><span class="line"><span class="keyword">if</span> number.isEmpty &#123;</span><br><span class="line">    print(<span class="string">"为空"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"不为空"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则99-strict-fileprivate"><a href="#规则99-strict-fileprivate" class="headerlink" title="规则99: strict_fileprivate"></a>规则99: strict_fileprivate</h3><p>extension中不建议使用fileprivate 修饰方法和属性</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>strict_fileprivate</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><h3 id="规则100-superfluous-disable-command"><a href="#规则100-superfluous-disable-command" class="headerlink" title="规则100: superfluous_disable_command"></a>规则100: superfluous_disable_command</h3><p>被禁用的规则不会在禁用区域触发警告</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>superfluous_disable_command</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><blockquote><p>文中如有不足之处请多指教</p></blockquote><blockquote><p>持续更新中…..</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> SwiftLint </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于GitHub和Hexo搭建个人博客</title>
      <link href="/2018/03/08/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<p>本文是使用Mac电脑, 基于GitHub和Hexo搭建个人博客, 搞了两三天, 反复尝试了无数次, 踩了无数坑搭建起来的, 主要跟大家分享一点小经验, 希望对大家能有帮助!</p><a id="more"></a><h2 id="一-github博客简介"><a href="#一-github博客简介" class="headerlink" title="一. github博客简介"></a>一. github博客简介</h2><p>github 是全球最大的社交编程及代码托管网站，GitHub可以托管各种git库，并提供一个web界面，但与其它像SourceForge或Google Code这样的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。这里着重写如何使用Github的page功能搭建个人博客!</p><blockquote><p>使用github pages服务搭建博客的好处有：</p></blockquote><ul><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li></ul><h2 id="二-准备工作"><a href="#二-准备工作" class="headerlink" title="二. 准备工作"></a>二. 准备工作</h2><ul><li>有一个<a href="https://github.com/login?return_to=%2Fjoin%3Fsource%3Dheader-home" target="_blank" rel="noopener">github账号</a>，没有的话去<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">GitHub注册</a>一个</li><li>安装了<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>、npm，并了解相关基础知识</li><li>安装了git </li></ul><h2 id="三-环境搭建"><a href="#三-环境搭建" class="headerlink" title="三. 环境搭建"></a>三. 环境搭建</h2><h3 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1. 安装Node.js"></a>1. 安装Node.js</h3><ul><li>用来生成静态页面, 到<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a>，下载最新版本, 根据提示一路安装即可</li><li><code>Node.js</code>默认会安装 npm</li><li>也可以使用<code>Homebrew</code>进行命令安装, 详情参考<a href="https://reactnative.cn/docs/0.51/getting-started.html#content" target="_blank" rel="noopener">React Native中文网</a>安装方法</li></ul><h3 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h3><ul><li>用来将本地Hexo内容提交到Github上。下载的Xcode自带Git，这里不再赘述。</li><li>如果没有Xcode可以参考<a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo官网</a>上的安装方法</li><li>通用版的<a href="https://www.git-scm.com/download/win" target="_blank" rel="noopener">Git安装</a>, 无法下载的童鞋，可以去网上搜索下载</li></ul><h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h3><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure><p>此时, 会提示你输入管理员密码(电脑密码), 开始安装</p><h2 id="四-本地搭建-hexo-静态博客"><a href="#四-本地搭建-hexo-静态博客" class="headerlink" title="四. 本地搭建 hexo 静态博客"></a>四. 本地搭建 hexo 静态博客</h2><ul><li>在电脑中新建一个文件夹, 文件夹名字随意, 如MyBlog</li><li>在终端, cd 进入该文件夹</li><li>终端运行 git, 生成hexo模板，可能要翻墙</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p> 安装完模板, 安装npm</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>最后, 开启hexo服务器</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时，浏览器中打开网址<a href="http://localhost:4000，能看到如下页面：" target="_blank" rel="noopener">http://localhost:4000，能看到如下页面：</a></p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-dfe49f13bcfd743d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Snip20180303_1.png"></p><h2 id="五-将博客与Github关联"><a href="#五-将博客与Github关联" class="headerlink" title="五. 将博客与Github关联"></a>五. 将博客与Github关联</h2><h3 id="1-在GitHub上配置SSH-key"><a href="#1-在GitHub上配置SSH-key" class="headerlink" title="1. 在GitHub上配置SSH key"></a>1. 在GitHub上配置SSH key</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><h4 id="1-1首先检查本机是否存在的ssh密钥"><a href="#1-1首先检查本机是否存在的ssh密钥" class="headerlink" title="1.1首先检查本机是否存在的ssh密钥"></a>1.1首先检查本机是否存在的ssh密钥</h4><ul><li>如果存在, 直接进行步骤1.3, 否则执行步骤1.2生成新的密钥</li><li>打开终端输入, 注意<code>~/.ssh</code>之间没有空格</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git, 或者之前没有安装过SSh密钥</p><h4 id="1-2-生成新的ssh-key"><a href="#1-2-生成新的ssh-key" class="headerlink" title="1.2. 生成新的ssh key"></a>1.2. 生成新的ssh key</h4><p>注意后面添加自己注册GitHub的邮箱地址, 打开终端输入</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"邮件地址"</span></span><br></pre></td></tr></table></figure><ul><li>输入命令后, 然后连续回车, 默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件</li><li>打开’访达’, 选择进入文件夹(快捷键Command+Shift+G), 输入~/.ssh, 进入该文件夹</li></ul><h4 id="1-3-将ssh-key添加到Github中"><a href="#1-3-将ssh-key添加到Github中" class="headerlink" title="1.3. 将ssh key添加到Github中"></a>1.3. 将ssh key添加到Github中</h4><p>打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><p>将刚复制的内容粘贴到key那里，title随便填，保存</p><h4 id="1-4-测试SSH配置是否成功"><a href="#1-4-测试SSH配置是否成功" class="headerlink" title="1.4. 测试SSH配置是否成功"></a>1.4. 测试SSH配置是否成功</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入<code>yes</code>，然后会看到：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi XXXX! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>看到这个信息说明SSH已配置成功！</p><h4 id="1-5-更改GitHub用户名和邮箱"><a href="#1-5-更改GitHub用户名和邮箱" class="headerlink" title="1.5. 更改GitHub用户名和邮箱"></a>1.5. 更改GitHub用户名和邮箱</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name XXXX<span class="comment">// 你的github用户名，非昵称</span></span><br><span class="line">$ git config --global user.email  <span class="string">"xxx@qq.com"</span><span class="comment">// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure><h3 id="2-关联Github"><a href="#2-关联Github" class="headerlink" title="2. 关联Github"></a>2. 关联Github</h3><h4 id="2-1-新建XXX-github-io-的项目"><a href="#2-1-新建XXX-github-io-的项目" class="headerlink" title="2.1 新建XXX.github.io 的项目"></a>2.1 新建XXX.github.io 的项目</h4><p> 在 Github 上创建名字为 XXX.github.io 的项目，XXX为必须和自己的 github 用户名一模一样</p><h4 id="2-2-修改-config-yml文件配置"><a href="#2-2-修改-config-yml文件配置" class="headerlink" title="2.2 修改_config.yml文件配置"></a>2.2 修改<code>_config.yml</code>文件配置</h4><ul><li>打开本地的 MyBlog 文件夹项目内的_config.yml 配置文件</li><li>将其中的 type 设置为git，repository 是你 github.io 仓库的 git 地址, 如下所示</li><li>此处切记, 每一个毛好的后面都要加一个空格, 垂直方向一定要对齐, 否则可能会报错</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:<span class="comment">//github.com/CoderTitan/CoderTitan.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="2-3-将配置文件上传GitHub"><a href="#2-3-将配置文件上传GitHub" class="headerlink" title="2.3 将配置文件上传GitHub"></a>2.3 将配置文件上传GitHub</h4><ul><li>打开终端, cd到MyBlog文件夹下, 以下命令均在MyBlog文件夹下执行</li></ul><p>在blog文件夹目录下执行生成静态页面命令：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate     或者：hexo g</span><br></pre></td></tr></table></figure><p>此时若出现如下报错：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found <span class="keyword">in</span> ~/blog</span><br><span class="line">ERROR Try runing: 'npm install hexo --save'</span><br></pre></td></tr></table></figure><p>则执行命令：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>再执行配置命令：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy           或者：hexo d</span><br></pre></td></tr></table></figure><p>报错一: 若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>报错二: 若执行命令hexo d报以下错误:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR Plugin load failed: hexo-server</span><br><span class="line"><span class="comment">//或者类似的错误</span></span><br><span class="line">ERROR Plugin load failed: hexo-renderer-sass</span><br></pre></td></tr></table></figure><p>则执行响应的命令:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-server</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">sudo npm install hexo-renderer-sass</span><br></pre></td></tr></table></figure><p>解决玩错误之后, 最后在执行<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><blockquote><p>几个注意的地方：</p><ol><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的用户名；</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；</li><li>hexo d命令执行成功后，浏览器中打开网址<code>http://XXX.github.io</code>（将XXX换成你的用户名）能看到和打开http:<code>//localhost:4000</code>时一样的页面</li></ol></blockquote><h2 id="六-安装theme主题"><a href="#六-安装theme主题" class="headerlink" title="六. 安装theme主题"></a>六. 安装theme主题</h2><ul><li>搭建好的默认的主题真的是很丑, 所以这里我们先替换一个好看的主题, 大家更可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题</a>去选择自己喜欢的主题样式</li><li>示例主题: <a href="hexo-theme-random">Random</a></li></ul><p>终端cd到 MyBlog 目录下执行如下命令：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/stiekel/hexo-theme-random.git themes/random</span></span><br></pre></td></tr></table></figure><p>修改_config.yml中的theme: landscape改为theme: random，然后重新执行hexo g来重新生成</p><p>终端cd到MyBlog目录下执行如下命令(每次部署文章的步骤)：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean           <span class="comment">//清除缓存文件 (db.json) 和已生成的静态文件 (public)</span></span><br><span class="line"></span><br><span class="line">hexo g             <span class="comment">//生成缓存和静态文件</span></span><br><span class="line"> </span><br><span class="line">hexo d             <span class="comment">//重新部署到服务器</span></span><br></pre></td></tr></table></figure><h2 id="七-域名绑定"><a href="#七-域名绑定" class="headerlink" title="七. 域名绑定"></a>七. 域名绑定</h2><ul><li>现在使用的域名是Github提供的二级域名<code>XXX.github.io</code>，也可以绑定为自己的个性域名。</li><li>购买域名，可以到<a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">GoDaddy官网</a>，现在 <code>GoDaddy</code>已经有中文版了，虽然国家显示是新加坡，但不影响使用, 还可使用支付宝支付</li><li>也可以到<a href="https://wanwang.aliyun.com/?utm_content=se_1010380" target="_blank" rel="noopener">阿里万网</a>购买, 我是在万网买的，可直接在其网站做域名解析</li></ul><h3 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1. 域名解析"></a>1. 域名解析</h3><p>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析, 如下图</p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-952aa0a8a84a089f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20180303_4.png"></p><p>进入解析页面后点击添加解析, 向你的 DNS 配置中添加 3 条记录, 如下图<br>注意CNAME记录添加的是username.github.io.(不要忘记后面的.), 可能最后一个点不显示(我的就不显示)</p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-b2435667d603f844.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20180303_5.png"></p><h3 id="2-设置GitHub配置信息"><a href="#2-设置GitHub配置信息" class="headerlink" title="2. 设置GitHub配置信息"></a>2. 设置GitHub配置信息</h3><ul><li>打开你的XXX.github.io项目地址, 找到设置页面</li><li>滚动到下方找到<code>GitHub Pages</code>模块, 在<code>Custom domain</code>, 输入你购买的域名, 点击Save保存</li></ul><h3 id="3-创建CNAME文件"><a href="#3-创建CNAME文件" class="headerlink" title="3. 创建CNAME文件"></a>3. 创建CNAME文件</h3><ul><li>在/MyBlog/themes/landscape/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名写入</li><li><code>CNAME</code>一定要大写</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在终端cd到该目录下, 然后输入命令, 即可创建该文件</span></span><br><span class="line">touch <span class="built_in">CNAME</span></span><br></pre></td></tr></table></figure><ul><li>完成上述步骤后, 终端cd到MyBlog目录下执行如下命令重新部署：</li><li>最后, 等十分钟左右，刷新浏览器，用你自己域名访问下试试</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line"></span><br><span class="line">$ hexo g</span><br><span class="line"></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><blockquote><h4 id="至此也算终于大功告成了-感受一下-https-www-titanjun-top"><a href="#至此也算终于大功告成了-感受一下-https-www-titanjun-top" class="headerlink" title="至此也算终于大功告成了, 感受一下: https://www.titanjun.top"></a>至此也算终于大功告成了, 感受一下: <a href="https://www.titanjun.top" target="_blank" rel="noopener">https://www.titanjun.top</a></h4></blockquote>]]></content>
      
      <categories>
          
          <category> 入坑指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SwiftLint代码规范属性说明(一)</title>
      <link href="/2018/03/03/SwiftLint%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E(%E4%B8%80)/"/>
      <content type="html"><![CDATA[<blockquote><p>下面来具体介绍一下SwiftLint的具体的代码规则的相关说明</p><ul><li><a href="https://github.com/github/swift-style-guide" target="_blank" rel="noopener">Github 公布的 Swift 代码规范–原文</a></li><li><a href="https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md" target="_blank" rel="noopener">Github 公布的 Swift 代码规范–中文</a></li><li><a href="https://github.com/realm/SwiftLint/blob/master/Rules.md" target="_blank" rel="noopener">官方的SwiftLint规则说明</a></li></ul></blockquote><a id="more"></a><h2 id="以下个属性均按照字母顺序排列"><a href="#以下个属性均按照字母顺序排列" class="headerlink" title="以下个属性均按照字母顺序排列"></a>以下个属性均按照字母顺序排列</h2><h3 id="规则1-closing-brace"><a href="#规则1-closing-brace" class="headerlink" title="规则1: closing_brace"></a>规则1: closing_brace</h3><p>在使用Swift 3.2或更高版本时，首选系统的KVO 的API和keypath</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>block_based_kvo</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>官方示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译通过</span></span><br><span class="line">let observer = foo.observe(\.value, options: [.new]) &#123; (foo, change) <span class="keyword">in</span></span><br><span class="line">   print(change.newValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发警告</span></span><br><span class="line"><span class="keyword">class</span> Foo: <span class="built_in">NSObject</span> &#123;</span><br><span class="line">   override func observeValue(forKeyPath keyPath: String?, of object: Any?,</span><br><span class="line">                               change: [<span class="built_in">NSKeyValueChangeKey</span> : Any]?,</span><br><span class="line">                               context: UnsafeMutableRawPointer?) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则2-class-delegate-protocol"><a href="#规则2-class-delegate-protocol" class="headerlink" title="规则2: class_delegate_protocol"></a>规则2: class_delegate_protocol</h3><p>委托协议应该只是class类，可以被弱引用(官方解释,先放出官方示例吧)</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>class_delegate_protocol</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><p>示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">protocol FooDelegate: <span class="keyword">class</span> &#123;&#125;</span><br><span class="line">protocol FooDelegate: <span class="keyword">class</span>, BarDelegate &#123;&#125;</span><br><span class="line">protocol Foo &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> FooDelegate &#123;&#125;</span><br><span class="line">@objc protocol FooDelegate &#123;&#125;</span><br><span class="line">@objc(MyFooDelegate)</span><br><span class="line">protocol FooDelegate &#123;&#125;</span><br><span class="line">protocol FooDelegate: BarDelegate &#123;&#125;</span><br><span class="line">protocol FooDelegate: AnyObject &#123;&#125;</span><br><span class="line">protocol FooDelegate: <span class="built_in">NSObjectProtocol</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">protocol FooDelegate &#123;&#125;</span><br><span class="line">protocol FooDelegate: Bar &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="规则3-closing-brace"><a href="#规则3-closing-brace" class="headerlink" title="规则3: closing_brace"></a>规则3: closing_brace</h3><p>类似小括号包含大括号的不能用空格</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>closing_brace</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>具体示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(&#123; $<span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(</span><br><span class="line">  &#123; $<span class="number">0</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(&#123; $<span class="number">0</span> &#125; )</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(&#123; $<span class="number">0</span> &#125;   )</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map( &#123; $<span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="规则4-closure-end-indentation"><a href="#规则4-closure-end-indentation" class="headerlink" title="规则4: closure_end_indentation"></a>规则4: closure_end_indentation</h3><p>闭包的封闭端和开始端有相同的缩进, 意思就是 大括号（一般是方法）上下对齐的问题，这样使code看起来更加整洁</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>closure_end_indentation</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>具体示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发closure_end_indentation</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">//不会触发closure_end_indentation</span></span><br><span class="line">SignalProducer(values: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">   .startWithNext &#123; number <span class="keyword">in</span></span><br><span class="line">       print(number)</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//不会触发closure_end_indentation</span></span><br><span class="line">function &#123;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发closure_end_indentation</span></span><br><span class="line">SignalProducer(values: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">   .startWithNext &#123; number <span class="keyword">in</span></span><br><span class="line">       print(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不会触发closure_end_indentation</span></span><br><span class="line">function &#123;</span><br><span class="line">    ..........</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="规则5-closure-parameter-position"><a href="#规则5-closure-parameter-position" class="headerlink" title="规则5: closure_parameter_position"></a>规则5: closure_parameter_position</h3><p>闭包参数位置， 闭包参数应该和大括号左边在同一行, 推荐使用</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>closure_parameter_position</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><p>具体示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// number 和 &#123; 在同一行, 不会触发warning</span></span><br><span class="line">let names = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">names.forEach &#123; (number) <span class="keyword">in</span></span><br><span class="line">    print(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let names = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">names.map &#123; number <span class="keyword">in</span></span><br><span class="line">    number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这样不行，违背 closure_parameter_position规则, 触发warning</span></span><br><span class="line">let names = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">names.forEach &#123; </span><br><span class="line">    (number) <span class="keyword">in</span></span><br><span class="line">    print(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> let names = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> names.map &#123;</span><br><span class="line">     number <span class="keyword">in</span></span><br><span class="line">     number + <span class="number">1</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="规则6-closure-spacing"><a href="#规则6-closure-spacing" class="headerlink" title="规则6: closure_spacing"></a>规则6: closure_spacing</h3><p>在闭包的{}中间要有一个空格,如map({ $0 })</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>closure_spacing</td><td>未启用</td><td>yes</td><td>style</td></tr></tbody></table><p>以下示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">不会触发警告</span><br><span class="line">map(&#123; $<span class="number">0</span> &#125;)</span><br><span class="line">[].map (&#123; $<span class="number">0.</span>description &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发警告</span></span><br><span class="line">map(&#123;$<span class="number">0</span> &#125;)</span><br><span class="line">map(&#123; $<span class="number">0</span>&#125;)</span><br><span class="line">map(&#123;$<span class="number">0</span>&#125;)</span><br><span class="line">[].map (&#123;$<span class="number">0.</span>description     &#125;)</span><br></pre></td></tr></table></figure><h3 id="规则7-colon"><a href="#规则7-colon" class="headerlink" title="规则7: colon"></a>规则7: colon</h3><p>冒号的使用， swiftlint的这个colon属性规则很简单，要求“ ：”紧靠所定义的常量或变量等，必须没有空格，与所指定的类型之间必须只有一个空格，多一个或少一个都不行，如果是用在Dictionary中，则要求紧靠Key，与Value之间必须有且仅有一个空格。这个规则我觉得应该强制推荐使用</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>colon</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>具体示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发警告</span></span><br><span class="line">let abc: String = <span class="string">"jun"</span></span><br><span class="line">let abc = [<span class="number">1</span>: [<span class="number">3</span>: <span class="number">2</span>], <span class="number">3</span>: <span class="number">4</span>]</span><br><span class="line">let abc = [<span class="number">1</span>: [<span class="number">3</span>: <span class="number">2</span>], <span class="number">3</span>: <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发警告</span></span><br><span class="line">let jun:Void</span><br><span class="line">let jun : Void</span><br><span class="line">let jun :Void</span><br><span class="line">let jun:   Void</span><br></pre></td></tr></table></figure><h3 id="规则8-comma"><a href="#规则8-comma" class="headerlink" title="规则8: comma"></a>规则8: comma</h3><p>逗号使用只要遵循“前不离身后退一步”就行了，这个也强制推荐使用</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>comma</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>具体示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不触发警告</span></span><br><span class="line">[a, b, c, d]</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发警告</span></span><br><span class="line">[a ,b]</span><br></pre></td></tr></table></figure><h3 id="规则9-compiler-protocol-init"><a href="#规则9-compiler-protocol-init" class="headerlink" title="规则9: compiler_protocol_init"></a>规则9: compiler_protocol_init</h3><p>编译器协议初始化, 不建议.init等初始化方式, 建议使用简单的初始化形式</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>compiler_protocol_init</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><p>官方示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> let description = RuleDescription(</span><br><span class="line">    identifier: <span class="string">"compiler_protocol_init"</span>,</span><br><span class="line">    name: <span class="string">"Compiler Protocol Init"</span>,</span><br><span class="line">    description: <span class="string">"The initializers declared in compiler protocols such as `ExpressibleByArrayLiteral` "</span> +</span><br><span class="line">                 <span class="string">"shouldn't be called directly."</span>,</span><br><span class="line">    kind: .lint,</span><br><span class="line">    nonTriggeringExamples: [</span><br><span class="line">        <span class="string">"let set: Set&lt;Int&gt; = [1, 2]\n"</span>,</span><br><span class="line">        <span class="string">"let set = Set(array)\n"</span></span><br><span class="line">    ],</span><br><span class="line">    triggeringExamples: [</span><br><span class="line">        <span class="string">"let set = ↓Set(arrayLiteral: 1, 2)\n"</span>,</span><br><span class="line">        <span class="string">"let set = ↓Set.init(arrayLiteral: 1, 2)\n"</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="规则10-conditional-returns-on-newline"><a href="#规则10-conditional-returns-on-newline" class="headerlink" title="规则10: conditional_returns_on_newline"></a>规则10: conditional_returns_on_newline</h3><p>条件语句不能写在同一行, 条件返回语句应该在新的一行。 当有条件返回的时候应该换行返回，而不是在同一行</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>conditional_returns_on_newline</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>具体示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// swiftlint 不推荐的写法, 否则会触发warning</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">guard <span class="literal">true</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// swiftlint 推荐的写法</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard <span class="literal">true</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则11-contains-over-first-not-nil"><a href="#规则11-contains-over-first-not-nil" class="headerlink" title="规则11: contains_over_first_not_nil"></a>规则11: contains_over_first_not_nil</h3><p>类似first函数不能判断是否为nil</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>contains_over_first_not_nil</td><td>未启用</td><td>no</td><td>performance</td></tr></tbody></table><p>具体示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">let first = myList.first(where: &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;)</span><br><span class="line">let first = myList.first &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line">myList.first &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125; != <span class="literal">nil</span></span><br><span class="line">myList.first(where: &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;) != <span class="literal">nil</span></span><br></pre></td></tr></table></figure><h3 id="规则12-control-statement"><a href="#规则12-control-statement" class="headerlink" title="规则12: control_statement"></a>规则12: control_statement</h3><p>控制语句, for，while，do，catch语句中的条件不能包含在()中</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>control_statement</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><p>具体示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line"><span class="keyword">if</span> (a, b) == (<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">if</span>(condition) &#123;</span><br><span class="line"><span class="keyword">if</span> ((a || b) &amp;&amp; (c || d)) &#123;</span><br></pre></td></tr></table></figure><h3 id="规则13-custom-rules"><a href="#规则13-custom-rules" class="headerlink" title="规则13: custom_rules"></a>规则13: custom_rules</h3><p>自定义规则。 这个属性可以通过提供正则表达式来创建自定义规则， 可选指定语法类型搭配， 安全、级别和要陈列的什么信息。 这个属性只要熟悉使用正则表达式的人使用，目前可以不适用</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>custom_rules</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><h3 id="规则14-cyclomatic-complexity"><a href="#规则14-cyclomatic-complexity" class="headerlink" title="规则14: cyclomatic_complexity"></a>规则14: cyclomatic_complexity</h3><p>循环复杂度。函数体的复杂度应该要限制，这个属性主要约束条件句、循环句中的循环嵌套问题， 当嵌套太多的循环时，则会触发swiftlint中的warning和error，当达到10个循环嵌套时就会报warning，达到20个循环嵌套时就会报error</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>cyclomatic_complexity</td><td>启用</td><td>no</td><td>metrics</td></tr></tbody></table><h3 id="规则15-discarded-notification-center-observer"><a href="#规则15-discarded-notification-center-observer" class="headerlink" title="规则15: discarded_notification_center_observer"></a>规则15: discarded_notification_center_observer</h3><p>当使用注册的通知时, 应该存储返回的观察者, 便于用完之后移除通知</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>discarded_notification_center_observer</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">let foo = nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">let foo = nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>, using: &#123; &#125;)</span><br><span class="line"></span><br><span class="line">func foo() -&gt; Any &#123;</span><br><span class="line">   <span class="keyword">return</span> nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>, using: &#123; &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line">nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>, using: &#123; &#125;)</span><br><span class="line"></span><br><span class="line">@discardableResult func foo() -&gt; Any &#123;</span><br><span class="line">   <span class="keyword">return</span> nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>, using: &#123; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则16-discouraged-direct-init"><a href="#规则16-discouraged-direct-init" class="headerlink" title="规则16: discouraged_direct_init"></a>规则16: discouraged_direct_init</h3><p>阻止直接初始化导致的错误类型, 有类方法的,用类方法初始化(不建议直接init初始化)</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>discouraged_direct_init</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">let foo = <span class="built_in">UIDevice</span>.current</span><br><span class="line">let foo = Bundle.main</span><br><span class="line">let foo = Bundle(path: <span class="string">"bar"</span>)</span><br><span class="line">let foo = Bundle(identifier: <span class="string">"bar"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">let foo = <span class="built_in">UIDevice</span>()</span><br><span class="line">let foo = Bundle()</span><br><span class="line">let foo = bar(bundle: Bundle(), device: <span class="built_in">UIDevice</span>())</span><br></pre></td></tr></table></figure><h3 id="规则17-discouraged-optional-boolean"><a href="#规则17-discouraged-optional-boolean" class="headerlink" title="规则17: discouraged_optional_boolean"></a>规则17: discouraged_optional_boolean</h3><p>不建议使用可选布尔值</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>discouraged_optional_boolean</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">var foo: Bool</span><br><span class="line">var foo: [String: Bool]</span><br><span class="line">var foo: [Bool]</span><br><span class="line">let foo: Bool = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">var foo: Bool?</span><br><span class="line">var foo: [String: Bool?]</span><br><span class="line">var foo: [Bool?]</span><br><span class="line">let foo: Bool? = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><h3 id="规则18-discouraged-object-literal"><a href="#规则18-discouraged-object-literal" class="headerlink" title="规则18: discouraged_object_literal"></a>规则18: discouraged_object_literal</h3><p>优先使用对象初始化方法, 不建议使用代码块初始化</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>discouraged_object_literal</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">let white = <span class="meta">#colorLiteral(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)</span></span><br><span class="line">let image = ↓<span class="meta">#imageLiteral(resourceName: <span class="meta-string">"image.jpg"</span>)</span></span><br></pre></td></tr></table></figure><h3 id="规则19-dynamic-inline"><a href="#规则19-dynamic-inline" class="headerlink" title="规则19: dynamic_inline"></a>规则19: dynamic_inline</h3><p>避免一起使用 dynamic 和 @inline(_ _always)， 否则报 error</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>dynamic_inline</td><td>启用</td><td>no</td><td>lint</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 正确的做法</span></span><br><span class="line"><span class="keyword">class</span> LangKe &#123;</span><br><span class="line">    dynamic func myFunction() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LangKe &#123;</span><br><span class="line">    @inline(__always) func myFunction() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LangKe &#123;</span><br><span class="line">    @inline(never) dynamic func myFunction() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 只要同时使用 dynamic 和 @inline(_ _always)都报错 error！！！</span></span><br><span class="line"><span class="keyword">class</span> LangKe &#123;</span><br><span class="line">    @inline(__always) public dynamic func myFunction() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则20-array-init"><a href="#规则20-array-init" class="headerlink" title="规则20: array_init"></a>规则20: array_init</h3><p>序列转化成数组时, 优先使用数组转化, 而不是seq.map {$ 0}将序列转换为数组</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>array_init</td><td>未启用</td><td>no</td><td>lint</td></tr></tbody></table><p>官方示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> let description = RuleDescription(</span><br><span class="line">    identifier: <span class="string">"array_init"</span>,</span><br><span class="line">    name: <span class="string">"Array Init"</span>,</span><br><span class="line">    description: <span class="string">"Prefer using Array(seq) than seq.map &#123; $0 &#125; to convert a sequence into an Array."</span>,</span><br><span class="line">    kind: .lint,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下示例不会触发警告</span></span><br><span class="line">    nonTriggeringExamples: [</span><br><span class="line">        <span class="string">"Array(foo)\n"</span>,</span><br><span class="line">        <span class="string">"foo.map &#123; $0.0 &#125;\n"</span>,</span><br><span class="line">        <span class="string">"foo.map &#123; $1 &#125;\n"</span>,</span><br><span class="line">        <span class="string">"foo.map &#123; $0() &#125;\n"</span>,</span><br><span class="line">        <span class="string">"foo.map &#123; ((), $0) &#125;\n"</span>,</span><br><span class="line">        <span class="string">"foo.map &#123; $0! &#125;\n"</span>,</span><br><span class="line">        <span class="string">"foo.map &#123; $0! /* force unwrap */ &#125;\n"</span>,</span><br><span class="line">        <span class="string">"foo.something &#123; RouteMapper.map($0) &#125;\n"</span></span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下示例会触发警告</span></span><br><span class="line">    triggeringExamples: [</span><br><span class="line">        <span class="string">"↓foo.map(&#123; $0 &#125;)\n"</span>,</span><br><span class="line">        <span class="string">"↓foo.map &#123; $0 &#125;\n"</span>,</span><br><span class="line">        <span class="string">"↓foo.map &#123; return $0 &#125;\n"</span>,</span><br><span class="line">        <span class="string">"↓foo.map &#123; elem in\n"</span> +</span><br><span class="line">        <span class="string">"   elem\n"</span> +</span><br><span class="line">        <span class="string">"&#125;\n"</span>,</span><br><span class="line">        <span class="string">"↓foo.map &#123; elem in\n"</span> +</span><br><span class="line">        <span class="string">"   return elem\n"</span> +</span><br><span class="line">        <span class="string">"&#125;\n"</span>,</span><br><span class="line">        <span class="string">"↓foo.map &#123; (elem: String) in\n"</span> +</span><br><span class="line">            <span class="string">"   elem\n"</span> +</span><br><span class="line">        <span class="string">"&#125;\n"</span>,</span><br><span class="line">        <span class="string">"↓foo.map &#123; elem -&gt; String in\n"</span> +</span><br><span class="line">        <span class="string">"   elem\n"</span> +</span><br><span class="line">        <span class="string">"&#125;\n"</span>,</span><br><span class="line">        <span class="string">"↓foo.map &#123; $0 /* a comment */ &#125;\n"</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="规则21-empty-count"><a href="#规则21-empty-count" class="headerlink" title="规则21: empty_count"></a>规则21: empty_count</h3><p>建议使用isEmpty判断,而不是使用count==0判断</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>empty_count</td><td>未启用</td><td>no</td><td>performance</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// swiftlint不建议这样使用</span></span><br><span class="line">let number = <span class="string">"long"</span></span><br><span class="line"><span class="keyword">if</span> number.characters.count == <span class="number">0</span> &#123;</span><br><span class="line">    print(<span class="string">"为空"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"不为空"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// swiftlint建议这种正式风格</span></span><br><span class="line"><span class="keyword">if</span> number.isEmpty &#123;</span><br><span class="line">    print(<span class="string">"为空"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"不为空"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则22-empty-enum-arguments"><a href="#规则22-empty-enum-arguments" class="headerlink" title="规则22: empty_enum_arguments"></a>规则22: empty_enum_arguments</h3><p>当枚举与关联类型匹配时，如果不使用它们，参数可以省略</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>empty_enum_arguments</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SwiftLint建议写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .bar: <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .bar(let x): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> let .bar(x): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (foo, bar) &#123;</span><br><span class="line">    <span class="keyword">case</span> (_, _): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"bar"</span>.uppercased(): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SwiftLint不建议写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .bar(_): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .bar(): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .bar(_), .bar2(_): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则23-empty-parameters"><a href="#规则23-empty-parameters" class="headerlink" title="规则23: empty_parameters"></a>规则23: empty_parameters</h3><p>闭包参数为空时,建议使用() -&gt;Void, 而不是Void -&gt;Void</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>empty_parameters</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 01 不会触发warning</span></span><br><span class="line">let abc: () -&gt; Void</span><br><span class="line"></span><br><span class="line">func foo(completion: () -&gt; Void) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 02 直接报错</span></span><br><span class="line">let bcd: Void -&gt; Void</span><br><span class="line"></span><br><span class="line">func foo(completion: Void -&gt; Void) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则24-empty-parentheses-with-trailing-closure"><a href="#规则24-empty-parentheses-with-trailing-closure" class="headerlink" title="规则24: empty_parentheses_with_trailing_closure"></a>规则24: empty_parentheses_with_trailing_closure</h3><p>在使用尾随闭包的时候， 应该尽量避免使用空的圆括号</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>empty_parentheses_with_trailing_closure</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(&#123; $<span class="number">0</span> + <span class="number">1</span> &#125;)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].reduce(<span class="number">0</span>) &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; number <span class="keyword">in</span></span><br><span class="line">   number + <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map() &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map( ) &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map() &#123; number <span class="keyword">in</span></span><br><span class="line">   number + <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(  ) &#123; number <span class="keyword">in</span></span><br><span class="line">   number + <span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则26-explicit-acl"><a href="#规则26-explicit-acl" class="headerlink" title="规则26: explicit_acl"></a>规则26: explicit_acl</h3><p>…所有属性和方法的声明, 都应该明确指定修饰关键字</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>explicit_acl</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>官方代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非触发示例</span></span><br><span class="line">internal <span class="keyword">enum</span> A &#123;&#125;</span><br><span class="line">public final <span class="keyword">class</span> B &#123;&#125;</span><br><span class="line">private <span class="keyword">struct</span> C &#123;&#125;</span><br><span class="line">internal func a() &#123; let a =  &#125;</span><br><span class="line">private <span class="keyword">struct</span> C &#123; let d = <span class="number">5</span> &#125;</span><br><span class="line">internal <span class="keyword">class</span> A &#123; deinit &#123;&#125; &#125;</span><br><span class="line">internal protocol A &#123;</span><br><span class="line">    func b()</span><br><span class="line">    var c: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//触发示例</span></span><br><span class="line"><span class="keyword">enum</span> A &#123;&#125;</span><br><span class="line">final <span class="keyword">class</span> B &#123;&#125;</span><br><span class="line">internal <span class="keyword">struct</span> C &#123; let d = <span class="number">5</span> &#125;</span><br><span class="line">public <span class="keyword">struct</span> C &#123; let d = <span class="number">5</span> &#125;</span><br><span class="line">func a() &#123;&#125;</span><br><span class="line">internal let a = <span class="number">0</span></span><br><span class="line">func b() &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="规则27-explicit-type-interface"><a href="#规则27-explicit-type-interface" class="headerlink" title="规则27: explicit_type_interface"></a>规则27: explicit_type_interface</h3><p>声明的属性应该明确其类型, 如: var myVar: Int = 0</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>explicit_type_interface</td><td>未启用</td><td>no</td><td>idomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var myVar: Int? = <span class="number">0</span></span><br><span class="line">  let myLet: Int? = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var myVar = <span class="number">0</span></span><br><span class="line">  let myLet = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则28-extension-access-modifier"><a href="#规则28-extension-access-modifier" class="headerlink" title="规则28: extension_access_modifier"></a>规则28: extension_access_modifier</h3><p>在自定义类中,推荐使用extension扩展</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>extension_access_modifier</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><h3 id="规则29-no-extension-access-modifier"><a href="#规则29-no-extension-access-modifier" class="headerlink" title="规则29: no_extension_access_modifier"></a>规则29: no_extension_access_modifier</h3><p>在extension扩展前面,不建议使用(fileprivate, public)等修饰符</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>no_extension_access_modifier</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不建议以下写法</span></span><br><span class="line">private extension String &#123;&#125;</span><br><span class="line">public extension String &#123;&#125;</span><br><span class="line">open extension String &#123;&#125;</span><br><span class="line">internal extension String &#123;&#125;</span><br><span class="line">fileprivate extension String &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="规则30-fallthrough"><a href="#规则30-fallthrough" class="headerlink" title="规则30: fallthrough"></a>规则30: fallthrough</h3><p>switch语句中不建议使用fallthrough</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>fallthrough</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">case</span> .bar, .bar2, .bar3:</span><br><span class="line">    something()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">case</span> .bar:</span><br><span class="line">    fallthrough</span><br><span class="line"><span class="keyword">case</span> .bar2:</span><br><span class="line">    something()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则31-fatal-error-message"><a href="#规则31-fatal-error-message" class="headerlink" title="规则31: fatal_error_message"></a>规则31: fatal_error_message</h3><p>执行fatalError错误时,建议有一个提示信息; 如:fatalError(“Foo”)</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>fatal_error_message</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">required init?(coder aDecoder: <span class="built_in">NSCoder</span>) &#123;</span><br><span class="line">    fatalError(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议</span></span><br><span class="line">required init?(coder aDecoder: <span class="built_in">NSCoder</span>) &#123;</span><br><span class="line">    fatalError(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则32-file-header"><a href="#规则32-file-header" class="headerlink" title="规则32: file_header"></a>规则32: file_header</h3><p>文件头。新建的文件开始的注释应该一样</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>aaa</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 不会触发warning</span></span><br><span class="line"><span class="comment">/// 如果我新建一个工程，在ViewController.swift文件中， 开始的注释应该是：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  SwiftLint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by langke on 17/1/17.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 langke. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">改变一下变为：</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  MyViewController.swift...................由于这里和外面的文件名不一样，所以触发warning（实际上在swift 3.0上测试这个属性暂时没有任何作用！！）</span></span><br><span class="line"><span class="comment">//  SwiftLint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by langke on 17/1/17.</span></span><br><span class="line"><span class="comment">//   Copyright © 2017年 langke. All rights reserved................官方terminal表示，Copyright和Created没有对齐，也会触发warning！！！</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="规则33-file-length"><a href="#规则33-file-length" class="headerlink" title="规则33: file_length"></a>规则33: file_length</h3><p>文件内容行数, 超过400行warning, 超过1000行给error</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>file_length</td><td>启用</td><td>no</td><td>metrics</td></tr></tbody></table><h3 id="规则34-first-where"><a href="#规则34-first-where" class="headerlink" title="规则34: first_where"></a>规则34: first_where</h3><p>不建议在使用filter和map函数后直接使用.first</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>first_where</td><td>未启用</td><td>no</td><td>performance</td></tr></tbody></table><p>官方代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> let description = RuleDescription(</span><br><span class="line">    identifier: <span class="string">"first_where"</span>,</span><br><span class="line">    name: <span class="string">"First Where"</span>,</span><br><span class="line">    description: <span class="string">"Prefer using `.first(where:)` over `.filter &#123; &#125;.first` in collections."</span>,</span><br><span class="line">    kind: .performance,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不会触发警告</span></span><br><span class="line">    nonTriggeringExamples: [</span><br><span class="line">        <span class="string">"kinds.filter(excludingKinds.contains).isEmpty &amp;&amp; kinds.first == .identifier\n"</span>,</span><br><span class="line">        <span class="string">"myList.first(where: &#123; $0 % 2 == 0 &#125;)\n"</span>,</span><br><span class="line">        <span class="string">"match(pattern: pattern).filter &#123; $0.first == .identifier &#125;\n"</span>,</span><br><span class="line">        <span class="string">"(myList.filter &#123; $0 == 1 &#125;.suffix(2)).first\n"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//以下写法会触发警告</span></span><br><span class="line">    triggeringExamples: [</span><br><span class="line">        <span class="string">"↓myList.filter &#123; $0 % 2 == 0 &#125;.first\n"</span>,</span><br><span class="line">        <span class="string">"↓myList.filter(&#123; $0 % 2 == 0 &#125;).first\n"</span>,</span><br><span class="line">        <span class="string">"↓myList.map &#123; $0 + 1 &#125;.filter(&#123; $0 % 2 == 0 &#125;).first\n"</span>,</span><br><span class="line">        <span class="string">"↓myList.map &#123; $0 + 1 &#125;.filter(&#123; $0 % 2 == 0 &#125;).first?.something()\n"</span>,</span><br><span class="line">        <span class="string">"↓myList.filter(someFunction).first\n"</span>,</span><br><span class="line">        <span class="string">"↓myList.filter(&#123; $0 % 2 == 0 &#125;)\n.first\n"</span>,</span><br><span class="line">        <span class="string">"(↓myList.filter &#123; $0 == 1 &#125;).first\n"</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="规则35-for-where"><a href="#规则35-for-where" class="headerlink" title="规则35: for_where"></a>规则35: for_where</h3><p>在for循环中,不建议使用单个if语句或者只使用一次循环变量,可使用where或者if{}else{}语句</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>for_where</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users where user.id == <span class="number">1</span> &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> let <span class="keyword">id</span> = user.id &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> var <span class="keyword">id</span> = user.id &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> user.id == <span class="number">1</span> &#123; &#125; <span class="keyword">else</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> user.id == <span class="number">1</span> &#123; &#125;</span><br><span class="line">   print(user)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   let <span class="keyword">id</span> = user.id</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">id</span> == <span class="number">1</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> user.id == <span class="number">1</span> &amp;&amp; user.age &gt; <span class="number">18</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> user.id == <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则36-force-cast"><a href="#规则36-force-cast" class="headerlink" title="规则36: force_cast"></a>规则36: force_cast</h3><p>不建议直接强解类型</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>force_cast</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line"><span class="built_in">NSNumber</span>() as? Int</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"><span class="built_in">NSNumber</span>() ↓as! Int</span><br></pre></td></tr></table></figure><h3 id="规则37-force-try"><a href="#规则37-force-try" class="headerlink" title="规则37: force_try"></a>规则37: force_try</h3><p>对会抛出异常(throws)的方法,不建议try!强解</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>force_try</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func myFunction() throws &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这样写是可以的，不会触发 error</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try myFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这样直接触发 error</span></span><br><span class="line">try! myFunction()</span><br></pre></td></tr></table></figure><h3 id="规则38-force-unwrapping"><a href="#规则38-force-unwrapping" class="headerlink" title="规则38: force_unwrapping"></a>规则38: force_unwrapping</h3><p>强制解包/拆包。我们知道，当一个类型是可选类型的时候，当我们获取值时，需要强制解包（也叫隐式解包）, 通常我们是在一个变量或者所需要的常量、类型等后面加一个“ ！”， 然而，swiftlint建议强制解包应该要避免， 否则将给予warning</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>force_unwrapping</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将触发warning</span></span><br><span class="line">navigationController!.pushViewController(myViewController, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">let url = <span class="built_in">NSURL</span>(string: <span class="string">"http://www.baidu.com"</span>)!</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cell!</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 不会触发warning</span></span><br><span class="line">navigationController?.pushViewController(myViewController, animated: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="规则39-function-body-length"><a href="#规则39-function-body-length" class="headerlink" title="规则39: function_body_length"></a>规则39: function_body_length</h3><p>函数体长度， 函数体不应该跨越太多行， 超过40行给warning， 超过100行直接报错</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>function_body_length</td><td>启用</td><td>no</td><td>metrics</td></tr></tbody></table><h3 id="规则40-function-parameter-count"><a href="#规则40-function-parameter-count" class="headerlink" title="规则40: function_parameter_count"></a>规则40: function_parameter_count</h3><ul><li>函数参数个数， 函数参数数量(init方法除外)应该少点， 不要太多，swiftlint规定函数参数数量超过5个给warning， 超过8个直接报error</li><li>注：<code>function_parameter_count: error</code> 这样并不能改变它的警告或错误，该属性不允许修改，但是可以禁用</li></ul><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>function_parameter_count</td><td>启用</td><td>no</td><td>metrics</td></tr></tbody></table><h3 id="规则41-generic-type-name"><a href="#规则41-generic-type-name" class="headerlink" title="规则41: generic_type_name"></a>规则41: generic_type_name</h3><p>泛型类型名称只能包含字母数字字符，以大写字母开头，长度介于1到20个字符之间</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>generic_type_name</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">func foo&lt;T&gt;() &#123;&#125;</span><br><span class="line">func foo&lt;T&gt;() -&gt; T &#123;&#125;</span><br><span class="line">func foo&lt;T, U&gt;(param: U) -&gt; T &#123;&#125;</span><br><span class="line">func foo&lt;T: Hashable, U: Rule&gt;(param: U) -&gt; T &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line">func foo&lt;T_Foo&gt;() &#123;&#125;</span><br><span class="line">func foo&lt;T, U_Foo&gt;(param: U_Foo) -&gt; T &#123;&#125;</span><br><span class="line">func foo&lt;TTTTTTTTTTTTTTTTTTTTT&gt;() &#123;&#125;</span><br><span class="line">func foo&lt;type&gt;() &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="规则42-identifier-name"><a href="#规则42-identifier-name" class="headerlink" title="规则42: identifier_name"></a>规则42: identifier_name</h3><p>变量标识符名称应该只包含字母数字字符，并以小写字母开头或只应包含大写字母。在上述例外情况下，当变量名称被声明为静态且不可变时，变量名称可能以大写字母开头。变量名称不应该太长或太短</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>identifier_name</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><p>官方给出的示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="keyword">struct</span> IdentifierNameRuleExamples &#123;</span><br><span class="line">    <span class="comment">//不会触发error</span></span><br><span class="line">    <span class="keyword">static</span> let nonTriggeringExamples = [</span><br><span class="line">        <span class="string">"let myLet = 0"</span>,</span><br><span class="line">        <span class="string">"var myVar = 0"</span>,</span><br><span class="line">        <span class="string">"private let _myLet = 0"</span>,</span><br><span class="line">        <span class="string">"class Abc &#123; static let MyLet = 0 &#125;"</span>,</span><br><span class="line">        <span class="string">"let URL: NSURL? = nil"</span>,</span><br><span class="line">        <span class="string">"let XMLString: String? = nil"</span>,</span><br><span class="line">        <span class="string">"override var i = 0"</span>,</span><br><span class="line">        <span class="string">"enum Foo &#123; case myEnum &#125;"</span>,</span><br><span class="line">        <span class="string">"func isOperator(name: String) -&gt; Bool"</span>,</span><br><span class="line">        <span class="string">"func typeForKind(_ kind: SwiftDeclarationKind) -&gt; String"</span>,</span><br><span class="line">        <span class="string">"func == (lhs: SyntaxToken, rhs: SyntaxToken) -&gt; Bool"</span>,</span><br><span class="line">        <span class="string">"override func IsOperator(name: String) -&gt; Bool"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//会触发error</span></span><br><span class="line">    <span class="keyword">static</span> let triggeringExamples = [</span><br><span class="line">        <span class="string">"↓let MyLet = 0"</span>,</span><br><span class="line">        <span class="string">"↓let _myLet = 0"</span>,</span><br><span class="line">        <span class="string">"private ↓let myLet_ = 0"</span>,</span><br><span class="line">        <span class="string">"↓let myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0"</span>,</span><br><span class="line">        <span class="string">"↓var myExtremelyVeryVeryVeryVeryVeryVeryLongVar = 0"</span>,</span><br><span class="line">        <span class="string">"private ↓let _myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0"</span>,</span><br><span class="line">        <span class="string">"↓let i = 0"</span>,</span><br><span class="line">        <span class="string">"↓var id = 0"</span>,</span><br><span class="line">        <span class="string">"private ↓let _i = 0"</span>,</span><br><span class="line">        <span class="string">"↓func IsOperator(name: String) -&gt; Bool"</span>,</span><br><span class="line">        <span class="string">"enum Foo &#123; case ↓MyEnum &#125;"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则44-implicit-getter"><a href="#规则44-implicit-getter" class="headerlink" title="规则44: implicit_getter"></a>规则44: implicit_getter</h3><p>对于只有只读属性不建议重写get方法</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>implicit_getter</td><td>启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发error</span></span><br><span class="line"><span class="comment">//重写get和set方法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var foo: Int &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    set &#123;</span><br><span class="line">      _abc = newValue </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只读</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var foo: Int &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">20</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  <span class="keyword">static</span> var foo: Int &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">20</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发error</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var foo: Int &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">20</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var foo: Int &#123;</span><br><span class="line">    get&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">20</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则45-implicit-return"><a href="#规则45-implicit-return" class="headerlink" title="规则45: implicit_return"></a>规则45: implicit_return</h3><p> 建议使用隐式返回闭包; 如: foo.map({ $0 + 1 })</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>implicit_return</td><td>未启用</td><td>no</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">foo.map &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">foo.map(&#123; $<span class="number">0</span> + <span class="number">1</span> &#125;)</span><br><span class="line">foo.map &#123; value <span class="keyword">in</span> value + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">foo.map &#123; value <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">foo.map &#123;</span><br><span class="line">  <span class="keyword">return</span> $<span class="number">0</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则46-implicitly-unwrapped-optional"><a href="#规则46-implicitly-unwrapped-optional" class="headerlink" title="规则46: implicitly_unwrapped_optional"></a>规则46: implicitly_unwrapped_optional</h3><p>尽量避免隐式解析可选类型的使用</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>implicitly_unwrapped_optional</td><td>未启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>下面吗给出官方示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> let description = RuleDescription(</span><br><span class="line">    identifier: <span class="string">"implicitly_unwrapped_optional"</span>,</span><br><span class="line">    name: <span class="string">"Implicitly Unwrapped Optional"</span>,</span><br><span class="line">    description: <span class="string">"Implicitly unwrapped optionals should be avoided when possible."</span>,</span><br><span class="line">    kind: .idiomatic,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不会触发warning</span></span><br><span class="line">    nonTriggeringExamples: [</span><br><span class="line">        <span class="string">"@IBOutlet private var label: UILabel!"</span>,</span><br><span class="line">        <span class="string">"@IBOutlet var label: UILabel!"</span>,</span><br><span class="line">        <span class="string">"@IBOutlet var label: [UILabel!]"</span>,</span><br><span class="line">        <span class="string">"if !boolean &#123;&#125;"</span>,</span><br><span class="line">        <span class="string">"let int: Int? = 42"</span>,</span><br><span class="line">        <span class="string">"let int: Int? = nil"</span></span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//会触发warning</span></span><br><span class="line">    triggeringExamples: [</span><br><span class="line">        <span class="string">"let label: UILabel!"</span>,</span><br><span class="line">        <span class="string">"let IBOutlet: UILabel!"</span>,</span><br><span class="line">        <span class="string">"let labels: [UILabel!]"</span>,</span><br><span class="line">        <span class="string">"var ints: [Int!] = [42, nil, 42]"</span>,</span><br><span class="line">        <span class="string">"let label: IBOutlet!"</span>,</span><br><span class="line">        <span class="string">"let int: Int! = 42"</span>,</span><br><span class="line">        <span class="string">"let int: Int! = nil"</span>,</span><br><span class="line">        <span class="string">"var int: Int! = 42"</span>,</span><br><span class="line">        <span class="string">"let int: ImplicitlyUnwrappedOptional&lt;Int&gt;"</span>,</span><br><span class="line">        <span class="string">"let collection: AnyCollection&lt;Int!&gt;"</span>,</span><br><span class="line">        <span class="string">"func foo(int: Int!) &#123;&#125;"</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="规则47-is-disjoint"><a href="#规则47-is-disjoint" class="headerlink" title="规则47: is_disjoint"></a>规则47: is_disjoint</h3><p>初始化集合Set时,推荐使用Set.isDisjoint(), 不建议:Set.intersection</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>is_disjoint</td><td>启用</td><td>no</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">_ = Set(syntaxKinds).isDisjoint(with: commentAndStringKindsSet)</span><br><span class="line">let isObjc = !objcAttributes.isDisjoint(with: dictionary.enclosedSwiftAttributes)</span><br></pre></td></tr></table></figure><h3 id="规则48-joined-default-parameter"><a href="#规则48-joined-default-parameter" class="headerlink" title="规则48: joined_default_parameter"></a>规则48: joined_default_parameter</h3><p>joined方法使用默认分隔符时, 建议使用joined()方法, 而不是joined(separator: “”)方法</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>joined_default_parameter</td><td>未启用</td><td>yes</td><td>idiomatic</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">let foo = bar.joined()</span><br><span class="line">let foo = bar.joined(separator: <span class="string">","</span>)</span><br><span class="line">let foo = bar.joined(separator: toto)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">let foo = bar.joined(separator: <span class="string">""</span>)</span><br><span class="line">let foo = bar.filter(toto).joined(separator: <span class="string">""</span>)</span><br></pre></td></tr></table></figure><h3 id="规则49-large-tuple"><a href="#规则49-large-tuple" class="headerlink" title="规则49: large_tuple"></a>规则49: large_tuple</h3><p>定义的元组成员个数,超过两个warning</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>large_tuple</td><td>启用</td><td>no</td><td>metrics</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">let foo: (Int, Int)</span><br><span class="line">let foo: (start: Int, end: Int)</span><br><span class="line">let foo: (Int, (Int, String))</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">let foo: (Int, Int, Int)</span><br><span class="line">let foo: (start: Int, end: Int, value: String)</span><br><span class="line">let foo: (Int, (Int, Int, Int))</span><br></pre></td></tr></table></figure><h3 id="规则50-leading-whitespace"><a href="#规则50-leading-whitespace" class="headerlink" title="规则50: leading_whitespace"></a>规则50: leading_whitespace</h3><p>文件开始不应该有空格或者换行, 否则就会触发warning</p><table><thead><tr><th>识别码</th><th>默认是否启用</th><th>是否支持自动更正</th><th>类型</th></tr></thead><tbody><tr><td>leading_whitespace</td><td>启用</td><td>yes</td><td>style</td></tr></tbody></table><p>代码示例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 不会触发warning</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  SwiftLint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by langke on 17/1/12.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 langke. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 会触发warning</span></span><br><span class="line"> <span class="comment">//..................................这里有一个空格</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  SwiftLint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by langke on 17/1/12.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 langke. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 会触发warning</span></span><br><span class="line">......................................这里是一个空行</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  SwiftLint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by langke on 17/1/12.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 langke. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><blockquote><p>参考文档<br><a href="https://github.com/realm/SwiftLint/blob/master/Rules.md#array-init" target="_blank" rel="noopener">SwiftLint规则官方文档</a><br><a href="https://github.com/realm/SwiftLint/tree/master/Source/SwiftLintFramework/Rules" target="_blank" rel="noopener">SwiftLint个规则详细介绍</a></p></blockquote><blockquote><p>有些地方的解释和示例可能不是很完善, 希望各位大神多多指导,后续会持续更新中…….</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> SwiftLint </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Xcode代码规范之SwiftLint配置</title>
      <link href="/2018/02/07/Xcode%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B9%8BSwiftLint%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>最近公司大佬考虑将项目代码规范化, 然而自Xcode9之后,Xcode的插件基本处于废弃的状态大部分插件都是在一年前就停止更新了;</li><li>于是在谷歌找到了一款强大的代码规范工具<a href="https://github.com/realm/SwiftLint" target="_blank" rel="noopener">SwiftLint</a></li><li><a href="https://github.com/realm/SwiftLint" target="_blank" rel="noopener">SwiftLint</a>是 <a href="https://realm.io/" target="_blank" rel="noopener">Realm</a> 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 <a href="https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md" target="_blank" rel="noopener">Github 公布的 Swift 代码规范</a>进行代码检查，并且能够很好的和 Xcode 整合</li><li><a href="https://github.com/github/swift-style-guide" target="_blank" rel="noopener">Github 公布的 Swift 代码规范–原文</a></li><li><a href="https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md" target="_blank" rel="noopener">Github 公布的 Swift 代码规范–中文</a></li><li>配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 红色错误 的形式指示出来</li><li>支持自定义规则,可禁用或者开启某一些规则</li></ul><a id="more"></a><h2 id="一-安装SwiftLint"><a href="#一-安装SwiftLint" class="headerlink" title="一. 安装SwiftLint"></a>一. 安装SwiftLint</h2><ul><li>SwiftLint目前有三种安装方式可供选择,可以根据自己的项目需要自行选择</li></ul><h3 id="1-安装全局配置-Homebrew-安装"><a href="#1-安装全局配置-Homebrew-安装" class="headerlink" title="1. 安装全局配置(Homebrew 安装)"></a>1. 安装全局配置(Homebrew 安装)</h3><h4 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h4><ul><li>Homebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件, 输入以下代码安装:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>译注：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R `whoami` /usr/local</span><br></pre></td></tr></table></figure><ul><li>Homebrew 会自动安装最新版本</li><li>打开终端输入以下代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install swiftlint</span><br></pre></td></tr></table></figure><h4 id="安装成功-如下图所示"><a href="#安装成功-如下图所示" class="headerlink" title="安装成功,如下图所示:"></a>安装成功,如下图所示:</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-aaabe87320b6b9f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Homebrew 安装"></p><h3 id="2-使用-CocoaPods-安装"><a href="#2-使用-CocoaPods-安装" class="headerlink" title="2. 使用 CocoaPods 安装"></a>2. 使用 CocoaPods 安装</h3><ul><li>这种方式只能针对单个项目有效,如果你想要针对不同的项目使用不同的<code>SwiftLint</code> 版本，这是一种很好的解决方案</li><li>需要注意的是使用这种方案会将整个<code>SwiftLint</code>以及他的依赖包的完整资源文件都安装到 Pods/ 目录中去，所以在使用版本管理工具比如 <code>git/svn</code> 时要注意设置忽略相关目录</li><li>CocosPods安装和安装第三方框架一样</li><li>在根目录创建<code>Podfile</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;SwiftLint&apos;</span><br></pre></td></tr></table></figure><h3 id="3-使用安装包"><a href="#3-使用安装包" class="headerlink" title="3. 使用安装包"></a>3. 使用安装包</h3><p><code>SwiftLint</code> 还支持使用 <code>pkg</code> 安装包进行安装，在官方的 Github 页面可以找到最新发布的<a href="https://github.com/realm/SwiftLint/releases/tag/0.17.0" target="_blank" rel="noopener">安装包</a></p><h2 id="二-查看SwiftLint的全部命令"><a href="#二-查看SwiftLint的全部命令" class="headerlink" title="二. 查看SwiftLint的全部命令"></a>二. 查看SwiftLint的全部命令</h2><ul><li>等待安装完成，在终端输入 <code>swiftlint help</code> 可以查看所有可用的命令：</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-a9eaa0ae5b92f67b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SwiftLint的所有命令"></p><p><strong>各个命令注释</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看所有命令</span></span><br><span class="line">swiftlint help</span><br><span class="line"></span><br><span class="line"><span class="comment">//忽略空格导致的警告和错误</span></span><br><span class="line">swiftlint autocorrect</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出所有的警告和错误</span></span><br><span class="line">swiftlint lint</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有可获得的规则以及对应的 ID</span></span><br><span class="line">swiftlint rules</span><br><span class="line"></span><br><span class="line"><span class="comment">//产看当前版本号</span></span><br><span class="line">swiftlint version</span><br></pre></td></tr></table></figure></p><ul><li>我们将目录切换到工程的根目录之下，然后敲击如下命令:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftlint autocorrect</span><br></pre></td></tr></table></figure><p>然后我们就会发现，所有的空格符Warning都消失了。这都得益于我们刚刚所进行的命令行操作，它会将已知的能够自动修复的Error和Warning都自动修复，大大的减轻了我们的工作量。</p><h2 id="三-SwiftLint的使用"><a href="#三-SwiftLint的使用" class="headerlink" title="三. SwiftLint的使用"></a>三. SwiftLint的使用</h2><blockquote><p>安装完成后,需要在Xcode中配置相关设置,才能使 SwiftLint 在 Xcode 中自动检测代码规范。配置也很简单，只需要在 Xcode 的 Build Phases 中新建一个 Run Script Phase 配置项，在里面添加相关代码后,编译即可!</p></blockquote><ul><li>配置代码添加步骤</li><li>需要将相关脚本添加到红色框内</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-9fcfc0ce421210db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="配置代码添加步骤"></p><p><strong>1. 全局安装脚本添加方式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if which swiftlint &gt;/dev/null; then</span><br><span class="line">  swiftlint</span><br><span class="line">else</span><br><span class="line">  echo &quot;warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p><strong>2. CocoaPods安装脚本添加</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;$&#123;PODS_ROOT&#125;/SwiftLint/swiftlint&quot;</span><br></pre></td></tr></table></figure></p><ul><li>这里其实是设置了一个自动编译脚本，每次运行编译都会自动执行这个脚本</li><li>如果正确安装了 SwiftLint，就会执行 SwiftLint 中的代码规范检查，如果没有安装，脚本会抛出一个没有安装 SwiftLint 并提示下载的警告，方便提醒团队团队中没有安装的成员。</li><li>当然，你也可以设置为强制要求安装，这时如果没有安装则无法通过编译。只需要在脚本中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;warning: ...&quot;</span><br></pre></td></tr></table></figure></li></ul><p>之后添加一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit 1</span><br></pre></td></tr></table></figure></p><ul><li>这样一来，如果没有安装 SwiftLint，编译时会直接抛出一个编译错误而非警告，提示需要安装 SwiftLint。</li></ul><p><strong>3. 配置完成后,<code>command+B</code>编译</strong></p><ul><li>如果你的是正在开发中的项目, 你可能会发现你的项目提示999+的黄色警告和999+的红色错误</li><li>甚至你会发现甚至一些空格和一些系统的方法和注释也会报错或者警告</li><li><code>SwiftLint</code>默认方法名或者注释不得超过120个字符</li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-271410cb5d83bea3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试项目"></p></li><li><p>Swift Lint 在完成上述操作之后，便已经生效。但是，如果觉得默认的风格过于严格，或者项目组有另外的要求，Swift Lint 也可以定制相应的风格，或者禁用某些规则。</p></li><li><a href="https://github.com/realm/SwiftLint" target="_blank" rel="noopener">SwiftLint</a> 的全部规则可以在：<a href="https://github.com/realm/SwiftLint/tree/master/Source/SwiftLintFramework/Rules" target="_blank" rel="noopener">Source/SwiftLintFramework/Rules</a> 目录内找到</li><li></li></ul><h2 id="四-自定义配置"><a href="#四-自定义配置" class="headerlink" title="四. 自定义配置"></a>四. 自定义配置</h2><ul><li>当你编译过项目后,看到999+的警告和错误,是不是第一反应就是要放弃了,其实不然</li><li>仔细看一下具体的错误，会发现好多都是第三方库的代码规范问题，而且好多问题的级别被设置成为了 error</li><li>第三方库的代码规范问题,这个锅我们可不能背</li><li>这里我们可以做一些配置，让 <code>SwiftLint</code> 在做代码规范检查的时候自动忽略 <code>CocoaPods</code>、<code>Carthage</code> 等包管理器引入的第三方库（当然，手动导入的第三方库也能设置忽略）</li></ul><h3 id="1-创建配置文件"><a href="#1-创建配置文件" class="headerlink" title="1. 创建配置文件"></a>1. 创建配置文件</h3><ul><li>首先需要在项目的根目录下新建一个名为 .swiftlint.yml 的配置文件</li><li>打开终端, cd 到项目根目录下</li><li>输入: <code>touch .swiftlint.yml</code></li><li>执行完该命令后, 在文件夹中你可能找不到该yml格式文件,那是因为文件被隐藏了</li><li>关于隐藏/显示隐藏文件(命令一样): <code>command + shift + .</code></li><li>下面我们来认识一下主要的几个配置选项</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">disabled_rules: <span class="meta"># 禁用指定的规则</span></span><br><span class="line">  - colon</span><br><span class="line">  - comma</span><br><span class="line">  - control_statement</span><br><span class="line">opt_in_rules: <span class="meta"># 启用指定的规则</span></span><br><span class="line">  - empty_count</span><br><span class="line">  - missing_docs</span><br><span class="line">  <span class="meta"># 可以通过执行如下指令来查找所有可用的规则:</span></span><br><span class="line">  <span class="meta"># swiftlint rules</span></span><br><span class="line">included: <span class="meta"># 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。</span></span><br><span class="line">  - Source</span><br><span class="line">excluded: <span class="meta"># 执行 linting 时忽略的路径。 优先级比 `included` 更高。</span></span><br><span class="line">  - Carthage</span><br><span class="line">  - Pods</span><br><span class="line">  - Source/ExcludedFolder</span><br><span class="line">  - Source/ExcludedFile.swift</span><br></pre></td></tr></table></figure><h3 id="2-在代码中关闭某个规则"><a href="#2-在代码中关闭某个规则" class="headerlink" title="2. 在代码中关闭某个规则"></a>2. 在代码中关闭某个规则</h3><p>可以通过在一个源文件中定义一个如下格式的注释来关闭某个规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// swiftlint:disable &lt;rule&gt;</span><br></pre></td></tr></table></figure></p><p>在该文件结束之前或者在定义如下格式的匹配注释之前，这条规则都会被禁用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// swiftlint:enable &lt;rule&gt;</span><br></pre></td></tr></table></figure></p><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// swiftlint:disable opening_brace</span><br><span class="line">func initTakeScreenshot(launchOptions: [AnyHashable: Any]?)&#123;</span><br><span class="line">    // swiftlint:enable opening_brace</span><br><span class="line">    if let options = launchOptions &#123;</span><br><span class="line">        let userInfo = options[UIApplicationLaunchOptionsKey.remoteNotification]</span><br><span class="line">        NotificationCenter.default.post(name: Notification.Name.UIApplicationUserDidTakeScreenshot, object: userInfo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>规则关闭之前</p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-21790882f651fa95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20180207_1.png"></p><p>规则关闭之后<br><img src="http://upload-images.jianshu.io/upload_images/4122543-6ba8e782746c0849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20180207_2.png"></p><p>也可以通过添加 :previous, :this 或者 :next 来使关闭或者打开某条规则的命令分别应用于前一行，当前或者后一行代码。</p><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// swiftlint:disable:next force_cast</span><br><span class="line">let noWarning = NSNumber() as! Int</span><br><span class="line">let hasWarning = NSNumber() as! Int</span><br><span class="line">let noWarning2 = NSNumber() as! Int // swiftlint:disable:this force_cast</span><br><span class="line">let noWarning3 = NSNumber() as! Int</span><br><span class="line">// swiftlint:disable:previous force_cast</span><br></pre></td></tr></table></figure></p><h3 id="3-忽略引入的第三方库"><a href="#3-忽略引入的第三方库" class="headerlink" title="3. 忽略引入的第三方库"></a>3. 忽略引入的第三方库</h3><ul><li>1). 忽略<code>CocoaPods</code>导入的第三方库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">excluded: </span><br><span class="line">  - Pods</span><br></pre></td></tr></table></figure><ul><li>2). excluded 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹</li><li>比如如果你的项目使用 Carthage 管理第三方库的话，可以将 Carthage 目录添加到忽略列表：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">excluded: </span><br><span class="line">  - Pods</span><br><span class="line">  - Carthage</span><br></pre></td></tr></table></figure><ul><li>3). 指定精确路径下的文件，通过 - xxxx 的形式列在下面就可以了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。</span><br><span class="line">  - Source/ExcludedFolder</span><br><span class="line">  - Source/ExcludedFile.swift</span><br></pre></td></tr></table></figure><h3 id="4-嵌套配置"><a href="#4-嵌套配置" class="headerlink" title="4. 嵌套配置"></a>4. 嵌套配置</h3><p><code>SwiftLint</code> 支持通过嵌套配置文件的方式来对代码分析过程进行更加细致的控制。</p><ul><li>在你的根 <code>.swiftlint.yml</code> 文件里设置 <code>use_nested_configs: true</code> 值。</li><li>在目录结构必要的地方引入额外的 <code>.swiftlint.yml</code> 文件。</li><li>每个文件被检查时会使用在文件所在目录下的或者父目录的更深层目录下的配置文件。否则根配置文件将会生效。</li><li><code>excluded</code>，<code>included</code>，和 <code>use_nested_configs</code> 在嵌套结构中会被忽略。</li></ul><h3 id="5-自动更正"><a href="#5-自动更正" class="headerlink" title="5. 自动更正"></a>5. 自动更正</h3><ul><li><code>SwiftLint</code> 可以自动修正某些错误，磁盘上的文件会被一个修正后的版本覆盖。</li><li>请确保在对文件执行 <code>swiftlint autocorrect</code> 之前有对它们做过备份，否则的话有可能导致重要数据的丢失。</li><li>因为在执行自动更正修改某个文件后很有可能导致之前生成的代码检查信息无效或者不正确，所以当在执行代码更正时标准的检查是无法使用的。</li></ul><h2 id="五-最后贴上官方示例"><a href="#五-最后贴上官方示例" class="headerlink" title="五. 最后贴上官方示例"></a>五. 最后贴上官方示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">disabled_rules: # 执行时排除掉的规则</span><br><span class="line">  - colon</span><br><span class="line">  - comma</span><br><span class="line">  - control_statement</span><br><span class="line">opt_in_rules: # 一些规则仅仅是可选的</span><br><span class="line">  - empty_count</span><br><span class="line">  - missing_docs</span><br><span class="line">  # 可以通过执行如下指令来查找所有可用的规则:</span><br><span class="line">  # swiftlint rules</span><br><span class="line">included: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。</span><br><span class="line">  - Source</span><br><span class="line">excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。</span><br><span class="line">  - Carthage</span><br><span class="line">  - Pods</span><br><span class="line">  - Source/ExcludedFolder</span><br><span class="line">  - Source/ExcludedFile.swift</span><br><span class="line"></span><br><span class="line"># 可配置的规则可以通过这个配置文件来自定义</span><br><span class="line"># 二进制规则可以设置他们的严格程度</span><br><span class="line">force_cast: warning # 隐式</span><br><span class="line">force_try:</span><br><span class="line">  severity: warning # 显式</span><br><span class="line"># 同时有警告和错误等级的规则，可以只设置它的警告等级</span><br><span class="line"># 隐式</span><br><span class="line">line_length: 110</span><br><span class="line"># 可以通过一个数组同时进行隐式设置</span><br><span class="line">type_body_length:</span><br><span class="line">  - 300 # warning</span><br><span class="line">  - 400 # error</span><br><span class="line"># 或者也可以同时进行显式设置</span><br><span class="line">file_length:</span><br><span class="line">  warning: 500</span><br><span class="line">  error: 1200</span><br><span class="line"># 命名规则可以设置最小长度和最大程度的警告/错误</span><br><span class="line"># 此外它们也可以设置排除在外的名字</span><br><span class="line">type_name:</span><br><span class="line">  min_length: 4 # 只是警告</span><br><span class="line">  max_length: # 警告和错误</span><br><span class="line">    warning: 40</span><br><span class="line">    error: 50</span><br><span class="line">  excluded: iPhone # 排除某个名字</span><br><span class="line">variable_name:</span><br><span class="line">  min_length: # 只有最小长度</span><br><span class="line">    error: 4 # 只有错误</span><br><span class="line">  excluded: # 排除某些名字</span><br><span class="line">    - id</span><br><span class="line">    - URL</span><br><span class="line">    - GlobalAPIKey</span><br><span class="line">reporter: &quot;xcode&quot; # 报告类型 (xcode, json, csv, checkstyle)</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><blockquote><p>原文链接：<a href="https://github.com/realm/SwiftLint/blob/master/README.md" target="_blank" rel="noopener">https://github.com/realm/SwiftLint/blob/master/README.md</a><br>译文链接：<a href="https://github.com/realm/SwiftLint/blob/master/README_CN.md" target="_blank" rel="noopener">https://github.com/realm/SwiftLint/blob/master/README_CN.md</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 入坑指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> SwiftLint </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactNative之AsyncStorage本地存储</title>
      <link href="/2018/01/24/ReactNative%E4%B9%8BAsyncStorage%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
      <content type="html"><![CDATA[<ul><li>在RN开发中，持久化存储数据，可以使用<code>AsyncStorage</code>，对原生的API进行了一层封装</li><li><code>AsyncStorage</code>是一个简单的、异步的、持久化的<code>Key-Value</code>存储系统，它对于<code>App</code>来说是全局性的</li></ul><a id="more"></a><blockquote><h2 id="AsyncStorage原理和使用"><a href="#AsyncStorage原理和使用" class="headerlink" title="AsyncStorage原理和使用"></a><code>AsyncStorage</code>原理和使用</h2><ul><li><code>AsyncStorage</code>存储数据，在iOS中，底层会把数据保存到沙盒中的<code>Documents</code>中,并生成<code>manifest.json</code>文件。保存的数据都在<code>manifest.json</code>中。</li><li><code>AsyncStorage</code>删除数据，也仅仅是删除<code>manifest.json</code>文件中的数据，并不是删除<code>manifest.json</code>文件</li><li>唯有<code>clear</code>方法是将文件删除</li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-59ec94ecc769d233.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="数据持久化.jpg"></p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-296bd2a19ea5dc90.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="json文件内容.jpg"></p><h3 id="一-存储"><a href="#一-存储" class="headerlink" title="一. 存储"></a>一. 存储</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> setItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; <span class="keyword">void</span>) </span><br><span class="line"><span class="comment">//将key字段的值设置成value，并在完成后调用callback函数。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象</span></span><br></pre></td></tr></table></figure><ul><li>注意：<code>AsyncStorage</code>只能存储字符串，需要把对象转换为字符串才行</li><li>具体使用</li><li></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key值</span></span><br><span class="line">var key = 'per'</span><br><span class="line">var person = &#123;</span><br><span class="line">    name:'jun',</span><br><span class="line">    age:<span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//json转成字符串</span></span><br><span class="line">var jsonStr = JSON.stringify(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储</span></span><br><span class="line">AsyncStorage.setItem('person', jsonStr, function (error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        alert('存储失败')</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        alert('存储完成')</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="二-读取"><a href="#二-读取" class="headerlink" title="二. 读取"></a>二. 读取</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getItem(key: string, callback?: ?(error: ?Error, result: ?string) =&gt; <span class="keyword">void</span>) </span><br><span class="line"><span class="comment">//读取key字段并将结果作为第二个参数传递给callback。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。</span></span><br></pre></td></tr></table></figure><blockquote><p>使用方法</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取</span></span><br><span class="line">_readData()&#123;</span><br><span class="line">    console.log('读取')</span><br><span class="line">    AsyncStorage.getItem('per', function (error, result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            alert('读取失败')</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            console.log(result)</span><br><span class="line">            alert('读取完成')</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-删除"><a href="#三-删除" class="headerlink" title="三. 删除"></a>三. 删除</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> removeItem(key: string, callback?: ?(error: ?Error) =&gt; <span class="keyword">void</span>) </span><br><span class="line"><span class="comment">//删除一个字段。返回一个Promise对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> clear(callback?: ?(error: ?Error) =&gt; <span class="keyword">void</span>) </span><br><span class="line"><span class="comment">//删除全部的AsyncStorage数据，即直接删除该缓存文件</span></span><br></pre></td></tr></table></figure><blockquote><p>函数用法</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line">_deleteData()&#123;</span><br><span class="line">    console.log('删除')</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一条数据</span></span><br><span class="line">    AsyncStorage.removeItem('per', function (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            alert('删除失败')</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            alert('删除完成')</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除json文件</span></span><br><span class="line">    AsyncStorage.clear(function (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            alert('文件删除失败')</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            alert('文件删除完成')</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-其他用法"><a href="#四-其他用法" class="headerlink" title="四. 其他用法"></a>四. 其他用法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mergeItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; <span class="keyword">void</span>) </span><br><span class="line"><span class="comment">//假设已有的值和新的值都是字符串化的JSON，则将两个值合并。返回一个Promise对象。还没有被所有原生实现都支持</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> getAllKeys(callback?: ?(error: ?Error, keys: ?Array&lt;string&gt;) =&gt; <span class="keyword">void</span>) </span><br><span class="line"><span class="comment">//获取所有本应用可以访问到的数据，不论来自什么库或调用者。返回一个Promise对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> flushGetRequests() </span><br><span class="line"><span class="comment">//清除所有进行中的查询操作。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AsyncStorage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Node.js搭建Web服务器</title>
      <link href="/2018/01/20/Node.js%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <content type="html"><![CDATA[<ul><li>服务器种类<ul><li>Web服务器: 处理<code>HTTP</code>请求的服务器</li><li><code>Socket</code>服务器(即时通讯): 通过<code>socket</code>传输<ul><li>即时通讯(IM): 允许两人或多人使用网路即时的传递文字讯息、档案、语音与视频交流</li></ul></li><li>流媒体服务器: 音视频处理程序, 接受流媒体格式文件,<code>flv/ts</code>等</li></ul></li></ul><a id="more"></a><ul><li>简单效果图</li><li><img src="http://upload-images.jianshu.io/upload_images/4122543-be8bdfac135d99e8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求返回结果.jpg"></li></ul><hr><h2 id="一-Node-js介绍"><a href="#一-Node-js介绍" class="headerlink" title="一. Node.js介绍"></a>一. Node.js介绍</h2><ul><li><code>Node.js</code>发布于2009年5月，由Ryan Dahl(瑞恩·达尔)在<code>GitHub</code>上发布了最初版本的部分<code>Node.js</code>包，随后几个月里，有人开始使用Node.js开发应用</li><li><code>Node.js</code>是一个基于<code>Chrome JavaScript</code>运行时建立的平台， 是一个<code>Javascript</code>运行环境</li><li>Node 是一个服务器程序, 用Javascript这个语言开发服务器</li><li><code>Node.js</code>的实质是对<code>Chrome V8</code>引擎进行了封装</li><li><code>V8 JavaScript</code> 引擎是 <code>Google</code> 用于其 <code>Chrome</code> 浏览器的底层 JavaScript 引擎</li><li>传统意义上的 JavaScript 运行在浏览器上，这是因为浏览器内核实际上分为两个部分:渲染引擎和 JavaScript 引擎。前者负责渲染 HTML + CSS，后者则负责运行 JavaScript。Chrome 使用的 JavaScript 引擎是 V8，它的速度非常快</li><li>参考<a href="https://www.ibm.com/developerworks/cn/opensource/os-nodejs/" target="_blank" rel="noopener">Node.js 究竟是什么？</a>和<a href="https://nodejs.org/dist/latest-v7.x/docs/api/" target="_blank" rel="noopener">Node.js的SDK文档</a></li></ul><h3 id="1-Node-js的优缺点"><a href="#1-Node-js的优缺点" class="headerlink" title="1. Node.js的优缺点"></a>1. Node.js的优缺点</h3><ul><li>Node.js优点：<ul><li>采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。</li><li>Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。</li><li>Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。</li></ul></li><li>Node.js缺点：<ul><li>可靠性低</li><li>单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。</li><li>一旦这个进程崩掉，那么整个web服务就崩掉了。</li></ul></li></ul><h3 id="2-Node-js使用介绍"><a href="#2-Node-js使用介绍" class="headerlink" title="2. Node.js使用介绍"></a>2. Node.js使用介绍</h3><ul><li>Node.js使用Module模块去划分不同的功能，以简化App开发，Module就是库，跟组件化差不多，一个功能一个库。</li><li>NodeJS内建了一个HTTP服务器，可以轻而易举的实现一个网站和服务器的组合，不像PHP那样，在使用PHP的时候，必须先搭建一个Apache之类的HTTP服务器，然后通过HTTP服务器的模块加载CGI调用，才能将PHP脚本的执行结果呈现给用户</li><li>require() 函数，用于在当前模块中加载和使用其他模块；</li></ul><h2 id="二-Express模块-框架"><a href="#二-Express模块-框架" class="headerlink" title="二. Express模块(框架)"></a>二. Express模块(框架)</h2><ul><li>Express是Node.JS第三方库</li><li>Express可以处理各种HTTP请求</li><li>Express是目前最流行的基于Node.js的Web开发框架，</li><li>Express框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器</li></ul><h3 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1. 安装Node.js"></a>1. 安装Node.js</h3><ul><li>打开终端，输入node -v，先查看是否已经安装</li><li>如果没有安装，就需要安装node软件</li><li>参考<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">Node.js 安装配置</a></li></ul><h3 id="2-安装npm"><a href="#2-安装npm" class="headerlink" title="2. 安装npm"></a>2. 安装npm</h3><ul><li>npm是随同<code>NodeJS</code>一起安装的包管理工具，用于下载<code>NodeJS</code>第三方库。</li><li>类似iOS开发中<code>cocoapods</code>，用于安装第三方框架</li><li>新版的<code>NodeJS</code>已经集成了npm，所以只要安装好Node.JS就好<h3 id="3-下载第三方模块Express"><a href="#3-下载第三方模块Express" class="headerlink" title="3. 下载第三方模块Express"></a>3. 下载第三方模块<code>Express</code></h3></li><li>首先先创建项目<ul><li>新建一个文件夹, 打开终端</li><li>cd到当前文件夹, 创建一个js文件, 如: <code>touch app.js</code></li></ul></li><li>安装<code>package.json</code>文件, 类似于CocoaPods中的<code>Podfile</code>   - cd到当前文件夹<ul><li>终端输入: <code>npm init</code></li></ul></li><li>最后安装express库 <ul><li>终端输入: <code>npm install express --save</code></li></ul></li></ul><h2 id="三-搭建简单的Http服务器"><a href="#三-搭建简单的Http服务器" class="headerlink" title="三. 搭建简单的Http服务器"></a>三. 搭建简单的Http服务器</h2><h3 id="1-开始搭建Http服务器"><a href="#1-开始搭建Http服务器" class="headerlink" title="1. 开始搭建Http服务器"></a>1. 开始搭建Http服务器</h3><ul><li>require加载模块</li><li>监听端口号和网址, 端口号不能使用已经占用的端口比如（80），每个服务器相当于一个app，都需要端口，才能找到入口</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建HTTP服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 加载http模块</span></span><br><span class="line">var http = require('http');</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建http服务器</span></span><br><span class="line"><span class="comment">// 参数: 请求的回调, 当有人访问服务器的时候,就会自动调用回调函数</span></span><br><span class="line">var server = http.createServer(function (request, response) &#123;</span><br><span class="line">    console.log('有人访问了服务器')</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调数据</span></span><br><span class="line">    response.write('Hello, My Love')</span><br><span class="line">    response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 绑定端口</span></span><br><span class="line">server.listen(3030, '192.168.2.11')</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 执行</span></span><br><span class="line">console.log('执行了3030')</span><br></pre></td></tr></table></figure><h3 id="2-开始运行服务器"><a href="#2-开始运行服务器" class="headerlink" title="2. 开始运行服务器"></a>2. 开始运行服务器</h3><ul><li>那么还是要打开终端</li><li>输入: <code>node app.js</code><ul><li><code>app.ja</code>为文件名</li></ul></li></ul><h2 id="四-express搭建服务器"><a href="#四-express搭建服务器" class="headerlink" title="四. express搭建服务器"></a>四. express搭建服务器</h2><h3 id="1-express框架的使用"><a href="#1-express框架的使用" class="headerlink" title="1. express框架的使用"></a>1. express框架的使用</h3><ul><li>引入express模块</li><li>创建express服务器</li><li>get, post请求中: <ul><li>参数一: 请求根路径,若传<code>&#39;/&#39;</code>, 则url为: <code>http://192.168.0.0:3030</code></li><li>若传<code>&#39;/home&#39;</code>, 则url为: <code>http://192.168.0.0:3030/home</code></li><li>参数二: 请求数据的回调函数</li></ul></li><li>监听端口: 默认url为当前电脑的IP地址</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* express的服务器 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建express服务器</span></span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 访问服务器(get或者post)</span></span><br><span class="line"><span class="comment">//参数一: 请求根路径</span></span><br><span class="line"><span class="comment">//3.1 get请求</span></span><br><span class="line">server.get(<span class="string">'/'</span>, function (request, response) &#123;</span><br><span class="line">    <span class="comment">// console.log(request)</span></span><br><span class="line">    response.send('get请求成功')</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2 post请求</span></span><br><span class="line">server.post(<span class="string">'/'</span>, function (request, response) &#123;</span><br><span class="line">    response.send('post请求成功')</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">4040</span>)</span><br><span class="line">console.log('启动4040')</span><br></pre></td></tr></table></figure><h3 id="2-路由"><a href="#2-路由" class="headerlink" title="2. 路由"></a>2. 路由</h3><ul><li>路由:针对不同的URL有不同的处理方式，比如以后会有首页，发现模块，每个模块处理不一样。</li><li>添加url路径,根据不同路径，显示不同内容</li><li>路由句柄(索引):执行完一个函数，在执行下一个 ,因为有时候处理一个请求，需要做很多其他事情，写在一起业务逻辑不好分开,所以多弄几个行数</li><li>函数一定要添加next参数，一定要调用next(),才会进行下面操作，代码使一行一行执行，解释性语言</li><li></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* express的路由 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建express服务器</span></span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 访问服务器(get或者post)</span></span><br><span class="line"><span class="comment">//参数一: 请求根路径</span></span><br><span class="line"><span class="comment">//3.1 get请求</span></span><br><span class="line">server.get(<span class="string">'/'</span>, function (request, response, next) &#123;</span><br><span class="line">    <span class="comment">// console.log(request)</span></span><br><span class="line">    console.log('从据库获取数据')</span><br><span class="line">    next()</span><br><span class="line">&#125;, function (request, response) &#123;</span><br><span class="line">    response.send('get请求成功')</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">4040</span>)</span><br><span class="line">console.log('启动4040')</span><br></pre></td></tr></table></figure><h3 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3. 中间件"></a>3. 中间件</h3><ul><li>优化代码，使代码清晰可读</li><li>原理，发送一个请求给服务器的时候，会被中间件拦截，先由中间件处理，每个中间件都有一个回调函数作为参数,拦截到参数，就会自动执行回调函数。</li><li>注意：有中间件use，会先执行中间件的回调函数，然后才会调用get或者<code>post</code>的回调函数，也就是当监听到请求，先执行中间件，才会到get,post请求。</li><li>use是<code>express</code>注册中间件的方法</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* express的中间件 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建express服务器</span></span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建中间件:use</span></span><br><span class="line"><span class="comment">//截取请求, 拦截回调</span></span><br><span class="line">server.use(<span class="string">'/'</span>, function (request, response, next) &#123;</span><br><span class="line">    console.log('执行中间件')</span><br><span class="line">    <span class="comment">// console.log('获取数据库数据')</span></span><br><span class="line">    console.log(request.query.page)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 访问服务器(get或者post)</span></span><br><span class="line"><span class="comment">//参数一: 请求根路径</span></span><br><span class="line"><span class="comment">//4.1 get请求</span></span><br><span class="line">server.get('/home', function (request, response) &#123;</span><br><span class="line">    <span class="comment">// console.log(request)</span></span><br><span class="line">    response.send('get参数请求成功')</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">4040</span>)</span><br><span class="line">console.log('启动4040')</span><br></pre></td></tr></table></figure><h3 id="4-get请求参数"><a href="#4-get请求参数" class="headerlink" title="4. get请求参数"></a>4. get请求参数</h3><ul><li>request.query会把请求参数包装成字典对象，直接通过点就能获取参数</li><li>这里的请求地址为: <code>http://192.168.2.11:4040/home?page=12</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* express的中间件 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建express服务器</span></span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 访问服务器(get或者post)</span></span><br><span class="line"><span class="comment">//参数一: 请求根路径</span></span><br><span class="line"><span class="comment">//4.1 get请求</span></span><br><span class="line">server.get('/home', function (request, response) &#123;</span><br><span class="line">    <span class="comment">// console.log(request)</span></span><br><span class="line">    console.log(request.query.page)</span><br><span class="line">    response.send('get参数请求成功')</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">4040</span>)</span><br><span class="line">console.log('启动4040')</span><br></pre></td></tr></table></figure><ul><li>输出结果<br>-<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动4040</span><br><span class="line">12</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-post请求参数"><a href="#5-post请求参数" class="headerlink" title="5. post请求参数"></a>5. post请求参数</h3><ul><li>这里先让我们看一下request的部分参数</li><li></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">headers: </span><br><span class="line">   &#123; </span><br><span class="line">   <span class="comment">//请求头</span></span><br><span class="line">     host: '192.168.2.11:4040/home',</span><br><span class="line">     <span class="comment">//保持长连接</span></span><br><span class="line">     connection: 'keep-alive',</span><br><span class="line">     'cache-control': 'max-age=0',</span><br><span class="line">     'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36',</span><br><span class="line">     'upgrade-insecure-requests': '1',</span><br><span class="line">     <span class="comment">//可接受的数据解析方式</span></span><br><span class="line">     accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',</span><br><span class="line">     'accept-encoding': 'gzip, deflate',</span><br><span class="line">     'accept-language': 'zh-CN,zh;q=0.9',</span><br><span class="line">     'if-none-match': 'W/"15-H7HlVCzzVfmRL56LAnLfNUaMM+8"' </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>使用http发送请求，需要设置<code>content-type</code>字段</li><li><code>content-type</code>字段<ul><li><code>application/x-www-form-urlencoded</code>(普通请求，默认一般使用这种)</li><li><code>application/json</code>(带有json格式的参数，需要使用这个，比如参数是字典或者数组)</li><li><code>multipart/form-data</code>(传输文件，文件上传使用这个)</li></ul></li><li>AFN框架中<code>AFHTTPRequestSerializer</code>使用的是<code>application/x-www-form-urlencoded</code>，<code>AFJSONRequestSerializer</code>使用的是<code>application/json</code></li><li><code>Node.JS</code>需要使用<code>body-parser</code>模块,解析post请求参数</li><li>可以采用中间件的方式解析post请求参数<ul><li>注意<code>bodyParser.urlencoded</code>参数是一个字典，需要添加<code>{}`</code>包装</li><li>extends必传参数，是否展开</li></ul></li><li>完整代码示例</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Post请求</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line">var express = require('express')</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 加载模块</span></span><br><span class="line">var bodyParse = require('body-parser')</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建服务器</span></span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 生成解析器</span></span><br><span class="line"><span class="comment">// application/x-www-form-urlencoded</span></span><br><span class="line">var urlencoded = bodyParse.urlencoded(&#123; extends:<span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// application/json</span></span><br><span class="line">var jsonParser = bodyParse.json()</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 中间件: 把请求体参数 存放到request.body</span></span><br><span class="line">server.use('./home', jsonParser)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 请求数据</span></span><br><span class="line"><span class="comment">// request:request请求头,请求体</span></span><br><span class="line">server.post('./home', function (request, response) &#123;</span><br><span class="line">    <span class="comment">//解析post请求参数</span></span><br><span class="line">    console.log(request.body)</span><br><span class="line">    response.send(request.body)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">5050</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><h4 id="Demo地址"><a href="#Demo地址" class="headerlink" title="Demo地址"></a><a href="https://github.com/CoderTitan/WebServer" target="_blank" rel="noopener">Demo地址</a></h4></blockquote><hr><blockquote><p>参考文章:</p><ol><li><a href="http://blog.csdn.net/kaosini/article/details/8089597" target="_blank" rel="noopener">Node.js优缺点</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-nodejs/" target="_blank" rel="noopener">Node.js 究竟是什么？</a></li><li><a href="http://www.expressjs.com.cn/4x/api.html" target="_blank" rel="noopener">Express 4.x API 中文手册</a></li><li>[JavaScript 语言参考]: <a href="https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94).aspx</a></li></ol></blockquote>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Web服务器 </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactNative之TabBariOS和TabNavigator</title>
      <link href="/2018/01/06/ReactNative%E4%B9%8BTabBariOS%E5%92%8CTabNavigator/"/>
      <content type="html"><![CDATA[<p>目前<code>React Native</code>提供的官方的<code>Tab Bar</code>主要是<code>TabBarIOS</code>, 但是该控件目前只支持IOS端</p><a id="more"></a><blockquote><p>效果图</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-ecacb6e40602657c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="底部选项条.png"></p><h2 id="一-TabBarIOS"><a href="#一-TabBarIOS" class="headerlink" title="一. TabBarIOS"></a>一. TabBarIOS</h2><ul><li>底部选项条, 不能跨平台,只能iOS端使用</li><li>添加如下代码, 就会出现底部选项条</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;TabBarIOS&gt;&lt;/TabBarIOS&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-相关属性"><a href="#1-相关属性" class="headerlink" title="1. 相关属性"></a>1. 相关属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">barTintColor='yellow'</span><br><span class="line"><span class="comment">//标签栏的背景颜色</span></span><br><span class="line"></span><br><span class="line">tintColor='#ed7f30'</span><br><span class="line"><span class="comment">//当前被选中的标签图标的颜色</span></span><br><span class="line"></span><br><span class="line">unselectedItemTintColor='#a19a9a'</span><br><span class="line"><span class="comment">//当前没有被选中的标签图标的颜色。仅在iOS 10及以上版本有效</span></span><br><span class="line"></span><br><span class="line">translucent=&#123;<span class="literal">false</span>&#125; </span><br><span class="line"><span class="comment">//一个布尔值，决定标签栏是否需要半透明化</span></span><br><span class="line"><span class="comment">//默认为true, 有透明效果</span></span><br></pre></td></tr></table></figure><h2 id="二-选项卡-TabBarIOS-Item"><a href="#二-选项卡-TabBarIOS-Item" class="headerlink" title="二. 选项卡: TabBarIOS.Item"></a>二. 选项卡: <code>TabBarIOS.Item</code></h2><ul><li><code>TabBarIOS</code>: 只是表示底部的一个选项条</li><li><code>TabBarIOS.Item</code>: 才代表每一个选项卡</li><li><code>TabBarIOS.Item</code>必须包装一个View,作为点击tabBar按钮，切换的View</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;TabBarIOS.Item title='首页'</span><br><span class="line">                icon=&#123;&#123;uri:'btn_home_normal'&#125;&#125;</span><br><span class="line">                selectedIcon=&#123;&#123;uri:'btn_home_selected'&#125;&#125;</span><br><span class="line">                onPress=&#123;()=&gt;&#123;</span><br><span class="line">                    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                        selectedIndex:<span class="number">0</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;&#125;</span><br><span class="line">                selected=&#123;<span class="keyword">this</span>.state.selectedIndex == <span class="number">0</span>&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;View style=&#123;&#123;backgroundColor:'red', flex:1&#125;&#125;/&gt;</span><br><span class="line">&lt;/TabBarIOS.Item&gt;</span><br></pre></td></tr></table></figure><h3 id="1-常用属性"><a href="#1-常用属性" class="headerlink" title="1. 常用属性"></a>1. 常用属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">badge string, number </span><br><span class="line">badge=<span class="string">'我'</span></span><br><span class="line">badge=&#123;<span class="number">12</span>&#125;</span><br><span class="line"><span class="comment">//在图标右上角显示一个红色的气泡, 可接受string和number类型</span></span><br><span class="line"></span><br><span class="line">title string </span><br><span class="line"><span class="comment">//在图标下面显示的标题文字。如果定义了systemIcon属性，这个属性会被忽略。</span></span><br><span class="line"></span><br><span class="line">icon Image.propTypes.source </span><br><span class="line"><span class="comment">//给当前标签指定一个自定义的图标。如果定义了systemIcon属性， 这个属性会被忽略。</span></span><br><span class="line"></span><br><span class="line">selectedIcon Image.propTypes.source </span><br><span class="line"><span class="comment">//当标签被选中的时候显示的自定义图标。如果定义了systemIcon属性，这个属性会被忽略。如果定义了icon而没定义这个属性，在选中的时候图标会染上蓝色。</span></span><br><span class="line"></span><br><span class="line">onPress function </span><br><span class="line"><span class="comment">//当此标签被选中时调用。你应该修改组件的状态来使得selected属性为true</span></span><br><span class="line"></span><br><span class="line">selected <span class="keyword">bool</span> </span><br><span class="line"><span class="comment">//这个属性决定了子视图是否可见。如果你看到一个空白的页面，很可能是没有选中任何一个标签</span></span><br><span class="line"></span><br><span class="line">systemIcon enum('bookmarks', 'contacts', 'downloads', 'favorites', 'featured', 'history', 'more', 'most-recent', 'most-viewed', 'recents', 'search', 'top-rated') </span><br><span class="line"><span class="comment">//一些预定义的系统图标。注意如果你使用了此属性，标题和自定义图标都会被覆盖为系统定义的值。</span></span><br></pre></td></tr></table></figure><ul><li>只要设置对应的tabBarItem的selected为true,就会自动跳转到对应界面<ul><li>注意：tabBarItem的selected属性不能写死，可以搞个角标记录当前选中那个角标</li></ul></li><li>监听tabBarItem的点击，修改selected属性</li><li>相关示例代码</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> App extends Component&lt;&#123;&#125;&gt; &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            selectedIndex:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当一个组件要显示的时候,就会自动调用render,渲染组件</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;TabBarIOS tintColor='#ed7f30'&gt;</span><br><span class="line">                &lt;TabBarIOS.Item title='首页'</span><br><span class="line">                         icon=&#123;&#123;uri:'btn_home_normal'&#125;&#125;</span><br><span class="line">                                selectedIcon=&#123;&#123;uri:'btn_home_selected'&#125;&#125;</span><br><span class="line">                                badge=<span class="string">'我'</span></span><br><span class="line">                                onPress=&#123;()=&gt;&#123;</span><br><span class="line">                                    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                                        selectedIndex:<span class="number">0</span></span><br><span class="line">                                    &#125;)</span><br><span class="line">                                &#125;&#125;</span><br><span class="line">                                selected=&#123;<span class="keyword">this</span>.state.selectedIndex == <span class="number">0</span>&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;&#123;backgroundColor:'red', flex:1&#125;&#125;/&gt;</span><br><span class="line">                &lt;/TabBarIOS.Item&gt;</span><br><span class="line"></span><br><span class="line">                &lt;TabBarIOS.Item title='直播'</span><br><span class="line">                                icon=&#123;&#123;uri:'btn_column_normal'&#125;&#125;</span><br><span class="line">                                selectedIcon=&#123;&#123;uri:'btn_column_selected'&#125;&#125;</span><br><span class="line">                                badge=&#123;<span class="number">12</span>&#125;</span><br><span class="line">                                onPress=&#123;()=&gt;&#123;</span><br><span class="line">                                    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                                        selectedIndex:<span class="number">1</span></span><br><span class="line">                                    &#125;)</span><br><span class="line">                                &#125;&#125;</span><br><span class="line">                                selected=&#123;<span class="keyword">this</span>.state.selectedIndex == <span class="number">1</span>&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;&#123;backgroundColor:'yellow', flex:1&#125;&#125;/&gt;</span><br><span class="line">                &lt;/TabBarIOS.Item&gt;</span><br><span class="line">            &lt;/TabBarIOS&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-TabNavigator"><a href="#三-TabNavigator" class="headerlink" title="三. TabNavigator"></a>三. TabNavigator</h2><ul><li>TabBarIOS只能用于iOS平台，如果在安卓上也需要有TabBar,就不能使用TabBarIOS。</li><li>TabNavigator:一个跨平台的TabBar第三方框架组件，可以用于iOS和安卓平台</li><li><a href="https://github.com/expo/react-native-tab-navigator" target="_blank" rel="noopener">TabNavigator地址</a></li></ul><h3 id="1-安装和导入"><a href="#1-安装和导入" class="headerlink" title="1. 安装和导入"></a>1. 安装和导入</h3><h4 id="1-1-安装第三方框架"><a href="#1-1-安装第三方框架" class="headerlink" title="1-1. 安装第三方框架"></a>1-1. 安装第三方框架</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-native-tab-navigator</span><br></pre></td></tr></table></figure><h4 id="1-2-导入框架"><a href="#1-2-导入框架" class="headerlink" title="1-2. 导入框架"></a>1-2. 导入框架</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import TabNavigator from 'react-native-tab-navigator';</span><br></pre></td></tr></table></figure><h3 id="2-TabNavigator常用属性"><a href="#2-TabNavigator常用属性" class="headerlink" title="2. TabNavigator常用属性"></a>2. TabNavigator常用属性</h3><table><thead><tr><th>属性</th><th>默认值</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>sceneStyle</td><td>inherited</td><td>object (style)</td><td>定义渲染的场景</td></tr><tr><td>tabBarStyle</td><td>inherited</td><td>object (style)</td><td>为TabBar定义样式</td></tr><tr><td>tabBarShadowStyle</td><td>inherited</td><td>object (style)</td><td>为TabBar定义阴影样式</td></tr><tr><td>hidesTabTouch</td><td>false</td><td>boolean</td><td>禁用选项卡的onPress</td></tr></tbody></table><h3 id="3-TabNavigator-Item常用属性"><a href="#3-TabNavigator-Item常用属性" class="headerlink" title="3. TabNavigator.Item常用属性"></a>3. TabNavigator.Item常用属性</h3><table><thead><tr><th>属性</th><th>默认值</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>renderIcon</td><td>none</td><td>function</td><td>选项卡图标</td></tr><tr><td>renderSelectedIcon</td><td>none</td><td>function</td><td>选项卡选中状态图标</td></tr><tr><td>badgeText</td><td>none</td><td>string or number</td><td>图标右上角显示</td></tr><tr><td>title</td><td>none</td><td>string</td><td>tabbar标题</td></tr><tr><td>titleStyle</td><td>inherited</td><td>style</td><td>标题样式</td></tr><tr><td>selectedTitleStyle</td><td>inherited</td><td>style</td><td>选中状态标题样式</td></tr><tr><td>tabStyle</td><td>inherited</td><td>style</td><td>选项卡样式</td></tr><tr><td>hidesTabTouch</td><td>false</td><td>boolean</td><td>是否选中该tabbar</td></tr><tr><td>onPress</td><td>none</td><td>function</td><td>选项卡的点击方法</td></tr><tr><td>allowFontScaling</td><td>false</td><td>boolean</td><td>允许标题的字体缩放</td></tr></tbody></table><ul><li>使用示例</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;TabNavigator&gt;</span><br><span class="line">                &lt;TabNavigator.Item title='首页'</span><br><span class="line">                                   selected=&#123;<span class="keyword">this</span>.state.selectedIndex == <span class="number">0</span>&#125;</span><br><span class="line">                                   titleStyle=&#123;&#123;color:'#9d9d9d'&#125;&#125;</span><br><span class="line">                                   selectedTitleStyle=&#123;&#123;color:'#ed7f30'&#125;&#125;</span><br><span class="line">                                   badgeText='首页'</span><br><span class="line">                                   allowFontScaling=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">                                   renderIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:'btn_home_normal'&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   renderSelectedIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:'btn_home_selected'&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   onPress=&#123;()=&gt;</span><br><span class="line">                                       <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                                           selectedIndex:<span class="number">0</span></span><br><span class="line">                                       &#125;)</span><br><span class="line">                                   &#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;[styles.viewStyle, &#123;backgroundColor:'red'&#125;]&#125;&gt;</span><br><span class="line">                        &lt;Text&gt;首页&lt;/Text&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line">                &lt;/TabNavigator.Item&gt;</span><br><span class="line"></span><br><span class="line">                &lt;TabNavigator.Item title='我的'</span><br><span class="line">                                   selected=&#123;<span class="keyword">this</span>.state.selectedIndex == <span class="number">1</span>&#125;</span><br><span class="line">                                   titleStyle=&#123;&#123;color:'#9d9d9d'&#125;&#125;</span><br><span class="line">                                   selectedTitleStyle=&#123;&#123;color:'#ed7f30'&#125;&#125;</span><br><span class="line">                                   badgeText=&#123;<span class="number">10</span>&#125;</span><br><span class="line">                                   renderIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:'btn_user_normal'&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   renderSelectedIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:'btn_user_selected'&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   onPress=&#123;()=&gt;</span><br><span class="line">                                       <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                                           selectedIndex:<span class="number">1</span></span><br><span class="line">                                       &#125;)</span><br><span class="line">                                   &#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;[styles.viewStyle, &#123;backgroundColor:'green'&#125;]&#125;&gt;</span><br><span class="line">                        &lt;Text&gt;我的&lt;/Text&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/TabNavigator.Item&gt;</span><br><span class="line">            &lt;/TabNavigator&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> TabBariOS </tag>
            
            <tag> TabNavigator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React Native之导航组件NavigatorIOS和Navigator</title>
      <link href="/2018/01/05/React%20Native%E4%B9%8B%E5%AF%BC%E8%88%AA%E7%BB%84%E4%BB%B6NavigatorIOS%E5%92%8CNavigator/"/>
      <content type="html"><![CDATA[<h2 id="一-NavigatorIOS"><a href="#一-NavigatorIOS" class="headerlink" title="一. NavigatorIOS"></a>一. NavigatorIOS</h2><ul><li><code>NavigatorIOS</code>是一个包装<code>UINavigationController</code>，能够实现一个导航堆栈, 且只能在iOS上使用的组件</li><li>它的工作原理与使用本地应用程序<code>UINavigationController</code>的效果完全相同，从<code>UIKIt</code>提供相同的动画和行为<a id="more"></a></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-d1e3e673185be43f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="Navigator.png"></p><h3 id="1-常用属性"><a href="#1-常用属性" class="headerlink" title="1. 常用属性"></a>1. 常用属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//样式, 必须设置&#123;flex:1&#125;, 否则看不到子控件</span></span><br><span class="line">style=&#123;&#123;flex:<span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导航条的背景颜色</span></span><br><span class="line">barTintColor='yellow'</span><br><span class="line"></span><br><span class="line"><span class="comment">//为true , 隐藏导航栏</span></span><br><span class="line">navigationBarHidden=&#123;<span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否隐藏阴影，true／false。</span></span><br><span class="line">shadowHidden=&#123;<span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导航栏上按钮的颜色设置</span></span><br><span class="line">tintColor='black'</span><br><span class="line"></span><br><span class="line"><span class="comment">//导航栏上标题的颜色设置</span></span><br><span class="line">titleTextColor='blue'</span><br><span class="line"></span><br><span class="line"><span class="comment">//导航栏是否是半透明的，true／false。</span></span><br><span class="line">translucent=&#123;<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="2-NavigatorIOS的使用"><a href="#2-NavigatorIOS的使用" class="headerlink" title="2. NavigatorIOS的使用"></a>2. NavigatorIOS的使用</h3><ul><li>必须初始化路由: <code>initialRoute{}</code></li><li>注意:<code>component</code>，需要传入组件，自定义组件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于初始化路由。其参数对象中的各个属性如下：</span></span><br><span class="line">initialRoute：</span><br><span class="line"> &#123;</span><br><span class="line">  component: function, <span class="comment">//加载的视图组件</span></span><br><span class="line">  title: string, <span class="comment">//当前视图的标题</span></span><br><span class="line">  passPros: object, <span class="comment">//传递的数据</span></span><br><span class="line">  backButtonIcon: Image.propTypes.source, <span class="comment">// 后退按钮图标</span></span><br><span class="line">  backButtonTitle: string, <span class="comment">//后退按钮标题</span></span><br><span class="line">  leftButtonIcon: Image.propTypes.soruce, <span class="comment">// 左侧按钮图标</span></span><br><span class="line">  leftButtonTitle: string, <span class="comment">//左侧按钮标题</span></span><br><span class="line">  onLeftButtonPress: function, <span class="comment">//左侧按钮点击事件</span></span><br><span class="line">  rightButtonIcon: Image.propTypes.soruce, <span class="comment">// 右侧按钮图标</span></span><br><span class="line">  rightButtonTitle: string, <span class="comment">//右侧按钮标题</span></span><br><span class="line">  onRightButtonPress: function, <span class="comment">//右侧按钮点击事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用示例</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavigatorIOS initialRoute=&#123;</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//JunNavigatorView: 为自定义的组件</span></span><br><span class="line">            component:JunNavigatorView,</span><br><span class="line">            title: '首页',</span><br><span class="line">            leftButtonTitle:'左按钮',</span><br><span class="line">            rightButtonTitle:'跳转'</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3 id="3-页面间的跳转"><a href="#3-页面间的跳转" class="headerlink" title="3. 页面间的跳转"></a>3. 页面间的跳转</h3><ul><li>获取Navigator，只有它才能跳转</li><li>只要是导航控制器下的组件，都可以通过props获取</li><li><code>this.props.navigator</code></li><li>界面跳转方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pust(route)：<span class="comment">//加载一个新的页面（视图或者路由）并且路由到该页面。</span></span><br><span class="line">pop()：<span class="comment">//返回到上一个页面。</span></span><br><span class="line">popN(n)：<span class="comment">//一次性返回N个页面。当 N=1 时，相当于 pop() 方法的效果。</span></span><br><span class="line">replace(route)：<span class="comment">//替换当前的路由。</span></span><br><span class="line">replacePrevious（route）：<span class="comment">//替换前一个页面的视图并且回退过去。</span></span><br><span class="line">resetTo(route)：<span class="comment">//取代最顶层的路由并且回退过去。</span></span><br><span class="line">popToTop()：<span class="comment">//回到最上层视图。</span></span><br></pre></td></tr></table></figure><ul><li>使用示例</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text onPress=&#123;()=&gt;&#123;</span><br><span class="line">    <span class="keyword">this</span>.props.navigator.push(&#123;</span><br><span class="line">        component:JunTwoView,</span><br><span class="line">        title:'第二页面'</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br><span class="line">&gt;点击跳转到第二个页面&lt;/Text&gt;</span><br></pre></td></tr></table></figure><h2 id="二-Navigator"><a href="#二-Navigator" class="headerlink" title="二. Navigator"></a>二. Navigator</h2><ul><li><code>Navigator</code>很好解决了<code>NavigatorIOS</code>不能跨平台和自定义的问题</li><li>RN开发中通常使用<code>Navigator</code></li><li>Navigator作用：只提供跳转功能，支持iOS,安卓</li><li>导航条需要自定义，需要导航条的界面，自己添加<br>只要一个控件，包装成Navigator就能获取跳转功能</li></ul><h3 id="1-Navigator导入问题"><a href="#1-Navigator导入问题" class="headerlink" title="1. Navigator导入问题"></a>1. Navigator导入问题</h3><ul><li>在0,43版本之前(包括0.43), <code>Navigator</code>在<code>react-native</code>库中</li><li>从0.44版本开始<code>Navigator</code>就被移入了<code>react-native-deprecated-custom-components</code>库中</li><li>使用前,先进入当前项目文件，安装Navigator所在的库</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端输入</span></span><br><span class="line">yarn add react-native-deprecated-custom-components</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面方法可能已经失效(亲测失败)</span></span><br><span class="line">npm install react-native-deprecated-custom-components --save</span><br></pre></td></tr></table></figure><ul><li>下载完成后，导入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Navigator的使用"><a href="#2-Navigator的使用" class="headerlink" title="2. Navigator的使用"></a>2. Navigator的使用</h3><h4 id="2-1-initialRoute：-初始化路由"><a href="#2-1-initialRoute：-初始化路由" class="headerlink" title="2-1. initialRoute： 初始化路由"></a>2-1. <code>initialRoute</code>： 初始化路由</h4><ul><li>定义启动时加载的路由</li><li>路由是导航栏用来识别渲染场景的一个对象</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Navigator initialRoute=&#123;&#123;component: JunOneView&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure><h4 id="2-2-配置场景动画和手势"><a href="#2-2-配置场景动画和手势" class="headerlink" title="2-2. 配置场景动画和手势"></a>2-2. 配置场景动画和手势</h4><ul><li>可选的函数, 设置跳转方向</li><li>会带有两个参数调用，一个是当前的路由，一个是当前的路由栈</li><li>返回一个场景配置对象</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_configureScene(route, routeStack) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator.SceneConfigs.PushFromLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他跳转方向参数</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Navigator.SceneConfigs.PushFromRight (默认)</span><br><span class="line">Navigator.SceneConfigs.FloatFromRight</span><br><span class="line">Navigator.SceneConfigs.FloatFromLeft</span><br><span class="line">Navigator.SceneConfigs.FloatFromBottom</span><br><span class="line">Navigator.SceneConfigs.FloatFromBottomAndroid</span><br><span class="line">Navigator.SceneConfigs.FadeAndroid</span><br><span class="line">Navigator.SceneConfigs.HorizontalSwipeJump</span><br><span class="line">Navigator.SceneConfigs.HorizontalSwipeJumpFromRight</span><br><span class="line">Navigator.SceneConfigs.VerticalUpSwipeJump</span><br><span class="line">Navigator.SceneConfigs.VerticalDownSwipeJump</span><br></pre></td></tr></table></figure><h4 id="2-3-渲染指定路由的场景"><a href="#2-3-渲染指定路由的场景" class="headerlink" title="2-3. 渲染指定路由的场景"></a>2-3. 渲染指定路由的场景</h4><ul><li>必要参数, 调用的参数是路由和导航器</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_renderScene(route, navigator) &#123;</span><br><span class="line">        <span class="comment">// ...扩展符, 作用:如果是对象,就获取对象中所有值,如果是数组,就获取数组中所有值</span></span><br><span class="line">    <span class="keyword">return</span> (&lt;route.component navigator=&#123;navigator&#125; &#123;... route.props&#125;/&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-设置导航尺寸"><a href="#2-4-设置导航尺寸" class="headerlink" title="2-4. 设置导航尺寸"></a>2-4. 设置导航尺寸</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=&#123;&#123;flex:<span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-其他属性或方法"><a href="#3-其他属性或方法" class="headerlink" title="3. 其他属性或方法"></a>3. 其他属性或方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onDidFocus function </span><br><span class="line"><span class="comment">//每当导航切换完成或初始化之后，调用此回调，参数为新场景的路由。</span></span><br><span class="line"></span><br><span class="line">onWillFocus function </span><br><span class="line"><span class="comment">//会在导航切换之前调用，参数为目标路由。</span></span><br></pre></td></tr></table></figure><h2 id="三-延展符"><a href="#三-延展符" class="headerlink" title="三. 延展符"></a>三. 延展符</h2><ul><li>文中用到了一个操作符: <code>...</code>即为延展符</li><li>延展符的作用<ul><li>遍历数组</li><li>遍历对象的属性,一个一个传值给下一个控件</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var arr2 = [<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">arr2.push(...arr1)</span><br><span class="line">console.log(arr2)</span><br><span class="line"><span class="comment">//输出结果: [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><ul><li>作用等同于<code>JavaScript</code>数组中的concat方法</li><li>区别在于<code>concat</code>只能作用于数组</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var arr2 = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2.push(...arr1)</span></span><br><span class="line">arr2 = arr2.concat(arr1)</span><br><span class="line">console.log(arr2)</span><br><span class="line"><span class="comment">//输出结果: [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="关于JavaScript的数组语法-请查看我的另一篇文章JavaScript基本语法01"><a href="#关于JavaScript的数组语法-请查看我的另一篇文章JavaScript基本语法01" class="headerlink" title="关于JavaScript的数组语法, 请查看我的另一篇文章JavaScript基本语法01"></a>关于<code>JavaScript</code>的数组语法, 请查看我的另一篇文章<a href="https://www.titanjun.top/2017/08/09/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%9501/" target="_blank" rel="noopener">JavaScript基本语法01</a></h4></blockquote>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> NavigatorIOS </tag>
            
            <tag> Navigator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactNaive之ScrollView和ListView</title>
      <link href="/2018/01/03/ReactNaive%E4%B9%8BScrollView%E5%92%8CListView/"/>
      <content type="html"><![CDATA[<h2 id="一-ScrollView"><a href="#一-ScrollView" class="headerlink" title="一. ScrollView"></a>一. ScrollView</h2><ul><li>记住ScrollView必须有一个确定的高度才能正常工作，因为它实际上所做的就是将一系列不确定高度的子组件装进一个确定高度的容器（通过滚动操作）</li><li>要给一个ScrollView确定一个高度的话，要么直接给它设置高度（不建议），要么确定所有的父容器都有确定的高度</li></ul><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/4122543-45456c9ba9799576.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="ListView.png"></p><h3 id="1-ScrollView常用的属性"><a href="#1-ScrollView常用的属性" class="headerlink" title="1. ScrollView常用的属性"></a>1. ScrollView常用的属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">horizontal <span class="keyword">bool</span> </span><br><span class="line"><span class="comment">//当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。</span></span><br><span class="line"></span><br><span class="line">showsHorizontalScrollIndicator <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当此属性为true的时候，显示一个水平方向的滚动条。</span></span><br><span class="line">showsVerticalScrollIndicator <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当此属性为true的时候，显示一个垂直方向的滚动条。</span></span><br><span class="line"></span><br><span class="line">alwaysBounceHorizontal <span class="keyword">bool</span> </span><br><span class="line"><span class="comment">//当此属性为true时，水平方向即使内容比滚动视图本身还要小，也可以弹性地拉动一截。当horizontal=&#123;true&#125;时默认值为true，否则为false。</span></span><br><span class="line"></span><br><span class="line">refreshControl element </span><br><span class="line"><span class="comment">//指定RefreshControl组件，用于为ScrollView提供下拉刷新功能</span></span><br><span class="line"></span><br><span class="line">(ios) alwaysBounceVertical <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当此属性为true时，垂直方向即使内容比滚动视图本身还要小，也可以弹性地拉动一截。</span></span><br><span class="line"><span class="comment">//当horizontal=&#123;true&#125;时默认值为false，否则为true。</span></span><br><span class="line"></span><br><span class="line">(ios) automaticallyAdjustContentInsets <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当滚动视图放在一个导航条或者工具条后面的时候，iOS系统是否要自动调整内容的范围。默认值为true。（译注：如果你的ScrollView或ListView的头部出现莫名其妙的空白，尝试将此属性置为false）</span></span><br><span class="line"></span><br><span class="line">(ios) bounces <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当值为true时，如果内容范围比滚动视图本身大，在到达内容末尾的时候，可以弹性地拉动一截。如果为false，尾部的所有弹性都会被禁用，即使alwaysBounce*属性为true。默认值为true。</span></span><br><span class="line"></span><br><span class="line">(ios) bouncesZoom <span class="keyword">bool</span> </span><br><span class="line"><span class="comment">//当值为true时，使用手势缩放内容可以超过min/max的限制，然后在手指抬起之后弹回min/max的缩放比例。否则的话，缩放不能超过限制。</span></span><br><span class="line"></span><br><span class="line">(ios) contentInset &#123;top: number, left: number, bottom: number, right: number&#125; </span><br><span class="line"><span class="comment">//内容范围相对滚动视图边缘的坐标。默认为&#123;0, 0, 0, 0&#125;</span></span><br><span class="line"></span><br><span class="line">(ios) contentOffset PointPropType</span><br><span class="line"><span class="comment">//用来手动设置初始的滚动坐标。默认值为&#123;x: 0, y: 0&#125;</span></span><br><span class="line"></span><br><span class="line">pagingEnabled <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。</span></span><br><span class="line"></span><br><span class="line">scrollEnabled <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//当值为false的时候，内容不能滚动，默认值为true。</span></span><br><span class="line"></span><br><span class="line">(ios) scrollEventThrottle number</span><br><span class="line"><span class="comment">//这个属性控制在滚动过程中，scroll事件被调用的频率（单位是每秒事件数量）。更大的数值能够更及时的跟踪滚动位置，不过可能会带来性能问题，因为更多的信息会通过bridge传递。默认值为0，意味着每次视图被滚动，scroll事件只会被调用一次。</span></span><br><span class="line"></span><br><span class="line">(ios)scrollIndicatorInsets &#123;top: number, left: number, bottom: number, right: number&#125; </span><br><span class="line"><span class="comment">//决定滚动条距离视图边缘的坐标。这个值应该和contentInset一样。默认值为&#123;0, 0, 0, 0&#125;。</span></span><br><span class="line"></span><br><span class="line">(ios) scrollsToTop <span class="keyword">bool</span> </span><br><span class="line"><span class="comment">//当此值为true时，点击状态栏的时候视图会滚动到顶部。默认值为true。</span></span><br><span class="line"></span><br><span class="line">stickyHeaderIndices [number]</span><br><span class="line"><span class="comment">//一个子视图下标的数组，用于决定哪些成员会在滚动之后固定在屏幕顶端。</span></span><br><span class="line"><span class="comment">//举个例子，传递stickyHeaderIndices=&#123;[0]&#125;会让第一个成员固定在滚动视图顶端。</span></span><br><span class="line"><span class="comment">//这个属性不能和horizontal=&#123;true&#125;一起使用。</span></span><br><span class="line"></span><br><span class="line">(ios) maximumZoomScale number </span><br><span class="line"><span class="comment">//允许的最大缩放比例。默认值为1.0。</span></span><br><span class="line"></span><br><span class="line">(ios) minimumZoomScale number </span><br><span class="line"><span class="comment">//允许的最小缩放比例。默认值为1.0。</span></span><br></pre></td></tr></table></figure><h3 id="2-ScrollView常用的方法"><a href="#2-ScrollView常用的方法" class="headerlink" title="2. ScrollView常用的方法"></a>2. ScrollView常用的方法</h3><ul><li>开发中，常需要在滚动的时候做事情，那怎么监听ScrollView滚动</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听滚动开始</span></span><br><span class="line">onMomentumScrollBegin=&#123;<span class="keyword">this</span>._onMomentumScrollBegin.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听滚动结束</span></span><br><span class="line">onMomentumScrollEnd=&#123;<span class="keyword">this</span>._onMomentumScrollEnd.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听开始拖拽</span></span><br><span class="line">onScrollBeginDrag=&#123;<span class="keyword">this</span>._onScrollBeginDrag.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听结束拖拽</span></span><br><span class="line">onScrollEndDrag=&#123;<span class="keyword">this</span>._onScrollEndDrag.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听滚动动画完成</span></span><br><span class="line">onScrollAnimationEnd=&#123;<span class="keyword">this</span>._onScrollAnimationEnd.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line"></span><br><span class="line">onMomentumScrollStart?: function </span><br><span class="line"><span class="comment">//滚动动画开始时调用此函数。</span></span><br><span class="line"></span><br><span class="line">onMomentumScrollEnd?: function </span><br><span class="line"><span class="comment">//滚动动画结束时调用此函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听滚动的时候</span></span><br><span class="line">onScroll=&#123;<span class="keyword">this</span>._onScroll.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置滚动频率,一滚动就监听,需要和onScroll配套使用</span></span><br><span class="line">scrollEventThrottle=&#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scrollTo(y: number | &#123; x?: number, y?: number, animated?: boolean &#125;, x: number, animated: boolean) </span><br><span class="line"><span class="comment">//滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画。</span></span><br><span class="line"><span class="comment">//使用示例:</span></span><br><span class="line">scrollTo(&#123;x: <span class="number">0</span>, y: <span class="number">0</span>, animated: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">scrollToEnd(options?) </span><br><span class="line"><span class="comment">//滚动到视图底部（水平方向的视图则滚动到最右边）。</span></span><br><span class="line"><span class="comment">//加上动画参数 scrollToEnd(&#123;animated: true&#125;)则启用平滑滚动动画，或是调用 scrollToEnd(&#123;animated: false&#125;)来立即跳转。如果不使用参数，则animated选项默认启用。</span></span><br></pre></td></tr></table></figure><h3 id="3-获取原生事件"><a href="#3-获取原生事件" class="headerlink" title="3. 获取原生事件"></a>3. 获取原生事件</h3><ul><li>滚动的时候,会传入一个合成事件作为监听滚动方法的参数，每个方法都会有这个合成事件</li><li>通过合成事件能获取原生事件<code>nativeEvent</code>,原生事件<code>nativeEvent</code>会有我们想要的信息.</li><li>什么是合成事件：在RN中，事件的处理由其内部自己实现的事件系统完成，触发的事件都叫做 合成事件（<code>SyntheticEven</code>t）</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动完成的时候调用</span></span><br><span class="line">_onMomentumScrollEnd(e)&#123;</span><br><span class="line">    <span class="comment">// 获取原生事件</span></span><br><span class="line">    var nativeEvent = e.nativeEvent</span><br><span class="line">    <span class="comment">//获取当前偏移量</span></span><br><span class="line">    var contentX = nativeEvent.contentOffset.x</span><br><span class="line">    <span class="comment">//当前页</span></span><br><span class="line">    var page = contentX / kScreenWidth</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        currentPage:page</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-ListView"><a href="#二-ListView" class="headerlink" title="二. ListView"></a>二. ListView</h2><ul><li>官方文档提示: 在0.46版本开始此组件已过期, 并推荐使用<code>FlatList</code>或<code>SectionList</code>替代, 但是在0.51版本依然可以使用</li><li><code>ListView</code>: 一个核心组件，用于高效地显示一个可以垂直滚动的变化的数据列表</li><li>ListView内部是通过<code>ListViewDataSource</code>这个对象，显示数据，因此使用ListView必须先创建<code>ListViewDataSource</code>对象。</li><li><code>ListViewDataSource</code>构造方法(创建对象):可选择性传入4个参数,描述怎么提取数据，怎么刷新cell</li><li>这些参数：都是函数，当产生对应的事件的时候，会自动执行这些函数.</li></ul><h3 id="1-ListView常用的属性和方法"><a href="#1-ListView常用的属性和方法" class="headerlink" title="1. ListView常用的属性和方法"></a>1. ListView常用的属性和方法</h3><ul><li>ListView可以使用所有ScrollView的属性。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialListSize number </span><br><span class="line"><span class="comment">//指定在组件刚挂载的时候渲染多少行数据。用这个属性来确保首屏显示合适数量的数据，而不是花费太多帧逐步显示出来</span></span><br><span class="line"></span><br><span class="line">dataSource ListViewDataSource </span><br><span class="line"><span class="comment">//ListView.DataSource实例（列表依赖的数据源）</span></span><br></pre></td></tr></table></figure><ul><li><code>ListViewDataSource</code>构造函数可以接受下列四种参数（都是可选）：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getRowData(dataBlob, sectionID, rowID);</span><br><span class="line"><span class="comment">//怎么获取行数据</span></span><br><span class="line">getSectionHeaderData(dataBlob, sectionID);</span><br><span class="line"><span class="comment">//怎么获取每一组头部数据</span></span><br><span class="line">rowHasChanged(prevRowData, nextRowData);</span><br><span class="line"><span class="comment">//决定什么情况行数据才发生改变，当行数据发生改变，就会绘制下一行cell</span></span><br><span class="line">sectionHeaderHasChanged(prevSectionData, nextSectionData);</span><br><span class="line"><span class="comment">//决定什么情况头部数据才发生改变，当行数据发生改变，就会绘制下一行cell</span></span><br></pre></td></tr></table></figure><ul><li><code>ListViewDataSource</code>为<code>ListView</code>组件提供高性能的数据处理和访问。我们需要调用clone方法从原始输入数据中抽取数据来创建<code>ListViewDataSource</code>对象。</li><li>要更新<code>datasource</code>中的数据，请（每次都重新）调用<code>cloneWithRows</code>方法（如果用到了section，则对应<code>cloneWithRowsAndSections</code>方法）clone方法会自动提取新数据并进行逐行对比（使用<code>rowHasChanged</code>方法中的策略），这样<code>ListView</code>就知道哪些行需要重新渲染了</li><li>注意：初始化<code>ListViewDataSource</code>的时候，如果不需要修改提取数据的方式，只需要实现<code>rowHasChanged</code>，告诉什么时候刷新下一行数据.</li><li>注意：默认<code>ListViewDataSource</code>有提取数据方式，可以使用默认的提取方式.</li></ul><h3 id="2-ListView使用步骤"><a href="#2-ListView使用步骤" class="headerlink" title="2. ListView使用步骤"></a>2. ListView使用步骤</h3><ul><li>1). 创建数据源</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建数据源对象</span></span><br><span class="line">var datas = new ListView.DataSource(&#123;</span><br><span class="line">    <span class="comment">//设置数据改变的时候刷新下一行数据</span></span><br><span class="line">    rowHasChanged: (r1, r2)=&gt;&#123;r1 != r2&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 请求数据'</span></span><br><span class="line">var foodArr = require('./Resource/food.json')</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 设置数据</span></span><br><span class="line">datas = datas.cloneWithRows(foodArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 保存数据源</span></span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">    dataArr: datas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2). ListView实现</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView style=&#123;&#123;backgroundColor:'white', marginTop:20&#125;&#125;</span><br><span class="line">    <span class="comment">//设置数据源</span></span><br><span class="line">          dataSource=&#123;<span class="keyword">this</span>.state.dataArr&#125;</span><br><span class="line">    <span class="comment">//渲染哪一行(设置cell样式)</span></span><br><span class="line">          renderRow=&#123;<span class="keyword">this</span>._renderRow.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">          <span class="comment">//设置头部样式</span></span><br><span class="line">          renderHeader=&#123;<span class="keyword">this</span>._renderHeader.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">          <span class="comment">//设置section的头部样式</span></span><br><span class="line">          renderSectionHeader=&#123;<span class="keyword">this</span>._renderSectionHeader.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">          <span class="comment">//设置尾部样式</span></span><br><span class="line">          renderFooter=&#123;<span class="keyword">this</span>._renderFooter.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">          <span class="comment">//设置分割线样式</span></span><br><span class="line">          renderSeparator=&#123;<span class="keyword">this</span>._renderSeparator.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ul><li>3). 相关属性方法介绍<ul><li>renderRow: 设置每行cell样式</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现数据源方法,设置每行cell样式</span></span><br><span class="line"><span class="comment">/*这个方法会自动传入四个参数(rowData,sectionID,rowID,highlightRow)</span></span><br><span class="line"><span class="comment">rowData:当前行数据</span></span><br><span class="line"><span class="comment">sectionID:当前行所在组ID</span></span><br><span class="line"><span class="comment">rowID：哪一行的角标</span></span><br><span class="line"><span class="comment">highlightRow:高亮函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    _renderRow(rowData, sectionID, rowID, highlightRow) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>ListView头部和尾部视图</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头部视图</span></span><br><span class="line"> _renderHeader() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Text&gt;头部视图&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//尾部视图</span></span><br><span class="line"> _renderFooter() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Text&gt;尾部视图&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>renderSectionHeader: 设置每一个section的头部样式</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sectionData: 每一组的头部数据</span></span><br><span class="line"><span class="comment">//sectionID: 组ID</span></span><br><span class="line">_renderSectionHeader(sectionData, sectionID)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ListView分割线</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哪一组,哪一行,相邻行是否高亮</span></span><br><span class="line">   _renderSeparator(sectionID, rowID, adjacentRowHighlighted)  &#123;</span><br><span class="line">       console.log(sectionID,rowID,adjacentRowHighlighted);</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">           &lt;View style=&#123;&#123;height:1,backgroundColor:'black'&#125;&#125;&gt;&lt;/View&gt;</span><br><span class="line">       )</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> ScrollView </tag>
            
            <tag> ListView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift语音和文本的转换</title>
      <link href="/2017/12/10/Swift%E8%AF%AD%E9%9F%B3%E5%92%8C%E6%96%87%E6%9C%AC%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
      <content type="html"><![CDATA[<blockquote><p>谈到语音和文本的转换, 就要说到语音转文本和文本转语音两大技术</p><ul><li>文本转语音是iOS7以后的技术, 用到的是AVFoundation框架</li><li>语音转文本是iOS10以后, 苹果发布的一个<a href="https://developer.apple.com/documentation/speech" target="_blank" rel="noopener">Speech</a>框架</li></ul></blockquote><a id="more"></a><ul><li>下面先介绍一下简单的文本转语音</li><li><a href="https://github.com/CoderTitan/TextAndVoice" target="_blank" rel="noopener">GitHub上Demo地址</a></li><li>项目包括<ul><li>文本转语音</li><li>实时语音转文本</li><li>本地语音转文本</li><li>录音保存本地,转文本</li></ul></li></ul><h2 id="一-文本转语音"><a href="#一-文本转语音" class="headerlink" title="一. 文本转语音"></a>一. 文本转语音</h2><ul><li>文本转语音技术, 简称TTS (是<code>Text To Speech</code>的缩写), <a href="https://developer.apple.com/documentation/avfoundation/speech_synthesis" target="_blank" rel="noopener">语音合成苹果官方文档</a></li><li>是苹果iOS7以后新增的功能, 使用AVFoundation 库</li><li>下面介绍一下需要用到的类</li></ul><h3 id="1-AVSpeechSynthesizer-语音合成器"><a href="#1-AVSpeechSynthesizer-语音合成器" class="headerlink" title="1. AVSpeechSynthesizer: 语音合成器"></a>1. <code>AVSpeechSynthesizer</code>: 语音合成器</h3><h4 id="1-1-属性"><a href="#1-1-属性" class="headerlink" title="1-1. 属性"></a>1-1. 属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否正在语音播放</span></span><br><span class="line">open var isSpeaking: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否停止语音播放</span></span><br><span class="line">open var isPaused: Bool &#123; get &#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1-2. 方法"></a>1-2. 方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//播放语音</span></span><br><span class="line">open func speak(_ utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止语音播放</span></span><br><span class="line">open func stopSpeaking(at boundary: <span class="built_in">AVSpeechBoundary</span>) -&gt; Bool</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停语音播放</span></span><br><span class="line">open func pauseSpeaking(at boundary: <span class="built_in">AVSpeechBoundary</span>) -&gt; Bool</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续语音播放</span></span><br><span class="line">open func continueSpeaking() -&gt; Bool</span><br><span class="line"></span><br><span class="line"><span class="comment">//(iOS10以上, 输出通道)</span></span><br><span class="line">open var outputChannels: [<span class="built_in">AVAudioSessionChannelDescription</span>]?</span><br></pre></td></tr></table></figure><h3 id="2-AVSpeechBoundary"><a href="#2-AVSpeechBoundary" class="headerlink" title="2. AVSpeechBoundary"></a>2. AVSpeechBoundary</h3><ul><li>描述语音可能被暂停或停止的枚举值</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> immediate</span><br><span class="line"><span class="comment">//表示发言应该暂停或立即停止。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> word</span><br><span class="line"><span class="comment">//说完整个词语之后再暂停或者停止</span></span><br></pre></td></tr></table></figure><h3 id="3-AVSpeechUtterance"><a href="#3-AVSpeechUtterance" class="headerlink" title="3. AVSpeechUtterance"></a>3. AVSpeechUtterance</h3><ul><li>可以将文本和成一段语音的类, 或者说就是一段要播放的语音<h4 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3-1. 属性"></a>3-1. 属性</h4></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用的声音</span></span><br><span class="line">open var voice: <span class="built_in">AVSpeechSynthesisVoice</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本属性    </span></span><br><span class="line">open var speechString: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//富文本属性</span></span><br><span class="line">@available(iOS <span class="number">10.0</span>, *)</span><br><span class="line">open var attributedSpeechString: <span class="built_in">NSAttributedString</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说话的速度    </span></span><br><span class="line">open var rate: Float </span><br><span class="line"><span class="comment">//提供了两个语速 AVSpeechUtteranceMinimumSpeechRate和 AVSpeechUtteranceMaximumSpeechRate和AVSpeechUtteranceDefaultSpeechRate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//说话的基线音高, [0.5 - 2] Default = 1   </span></span><br><span class="line">open var pitchMultiplier: Float </span><br><span class="line"></span><br><span class="line"><span class="comment">//说话音量, [0-1] Default = 1</span></span><br><span class="line">open var volume: Float </span><br><span class="line"></span><br><span class="line"><span class="comment">//开始一段语音之前等待的时间</span></span><br><span class="line">open var preUtteranceDelay: TimeInterval </span><br><span class="line"></span><br><span class="line"><span class="comment">//语音合成器在当前语音结束之后处理下一个排队的语音之前需要等待的时间, 默认0.0 </span></span><br><span class="line">open var postUtteranceDelay: TimeInterval</span><br></pre></td></tr></table></figure><h4 id="3-2-初始化方法"><a href="#3-2-初始化方法" class="headerlink" title="3-2. 初始化方法"></a>3-2. 初始化方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public init(string: String)</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">10.0</span>, *)</span><br><span class="line">public init(attributedString string: <span class="built_in">NSAttributedString</span>)</span><br></pre></td></tr></table></figure><h3 id="4-AVSpeechSynthesisVoice"><a href="#4-AVSpeechSynthesisVoice" class="headerlink" title="4. AVSpeechSynthesisVoice"></a>4. AVSpeechSynthesisVoice</h3><ul><li>用于语音合成的独特声音, 主要是不同的语言和地区</li><li>所支持的所有语言种类详见最底部附录</li></ul><h4 id="4-1-相关属性"><a href="#4-1-相关属性" class="headerlink" title="4-1. 相关属性"></a>4-1. 相关属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得当前的语言</span></span><br><span class="line">open var language: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回用户当前语言环境的代码</span></span><br><span class="line">@available(iOS <span class="number">9.0</span>, *)</span><br><span class="line">open var identifier: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">9.0</span>, *)</span><br><span class="line">open var name: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">9.0</span>, *)</span><br><span class="line">open var quality: <span class="built_in">AVSpeechSynthesisVoiceQuality</span> &#123; get &#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-相关方法"><a href="#4-2-相关方法" class="headerlink" title="4-2. 相关方法"></a>4-2. 相关方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init?(language: String?)</span><br><span class="line"><span class="comment">//返回指定语言和语言环境的语音对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> func speechVoices()</span><br><span class="line"><span class="comment">//返回所有可用的语音。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> func currentLanguageCode()</span><br><span class="line"><span class="comment">//返回用户当前语言环境的代码。</span></span><br></pre></td></tr></table></figure><h3 id="5-AVSpeechSynthesizerDelegate代理"><a href="#5-AVSpeechSynthesizerDelegate代理" class="headerlink" title="5. AVSpeechSynthesizerDelegate代理"></a>5. AVSpeechSynthesizerDelegate代理</h3><ul><li>所有代理方法都是支持iOS7.0以上的系统</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始播放</span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, didStart utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//播放完成</span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, didFinish utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停播放</span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, didPause utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续播放</span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, didContinue utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消播放</span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, didCancel utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要播放某一段话  </span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, willSpeakRangeOfSpeechString characterRange: <span class="built_in">NSRange</span>, utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br></pre></td></tr></table></figure><h3 id="6-具体功能的核心代码"><a href="#6-具体功能的核心代码" class="headerlink" title="6. 具体功能的核心代码"></a>6. 具体功能的核心代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: 开始/停止转换</span></span><br><span class="line">extension TextToVoiceController&#123;</span><br><span class="line">    <span class="comment">//开始转换</span></span><br><span class="line">    fileprivate func startTranslattion()&#123;</span><br><span class="line">        <span class="comment">//1. 创建需要合成的声音类型</span></span><br><span class="line">        let voice = <span class="built_in">AVSpeechSynthesisVoice</span>(language: <span class="string">"zh-CN"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 创建合成的语音类</span></span><br><span class="line">        let utterance = <span class="built_in">AVSpeechUtterance</span>(string: textView.text)</span><br><span class="line">        utterance.rate = <span class="built_in">AVSpeechUtteranceDefaultSpeechRate</span></span><br><span class="line">        utterance.voice = voice</span><br><span class="line">        utterance.volume = <span class="number">1</span></span><br><span class="line">        utterance.postUtteranceDelay = <span class="number">0.1</span></span><br><span class="line">        utterance.pitchMultiplier = <span class="number">1</span></span><br><span class="line">        <span class="comment">//开始播放</span></span><br><span class="line">        avSpeech.speak(utterance)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暂停播放</span></span><br><span class="line">    fileprivate func pauseTranslation()&#123;</span><br><span class="line">        avSpeech.pauseSpeaking(at: .immediate)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继续播放</span></span><br><span class="line">    fileprivate func continueSpeek()&#123;</span><br><span class="line">        avSpeech.continueSpeaking()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取消播放</span></span><br><span class="line">    fileprivate func cancleSpeek()&#123;</span><br><span class="line">        avSpeech.stopSpeaking(at: .immediate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-语音转文本"><a href="#二-语音转文本" class="headerlink" title="二. 语音转文本"></a>二. 语音转文本</h2><ul><li>在2016 WWDC大会上，Apple公司介绍了一个很好的语音识别的API,那就是Speech框架</li><li>Speech框架支持iOS10以上系统</li><li><a href="https://developer.apple.com/documentation/speech" target="_blank" rel="noopener">Speech框架官方文档</a></li><li>下面简单介绍一下主要的操作类</li></ul><h3 id="1-SFSpeechRecognizer-语音识别器"><a href="#1-SFSpeechRecognizer-语音识别器" class="headerlink" title="1. SFSpeechRecognizer: 语音识别器"></a>1. <code>SFSpeechRecognizer</code>: 语音识别器</h3><ul><li>这个类是语音识别的操作类</li><li>用于语音识别用户权限的申请，语言环境的设置，语音模式的设置以及向Apple服务发送语音识别的请求</li><li>初始化方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个初始化方法将默认以设备当前的语言环境作为语音识别的语言环境</span></span><br><span class="line">public convenience init?() </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据支持的语言初始化</span></span><br><span class="line">public init?(locale: Locale) </span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">let recognize = SFSpeechRecognizer(locale: Locale(identifier: <span class="string">"zh-CN"</span>))</span><br></pre></td></tr></table></figure><ul><li>类方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有支持的语言</span></span><br><span class="line">open <span class="keyword">class</span> func supportedLocales() -&gt; Set&lt;Locale&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前用户权限状态</span></span><br><span class="line">open <span class="keyword">class</span> func authorizationStatus() -&gt; SFSpeechRecognizerAuthorizationStatus</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请语音识别用户权限</span></span><br><span class="line">open <span class="keyword">class</span> func requestAuthorization(_ handler: @escaping (SFSpeechRecognizerAuthorizationStatus) -&gt; Swift.Void)</span><br></pre></td></tr></table></figure><ul><li>其他属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var isAvailable: Bool</span><br><span class="line"><span class="comment">//指示语音识别器是否可用</span></span><br><span class="line"></span><br><span class="line">var locale: Locale</span><br><span class="line"><span class="comment">//当前语音识别器的语言环境</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> func supportedLocales()</span><br><span class="line"><span class="comment">//获取语音识别所有支持的语言</span></span><br><span class="line"></span><br><span class="line">var queue: OperationQueue</span><br><span class="line"><span class="comment">//语音识别器用于识别任务处理程序和委托消息的队列</span></span><br></pre></td></tr></table></figure><ul><li>相关方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//识别与指定请求关联的音频来源的语音，使用指定的协议返回结果</span></span><br><span class="line">open func recognitionTask(with request: SFSpeechRecognitionRequest, resultHandler: @escaping (SFSpeechRecognitionResult?, Error?) -&gt; Swift.Void) -&gt; SFSpeechRecognitionTask</span><br><span class="line"></span><br><span class="line"><span class="comment">//识别与指定请求关联的音频源的语音, 使用闭包结果</span></span><br><span class="line">open func recognitionTask(with request: SFSpeechRecognitionRequest, delegate: SFSpeechRecognitionTaskDelegate) -&gt; SFSpeechRecognitionTask</span><br></pre></td></tr></table></figure><ul><li>代理</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">weak</span> var delegate: SFSpeechRecognizerDelegate? &#123; get set &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理方法: 监视语音识别器的可用性</span></span><br><span class="line">func speechRecognizer(SFSpeechRecognizer, availabilityDidChange: Bool)</span><br></pre></td></tr></table></figure><h3 id="2-SFSpeechRecognitionRequest"><a href="#2-SFSpeechRecognitionRequest" class="headerlink" title="2. SFSpeechRecognitionRequest"></a>2. <code>SFSpeechRecognitionRequest</code></h3><ul><li>语音识别请求类，需要通过其子类来进行实例化</li><li>相关属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var contextualStrings: [String]</span><br><span class="line"><span class="comment">//一系列应该被识别的语言种类</span></span><br><span class="line"></span><br><span class="line">var shouldReportPartialResults: Bool</span><br><span class="line"><span class="comment">//是否获取每个语句的最终结果。</span></span><br><span class="line"></span><br><span class="line">var taskHint: SFSpeechRecognitionTaskHint</span><br><span class="line"><span class="comment">//正在执行的语音识别的类型</span></span><br><span class="line"></span><br><span class="line">var interactionIdentifier: String?</span><br><span class="line"><span class="comment">//标识与请求关联的识别请求对象的字符串</span></span><br></pre></td></tr></table></figure><ul><li>子类<ul><li><code>SFSpeechURLRecognitionRequest</code></li><li><code>SFSpeechAudioBufferRecognitionRequest</code></li></ul></li></ul><h4 id="2-1-SFSpeechURLRecognitionRequest"><a href="#2-1-SFSpeechURLRecognitionRequest" class="headerlink" title="2-1. SFSpeechURLRecognitionRequest"></a>2-1. <code>SFSpeechURLRecognitionRequest</code></h4><ul><li>通过制定的URL路径识别本地的语音</li><li>方法和属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个语音识别请求，使用指定的URL进行初始化</span></span><br><span class="line">public init(url URL: URL)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的usl路径    </span></span><br><span class="line">open var url: URL &#123; get &#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-SFSpeechAudioBufferRecognitionRequest"><a href="#2-2-SFSpeechAudioBufferRecognitionRequest" class="headerlink" title="2-2. SFSpeechAudioBufferRecognitionRequest"></a>2-2. <code>SFSpeechAudioBufferRecognitionRequest</code></h4><ul><li>识别音频缓冲区中提供的语音的请求</li><li>识别即时语音, 类似于iPhone 中的Siri</li><li><a href="https://developer.apple.com/documentation/speech/sfspeechaudiobufferrecognitionrequest" target="_blank" rel="noopener">官方文档</a></li><li>音频缓冲区相关方法属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func append(<span class="built_in">AVAudioPCMBuffer</span>)</span><br><span class="line"><span class="comment">//将PCM格式的音频追加到识别请求的末尾。</span></span><br><span class="line"></span><br><span class="line">func appendAudioSampleBuffer(<span class="built_in">CMSampleBuffer</span>)</span><br><span class="line"><span class="comment">//将音频附加到识别请求的末尾。</span></span><br><span class="line"></span><br><span class="line">func endAudio()</span><br><span class="line"><span class="comment">//完成输入</span></span><br></pre></td></tr></table></figure><ul><li>获取音频格式</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var nativeAudioFormat: <span class="built_in">AVAudioFormat</span></span><br><span class="line"><span class="comment">//用于最佳语音识别的首选音频格式。</span></span><br></pre></td></tr></table></figure><h3 id="3-SFSpeechRecognitionTask"><a href="#3-SFSpeechRecognitionTask" class="headerlink" title="3. SFSpeechRecognitionTask"></a>3. <code>SFSpeechRecognitionTask</code></h3><ul><li>语音识别请求结果类</li><li>语音识别任务，监视识别进度</li><li>相关方法属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func cancel()</span><br><span class="line"><span class="comment">//取消当前的语音识别任务。</span></span><br><span class="line"></span><br><span class="line">var isCancelled: Bool</span><br><span class="line"><span class="comment">//语音识别任务是否已被取消。</span></span><br><span class="line"></span><br><span class="line">func finish()</span><br><span class="line"><span class="comment">//停止接受新的音频，并完成已接受的音频输入处理</span></span><br><span class="line"></span><br><span class="line">var isFinishing: Bool</span><br><span class="line"><span class="comment">//音频输入是否已停止。</span></span><br><span class="line"></span><br><span class="line">var state: SFSpeechRecognitionTaskState</span><br><span class="line"><span class="comment">//获取语音识别任务的当前状态。</span></span><br><span class="line"></span><br><span class="line">var error: Error?</span><br><span class="line"><span class="comment">//在语音识别任务期间发生的错误的错误对象。</span></span><br></pre></td></tr></table></figure><h4 id="3-1-SFSpeechRecognitionTaskDelegate协议"><a href="#3-1-SFSpeechRecognitionTaskDelegate协议" class="headerlink" title="3-1. SFSpeechRecognitionTaskDelegate协议"></a>3-1. <code>SFSpeechRecognitionTaskDelegate</code>协议</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当开始检测音频源中的语音时首先调用此方法</span></span><br><span class="line">optional public func speechRecognitionDidDetectSpeech(_ task: SFSpeechRecognitionTask)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当识别出一条可用的信息后 会调用</span></span><br><span class="line"><span class="comment">//apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法</span></span><br><span class="line">optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didHypothesizeTranscription transcription: SFTranscription)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当识别完成所有可用的结果后调用</span></span><br><span class="line">optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishRecognition recognitionResult: SFSpeechRecognitionResult)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当不再接受音频输入时调用 即开始处理语音识别任务时调用   </span></span><br><span class="line">optional public func speechRecognitionTaskFinishedReadingAudio(_ task: SFSpeechRecognitionTask)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当语音识别任务被取消时调用    </span></span><br><span class="line">optional public func speechRecognitionTaskWasCancelled(_ task: SFSpeechRecognitionTask)</span><br><span class="line"></span><br><span class="line"><span class="comment">//语音识别任务完成时被调用    </span></span><br><span class="line">optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishSuccessfully successfully: Bool)</span><br></pre></td></tr></table></figure><h3 id="4-SFTranscription"><a href="#4-SFTranscription" class="headerlink" title="4. SFTranscription"></a>4. SFTranscription</h3><ul><li>语音转换后的信息类, 包含改短语音信息的类</li><li>你所说的一句话，可能是有好几个词语拼成的，<code>formattedString</code>就是你所说的那句话，<code>segments</code>就是你所说的你那句话的组成每个单词的集合</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回了一条表达语音译文的字符数据</span></span><br><span class="line">open var formattedString: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的可能的识别数据</span></span><br><span class="line">open var segments: [SFTranscriptionSegment] &#123; get &#125;</span><br></pre></td></tr></table></figure><h3 id="5-SFTranscriptionSegment"><a href="#5-SFTranscriptionSegment" class="headerlink" title="5. SFTranscriptionSegment"></a>5. SFTranscriptionSegment</h3><ul><li>语音转换中的音频节点类</li><li>相关属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前节点识别后的文本信息</span></span><br><span class="line">open var substring: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前节点识别后的文本信息在整体识别语句中的位置</span></span><br><span class="line">open var substringRange: <span class="built_in">NSRange</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前节点的音频时间戳</span></span><br><span class="line">open var timestamp: TimeInterval &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前节点音频的持续时间</span></span><br><span class="line">open var duration: TimeInterval &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可信度/准确度 0-1之间</span></span><br><span class="line">open var confidence: Float &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关于此节点的其他可能的识别结果 </span></span><br><span class="line">open var alternativeSubstrings: [String] &#123; get &#125;</span><br></pre></td></tr></table></figure><h3 id="6-SFSpeechRecognitionResult-语音识别结果类"><a href="#6-SFSpeechRecognitionResult-语音识别结果类" class="headerlink" title="6. SFSpeechRecognitionResult: 语音识别结果类"></a>6. <code>SFSpeechRecognitionResult</code>: 语音识别结果类</h3><ul><li>是语音识别结果的封装，其中包含了许多套平行的识别信息，其每一份识别信息都有可信度属性来描述其准确程度</li><li>该类只是语音识别结果的一个封装，真正的识别信息定义在SFTranscription类中</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准确性最高的识别实例</span></span><br><span class="line">@<span class="built_in">NSCopying</span> open var bestTranscription: SFTranscription &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//识别到的多套语音转换信息数组 其会按照准确度进行排序</span></span><br><span class="line">open var transcriptions: [SFTranscription] &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否已经完成 如果YES 则所有所有识别信息都已经获取完成</span></span><br><span class="line">open var isFinal: Bool &#123; get &#125;</span><br></pre></td></tr></table></figure><h2 id="三-语音识别转文本"><a href="#三-语音识别转文本" class="headerlink" title="三. 语音识别转文本"></a>三. 语音识别转文本</h2><ul><li>添加Speech框架<ul><li><code>import Speech</code></li></ul></li><li><code>info.plist</code>必须添加相关权限</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Privacy - Speech Recognition Usage Description</span><br><span class="line"><span class="comment">//语音识别权限</span></span><br><span class="line"></span><br><span class="line">Privacy - Microphone Usage Description</span><br><span class="line"><span class="comment">//麦克风使用权限</span></span><br></pre></td></tr></table></figure><ul><li>判断用户授权<ul><li>在使用speech framework做语音识别之前，你必须首先得到用户的允许</li><li>因为不仅仅只有本地的ios设备会进行识别，苹果的服务器也会识别</li><li>所有的语音数据都会被传递到苹果的后台进行处理</li><li>因此，获取用户授权是强制必须的</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///语音识别权限认证</span></span><br><span class="line">fileprivate func addSpeechRecordLimit()&#123;</span><br><span class="line">    SFSpeechRecognizer.requestAuthorization &#123; (state) <span class="keyword">in</span></span><br><span class="line">        var isEnable = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">switch</span> state &#123;</span><br><span class="line">        <span class="keyword">case</span> .authorized:</span><br><span class="line">            isEnable = <span class="literal">true</span></span><br><span class="line">            print(<span class="string">"已授权语音识别"</span>)</span><br><span class="line">        <span class="keyword">case</span> .notDetermined:</span><br><span class="line">            isEnable = <span class="literal">false</span></span><br><span class="line">            print(<span class="string">"没有授权语音识别"</span>)</span><br><span class="line">        <span class="keyword">case</span> .denied:</span><br><span class="line">            isEnable = <span class="literal">false</span></span><br><span class="line">            print(<span class="string">"用户已拒绝访问语音识别"</span>)</span><br><span class="line">        <span class="keyword">case</span> .restricted:</span><br><span class="line">            isEnable = <span class="literal">false</span></span><br><span class="line">            print(<span class="string">"不能在该设备上进行语音识别"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.recordBtn.isEnabled = isEnable</span><br><span class="line">            <span class="keyword">self</span>.recordBtn.backgroundColor = isEnable ? <span class="built_in">UIColor</span>(red: <span class="number">255</span>/<span class="number">255.0</span>, green: <span class="number">64</span>/<span class="number">255.0</span>, blue: <span class="number">64</span>/<span class="number">255.0</span>, alpha: <span class="number">1</span>) : <span class="built_in">UIColor</span>.lightGray</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再然后就是初始化相关请求和识别类处理相关语音</li><li><a href="https://github.com/CoderTitan/TextAndVoice" target="_blank" rel="noopener">详细代码参考GitHub的Demo地址</a></li></ul><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><h3 id="AVSpeechSynthesisVoice支持的语言种类"><a href="#AVSpeechSynthesisVoice支持的语言种类" class="headerlink" title="AVSpeechSynthesisVoice支持的语言种类"></a><code>AVSpeechSynthesisVoice</code>支持的语言种类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">ar-SA  沙特阿拉伯（阿拉伯文）</span><br><span class="line"></span><br><span class="line">en-ZA, 南非（英文）</span><br><span class="line"></span><br><span class="line">nl-BE, 比利时（荷兰文）</span><br><span class="line"></span><br><span class="line">en-AU, 澳大利亚（英文）</span><br><span class="line"></span><br><span class="line">th-TH, 泰国（泰文）</span><br><span class="line"></span><br><span class="line">de-DE, 德国（德文）</span><br><span class="line"></span><br><span class="line">en-US, 美国（英文）</span><br><span class="line"></span><br><span class="line">pt-BR, 巴西（葡萄牙文）</span><br><span class="line"></span><br><span class="line">pl-PL, 波兰（波兰文）</span><br><span class="line"></span><br><span class="line">en-IE, 爱尔兰（英文）</span><br><span class="line"></span><br><span class="line">el-GR, 希腊（希腊文）</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span>-ID, 印度尼西亚（印度尼西亚文）</span><br><span class="line"></span><br><span class="line">sv-SE, 瑞典（瑞典文）</span><br><span class="line"></span><br><span class="line">tr-TR, 土耳其（土耳其文）</span><br><span class="line"></span><br><span class="line">pt-PT, 葡萄牙（葡萄牙文）</span><br><span class="line"></span><br><span class="line">ja-JP, 日本（日文）</span><br><span class="line"></span><br><span class="line">ko-KR, 南朝鲜（朝鲜文）</span><br><span class="line"></span><br><span class="line">hu-HU, 匈牙利（匈牙利文）</span><br><span class="line"></span><br><span class="line">cs-CZ, 捷克共和国（捷克文）</span><br><span class="line"></span><br><span class="line">da-DK, 丹麦（丹麦文）</span><br><span class="line"></span><br><span class="line">es-MX, 墨西哥（西班牙文）</span><br><span class="line"></span><br><span class="line">fr-CA, 加拿大（法文）</span><br><span class="line"></span><br><span class="line">nl-NL, 荷兰（荷兰文）</span><br><span class="line"></span><br><span class="line">fi-FI, 芬兰（芬兰文）</span><br><span class="line"></span><br><span class="line">es-ES, 西班牙（西班牙文）</span><br><span class="line"></span><br><span class="line">it-IT, 意大利（意大利文）</span><br><span class="line"></span><br><span class="line">he-IL, 以色列（希伯莱文，阿拉伯文）</span><br><span class="line"></span><br><span class="line">no-<span class="literal">NO</span>, 挪威（挪威文）</span><br><span class="line"></span><br><span class="line">ro-RO, 罗马尼亚（罗马尼亚文）</span><br><span class="line"></span><br><span class="line">zh-HK, 香港（中文）</span><br><span class="line"></span><br><span class="line">zh-TW, 台湾（中文）</span><br><span class="line"></span><br><span class="line">sk-SK, 斯洛伐克（斯洛伐克文）</span><br><span class="line"></span><br><span class="line">zh-CN, 中国（中文）</span><br><span class="line"></span><br><span class="line">ru-RU, 俄罗斯（俄文）</span><br><span class="line"></span><br><span class="line">en-GB, 英国（英文）</span><br><span class="line"></span><br><span class="line">fr-FR, 法国（法文）</span><br><span class="line"></span><br><span class="line">hi-IN  印度（印度文）</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Speech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift之Vision 图像识别框架</title>
      <link href="/2017/11/29/Swift%E4%B9%8BVision%20%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E6%A1%86%E6%9E%B6/"/>
      <content type="html"><![CDATA[<ul><li>2017年苹果大大又推出了新机型iPhone 8和iPhone 8Plus, 这还不是重点, 重点是那一款价值9000RMB的iPhone X, 虽说网上吐槽声从未停止过, 但是我觉得还是不错的哈!</li><li>软件方面, 苹果大大也推出了iOS 11, 经本人iPhone 7手机亲测, 耗电快外加通知栏改不完的bug</li><li>当然了随着iOS 11的推出, 也随之推出了一些新的API，如：<a href="https://developer.apple.com/documentation/arkit" target="_blank" rel="noopener"><code>ARKit</code></a> 、<a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener"><code>Core ML</code></a>、<a href="https://developer.apple.com/documentation/fileprovider" target="_blank" rel="noopener"><code>FileProvider</code></a>、<a href="https://developer.apple.com/documentation/identitylookup" target="_blank" rel="noopener"><code>IdentityLookup</code></a> 、<a href="https://developer.apple.com/documentation/corenfc" target="_blank" rel="noopener"><code>Core NFC</code></a>、<a href="https://developer.apple.com/documentation/vision" target="_blank" rel="noopener"><code>Vison</code></a> 等。</li><li>这里我们还要说的就是Apple 在 WWDC 2017 推出的图像识别框架–<code>Vison</code><a href="https://developer.apple.com/documentation/vision" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://github.com/coderQuanjun/JunVisionFace" target="_blank" rel="noopener">Demo地址</a></li></ul><a id="more"></a><h2 id="一-Vision应用场景"><a href="#一-Vision应用场景" class="headerlink" title="一. Vision应用场景"></a>一. Vision应用场景</h2><ul><li><code>Face Detection and Recognition</code> : 人脸检测<ul><li>支持检测笑脸、侧脸、局部遮挡脸部、戴眼镜和帽子等场景，可以标记出人脸的矩形区域</li><li>可以标记出人脸和眼睛、眉毛、鼻子、嘴、牙齿的轮廓，以及人脸的中轴线</li></ul></li><li><code>Image Alignment Analysis</code>: 图像对比分析</li><li><code>Barcode Detection</code>: 二维码/条形码检测<ul><li>用于查找和识别图像中的条码</li><li>检测条形码信息</li></ul></li><li><code>Text Detection</code>: 文字检测<ul><li>查找图像中可见文本的区域</li><li>检测文本区域的信息</li></ul></li><li><code>Object Detection and Tracking</code>: 目标跟踪<ul><li>脸部，矩形和通用模板</li></ul></li></ul><h2 id="二-Vision支持的图片类型"><a href="#二-Vision支持的图片类型" class="headerlink" title="二. Vision支持的图片类型"></a>二. Vision支持的图片类型</h2><h3 id="1-Objective-C中"><a href="#1-Objective-C中" class="headerlink" title="1. Objective-C中"></a>1. Objective-C中</h3><ul><li><code>CVPixelBufferRef</code></li><li><code>CGImageRef</code></li><li><code>CIImage</code></li><li><code>NSURL</code></li><li><code>NSData</code></li></ul><h3 id="2-Swift中"><a href="#2-Swift中" class="headerlink" title="2. Swift中"></a>2. Swift中</h3><ul><li><code>CVPixelBuffer</code></li><li><code>CGImage</code></li><li><code>CIImage</code></li><li><code>URL</code></li><li><code>Data</code></li></ul><blockquote><p>具体详情可在<code>Vision.framework</code>的<code>VNImageRequestHandler.h</code>文件中查看</p></blockquote><h2 id="三-Vision之API介绍"><a href="#三-Vision之API介绍" class="headerlink" title="三. Vision之API介绍"></a>三. Vision之API介绍</h2><ul><li>使用在<code>vision</code>的时候，我们首先需要明确自己需要什么效果，然后根据想要的效果来选择不同的类</li><li>给各种功能的 <code>Request</code> 提供给一个 <code>RequestHandler</code></li><li><code>Handler</code> 持有需要识别的图片信息，并将处理结果分发给每个 <code>Request</code> 的 <code>completion Block</code> 中</li><li>可以从 <code>results</code> 属性中得到 <code>Observation</code> 数组</li><li><code>observations</code>数组中的内容根据不同的request请求返回了不同的<code>observation</code></li><li>每种<code>Observation</code>有<code>boundingBox</code>，<code>landmarks</code>等属性，存储的是识别后物体的坐标，点位等</li><li>我们拿到坐标后，就可以进行一些UI绘制。</li></ul><h3 id="1-RequestHandler处理请求对象"><a href="#1-RequestHandler处理请求对象" class="headerlink" title="1. RequestHandler处理请求对象"></a>1. <code>RequestHandler</code>处理请求对象</h3><ul><li><code>VNImageRequestHandler</code>: 处理与单个图像有关的一个或多个图像分析请求的对象<ul><li>一般情况下都是用该类处理识别请求</li><li>初始化方法支持<code>CVPixelBuffer</code>, <code>CGImage</code>, <code>CIImage</code>, <code>URL</code>, <code>Data</code></li></ul></li><li><code>VNSequenceRequestHandler</code>: 处理与多个图像序列有关的图像分析请求的对象<ul><li>目前我在处理物体跟踪的时候使用该类</li><li>初始化方法同上</li></ul></li></ul><h3 id="2-VNRequest介绍"><a href="#2-VNRequest介绍" class="headerlink" title="2. VNRequest介绍"></a>2. VNRequest介绍</h3><ul><li><code>VNRequest</code>: 图像分析请求的抽象类, 继承于<code>NSObject</code></li><li><code>VNBaseImageRequest</code>: 专注于图像的特定部分的分析请求</li><li>具体分析请求类如下: </li><li><img src="http://upload-images.jianshu.io/upload_images/4122543-b58783bec9d07551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VNImageBasedRequest.png"></li></ul><h3 id="3-VNObservation检测对象"><a href="#3-VNObservation检测对象" class="headerlink" title="3. VNObservation检测对象"></a>3. <code>VNObservation</code>检测对象</h3><ul><li><code>VNObservation</code>: 图像分析结果的抽象类, 继承与<code>NSObject</code></li><li>图像检测结果的相关处理类如下:</li><li><img src="http://upload-images.jianshu.io/upload_images/4122543-c0b83aa723e149ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VNObservation.png"></li></ul><h2 id="四-实战演练"><a href="#四-实战演练" class="headerlink" title="四. 实战演练"></a>四. 实战演练</h2><h3 id="1-文本检测"><a href="#1-文本检测" class="headerlink" title="1. 文本检测"></a>1. 文本检测</h3><ul><li>方式一: 识别出具体的每一个字体的位置信息</li><li>方式二: 识别一行字体的位置信息</li><li>如图效果:</li><li><img src="http://upload-images.jianshu.io/upload_images/4122543-0c09426c80013322.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="WechatIMG3.jpeg"> </li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-8b970c464c26ffb0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="WechatIMG5.jpeg"></p><h4 id="1-1-现将图片转成初始化VNImageRequestHandler对象时-可接受的的CIImage"><a href="#1-1-现将图片转成初始化VNImageRequestHandler对象时-可接受的的CIImage" class="headerlink" title="1.1 现将图片转成初始化VNImageRequestHandler对象时, 可接受的的CIImage"></a>1.1 现将图片转成初始化<code>VNImageRequestHandler</code>对象时, 可接受的的<code>CIImage</code></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 转成ciimage</span></span><br><span class="line">guard let ciImage = <span class="built_in">CIImage</span>(image: image) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-创建处理请求的handle"><a href="#1-2-创建处理请求的handle" class="headerlink" title="1.2 创建处理请求的handle"></a>1.2 创建处理请求的handle</h4><ul><li>参数一: 图片类型</li><li>参数二: 字典类型, 有默认值为[:]</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let requestHandle = VNImageRequestHandler(ciImage: ciImage, options: [:])</span><br></pre></td></tr></table></figure><h4 id="1-3-创建回调闭包"><a href="#1-3-创建回调闭包" class="headerlink" title="1.3 创建回调闭包"></a>1.3 创建回调闭包</h4><ul><li>两个参数, 无返回值</li><li><code>VNRequest</code>: 是所有请求Request的父类</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public typealias VNRequestCompletionHandler = (VNRequest, Error?) -&gt; Swift.Void</span><br></pre></td></tr></table></figure><ul><li>具体代码如下: </li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 设置回调</span></span><br><span class="line">let completionHandle: VNRequestCompletionHandler = &#123; request, error <span class="keyword">in</span></span><br><span class="line">    let observations = request.results</span><br><span class="line">    <span class="comment">//识别出来的对象数组    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-创建识别请求"><a href="#1-4-创建识别请求" class="headerlink" title="1.4 创建识别请求"></a>1.4 创建识别请求</h4><ul><li>两种初始化方式</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参数</span></span><br><span class="line">public convenience init()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//闭包参数</span></span><br><span class="line">public init(completionHandler: Vision.VNRequestCompletionHandler? = <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><ul><li>这里使用带闭包的初始化方式</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let baseRequest = VNDetectTextRectanglesRequest(completionHandler: completionHandle)</span><br></pre></td></tr></table></figure><ul><li>属性设置(是否识别具体的每一个文字)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置识别具体文字</span></span><br><span class="line">baseRequest.setValue(<span class="literal">true</span>, forKey: <span class="string">"reportCharacterBoxes"</span>)</span><br></pre></td></tr></table></figure><ul><li>不设置该属性, 识别出来的是一行文字</li></ul><h4 id="1-5-发送请求"><a href="#1-5-发送请求" class="headerlink" title="1.5 发送请求"></a>1.5 发送请求</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open func perform(_ requests: [VNRequest]) throws</span><br></pre></td></tr></table></figure><ul><li>该方法会抛出一个异常错误</li><li>在连续不断(摄像头扫描)发送请求过程中, 必须在子线程执行该方法, 否则会造成线程堵塞</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6. 发送请求</span></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        try requestHandle.perform([baseRequest])</span><br><span class="line">    &#125;catch&#123;</span><br><span class="line">        print(<span class="string">"Throws：\(error)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-处理识别的Observations对象"><a href="#1-6-处理识别的Observations对象" class="headerlink" title="1.6 处理识别的Observations对象"></a>1.6 处理识别的<code>Observations</code>对象</h4><ul><li>识别出来的<code>results</code>是<code>[Any]?</code>类型</li><li>根据<code>boundingBox</code>属性可以获取到对应的文本区域的尺寸</li><li>需要注意的是:<ul><li><code>boundingBox</code>得到的是相对iamge的比例尺寸, 都是小于1的</li><li>Y轴坐标于UIView坐标系是相反的</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 获取识别到的VNTextObservation</span></span><br><span class="line">guard let boxArr = observations as? [VNTextObservation] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2. 创建rect数组</span></span><br><span class="line">var bigRects = [<span class="built_in">CGRect</span>](), smallRects = [<span class="built_in">CGRect</span>]()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//3. 遍历识别结果</span></span><br><span class="line"><span class="keyword">for</span> boxObj <span class="keyword">in</span> boxArr &#123;</span><br><span class="line">    <span class="comment">// 3.1尺寸转换</span></span><br><span class="line">    <span class="comment">//获取一行文本的区域位置</span></span><br><span class="line">    bigRects.append(convertRect(boxObj.boundingBox, image))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取</span></span><br><span class="line">    guard let rectangleArr = boxObj.characterBoxes <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">    <span class="keyword">for</span> rectangle <span class="keyword">in</span> rectangleArr&#123;</span><br><span class="line">        <span class="comment">//3. 得到每一个字体的的尺寸</span></span><br><span class="line">        let boundBox = rectangle.boundingBox</span><br><span class="line">        smallRects.append(convertRect(boundBox, image))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>坐标转换</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// image坐标转换</span></span><br><span class="line">fileprivate func convertRect(_ rectangleRect: <span class="built_in">CGRect</span>, _ image: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">CGRect</span> &#123;</span><br><span class="line"><span class="comment">//此处是将Image的实际尺寸转化成imageView的尺寸</span></span><br><span class="line">    let imageSize = image.scaleImage()</span><br><span class="line">    let w = rectangleRect.width * imageSize.width</span><br><span class="line">    let h = rectangleRect.height * imageSize.height</span><br><span class="line">    let x = rectangleRect.minX * imageSize.width</span><br><span class="line">    <span class="comment">//该Y坐标与UIView的Y坐标是相反的</span></span><br><span class="line">    let y = (<span class="number">1</span> - rectangleRect.minY) * imageSize.height - h</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: x, y: y, width: w, height: h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-矩形识别和静态人脸识别"><a href="#2-矩形识别和静态人脸识别" class="headerlink" title="2. 矩形识别和静态人脸识别"></a>2. 矩形识别和静态人脸识别</h3><ul><li>识别图像中的矩形</li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-05e6a9cc6c193b1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511935758595.jpg"></p></li><li><p>静态人脸识别</p></li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-e5faf93cebae945e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511936019734.jpg"></p></li><li><p>主要核心代码</p></li><li></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 转成ciimage</span></span><br><span class="line">guard let ciImage = <span class="built_in">CIImage</span>(image: image) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2. 创建处理request</span></span><br><span class="line">let requestHandle = VNImageRequestHandler(ciImage: ciImage, options: [:])</span><br><span class="line">        </span><br><span class="line"><span class="comment">//3. 创建baseRequest</span></span><br><span class="line"><span class="comment">//大多数识别请求request都继承自VNImageBasedRequest</span></span><br><span class="line">var baseRequest = VNImageBasedRequest()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4. 设置回调</span></span><br><span class="line">let completionHandle: VNRequestCompletionHandler = &#123; request, error <span class="keyword">in</span></span><br><span class="line">    let observations = request.results</span><br><span class="line">    <span class="keyword">self</span>.handleImageObservable(type: type, image: image, observations, completeBack)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//5. 创建识别请求</span></span><br><span class="line"><span class="keyword">switch</span> type &#123;</span><br><span class="line"><span class="keyword">case</span> .rectangle:</span><br><span class="line">    baseRequest = VNDetectRectanglesRequest(completionHandler: completionHandle)</span><br><span class="line"><span class="keyword">case</span> .staticFace:</span><br><span class="line">    baseRequest = VNDetectFaceRectanglesRequest(completionHandler: completionHandle)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理识别的observation</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 矩形检测</span></span><br><span class="line">fileprivate func rectangleDectect(_ observations: [Any]?, image: <span class="built_in">UIImage</span>, _ complecHandle: JunDetectHandle)&#123;</span><br><span class="line">    <span class="comment">//1. 获取识别到的VNRectangleObservation</span></span><br><span class="line">    guard let boxArr = observations as? [VNRectangleObservation] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//2. 创建rect数组</span></span><br><span class="line">    var bigRects = [<span class="built_in">CGRect</span>]()</span><br><span class="line">    <span class="comment">//3. 遍历识别结果</span></span><br><span class="line">    <span class="keyword">for</span> boxObj <span class="keyword">in</span> boxArr &#123;</span><br><span class="line">        <span class="comment">// 3.1</span></span><br><span class="line">        bigRects.append(convertRect(boxObj.boundingBox, image))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 回调结果</span></span><br><span class="line">    complecHandle(bigRects, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态人脸识别需要将<code>observation</code>转成<code>VNFaceObservation</code></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">guard let boxArr = observations as? [VNFaceObservation] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-条码识别"><a href="#3-条码识别" class="headerlink" title="3. 条码识别"></a>3. 条码识别</h3><p><img src="http://upload-images.jianshu.io/upload_images/4122543-9f199a027f186a5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511936988374.jpg"></p><ul><li>这里请求的步骤与矩形识别相同, 这里不再赘述</li><li>需要注意的是,在初始化request的时候需要设一个置可识别的条码类型参数</li><li>这里先看一下<code>VNDetectBarcodesRequest</code>的两个参数</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的可识别的条码类型(需要直接用class调用)</span></span><br><span class="line">open <span class="keyword">class</span> var supportedSymbologies: [VNBarcodeSymbology] &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置可识别的条码类型</span></span><br><span class="line">open var symbologies: [VNBarcodeSymbology]</span><br></pre></td></tr></table></figure><ul><li>此处设置可识别到的条码类型为, 该请求支持是别的所有类型, 如下</li><li>注意<code>supportedSymbologies</code>参数的调用方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let request = VNDetectBarcodesRequest(completionHandler: completionHandle)</span><br><span class="line">request.symbologies = VNDetectBarcodesRequest.supportedSymbologies</span><br></pre></td></tr></table></figure><ul><li>条码识别不但能识别条码的位置信息, 还可以识别出条码的相关信息, 这里以二维码为例</li><li>这里需要将识别的<code>observations</code>转成<code>[VNBarcodeObservation]</code></li><li><code>VNBarcodeObservation</code>有三个属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条码类型: qr, code128....等等</span></span><br><span class="line">open var symbology: VNBarcodeSymbology &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条码的相关信息</span></span><br><span class="line">open var barcodeDescriptor: <span class="built_in">CIBarcodeDescriptor</span>? &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是二维码, 则是二维码的网址链接    </span></span><br><span class="line">open var payloadStringValue: String? &#123; get &#125;</span><br></pre></td></tr></table></figure><ul><li>如上述图片识别出来的<code>payloadStringValue</code>参数则是小编的<a href="http://www.jianshu.com/u/5bd5e9ed569e" target="_blank" rel="noopener">简书地址</a></li><li>下面是以上述图片的二维码为例处理的<code>CIBarcodeDescriptor</code>对象</li><li>有兴趣的可以仔细研究研究</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 二维码信息处理</span></span><br><span class="line">fileprivate func qrCodeHandle(barCode: <span class="built_in">CIBarcodeDescriptor</span>?)&#123;</span><br><span class="line">    <span class="comment">//1. 转成对应的条码对象</span></span><br><span class="line">    guard let code = barCode as? <span class="built_in">CIQRCodeDescriptor</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 解读条码信息</span></span><br><span class="line">    let level = code.errorCorrectionLevel.hashValue</span><br><span class="line">    let version = code.symbolVersion</span><br><span class="line">    let mask = code.maskPattern</span><br><span class="line">    let data = code.errorCorrectedPayload</span><br><span class="line">    let dataStr = String(data: data, encoding: .utf8)</span><br><span class="line">    print(<span class="string">"这是二维码信息--"</span>, level, <span class="string">"---"</span>, version, <span class="string">"----"</span>, mask, <span class="string">"---"</span>, dataStr ?? <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-人脸特征识别"><a href="#4-人脸特征识别" class="headerlink" title="4. 人脸特征识别"></a>4. 人脸特征识别</h3><ul><li>可识别出人脸的轮廓, 眼睛, 鼻子, 嘴巴等具体位置</li><li><img src="http://upload-images.jianshu.io/upload_images/4122543-895670df5fd8e2c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511944652200.jpg"></li></ul><ul><li><code>VNFaceLandmarks2D</code>介绍</li><li></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 脸部轮廓</span></span><br><span class="line">var faceContour: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 左眼, 右眼</span></span><br><span class="line">var leftEye: VNFaceLandmarkRegion2D?</span><br><span class="line">var rightEye: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 左睫毛, 右睫毛</span></span><br><span class="line">var leftEyebrow: VNFaceLandmarkRegion2D?</span><br><span class="line">var rightEyebrow: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 左眼瞳, 右眼瞳</span></span><br><span class="line">var leftPupil: VNFaceLandmarkRegion2D?</span><br><span class="line">var rightPupil: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 鼻子, 鼻嵴, 正中线</span></span><br><span class="line">var nose: VNFaceLandmarkRegion2D?</span><br><span class="line">var noseCrest: VNFaceLandmarkRegion2D?</span><br><span class="line">var medianLine: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 外唇, 内唇</span></span><br><span class="line">var outerLips: VNFaceLandmarkRegion2D?</span><br><span class="line">var innerLips: VNFaceLandmarkRegion2D?</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//某一部位所有的像素点</span><br><span class="line">@nonobjc public var normalizedPoints: [CGPoint] &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//某一部位的所有像素点的个数</span><br><span class="line">open var pointCount: Int &#123; get &#125;</span><br></pre></td></tr></table></figure><ul><li>将所有的像素点坐标转换成image对应的尺寸坐标</li><li>使用图像上下文, 对应部位画线</li><li>在UIView中重写<code>func draw(_ rect: CGRect)</code>方法</li><li></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.1 获取当前上下文</span></span><br><span class="line">let content = <span class="built_in">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.2 设置填充颜色(setStroke设置描边颜色)</span></span><br><span class="line"><span class="built_in">UIColor</span>.green.set()</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.3 设置宽度</span></span><br><span class="line">content?.setLineWidth(<span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.4. 设置线的类型(连接处)</span></span><br><span class="line">content?.setLineJoin(.round)</span><br><span class="line">content?.setLineCap(.round)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.5. 设置抗锯齿效果</span></span><br><span class="line">content?.setShouldAntialias(<span class="literal">true</span>)</span><br><span class="line">content?.setAllowsAntialiasing(<span class="literal">true</span>)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.6 开始绘制</span></span><br><span class="line">content?.addLines(between: pointArr)</span><br><span class="line">content?.drawPath(using: .stroke)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.7 结束绘制</span></span><br><span class="line">content?.strokePath()</span><br></pre></td></tr></table></figure><h3 id="5-动态人脸识别和实时动态添加"><a href="#5-动态人脸识别和实时动态添加" class="headerlink" title="5. 动态人脸识别和实时动态添加"></a>5. 动态人脸识别和实时动态添加</h3><blockquote><p>由于真机不好录制gif图(尝试了一下, 效果不是很好, 放弃了), 想看效果的朋友<a href="https://github.com/coderQuanjun/JunVisionFace" target="_blank" rel="noopener">下载源码</a>真机运行吧</p><ul><li>这里提供一张<a href="http://upload-images.jianshu.io/upload_images/4122543-e390e4107c0b811b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener">可供扫描的图片</a></li></ul></blockquote><ul><li><code>request</code>的初始化这里就不做介绍了, 说一下<code>handle</code>的初始化方法<ul><li><code>CVPixelBuffer</code>: 扫描实时输出的对象</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建处理请求</span></span><br><span class="line">let faceHandle = VNImageRequestHandler(cvPixelBuffer: pixelBuffer, options: [:])</span><br></pre></td></tr></table></figure><ul><li>主要强调一点, 相机扫描, 获取实时图像的过程, 必须在子线程执行, 否在会堵塞线程, 整个app失去响应, 亲自踩过的坑</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        try faceHandle.perform([baseRequest])</span><br><span class="line">    &#125;catch&#123;</span><br><span class="line">        print(<span class="string">"Throws：\(error)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扫描结果处理"><a href="#扫描结果处理" class="headerlink" title="扫描结果处理"></a>扫描结果处理</h4><ul><li>动态人脸识别和静态人脸识别不同的地方就是, 动态实时刷新, 更新UI, 所以处理结果的方法相同</li><li>动态添加: 这里处理方式是添加一个眼镜效果</li><li>这里需要获取到两只眼睛的位置和宽度<ul><li>先获取到左右眼的所有的像素点和像素点的个数</li><li>遍历所有的像素点, 转换成合适的坐标</li><li>将左右眼的所有的point, 分别获取X和Y坐标放到不同的数组</li><li>将数组有小到大排序, 得到X的最大和最小的差值, Y的最大和最小的差值</li><li>具体代码如下</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// H偶去转换后的尺寸坐标</span></span><br><span class="line">fileprivate func getEyePoint(faceModel: FaceFeatureModel, position: <span class="built_in">AVCaptureDevice</span>.Position) -&gt; <span class="built_in">CGRect</span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取左右眼</span></span><br><span class="line">    guard let leftEye = faceModel.leftEye <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">CGRect</span>.zero &#125;</span><br><span class="line">    guard let rightEye = faceModel.rightEye <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">CGRect</span>.zero &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 位置数组</span></span><br><span class="line">    let leftPoint = conventPoint(landmark: leftEye, faceRect: faceModel.faceObservation.boundingBox, position: position)</span><br><span class="line">    let rightPoint = conventPoint(landmark: rightEye, faceRect: faceModel.faceObservation.boundingBox, position: position)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 排序</span></span><br><span class="line">    let pointXs = (leftPoint<span class="number">.0</span> + rightPoint<span class="number">.0</span>).sorted()</span><br><span class="line">    let pointYs = (leftPoint<span class="number">.1</span> + rightPoint<span class="number">.1</span>).sorted()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 添加眼睛</span></span><br><span class="line">    let image = <span class="built_in">UIImage</span>(named: <span class="string">"eyes"</span>)!</span><br><span class="line">    let imageWidth = (pointXs.last ?? <span class="number">0.0</span>) - (pointXs.first ?? <span class="number">0</span>) + <span class="number">40</span></span><br><span class="line">    let imageHeight = image.size.height / image.size.width * imageWidth</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: (pointXs.first ?? <span class="number">0</span>) - <span class="number">20</span>, y: (pointYs.first ?? <span class="number">0</span>) - <span class="number">5</span>, width: imageWidth, height: imageHeight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每一只眼睛的坐标处理</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 坐标转换</span></span><br><span class="line">fileprivate func conventPoint(landmark: VNFaceLandmarkRegion2D, faceRect: <span class="built_in">CGRect</span>, position: <span class="built_in">AVCaptureDevice</span>.Position) -&gt; ([<span class="built_in">CGFloat</span>], [<span class="built_in">CGFloat</span>])&#123;</span><br><span class="line">    <span class="comment">//1. 定义</span></span><br><span class="line">    var XArray = [<span class="built_in">CGFloat</span>](), YArray = [<span class="built_in">CGFloat</span>]()</span><br><span class="line">    let viewRect = previewLayer.frame</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;landmark.pointCount &#123;</span><br><span class="line">        <span class="comment">//2.1 获取当前位置并转化到合适尺寸</span></span><br><span class="line">        let point = landmark.normalizedPoints[i]</span><br><span class="line">        let rectWidth = viewRect.width * faceRect.width</span><br><span class="line">        let rectHeight = viewRect.height * faceRect.height</span><br><span class="line">        let rectY = viewRect.height - (point.y * rectHeight + faceRect.minY * viewRect.height)</span><br><span class="line">        var rectX = point.x * rectWidth + faceRect.minX * viewRect.width</span><br><span class="line">        <span class="keyword">if</span> position == .front&#123;</span><br><span class="line">            rectX = viewRect.width + (point.x - <span class="number">1</span>) * rectWidth</span><br><span class="line">        &#125;</span><br><span class="line">        XArray.append(rectX)</span><br><span class="line">        YArray.append(rectY)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (XArray, YArray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后获取到该<code>CGRect</code>, 添加眼镜效果即可</li></ul><h3 id="6-物体跟踪"><a href="#6-物体跟踪" class="headerlink" title="6. 物体跟踪"></a>6. 物体跟踪</h3><ul><li>简介<ul><li>我们在屏幕上点击某物体, 然后Vision就会根据点击的物体, 实时跟踪该物体</li><li>当你移动手机或者物体时, 识别的对象和红框的位置是统一的</li></ul></li><li>这里我们出的的对象是<code>VNDetectedObjectObservation</code></li><li>定义一个观察属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileprivate var lastObservation: VNDetectedObjectObservation?</span><br></pre></td></tr></table></figure><ul><li>创建一个处理多个图像序列的请求</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理与多个图像序列的请求handle</span></span><br><span class="line">let sequenceHandle = VNSequenceRequestHandler()</span><br></pre></td></tr></table></figure><ul><li>创建跟踪识别请求</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 创建跟踪识别请求</span></span><br><span class="line">let trackRequest = VNTrackObjectRequest(detectedObjectObservation: lastObservation, completionHandler: completionHandle)</span><br><span class="line"><span class="comment">//将精度设置为高</span></span><br><span class="line">trackRequest.trackingLevel = .accurate</span><br></pre></td></tr></table></figure><ul><li>当用户点击屏幕时，我们想要找出用户点击的位置,</li><li>根据点击的位置, 获取到一个新的物体对象</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 转换坐标</span></span><br><span class="line">let convertRect = visionTool.convertRect(viewRect: redView.frame, layerRect: previewLayer.frame)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//3. 根据点击的位置获取新的对象</span></span><br><span class="line">let newObservation = VNDetectedObjectObservation(boundingBox: convertRect)</span><br><span class="line">lastObservation = newObservation</span><br></pre></td></tr></table></figure><ul><li>获取到扫描的结果, 如果是一个<code>VNDetectedObjectObservation</code>对象, 重新赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//1. 获取一个实际的结果</span><br><span class="line">guard let newObservation = observations?.first as? VNDetectedObjectObservation else &#123; return &#125;</span><br><span class="line">            </span><br><span class="line">//2. 重新赋值</span><br><span class="line">self.lastObservation = newObservation</span><br></pre></td></tr></table></figure><ul><li>根据获取到的新值, 获取物体的坐标位置</li><li>转换坐标, 改变红色框的位置</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 坐标转换</span></span><br><span class="line">let newRect = newObservation.boundingBox</span><br><span class="line">let convertRect = visionTool.convertRect(newRect, <span class="keyword">self</span>.previewLayer.frame)</span><br><span class="line"><span class="keyword">self</span>.redView.frame = convertRect</span><br></pre></td></tr></table></figure><blockquote><p>以上就是iOS 11的新框架Vision在Swift中的所有使用的情况</p><ul><li>文中所列的内容可能有点空洞, 也稍微有点乱</li><li>小编也是刚接触Vision, 文中如有解释不全, 或者错误的地方, 还请不吝赐教</li></ul></blockquote><hr><h3 id="GitHub–Demo地址"><a href="#GitHub–Demo地址" class="headerlink" title="GitHub–Demo地址"></a>GitHub–<a href="https://github.com/coderQuanjun/JunVisionFace" target="_blank" rel="noopener">Demo地址</a></h3><ul><li>注意:  <ul><li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li><li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li><li>如果方便的话, 还望star一下</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Swift黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Vision </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS黑科技之(AVFoundation)动态人脸识别(二)</title>
      <link href="/2017/11/22/iOS%E9%BB%91%E7%A7%91%E6%8A%80%E4%B9%8B(AVFoundation)%E5%8A%A8%E6%80%81%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB(%E4%BA%8C)/"/>
      <content type="html"><![CDATA[<blockquote><p>人脸识别原理简介：每一张图片都是由每一个像素点组成，而每一个像素点中又有对应的颜色值(如RGB)，人的面部特征中，不同的五官，颜色值肯定存在差异，而人脸识别技术就是通过对照片中每一个像素的识别进行大量的算法处理，最终得出五官的轮廓</p></blockquote><a id="more"></a><h2 id="一-首先介绍一些人脸识别的方式"><a href="#一-首先介绍一些人脸识别的方式" class="headerlink" title="一. 首先介绍一些人脸识别的方式"></a>一. 首先介绍一些人脸识别的方式</h2><h3 id="1-CoreImage静态人脸识别-可识别照片-图像等"><a href="#1-CoreImage静态人脸识别-可识别照片-图像等" class="headerlink" title="1. CoreImage静态人脸识别, 可识别照片, 图像等"></a>1. <code>CoreImage</code>静态人脸识别, 可识别照片, 图像等</h3><ul><li>详情可查看上一篇博客介绍</li></ul><h3 id="2-Face"><a href="#2-Face" class="headerlink" title="2. Face++"></a>2. Face++</h3><ul><li>是北京旷视科技有限公司旗下的新型视觉服务平台, 旨在提供简单易用，功能强大，平台通用的视觉服务</li><li>Face++是新一代云端视觉服务平台，提供一整套世界领先的人脸检测，人脸识别，面部分析的视觉技术服务</li><li><a href="https://baike.baidu.com/item/Face++/6754083" target="_blank" rel="noopener">Face++百度百科介绍</a></li><li><a href="https://www.faceplusplus.com.cn/pricing/" target="_blank" rel="noopener">Face++官网</a></li></ul><h3 id="3-OpenCV"><a href="#3-OpenCV" class="headerlink" title="3. OpenCV"></a>3. OpenCV</h3><ul><li>由一系列 C 函数和少量 C++ 类构成, 实现了图像处理和计算机视觉方面的很多通用算法, 其他的具体的不是很了解</li><li><a href="https://baike.baidu.com/item/opencv/10320623?fr=aladdin" target="_blank" rel="noopener">这是百度百科的内容</a></li></ul><h3 id="4-Vision"><a href="#4-Vision" class="headerlink" title="4. Vision"></a>4. Vision</h3><ul><li>Vision 是 Apple 在 WWDC 2017 伴随iOS 11推出的基于CoreML的图像识别框架</li><li>根据<a href="https://developer.apple.com/documentation/vision" target="_blank" rel="noopener">Vision官方文档看</a>，<code>Vision</code> 本身就有<code>Face Detection and Recognition</code>(人脸检测识别)、<code>Machine Learning Image Analysis</code>(机器学习图片分析)、<code>Barcode Detection</code>(条形码检测)、<code>Text Detection</code>(文本检测)。。。。。等等这些功能</li><li>感兴趣的同学可以查看相关文档学习一下, 这里小编就不过多作介绍了</li></ul><h4 id="5-AVFoundation"><a href="#5-AVFoundation" class="headerlink" title="5. AVFoundation"></a>5. AVFoundation</h4><ul><li>可以用来使用和创建基于时间的视听媒体的框架</li><li>这里我们使用的人脸识别方式也是使用<code>AVFoundation</code>框架</li></ul><h2 id="二-对关键类的简单介绍"><a href="#二-对关键类的简单介绍" class="headerlink" title="二. 对关键类的简单介绍"></a>二. 对关键类的简单介绍</h2><h3 id="1-AVCaptureDevice-代表硬件设备"><a href="#1-AVCaptureDevice-代表硬件设备" class="headerlink" title="1. AVCaptureDevice:代表硬件设备"></a>1. <code>AVCaptureDevice</code>:代表硬件设备</h3><ul><li>我们可以从这个类中获取手机硬件的照相机、声音传感器等。</li><li>当我们在应用程序中需要改变一些硬件设备的属性（例如：切换摄像头、闪光模式改变、相机聚焦改变）的时候必须要先为设备加锁，修改完成后解锁。</li><li>示例: 切换摄像头</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 移除旧输入，添加新输入</span></span><br><span class="line"><span class="comment">//4.1 设备加锁</span></span><br><span class="line">session.beginConfiguration()</span><br><span class="line"><span class="comment">//4.2. 移除旧设备</span></span><br><span class="line">session.removeInput(deviceIn)</span><br><span class="line"><span class="comment">//4.3 添加新设备</span></span><br><span class="line">session.addInput(newVideoInput)</span><br><span class="line"><span class="comment">//4.4 设备解锁</span></span><br><span class="line">session.commitConfiguration()</span><br></pre></td></tr></table></figure><h3 id="2-AVCaptureDeviceInput-设备输入数据管理对象"><a href="#2-AVCaptureDeviceInput-设备输入数据管理对象" class="headerlink" title="2. AVCaptureDeviceInput:设备输入数据管理对象"></a>2. <code>AVCaptureDeviceInput</code>:设备输入数据管理对象</h3><ul><li>可以根据<code>AVCaptureDevice</code>创建对应的AVCaptureDeviceInput对象，</li><li>该对象将会被添加到AVCaptureSession中管理,代表输入设备，它配置抽象硬件设备的ports。通常的输入设备有（麦克风，相机等）</li></ul><h3 id="3-AVCaptureOutput-代表输出数据"><a href="#3-AVCaptureOutput-代表输出数据" class="headerlink" title="3. AVCaptureOutput: 代表输出数据"></a>3. <code>AVCaptureOutput</code>: 代表输出数据</h3><ul><li>输出的可以是图片（<code>AVCaptureStillImageOutput</code>）或者视频（<code>AVCaptureMovieFileOutput</code>）</li></ul><h3 id="4-AVCaptureSession-媒体（音、视频）捕捉会话"><a href="#4-AVCaptureSession-媒体（音、视频）捕捉会话" class="headerlink" title="4. AVCaptureSession: 媒体（音、视频）捕捉会话"></a>4. <code>AVCaptureSession</code>: 媒体（音、视频）捕捉会话</h3><ul><li>负责把捕捉的音频视频数据输出到输出设备中。</li><li>一个<code>AVCaptureSession</code>可以有多个输入或输出。</li><li>是连接<code>AVCaptureInput</code>和<code>AVCaptureOutput</code>的桥梁，它协调input到output之间传输数据。</li><li>它有startRunning和stopRunning两种方法来开启会话和结束会话。</li><li>每个session称之为一个会话，也就是在应用运行过程中如果你需要改变会话的一些配置（例如：切换摄像头）,此时需要先开启配置，配置完成之后再提交配置。</li></ul><h3 id="5-AVCaptureVideoPreviewLayer-图片预览层"><a href="#5-AVCaptureVideoPreviewLayer-图片预览层" class="headerlink" title="5. AVCaptureVideoPreviewLayer: 图片预览层"></a>5. <code>AVCaptureVideoPreviewLayer</code>: 图片预览层</h3><ul><li>我们的照片以及视频是如何显示在手机上的呢？那就是通过把这个对象添加到<code>UIView</code>的<code>layer</code>上的</li></ul><blockquote><p>好了, 上面吧啦吧啦的说了那么多废话, 那么我们的人脸识别究竟是怎样实现的呢? 下面干货来了</p></blockquote><h2 id="三-添加扫描设备"><a href="#三-添加扫描设备" class="headerlink" title="三. 添加扫描设备"></a>三. 添加扫描设备</h2><ul><li>获取设备(摄像头)</li><li>创建输入设备</li><li>创建扫描输出</li><li>创建捕捉回话</li></ul><h3 id="1-输出设备"><a href="#1-输出设备" class="headerlink" title="1. 输出设备"></a>1. 输出设备</h3><ul><li>这里使用<code>AVCaptureMetadataOutput</code>, 可以扫描人脸, 二维码, 条形码等信息</li><li>必须设置代理, 否则获取不到扫描结果</li><li>需要设置要输出什么样的数据: face(人脸), qr(二维码)等等</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.创建原数据的输出对象</span></span><br><span class="line">let metadataOutput = <span class="built_in">AVCaptureMetadataOutput</span>()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4.设置代理监听输出对象输出的数据，在主线程中刷新</span></span><br><span class="line">metadataOutput.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: DispatchQueue.main)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.告诉输出对象要输出什么样的数据,识别人脸, 最多可识别10张人脸</span></span><br><span class="line">metadataOutput.metadataObjectTypes = [.face]</span><br></pre></td></tr></table></figure><blockquote><p>主要代码如下:</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func addScaningVideo()&#123;</span><br><span class="line">    <span class="comment">//1.获取输入设备（摄像头）</span></span><br><span class="line">    guard let device = <span class="built_in">AVCaptureDevice</span>.default(<span class="keyword">for</span>: .video) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.根据输入设备创建输入对象</span></span><br><span class="line">    guard let deviceIn = try? <span class="built_in">AVCaptureDeviceInput</span>(device: device) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    deviceInput = deviceIn</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.创建原数据的输出对象</span></span><br><span class="line">    let metadataOutput = <span class="built_in">AVCaptureMetadataOutput</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.设置代理监听输出对象输出的数据，在主线程中刷新</span></span><br><span class="line">    metadataOutput.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: DispatchQueue.main)</span><br><span class="line">    <span class="comment">//4.2 设置输出代理</span></span><br><span class="line">    faceDelegate = previewView</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.设置输出质量(高像素输出)</span></span><br><span class="line">    session.sessionPreset = .high</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.添加输入和输出到会话</span></span><br><span class="line">    <span class="keyword">if</span> session.canAddInput(deviceInput!) &#123;</span><br><span class="line">        session.addInput(deviceInput!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> session.canAddOutput(metadataOutput) &#123;</span><br><span class="line">        session.addOutput(metadataOutput)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.告诉输出对象要输出什么样的数据,识别人脸, 最多可识别10张人脸</span></span><br><span class="line">    metadataOutput.metadataObjectTypes = [.face]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8.创建预览图层</span></span><br><span class="line">    previewLayer = <span class="built_in">AVCaptureVideoPreviewLayer</span>(session: session)</span><br><span class="line">    previewLayer.videoGravity = .resizeAspectFill</span><br><span class="line">    previewLayer.frame = view.bounds</span><br><span class="line">    previewView.layer.insertSublayer(previewLayer, at: <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9.设置有效扫描区域(默认整个屏幕区域)（每个取值0~1, 以屏幕右上角为坐标原点）</span></span><br><span class="line">    metadataOutput.rectOfInterest = previewView.bounds</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10. 开始扫描</span></span><br><span class="line">    <span class="keyword">if</span> !session.isRunning &#123;</span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            <span class="keyword">self</span>.session.startRunning()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-切换摄像头"><a href="#2-切换摄像头" class="headerlink" title="2. 切换摄像头"></a>2. 切换摄像头</h3><ul><li>获取当前摄像头方向</li><li>创建新的输入input</li><li>移除旧输入<code>capture</code>, 添加新的输入<code>capture</code></li><li>具体代码如下: </li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func switchCameraAction(_ sender: Any) &#123;</span><br><span class="line">    <span class="comment">//1. 执行转场动画</span></span><br><span class="line">    let anima = <span class="built_in">CATransition</span>()</span><br><span class="line">    anima.type = <span class="string">"oglFlip"</span></span><br><span class="line">    anima.subtype = <span class="string">"fromLeft"</span></span><br><span class="line">    anima.duration = <span class="number">0.5</span></span><br><span class="line">    view.layer.add(anima, forKey: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取当前摄像头</span></span><br><span class="line">    guard let deviceIn = deviceInput <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    let position: <span class="built_in">AVCaptureDevice</span>.Position = deviceIn.device.position == .back ? .front : .back</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 创建新的input</span></span><br><span class="line">    let deviceSession = <span class="built_in">AVCaptureDevice</span>.DiscoverySession(deviceTypes: [.builtInWideAngleCamera], mediaType: .video, position: position)</span><br><span class="line">    guard let newDevice = deviceSession.devices.filter(&#123; $<span class="number">0.</span>position == position &#125;).first <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    guard let newVideoInput = try? <span class="built_in">AVCaptureDeviceInput</span>(device: newDevice) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 移除旧输入，添加新输入</span></span><br><span class="line">    <span class="comment">//4.1 设备加锁</span></span><br><span class="line">    session.beginConfiguration()</span><br><span class="line">    <span class="comment">//4.2. 移除旧设备</span></span><br><span class="line">    session.removeInput(deviceIn)</span><br><span class="line">    <span class="comment">//4.3 添加新设备</span></span><br><span class="line">    session.addInput(newVideoInput)</span><br><span class="line">    <span class="comment">//4.4 设备解锁</span></span><br><span class="line">    session.commitConfiguration()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 保存最新输入</span></span><br><span class="line">    deviceInput = newVideoInput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-处理扫描结果"><a href="#3-处理扫描结果" class="headerlink" title="3. 处理扫描结果"></a>3. 处理扫描结果</h3><blockquote><p>实现<code>AVCaptureMetadataOutputObjectsDelegate</code>该协议的协议方法(只有一个方法)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//`metadataObjects`就是返回的扫描结果</span><br><span class="line">optional public func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection)</span><br></pre></td></tr></table></figure><h3 id="4-AVMetadataFaceObject介绍"><a href="#4-AVMetadataFaceObject介绍" class="headerlink" title="4. AVMetadataFaceObject介绍"></a>4. <code>AVMetadataFaceObject</code>介绍</h3><ul><li><code>faceID</code>: 人脸的唯一标识 <ul><li>扫描出来的每一个人, 有不同的<code>faceID</code></li><li>同一个人, 不同的状态下(摇头, 歪头, 抬头等), 都会有不同<code>faceID</code></li></ul></li><li><code>hasRollAngle</code>: 是否有倾斜角,侧倾角(左右歪头)(BOOL类型)</li><li><code>rollAngle</code>: 倾斜角,侧倾角的角度(<code>CGFloat</code>类型)</li><li><code>hasYawAngle</code>: 是否有偏转角(左右摇头)</li><li><code>yawAngle</code>: 偏转角角度</li></ul><h3 id="5-处理扫描结果"><a href="#5-处理扫描结果" class="headerlink" title="5. 处理扫描结果"></a>5. 处理扫描结果</h3><h4 id="5-1-获取预览图层的人脸数组"><a href="#5-1-获取预览图层的人脸数组" class="headerlink" title="5.1 获取预览图层的人脸数组"></a>5.1 获取预览图层的人脸数组</h4><ul><li>遍历扫描的人脸数组, 转换成在预览图层的人脸数组</li><li>主要是人脸在图层的左边的转换</li><li>返回转换后的新的数组</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func transformedFaces(faceObjs: [<span class="built_in">AVMetadataObject</span>]) -&gt; [<span class="built_in">AVMetadataObject</span>] &#123;</span><br><span class="line">    var faceArr = [<span class="built_in">AVMetadataObject</span>]()</span><br><span class="line">    <span class="keyword">for</span> face <span class="keyword">in</span> faceObjs &#123;</span><br><span class="line">        <span class="comment">//将扫描的人脸对象转成在预览图层的人脸对象(主要是坐标的转换)</span></span><br><span class="line">        <span class="keyword">if</span> let transFace = previewLayer.transformedMetadataObject(<span class="keyword">for</span>: face)&#123;</span><br><span class="line">            faceArr.append(transFace)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> faceArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-根据人脸位置添加红框"><a href="#5-2-根据人脸位置添加红框" class="headerlink" title="5.2 根据人脸位置添加红框"></a>5.2 根据人脸位置添加红框</h4><ul><li>设置红框的frame</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faceLayer?.frame = face.bounds</span><br></pre></td></tr></table></figure><ul><li>根据偏转角和倾斜角的角度获取<code>CATransform3D</code></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func transformDegress(yawAngle: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">CATransform3D</span> &#123;</span><br><span class="line">    let yaw = degreesToRadians(degress: yawAngle)</span><br><span class="line">    <span class="comment">//围绕Y轴旋转</span></span><br><span class="line">    let yawTran = <span class="built_in">CATransform3DMakeRotation</span>(yaw, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//红框旋转问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DConcat</span>(yawTran, <span class="built_in">CATransform3DIdentity</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理偏转角问题</span></span><br><span class="line">fileprivate func transformDegress(rollAngle: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">CATransform3D</span> &#123;</span><br><span class="line">    let roll = degreesToRadians(degress: rollAngle)</span><br><span class="line">    <span class="comment">//围绕Z轴旋转</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DMakeRotation</span>(roll, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//角度转换</span></span><br><span class="line">fileprivate func degreesToRadians(degress: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">CGFloat</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degress * <span class="built_in">CGFloat</span>(Double.pi) / <span class="number">180</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据有无偏转角和倾斜角旋转红框</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.4 设置偏转角(左右摇头)</span></span><br><span class="line"><span class="keyword">if</span> face.hasYawAngle&#123;</span><br><span class="line">    let tranform3D = transformDegress(yawAngle: face.yawAngle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//矩阵处理</span></span><br><span class="line">    faceLayer?.transform = <span class="built_in">CATransform3DConcat</span>(faceLayer!.transform, tranform3D)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.5 设置倾斜角,侧倾角(左右歪头)</span></span><br><span class="line"><span class="keyword">if</span> face.hasRollAngle&#123;</span><br><span class="line">    let tranform3D = transformDegress(rollAngle: face.rollAngle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//矩阵处理</span></span><br><span class="line">    faceLayer?.transform = <span class="built_in">CATransform3DConcat</span>(faceLayer!.transform, tranform3D)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>至此, 动态的人脸识别就完成了, 会在人脸位置增加红框显示, 并且红框会根据人脸的位置动态的, 实时的调整</li><li>下面就快拿起你的相机测试吧</li></ul><hr><h3 id="GitHub–Demo地址"><a href="#GitHub–Demo地址" class="headerlink" title="GitHub–Demo地址"></a>GitHub–<a href="https://github.com/coderQuanjun/JunFaceRecognition" target="_blank" rel="noopener">Demo地址</a></h3><ul><li>注意:  <ul><li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li><li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Swift黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> AVFoundation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS黑科技之(CoreImage)静态人脸识别(一)</title>
      <link href="/2017/11/22/iOS%E9%BB%91%E7%A7%91%E6%8A%80%E4%B9%8B(CoreImage)%E9%9D%99%E6%80%81%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB(%E4%B8%80)/"/>
      <content type="html"><![CDATA[<blockquote><p>人脸识别原理简介：每一张图片都是由每一个像素点组成，而每一个像素点中又有对应的颜色值(如RGB)，人的面部特征中，不同的五官，颜色值肯定存在差异，而人脸识别技术就是通过对照片中每一个像素的识别进行大量的算法处理，最终得出五官的轮廓</p></blockquote><a id="more"></a><ul><li>这里我们将使用<code>CoreImage</code>框架,进行静态的人脸识别(类似照片, 图像等)</li><li>苹果原生的人脸识别并不是一个独立的框架，而是放在<code>CoreImage</code>框架中</li><li>Apple 已经帮我们把image的分类处理好了</li><li>CoreImage是iOS5新增的强大类库之一，它可以处理图片的各种效果，什么饱和度啊，旋转变形啊，色彩啊等等。</li><li>在使用CoreImage之前要导入CoreImage.framework框架</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-3f1d091e07de5a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Core Image框架图.png"></p><h2 id="一-主要类介绍"><a href="#一-主要类介绍" class="headerlink" title="一. 主要类介绍"></a>一. 主要类介绍</h2><ul><li>CIImage<ul><li>Core Image中的图像类，类似于UIKit中的UIImage类。</li></ul></li><li>CIContext: 上下文对象<ul><li>所有图像处理都在CIContext对象中实现，通过Quartz 2D、OpenGL渲染CIImage对象; 如滤镜、颜色等渲染处理</li></ul></li><li>CIColor：颜色<ul><li>图片的关联与画布、图片像素颜色的处理。</li></ul></li><li><p>CIVector：向量</p><ul><li>图片的坐标向量等几何方法处理。</li></ul></li><li><p>CIDetector<br>特征识别类</p><ul><li>该类集成了苹果有关特征识别的一些功能。</li><li>可检测图片中人脸的眼睛、嘴巴、等等</li></ul></li><li>CIFilter<ul><li>滤镜类，包含一个字典结构，对各种滤镜定义了属于自己的属性</li><li>CIFilter 产生一个CIImage</li><li>接受一到多的图片作为输入，经过一些过滤操作，产生指定输出的图片</li></ul></li><li>CIFeature: 代表由 detector处理后产生的特征</li></ul><h2 id="二-项目代码介绍"><a href="#二-项目代码介绍" class="headerlink" title="二. 项目代码介绍"></a>二. 项目代码介绍</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h3><h4 id="1-1-这里要先介绍一下检测器的类别"><a href="#1-1-这里要先介绍一下检测器的类别" class="headerlink" title="1.1 这里要先介绍一下检测器的类别"></a>1.1 这里要先介绍一下检测器的类别</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//人脸检测器</span></span><br><span class="line">public let <span class="built_in">CIDetectorTypeFace</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩形识别</span></span><br><span class="line">public let <span class="built_in">CIDetectorTypeRectangle</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维码识别</span></span><br><span class="line">public let <span class="built_in">CIDetectorTypeQRCode</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本识别</span></span><br><span class="line">public let <span class="built_in">CIDetectorTypeText</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定检测精度</span></span><br><span class="line">public let <span class="built_in">CIDetectorAccuracy</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定使用特征跟踪，这个功能就像相机中的人脸跟踪功能</span></span><br><span class="line">public let <span class="built_in">CIDetectorTracking</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置将要识别的特征的最小尺寸</span></span><br><span class="line">public let <span class="built_in">CIDetectorMinFeatureSize</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对矩形探测器的，用于设置返回矩形特征的最多个数。</span></span><br><span class="line"><span class="comment">//这个关键字的值是一个1~...的NSNumber值。有效范围1 &lt; = CIDetectorMaxFeatureCount &lt; = 256。默认值为1</span></span><br><span class="line">public let <span class="built_in">CIDetectorMaxFeatureCount</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//脸部透视数, 值为包含1、3、5、7、9、11的NSNumber对象</span></span><br><span class="line">public let <span class="built_in">CIDetectorNumberOfAngles</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置识别方向，值是一个从1 ~ 8的整型的NSNumber</span></span><br><span class="line">public let <span class="built_in">CIDetectorImageOrientation</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置这个参数为true(bool类型的NSNumber)，识别器将提取眨眼特征</span></span><br><span class="line">public let <span class="built_in">CIDetectorEyeBlink</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果设置这个参数为ture(bool类型的NSNumber)，识别器将提取微笑特征</span></span><br><span class="line">public let <span class="built_in">CIDetectorSmile</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于设置每帧焦距，值得类型为floot类型的NSNumber</span></span><br><span class="line">public let <span class="built_in">CIDetectorFocalLength</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于设置矩形的长宽比，值得类型为floot类型的NSNumber</span></span><br><span class="line">public let <span class="built_in">CIDetectorAspectRatio</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制文本检测器是否应该检测子特征。默认值是否，值的类型为bool类型的NSNumber</span></span><br><span class="line">public let <span class="built_in">CIDetectorReturnSubFeatures</span>: String</span><br></pre></td></tr></table></figure><ul><li>这里需要的是人脸识别的<code>CIDetectorTypeFace</code></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建上下文对象</span></span><br><span class="line">let context = <span class="built_in">CIContext</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. UIImage转成CIImage</span></span><br><span class="line">guard let image = imageView.image  <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">guard let ciImage = <span class="built_in">CIImage</span>(image: image) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 参数设置(精度设置)</span></span><br><span class="line">let parmes = [<span class="built_in">CIDetectorAccuracy</span>: <span class="built_in">CIDetectorAccuracyHigh</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 创建识别类</span></span><br><span class="line">let detector = <span class="built_in">CIDetector</span>(ofType: <span class="built_in">CIDetectorTypeFace</span>, context: context, options: parmes)</span><br></pre></td></tr></table></figure><h3 id="2-参数设置"><a href="#2-参数设置" class="headerlink" title="2. 参数设置"></a>2. 参数设置</h3><ul><li>这里设置了一个识别精度CIDetectorAccuracy，识别精度的值有：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//识别精度低，但识别速度快、性能高</span></span><br><span class="line">public let <span class="built_in">CIDetectorAccuracyLow</span>: String </span><br><span class="line"></span><br><span class="line"><span class="comment">// 识别精度高，但识别速度慢、性能低</span></span><br><span class="line">public let <span class="built_in">CIDetectorAccuracyHigh</span>: String</span><br></pre></td></tr></table></figure><ul><li>除了精度的设置，还有<code>CIDetectorMinFeatureSize</code>用于设置将要识别的特征的最小尺寸，也就是说小于这个尺寸的特征将不识别。<ul><li>对于人脸检测器，这个关键字的值是从0.0 ~ 1.0的<code>NSNumber</code>值，这个值表示：基于输入图像短边长度的百分比。有效值范围:0.01 &lt;= <code>CIDetectorMinFeatureSize</code> &lt;= 0.5。为这个参数设定更高值仅用于提高性能。默认值是0.15。</li><li>对于矩形探测器，这个关键字的值是从0.0 ~ 1.0的<code>NSNumber</code>值，这个值表示：基于输入图像短边长度的百分比。有效值范围:0.2 &lt;= <code>CIDetectorMinFeatureSize</code> &lt;= 1.0的默认值是0.2。</li><li>对于文本探测器，这个关键字的值是一个范围从0.0 ~ 1.0的<code>NSNumber</code>值，这个值表示：基于输入图像高度的百分比。有效值范围:0.0 &lt;= <code>CIDetectorMinFeatureSize</code> &lt;= 1.0。默认值是10/(输入图像的高度)</li></ul></li></ul><h3 id="3-CIFaceFeature概述"><a href="#3-CIFaceFeature概述" class="headerlink" title="3. CIFaceFeature概述"></a>3. CIFaceFeature概述</h3><ul><li><code>CIFaceFeature</code>是保存脸部所有信息的类</li><li><code>CIFaceFeature</code>是<code>CIFeature</code>的子类</li><li><code>CIFeature</code>类只保存基本信息， 所有的附加信息由子类(<code>CIFaceFeature</code>)保存</li><li>各属性简介:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测到的脸部在图片中的frame</span></span><br><span class="line">open var bounds: <span class="built_in">CGRect</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否检测到左眼的位置</span></span><br><span class="line">open var hasLeftEyePosition: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左眼的位置</span></span><br><span class="line">open var leftEyePosition: <span class="built_in">CGPoint</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否检测到右眼的位置</span></span><br><span class="line">open var hasRightEyePosition: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右眼的位置</span></span><br><span class="line">open var rightEyePosition: <span class="built_in">CGPoint</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否检测到嘴巴的位置</span></span><br><span class="line">open var hasMouthPosition: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//嘴巴的位置</span></span><br><span class="line">open var mouthPosition: <span class="built_in">CGPoint</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//脸部是否倾斜    </span></span><br><span class="line">open var hasFaceAngle: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//脸部倾斜角度</span></span><br><span class="line">open var faceAngle: Float &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否微笑    </span></span><br><span class="line">open var hasSmile: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左眼是否闭上</span></span><br><span class="line">open var leftEyeClosed: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右眼是否闭上</span></span><br><span class="line">open var rightEyeClosed: Bool &#123; get &#125;</span><br></pre></td></tr></table></figure><h3 id="4-Core-Image坐标系问题"><a href="#4-Core-Image坐标系问题" class="headerlink" title="4. Core Image坐标系问题"></a>4. <code>Core Image</code>坐标系问题</h3><ul><li>如图: </li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-a8af4dc80c214d1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="坐标系对比.png"></p></li><li><p><code>UIView</code>坐标系</p><ul><li>图中上半部分坐标系</li><li>Y轴自上而下依次增大</li></ul></li><li><code>Core Image</code>坐标系<ul><li>图中下半部分显示坐标系</li><li>X轴与<code>UIView</code>坐标系相同, Y轴坐标系最底部为0, 自下而上依次增大, 与<code>UIView</code>坐标系相反</li><li>所以需要对以次坐标设置frame的控件, 做一次针对Y轴的翻转, 如下: </li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultView.transform = <span class="built_in">CGAffineTransform</span>(scaleX: <span class="number">1</span>, y: <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="5-人脸检测-核心代码"><a href="#5-人脸检测-核心代码" class="headerlink" title="5. 人脸检测(核心代码)"></a>5. 人脸检测(核心代码)</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 通过人脸识别提取有效的人脸图片</span></span><br><span class="line"><span class="keyword">static</span> func faceImagesByFaceRecognition(imageView: <span class="built_in">UIImageView</span>, resultCallback: @escaping ((_ count: Int) -&gt; ())) &#123;</span><br><span class="line">    <span class="comment">//0. 删除子控件</span></span><br><span class="line">    let subViews = imageView.subviews</span><br><span class="line">    <span class="keyword">for</span> subview <span class="keyword">in</span> subViews &#123;</span><br><span class="line">        <span class="keyword">if</span> subview.isKind(of: <span class="built_in">UIView</span>.self) &#123;</span><br><span class="line">            subview.removeFromSuperview()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 创建上下文对象</span></span><br><span class="line">    let context = <span class="built_in">CIContext</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. UIImage转成CIImage</span></span><br><span class="line">    guard let image = imageView.image  <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    guard let ciImage = <span class="built_in">CIImage</span>(image: image) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 参数设置(精度设置)</span></span><br><span class="line">    let parmes = [<span class="built_in">CIDetectorAccuracy</span>: <span class="built_in">CIDetectorAccuracyHigh</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 创建识别类</span></span><br><span class="line">    let detector = <span class="built_in">CIDetector</span>(ofType: <span class="built_in">CIDetectorTypeFace</span>, context: context, options: parmes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 找到识别其中的人连对象</span></span><br><span class="line">    guard let faceArr = detector?.features(<span class="keyword">in</span>: ciImage) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6. 添加识别的红框</span></span><br><span class="line">    let resultView = <span class="built_in">UIView</span>(frame: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: imageView.frame.width, height: imageView.frame.height))</span><br><span class="line">    imageView.addSubview(resultView)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7. 遍历扫描结果</span></span><br><span class="line">    <span class="keyword">for</span> faceFeature <span class="keyword">in</span> faceArr &#123;</span><br><span class="line">        resultView.addSubview(addRedrectangleView(rect: faceFeature.bounds))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.1 如果识别到眼睛</span></span><br><span class="line">        guard let feature = faceFeature as? <span class="built_in">CIFaceFeature</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="comment">//左眼</span></span><br><span class="line">        <span class="keyword">if</span> feature.hasLeftEyePosition &#123;</span><br><span class="line">            let leftView = addRedrectangleView(rect: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">5</span>, height: <span class="number">5</span>))</span><br><span class="line">            leftView.center = feature.leftEyePosition</span><br><span class="line">            resultView.addSubview(leftView)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右眼</span></span><br><span class="line">        <span class="keyword">if</span> feature.hasRightEyePosition &#123;</span><br><span class="line">            let rightView = addRedrectangleView(rect: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">5</span>, height: <span class="number">5</span>))</span><br><span class="line">            rightView.setValue(feature.rightEyePosition, forKey: <span class="string">"center"</span>)</span><br><span class="line">            resultView.addSubview(rightView)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.2 识别嘴巴</span></span><br><span class="line">        <span class="keyword">if</span> feature.hasMouthPosition &#123;</span><br><span class="line">            let mouthView = addRedrectangleView(rect: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">10</span>, height: <span class="number">5</span>))</span><br><span class="line">            mouthView.setValue(feature.mouthPosition, forKey: <span class="string">"center"</span>)</span><br><span class="line">            resultView.addSubview(mouthView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8. 将resultView沿x轴翻转</span></span><br><span class="line">    resultView.transform = <span class="built_in">CGAffineTransform</span>(scaleX: <span class="number">1</span>, y: <span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9. 结果回调</span></span><br><span class="line">    resultCallback(faceArr.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-检测结果展示"><a href="#6-检测结果展示" class="headerlink" title="6. 检测结果展示"></a>6. 检测结果展示</h3><ul><li>检测到的人脸部位展示红色矩形框</li><li>眼镜和嘴巴部位显示红色矩形框</li><li>照片随机选取的, 不喜勿喷</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-424e5a9f1da0e4b5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="WechatIMG29.jpeg"></p><h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项:"></a>7. 注意事项:</h3><ul><li>image的实际尺寸需要和imageView的尺寸完全一样,获取的脸部各个部位的尺寸才能完全吻合</li><li>这里我只做了简单的尺寸比例转换</li><li>代码如下:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> func getScale(imageView: <span class="built_in">UIImageView</span>, image: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">CGFloat</span>&#123;</span><br><span class="line">    let viewSize = imageView.frame.size</span><br><span class="line">    let imageSize = image.size</span><br><span class="line">    </span><br><span class="line">    let widthScale = imageSize.width / viewSize.width</span><br><span class="line">    let heightScale = imageSize.height / viewSize.height</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> widthScale &gt; heightScale ? widthScale : heightScale</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="GitHub–Demo地址"><a href="#GitHub–Demo地址" class="headerlink" title="GitHub–Demo地址"></a>GitHub–<a href="https://github.com/coderQuanjun/JunFaceRecognition" target="_blank" rel="noopener">Demo地址</a></h3><ul><li>注意:  <ul><li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li><li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Swift黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> CIDetector </tag>
            
            <tag> AVFoundation </tag>
            
            <tag> CoreImage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift之二维码的生成、识别和扫描</title>
      <link href="/2017/11/16/Swift%E4%B9%8B%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E7%94%9F%E6%88%90%E3%80%81%E8%AF%86%E5%88%AB%E5%92%8C%E6%89%AB%E6%8F%8F/"/>
      <content type="html"><![CDATA[<blockquote><p>最近在项目中遇到了涉及二维码相关的问题, 这里想记录总结一下二维码相关技术<br><a id="more"></a></p></blockquote><h2 id="一-二维码的介绍"><a href="#一-二维码的介绍" class="headerlink" title="一. 二维码的介绍"></a>一. 二维码的介绍</h2><ul><li>二维条码/二维码是用某种特定的几何图形按一定规律在平面分布的黑白相间的图形记录数据符号信息的</li><li>总结: 用图形记录标记一些信息,方便通过图形识别来获取信息</li><li>应用场景<ul><li>信息获取（名片、地图、WIFI密码、资料）</li><li>手机电商（用户扫码、手机直接购物下单）</li><li>手机支付（扫描商品二维码，通过银行或第三方支付提供的手机端通道完成支付)</li><li>微信添加好友</li></ul></li></ul><h2 id="二-二维码的生成"><a href="#二-二维码的生成" class="headerlink" title="二. 二维码的生成"></a>二. 二维码的生成</h2><ul><li>生成二维码的方式<ul><li>采用第三方框架(放弃)<ul><li>ZXing/ZBar</li><li>框架不支持64位(2015年2月1号起, - 不允许不支持64位处理器的APP 上架)</li></ul></li><li>系统自带API</li></ul></li><li>生成二维码的步骤<ul><li>创建二维码滤镜–CIFilter</li><li>恢复滤镜的默认属性</li><li>设置滤镜的输入数据</li><li>将传入的字符串转换成Data(OC为NSData)数据</li><li>通过KVC来设置输入的内容<code>inputMessage</code><h3 id="1-二维码容错率"><a href="#1-二维码容错率" class="headerlink" title="1. 二维码容错率"></a>1. 二维码容错率</h3></li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter?.setValue(<span class="string">"H"</span>, forKey: <span class="string">"inputCorrectionLevel"</span>)</span><br></pre></td></tr></table></figure><ul><li><code>inputCorrectionLevel</code> 是一个单字母（@”L”, @”M”, @”Q”, @”H” 中的一个），表示不同级别的容错率，默认为 @”M”.</li><li>QR码有容错能力，QR码图形如果有破损，仍然可以被机器读取内容，最高可以到7%~30%面积破损仍可被读取,相对而言，容错率愈高，QR码图形面积愈大。所以一般折衷使用15%容错能力。</li><li>L水平 7%的字码可被修正.</li><li>M水平 15%的字码可被修正</li><li>Q水平 25%的字码可被修正</li><li>H水平 30%的字码可被修正</li><li>代码: </li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *  @param inputMsg 二维码保存的信息</span></span><br><span class="line"><span class="comment">   *  @param fgImage  前景图片  */</span></span><br><span class="line">func generateCode(inputMsg: String, fgImage: <span class="built_in">UIImage</span>?) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    <span class="comment">//1. 将内容生成二维码</span></span><br><span class="line">    <span class="comment">//1.1 创建滤镜</span></span><br><span class="line">    let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CIQRCodeGenerator"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.2 恢复默认设置</span></span><br><span class="line">    filter?.setDefaults()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.3 设置生成的二维码的容错率</span></span><br><span class="line">    <span class="comment">//value = @"L/M/Q/H"</span></span><br><span class="line">    filter?.setValue(<span class="string">"H"</span>, forKey: <span class="string">"inputCorrectionLevel"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.设置输入的内容(KVC)</span></span><br><span class="line">    <span class="comment">// 注意:key = inputMessage, value必须是NSData类型</span></span><br><span class="line">    let inputData = inputMsg.data(using: .utf8)</span><br><span class="line">    filter?.setValue(inputData, forKey: <span class="string">"inputMessage"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 获取输出的图片</span></span><br><span class="line">    guard let outImage = filter?.outputImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">UIImage</span>() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 获取高清图片</span></span><br><span class="line">    let hdImage = getHDImage(outImage)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 判断是否有前景图片</span></span><br><span class="line">    <span class="keyword">if</span> fgImage == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hdImage</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6. 获取有前景图片的二维码</span></span><br><span class="line">    <span class="keyword">return</span> getResultImage(hdImage: hdImage, fgImage: fgImage!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-获取高清图片"><a href="#2-获取高清图片" class="headerlink" title="2. 获取高清图片"></a>2. 获取高清图片</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 获取高清图片</span></span><br><span class="line">fileprivate func getHDImage(_ outImage: <span class="built_in">CIImage</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    let transform = <span class="built_in">CGAffineTransform</span>(scaleX: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line">    <span class="comment">//放大图片</span></span><br><span class="line">    let ciImage = outImage.transformed(by: transform)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(ciImage: ciImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-将图片合成到二维码中"><a href="#3-将图片合成到二维码中" class="headerlink" title="3. 将图片合成到二维码中"></a>3. 将图片合成到二维码中</h3><ul><li>需要用到图形上下文</li><li>将二维码画到图形上下文</li><li>将图片合成到图行上下文</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取前景图片</span></span><br><span class="line">fileprivate func getResultImage(hdImage: <span class="built_in">UIImage</span>, fgImage: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    let hdSize = hdImage.size</span><br><span class="line">    <span class="comment">//1. 开启图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(hdSize)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 将高清图片画到上下文</span></span><br><span class="line">    hdImage.draw(<span class="keyword">in</span>: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: hdSize.width, height: hdSize.height))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 将前景图片画到上下文</span></span><br><span class="line">    let fgWidth: <span class="built_in">CGFloat</span> = <span class="number">80</span></span><br><span class="line">    fgImage.draw(<span class="keyword">in</span>: <span class="built_in">CGRect</span>(x: (hdSize.width - fgWidth) / <span class="number">2</span>, y: (hdSize.height - fgWidth) / <span class="number">2</span>, width: fgWidth, height: fgWidth))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 获取上下文</span></span><br><span class="line">    guard let resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>() <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">UIImage</span>() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 关闭上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后续会研究彩色二维码的黑科技, 敬请期待…</p></blockquote><h2 id="识别二维码"><a href="#识别二维码" class="headerlink" title="识别二维码"></a>识别二维码</h2><blockquote><p>识别图片中二维码步骤</p><ul><li>创建探测器<ul><li>属于CoreImage框架(CIDetector)</li></ul></li><li>获取CIImage类型的图片</li><li>获取图片中所有符合特征的内容(CIQRCodeFeature)</li><li>遍历所有的特性(CIQRCodeFeature)</li><li>获取特征中代表的信息(messageString)</li><li>识别二维码的代码实现</li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *  @param qrCodeImage 二维码的图片</span></span><br><span class="line"><span class="comment">   *  @return 结果的数组 */</span></span><br><span class="line">func recognitionQRCode(qrCodeImage: <span class="built_in">UIImage</span>) -&gt; [String]? &#123;</span><br><span class="line">    <span class="comment">//1. 创建过滤器</span></span><br><span class="line">    let detector = <span class="built_in">CIDetector</span>(ofType: <span class="built_in">CIDetectorTypeQRCode</span>, context: <span class="literal">nil</span>, options: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取CIImage</span></span><br><span class="line">    guard let ciImage = <span class="built_in">CIImage</span>(image: qrCodeImage) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 识别二维码</span></span><br><span class="line">    guard let features = detector?.features(<span class="keyword">in</span>: ciImage) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 遍历数组, 获取信息</span></span><br><span class="line">    var resultArr = [String]()</span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> features &#123;</span><br><span class="line">        resultArr.append(feature.type)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-二维码的扫描"><a href="#三-二维码的扫描" class="headerlink" title="三. 二维码的扫描"></a>三. 二维码的扫描</h2><ul><li>创建输入设备(摄像头)<ul><li>获取摄像头设备</li><li>创建输入对象</li></ul></li><li>创建输出设置(元数据)<ul><li>创建输出对象</li><li>设置输出对象的代理(在代理中获取扫描到的数据)</li><li>设置输出数据的类型</li></ul></li><li>创建捕捉会话<ul><li>将输入添加到会话中</li><li>将输出添加到会话中</li></ul></li><li>添加预览图片(方便用于查看)<ul><li>创建图层,将图片添加到View图层中</li></ul></li><li>开始扫描</li></ul><h3 id="1-懒加载输入输出中间会话"><a href="#1-懒加载输入输出中间会话" class="headerlink" title="1. 懒加载输入输出中间会话"></a>1. 懒加载输入输出中间会话</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入输出中间桥梁(会话)</span></span><br><span class="line">fileprivate lazy var session : <span class="built_in">AVCaptureSession</span> = <span class="built_in">AVCaptureSession</span>()</span><br></pre></td></tr></table></figure><h3 id="2-初始化扫描设备"><a href="#2-初始化扫描设备" class="headerlink" title="2. 初始化扫描设备"></a>2. 初始化扫描设备</h3><h4 id="2-1-注意-AVCaptureMetadataOutputObjectsDelegate的代理设置-该协议中的方法会将扫描的结果返回"><a href="#2-1-注意-AVCaptureMetadataOutputObjectsDelegate的代理设置-该协议中的方法会将扫描的结果返回" class="headerlink" title="2.1. 注意: AVCaptureMetadataOutputObjectsDelegate的代理设置, 该协议中的方法会将扫描的结果返回"></a>2.1. 注意: <code>AVCaptureMetadataOutputObjectsDelegate</code>的代理设置, 该协议中的方法会将扫描的结果返回</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func addScaningVideo()&#123;</span><br><span class="line">    <span class="comment">//1.获取输入设备（摄像头）</span></span><br><span class="line">    guard let device = <span class="built_in">AVCaptureDevice</span>.default(<span class="keyword">for</span>: .video) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.根据输入设备创建输入对象</span></span><br><span class="line">    guard let deviceInput = try? <span class="built_in">AVCaptureDeviceInput</span>(device: device) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.创建原数据的输出对象</span></span><br><span class="line">    let metadataOutput = <span class="built_in">AVCaptureMetadataOutput</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.设置代理监听输出对象输出的数据，在主线程中刷新</span></span><br><span class="line">    metadataOutput.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: DispatchQueue.main)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.创建会话（桥梁）</span></span><br><span class="line">    <span class="comment">//        let session = AVCaptureSession()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.添加输入和输出到会话</span></span><br><span class="line">    <span class="keyword">if</span> session.canAddInput(deviceInput) &#123;</span><br><span class="line">        session.addInput(deviceInput)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> session.canAddOutput(metadataOutput) &#123;</span><br><span class="line">        session.addOutput(metadataOutput)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.告诉输出对象要输出什么样的数据(二维码还是条形码),要先创建会话才能设置</span></span><br><span class="line">    metadataOutput.metadataObjectTypes = [.qr, .code128, .code39, .code93, .code39Mod43, .ean8, .ean13, .upce, .pdf417, .aztec]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8.创建预览图层</span></span><br><span class="line">    let previewLayer: <span class="built_in">AVCaptureVideoPreviewLayer</span> = <span class="built_in">AVCaptureVideoPreviewLayer</span>(session: session)</span><br><span class="line">    previewLayer.videoGravity = .resizeAspectFill</span><br><span class="line">    previewLayer.frame = view.bounds</span><br><span class="line">    view.layer.insertSublayer(previewLayer, at: <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9.设置有效扫描区域(默认整个屏幕区域)（每个取值0~1, 以屏幕右上角为坐标原点）</span></span><br><span class="line">    let rect = <span class="built_in">CGRect</span>(x: scanImageView.frame.minY / kScreenHeight, y: scanImageView.frame.minX / kScreenWidth, width: scanImageView.frame.height / kScreenHeight, height: scanImageView.frame.width / kScreenWidth)</span><br><span class="line">    metadataOutput.rectOfInterest = rect</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10. 开始扫描</span></span><br><span class="line">    session.startRunning()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-代理方法的实现"><a href="#2-2-代理方法的实现" class="headerlink" title="2.2 代理方法的实现"></a>2.2 代理方法的实现</h4><ul><li>需要将扫描的结果转化成机器可读的编码数据,才能获取二维码的相关信息</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">extension ScaningViewController: <span class="built_in">AVCaptureMetadataOutputObjectsDelegate</span> &#123;</span><br><span class="line">    func metadataOutput(_ output: <span class="built_in">AVCaptureMetadataOutput</span>, didOutput metadataObjects: [<span class="built_in">AVMetadataObject</span>], from connection: <span class="built_in">AVCaptureConnection</span>) &#123;</span><br><span class="line">        <span class="comment">//1. 取出扫描到的数据: metadataObjects</span></span><br><span class="line">        <span class="comment">//2. 以震动的形式告知用户扫描成功</span></span><br><span class="line">        AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 关闭session</span></span><br><span class="line">        session.stopRunning()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 遍历结果</span></span><br><span class="line">        var resultArr = [String]()</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> metadataObjects &#123;</span><br><span class="line">            <span class="comment">//转换成机器可读的编码数据</span></span><br><span class="line">            <span class="keyword">if</span> let code = result as? <span class="built_in">AVMetadataMachineReadableCodeObject</span> &#123;</span><br><span class="line">                resultArr.append(code.stringValue ?? <span class="string">""</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                resultArr.append(result.type.rawValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5. 将结果</span></span><br><span class="line">        let vc = ShowViewController()</span><br><span class="line">        vc.scanDataArr = resultArr</span><br><span class="line">        navigationController?.pushViewController(vc, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目地址-Github"><a href="#项目地址-Github" class="headerlink" title="项目地址: Github "></a><a href="https://github.com/coderQuanjun/JunQRCode" target="_blank" rel="noopener">项目地址: Github </a></h2><ul><li>感谢大家的支持</li></ul><hr>]]></content>
      
      <categories>
          
          <category> Swift黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> CIFilter </tag>
            
            <tag> CIDetector </tag>
            
            <tag> AVFoundation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift之删除HTML5页面的广告</title>
      <link href="/2017/11/11/Swift%E4%B9%8B%E5%88%A0%E9%99%A4HTML5%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%B9%BF%E5%91%8A/"/>
      <content type="html"><![CDATA[<p>好久没来博客了,最近工作中任务(Bug)比较多!除了改Bug之外发现最近新出的一部电视剧不错, 给大家推荐一下&lt;&lt;&lt;&lt;猎场&gt;&gt;&gt;&gt;</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/4122543-050601a063e14ce8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="猎场.jpg"></p><h2 id="一-UIWebViewDelegate"><a href="#一-UIWebViewDelegate" class="headerlink" title="一. UIWebViewDelegate"></a>一. UIWebViewDelegate</h2><ul><li>好了,言归正传,今天遇到了一个关于UIWebView问题的问题,如何删除H5页面的广告问题(一般出现在第三方的H5页面的情况)</li><li>APP中嵌入一个H5的网页，但出现的广告条或是无关头尾，相当大煞风景, 那该如何去掉呢?</li><li>嵌入webview 一段JavaScript代码来隐藏，目前Android和iOS都支持此方法(这就是iOS中常说的js和OC交互)</li><li>UIWebVIew的基本使用这里就不多做介绍了</li><li>下面介绍一下UIWebViewDelegate的一些代理方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当网页视图被指示载入内容而得到通知。应当返回YES，这样会进行加载。通过导航类型参数可以得到请求发起的原因</span></span><br><span class="line">optional public func webView(_ webView: <span class="built_in">UIWebView</span>, shouldStartLoadWith request: URLRequest, navigationType: <span class="built_in">UIWebViewNavigationType</span>) -&gt; Bool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//UIWebView的控件加载网页的监听函数方法：</span></span><br><span class="line"><span class="comment">//1. 当网页视图已经开始加载一个请求后，得到通知。</span></span><br><span class="line">optional public func webViewDidStartLoad(_ webView: <span class="built_in">UIWebView</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 当网页视图结束加载一个请求之后，得到通知。</span></span><br><span class="line">optional public func webViewDidFinishLoad(_ webView: <span class="built_in">UIWebView</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 当前请求加载中发生错误时，得到通知。</span></span><br><span class="line">optional public func webView(_ webView: <span class="built_in">UIWebView</span>, didFailLoadWithError error: Error)</span><br></pre></td></tr></table></figure><h2 id="二-基于JavaScript的H5代码"><a href="#二-基于JavaScript的H5代码" class="headerlink" title="二. 基于JavaScript的H5代码"></a>二. 基于JavaScript的H5代码</h2><ul><li>首先,我们先看一下HTML5在浏览器中的现实情况, <a href="http://mini.eastday.com/mobile/170818161313395.html" target="_blank" rel="noopener">参考地址</a></li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-146823b54ab03b8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除前的原网页"></p></li><li><p>下面我们就要找到广告或者其他你想删除的部分对应的HTML代码</p></li><li>用浏览器打开<a href="http://mini.eastday.com/mobile/170818161313395.html" target="_blank" rel="noopener">参考地址</a>, 建议使用谷歌浏览器</li><li>找到浏览器的开发者工具, 按照如下操作</li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-c3efc0cb6e21f3ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看网页代码"></p></li><li><p>控制网页和js源码的显示方式</p></li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-ea333a6efa617e15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20171111_6.png"></p><ul><li>调节手机/电脑显示: 你要选择在那种情境下显示网页,通俗来说,就是模拟器</li><li>放大镜:你可以通过放大镜对网页上的控件进行选取,然后找到html代码</li><li>手机:转化为手机模式,但是前提必须要转换Device的模式,要不然,光是视图上的转变,没有实际的转变(注意:我现在拿手机的网页做示例,所有我需要转化,当你做的电脑的就不需要转换这些了)</li></ul></li><li><p>下面这就是要找到广告对应的js源码了(这里以订阅按钮为例)<br><img src="http://upload-images.jianshu.io/upload_images/4122543-e8c6dd62b00d9c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20171111_8.png"></p><ul><li>将右侧按钮为选中状态</li><li>用鼠标选中你要删除的控件(这里以订阅按钮为例), 这时你会发现右侧代码会有一行背景颜色被加深</li><li>我们要做的就是调用js语法删除这行js代码, 从而删除订阅按钮</li><li>找到该控件的class标签或者id标签</li><li>通过以下代码控制删除</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class类型</span></span><br><span class="line">document.getElementsByClassName('gg-item news-gg-img3').style.display = 'none'</span><br><span class="line"><span class="comment">//id类型</span></span><br><span class="line">document.getElementsById('gg-item news-gg-img3').style.display = 'none'</span><br></pre></td></tr></table></figure><ul><li>如果找到的该控件所在的js代码没有class或者id标志, 可以继续找到其父控件,通过以下方式删除</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByClassName('gg-item news-gg-img3')[0].style.display='none'</span><br></pre></td></tr></table></figure><h2 id="三-具体核心代码如下"><a href="#三-具体核心代码如下" class="headerlink" title="三. 具体核心代码如下"></a>三. 具体核心代码如下</h2><ul><li>删除广告后的效果如图</li><li><p><img src="http://upload-images.jianshu.io/upload_images/4122543-26d52ecdfceb0f52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="最终效果图"></p></li><li><p>核心代码</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extension NoneADViewController: <span class="built_in">UIWebViewDelegate</span>&#123;</span><br><span class="line">    func webViewDidFinishLoad(_ webView: <span class="built_in">UIWebView</span>) &#123;</span><br><span class="line">        <span class="comment">//最顶部的广告</span></span><br><span class="line">        webView.stringByEvaluatingJavaScript(from: <span class="string">"document.getElementsByClassName('gg-item news-gg-img3')[0].style.display='none'"</span>)</span><br><span class="line">        <span class="comment">//删除页面浮框广告</span></span><br><span class="line">        webView.stringByEvaluatingJavaScript(from: <span class="string">"document.getElementsByClassName('dbleleven-wrap')[0].style.display='none'"</span>)</span><br><span class="line">        <span class="comment">//第一张图片下面的广告</span></span><br><span class="line">        webView.stringByEvaluatingJavaScript(from: <span class="string">"document.getElementsByClassName('baiduimageplusm-title-img-only')[0].style.display = 'none'"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func webView(_ webView: <span class="built_in">UIWebView</span>, shouldStartLoadWith request: URLRequest, navigationType: <span class="built_in">UIWebViewNavigationType</span>) -&gt; Bool &#123;</span><br><span class="line">        guard let urlStr = request.url?.absoluteString <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">        print(urlStr)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 入坑指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> HTML5 </tag>
            
            <tag> WebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift之微信朋友圈图片浏览器</title>
      <link href="/2017/10/28/Swift%E4%B9%8B%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <content type="html"><![CDATA[<blockquote><p>最近闲来无事,突然对微信, 微博, QQ等社交APP的九宫格的图片浏览功能非常感兴趣, 最近就尝试着研究了一下:</p></blockquote><blockquote><p>这里先附上<a href="https://github.com/coderQuanjun/JunPhotoBrowseDemo" target="_blank" rel="noopener">Demo地址</a></p></blockquote><a id="more"></a><ul><li>在介绍项目之前, 先介绍三个基础知识<ul><li><code>CATransition</code>转场动画</li><li><code>ViewController</code>自定义转场</li><li><code>UIBesization</code>贝塞尔曲线</li></ul></li></ul><h2 id="一-CATransition转场动画"><a href="#一-CATransition转场动画" class="headerlink" title="一. CATransition转场动画"></a>一. CATransition转场动画</h2><blockquote><p>示例代码</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 转场动画</span></span><br><span class="line">let transition = <span class="built_in">CATransition</span>()</span><br><span class="line">transition.type = transitionType</span><br><span class="line">transition.subtype = isNext ? kCATransitionFromRight : kCATransitionFromLeft</span><br><span class="line">transition.duration = <span class="number">1</span></span><br><span class="line">downloadImage(url: imageURL)</span><br><span class="line">baseImage.layer.add(transition, forKey: <span class="string">"transition"</span>)</span><br></pre></td></tr></table></figure><p>更多关于该动画的详细介绍, 可参考<a href="http://www.jianshu.com/p/2b2f49399b7e" target="_blank" rel="noopener">iOS出门必备之CoreAnimation(核心动画)</a>中第七种CA动画, 故这里不多做介绍</p><h2 id="二-ViewController自定义转场"><a href="#二-ViewController自定义转场" class="headerlink" title="二. ViewController自定义转场"></a>二. <code>ViewController</code>自定义转场</h2><blockquote><p>从iOS7开始，苹果更新了自定义ViewController转场的API,会用到的几个协议<code>protocol</code>:</p></blockquote><ul><li>描述ViewController转场的：<ul><li><code>UIViewControllerTransitioningDelegate</code></li><li><code>UINavigationControllerDelegate</code></li><li><code>UITabBarControllerDelegate</code></li></ul></li><li>定义动画内容的<ul><li><code>UIViewControllerAnimatedTransitioning</code></li><li><code>UIViewControllerInteractiveTransitioning</code></li></ul></li><li>表示动画上下文的<ul><li><code>UIViewControllerContextTransitioning</code></li></ul></li></ul><h3 id="1-1-描述ViewController转场的"><a href="#1-1-描述ViewController转场的" class="headerlink" title="1-1. 描述ViewController转场的"></a>1-1. 描述ViewController转场的</h3><ul><li>为什么苹果要引入这一套API？因为在iOS7之前，做转场动画很麻烦，要写一大堆代码在ViewController中。</li><li>引入这一套API之后，在丰富功能的同时极大程度地降低了代码耦合，实现方式就是将之前在ViewController里面的代码通过protocol分离了出来。</li><li>顺着这个思路往下想，实现自定义转场动画首先需要找到ViewController的delegate。</li><li>苹果告诉我们切换ViewController有三种形式：<ul><li><code>UITabBarController</code>内部切换</li><li><code>UINavigationController</code>切换</li><li><code>present  ViewController</code></li><li>这三种方式是不是需要不同的protocol呢？</li></ul></li></ul><h3 id="1-2-详解Protocol"><a href="#1-2-详解Protocol" class="headerlink" title="1-2. 详解Protocol"></a>1-2. 详解Protocol</h3><ul><li><p><code>UIViewControllerTransitioningDelegate</code> 自定义模态转场动画时使用。</p><ul><li>设置<code>UIViewController</code>的属性<code>transitioningDelegate</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak open var transitioningDelegate: UIViewControllerTransitioningDelegate?</span><br></pre></td></tr></table></figure></li><li><p><code>UINavigationControllerDelegate</code> 自定义navigation转场动画时使用</p><ul><li>设置<code>UINavigationController</code>的属性<code>delegate</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak open var delegate: UINavigationControllerDelegate?</span><br></pre></td></tr></table></figure></li><li><p><code>UITabBarControllerDelegate</code>自定义tab转场动画时使用</p><ul><li>设置<code>UITabBarController</code>的属性<code>delegate</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak open var delegate: UITabBarControllerDelegate?</span><br></pre></td></tr></table></figure></li></ul><p>实际上这三个protocol干的事情是一样的只不过他们的应用场景不同罢了。我们下面以UINavigationControllerDelegate为例，其他的类似</p><ul><li><code>UINavigationControllerDelegate</code>主要的方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS <span class="number">7.0</span>, *)</span><br><span class="line">optional public func navigationController(_ navigationController: <span class="built_in">UINavigationController</span>, interactionControllerFor animationController: <span class="built_in">UIViewControllerAnimatedTransitioning</span>) -&gt; <span class="built_in">UIViewControllerInteractiveTransitioning</span>?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">7.0</span>, *)</span><br><span class="line">optional public func navigationController(_ navigationController: <span class="built_in">UINavigationController</span>, animationControllerFor operation: <span class="built_in">UINavigationControllerOperation</span>, from fromVC: <span class="built_in">UIViewController</span>, to toVC: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>?</span><br></pre></td></tr></table></figure><ul><li>两个方法分别返回<code>UIViewControllerInteractiveTransitioning</code>和<code>UIViewControllerAnimatedTransitioning</code>，它们的任务是描述动画行为（转场动画如何执行，就看它俩的）。</li><li>从名字可以看出，这两个<code>protocol</code>的区别在于是否是<code>interactive</code>的。如何理解？</li><li><code>interactive</code>动画可以根据输入信息的变化改变动画的进程。例如iOS系统为<code>UINavigationController</code>提供的默认右滑退出手势就是一个<code>interactive</code> 动画，整个动画的进程由用户手指的移动距离控制</li></ul><h3 id="1-3-UIViewControllerInteractiveTransitioning协议"><a href="#1-3-UIViewControllerInteractiveTransitioning协议" class="headerlink" title="1-3. UIViewControllerInteractiveTransitioning协议"></a>1-3. <code>UIViewControllerInteractiveTransitioning</code>协议</h3><blockquote><p>定义了两个属性可以做到平滑过渡</p><ul><li><code>completionCurve</code>: 交互结束后剩余动画的速率曲线</li><li><code>completionSpeed</code>: 交互结束后动画的开始速率由该参数与原来的速率相乘得到，实际上是个缩放参数，这里应该使用单位变化速率(即你要的速率/距离)。</li><li>注意：<ul><li><code>completionSpeed</code>会影响剩余的动画时间，而不是之前设定的转场动画时间剩下的时间；</li><li>当<code>completionSpeed</code>很小时剩余的动画时间可能会被拉伸得很长，所以过滤下较低的速率比较好。</li><li>如果不设置两个参数，转场动画将以原来的速率曲线在当前进度的速率继续。</li><li>不过从实际使用效果来看，往往不到0.5s的动画时间，基本上看不出什么效果来</li></ul></li></ul></blockquote><h3 id="1-4-定义动画内容的UIViewControllerAnimatedTransitioning"><a href="#1-4-定义动画内容的UIViewControllerAnimatedTransitioning" class="headerlink" title="1-4. 定义动画内容的UIViewControllerAnimatedTransitioning"></a>1-4. 定义动画内容的<code>UIViewControllerAnimatedTransitioning</code></h3><ul><li>必须实现的方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回动画的执行时间</span></span><br><span class="line">public func transitionDuration(using transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>?) -&gt; TimeInterval</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理具体的动画  </span></span><br><span class="line">public func animateTransition(using transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>)</span><br></pre></td></tr></table></figure><h3 id="1-5-表示动画上下文UIViewControllerContextTransitioning"><a href="#1-5-表示动画上下文UIViewControllerContextTransitioning" class="headerlink" title="1-5. 表示动画上下文UIViewControllerContextTransitioning"></a>1-5. 表示动画上下文<code>UIViewControllerContextTransitioning</code></h3><ul><li><code>UIViewControllerContextTransitioning提供了一系列方法</code></li><li>是唯一一个我们不需要实现的Protocol</li><li>下面是一些我们常用的属性和方法: </li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转场动画发生在该View中    </span></span><br><span class="line">public var containerView: <span class="built_in">UIView</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上报动画执行完毕</span></span><br><span class="line">public func completeTransition(_ didComplete: Bool)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key返回一个ViewController。我们通过`FromViewControllerKey`找到将被替换掉的VC，通过`ToViewControllerKey`找到将要显示的VC</span></span><br><span class="line">public func viewController(forKey key: <span class="built_in">UITransitionContextViewControllerKey</span>) -&gt; <span class="built_in">UIViewController</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key返回一个view, 我们通过from找到将要消失的view, 根据to找到将要弹出的view</span></span><br><span class="line">@available(iOS <span class="number">8.0</span>, *)</span><br><span class="line">public func view(forKey key: <span class="built_in">UITransitionContextViewKey</span>) -&gt; <span class="built_in">UIView</span>?</span><br></pre></td></tr></table></figure><h3 id="1-5-UIViewControllerTransitioningDelegate自定义模态转场时使用"><a href="#1-5-UIViewControllerTransitioningDelegate自定义模态转场时使用" class="headerlink" title="1-5. UIViewControllerTransitioningDelegate自定义模态转场时使用"></a>1-5. <code>UIViewControllerTransitioningDelegate</code>自定义模态转场时使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法是告诉系统,弹出动画交给谁来处理</span></span><br><span class="line">func animationController(forPresented presented: <span class="built_in">UIViewController</span>, presenting: <span class="built_in">UIViewController</span>, source: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">    isPresent = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法是告诉系统,消失动画交给谁来处理</span></span><br><span class="line">func animationController(forDismissed dismissed: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">    isPresent = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-图片浏览器项目介绍"><a href="#三-图片浏览器项目介绍" class="headerlink" title="三. 图片浏览器项目介绍"></a>三. 图片浏览器项目介绍</h2><h3 id="1-项目结构Alamofire-MVVM"><a href="#1-项目结构Alamofire-MVVM" class="headerlink" title="1. 项目结构Alamofire + MVVM"></a>1. 项目结构<code>Alamofire + MVVM</code></h3><p><img src="http://upload-images.jianshu.io/upload_images/4122543-20b3afa03d389bb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="框架结构"></p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-a54d1b9e6d553950.gif?imageMogr2/auto-orient/strip" alt="图片浏览器.gif"></p><h3 id="2-自定义ViewController的弹出和消失动画"><a href="#2-自定义ViewController的弹出和消失动画" class="headerlink" title="2. 自定义ViewController的弹出和消失动画"></a>2. 自定义<code>ViewController</code>的弹出和消失动画</h3><h4 id="2-1-自定义ViewController弹出和消失的Protocol"><a href="#2-1-自定义ViewController弹出和消失的Protocol" class="headerlink" title="2-1. 自定义ViewController弹出和消失的Protocol"></a>2-1. 自定义<code>ViewController</code>弹出和消失的Protocol</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: 自定义协议</span></span><br><span class="line">protocol JunBrowsePresentDelefate: <span class="built_in">NSObjectProtocol</span> &#123;</span><br><span class="line">    <span class="comment">/// 1. 提供弹出的imageView</span></span><br><span class="line">    func imageForPresent(indexPath: IndexPath) -&gt; <span class="built_in">UIImageView</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 2. 提供弹出的imageView的frame</span></span><br><span class="line">    func startImageRectForpresent(indexPath: IndexPath) -&gt; <span class="built_in">CGRect</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 3.提供弹出后imageView的frame</span></span><br><span class="line">    func endImageRectForpresent(indexPath: IndexPath) -&gt; <span class="built_in">CGRect</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol JunBrowserDismissDelegate &#123;</span><br><span class="line">    <span class="comment">/// 1.提供推出的imageView</span></span><br><span class="line">    func imageViewForDismiss() -&gt; <span class="built_in">UIImageView</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 2. 提供推出的indexPath</span></span><br><span class="line">    func indexPathForDismiss() -&gt; IndexPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-遵循协议"><a href="#2-2-遵循协议" class="headerlink" title="2-2. 遵循协议"></a>2-2. 遵循协议</h3><ul><li><code>UIViewControllerTransitioningDelegate</code>告诉系统弹出/消失动画的处理页面</li><li><code>UIViewControllerAnimatedTransitioning</code><ul><li>需要返回动画的执行时间</li><li>需要在弹出和消失页面的时候分别执行不同的动画</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: UIViewControllerTransitioningDelegate</span></span><br><span class="line">extension PhotoBrowseAnimation: <span class="built_in">UIViewControllerTransitioningDelegate</span> &#123;</span><br><span class="line">    <span class="comment">// 该方法是告诉系统,弹出动画交给谁来处理</span></span><br><span class="line">    func animationController(forPresented presented: <span class="built_in">UIViewController</span>, presenting: <span class="built_in">UIViewController</span>, source: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">        isPresent = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法是告诉系统,消失动画交给谁来处理</span></span><br><span class="line">    func animationController(forDismissed dismissed: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">        isPresent = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK: 继承AnimatedTransitioning协议</span></span><br><span class="line">extension PhotoBrowseAnimation: <span class="built_in">UIViewControllerAnimatedTransitioning</span> &#123;</span><br><span class="line">    <span class="comment">//返回动画的执行时间</span></span><br><span class="line">    func transitionDuration(using transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>?) -&gt; TimeInterval &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.6</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理具体的动画</span></span><br><span class="line">    func animateTransition(using transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>) &#123;</span><br><span class="line">        isPresent ? presentAnimation(transitionContext) : dismissAnimation(transitionContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-图片列表界面"><a href="#2-3-图片列表界面" class="headerlink" title="2-3. 图片列表界面"></a>2-3. 图片列表界面</h3><h4 id="1-在点击需要展示的imageView的时候-调用下面的方法"><a href="#1-在点击需要展示的imageView的时候-调用下面的方法" class="headerlink" title="1. 在点击需要展示的imageView的时候,调用下面的方法"></a>1. 在点击需要展示的imageView的时候,调用下面的方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK:- 弹出照片浏览器</span></span><br><span class="line">extension JunScrollViewController &#123;</span><br><span class="line">    fileprivate func presentPhotoBrowse(indexPath: IndexPath) &#123;</span><br><span class="line">        <span class="comment">//1. 创建图片浏览器</span></span><br><span class="line">        let photoBrowseVC = BrowseViewController(images: imageVM.imageArray, currentIndexP: indexPath)</span><br><span class="line">        <span class="comment">//2. 设置弹出样式为自定义</span></span><br><span class="line">        photoBrowseVC.modalPresentationStyle = .custom</span><br><span class="line">        <span class="comment">//3. 设置转场动画代理</span></span><br><span class="line">        photoBrowseVC.transitioningDelegate = photoAnimation</span><br><span class="line">        <span class="comment">//4. 设置broseAnimation的属性</span></span><br><span class="line">        photoAnimation.setProperty(indexPath: indexPath, <span class="keyword">self</span>, photoBrowseVC)</span><br><span class="line">        <span class="comment">//5. 弹出图片浏览器</span></span><br><span class="line">        present(photoBrowseVC, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-遵循并实现自定义的协议方法"><a href="#2-遵循并实现自定义的协议方法" class="headerlink" title="2. 遵循并实现自定义的协议方法"></a>2. 遵循并实现自定义的协议方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: JunBrowsePresentDelefate</span></span><br><span class="line">extension JunScrollViewController: JunBrowsePresentDelefate &#123;</span><br><span class="line">    func imageForPresent(indexPath: IndexPath) -&gt; <span class="built_in">UIImageView</span> &#123;</span><br><span class="line">        let imageV = <span class="built_in">UIImageView</span>()</span><br><span class="line">        imageV.contentMode = .scaleAspectFill</span><br><span class="line">        imageV.clipsToBounds = <span class="literal">true</span></span><br><span class="line">        <span class="comment">//设置图片</span></span><br><span class="line">        imageV.kf.setImage(with: URL(string: imageVM.imageArray[indexPath.item].pic74), placeholder: <span class="built_in">UIImage</span>(named: <span class="string">"coderJun"</span>))</span><br><span class="line">        <span class="keyword">return</span> imageV</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func startImageRectForpresent(indexPath: IndexPath) -&gt; <span class="built_in">CGRect</span> &#123;</span><br><span class="line">        <span class="comment">// 1.取出cell</span></span><br><span class="line">        guard let cell = imageCollection.cellForItem(at: indexPath) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: imageCollection.bounds.width * <span class="number">0.5</span>, y: kScreenHeight + <span class="number">50</span>, width: <span class="number">0</span>, height: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.计算转化为UIWindow上时的frame</span></span><br><span class="line">        <span class="keyword">return</span> imageCollection.convert( cell.frame, to: <span class="built_in">UIApplication</span>.shared.keyWindow)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func endImageRectForpresent(indexPath: IndexPath) -&gt; <span class="built_in">CGRect</span> &#123;</span><br><span class="line">        <span class="comment">//1. 取出对应的image的url</span></span><br><span class="line">        let imageUrl = URL(string: imageVM.imageArray[indexPath.item].pic74)!</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.从缓存中取出image</span></span><br><span class="line">        var image = KingfisherManager.shared.cache.retrieveImageInDiskCache(forKey: imageUrl.absoluteString)</span><br><span class="line">        <span class="keyword">if</span> image == <span class="literal">nil</span> &#123;</span><br><span class="line">            image = <span class="built_in">UIImage</span>(named: <span class="string">"coderJun"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.根据image计算位置</span></span><br><span class="line">        let imageH = kScreenWidth / image!.size.width * image!.size.height</span><br><span class="line">        let y: <span class="built_in">CGFloat</span> = imageH &lt; kScreenHeight ? (kScreenHeight - imageH) / <span class="number">2</span> : <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: y, width: kScreenWidth, height: imageH)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-在图片展示界面"><a href="#2-4-在图片展示界面" class="headerlink" title="2-4. 在图片展示界面"></a>2-4. 在图片展示界面</h3><ul><li>遵循并实现相关dismiss协议方法</li><li>该协议主要实现viewController返回到该图片对应的<code>IndexPath</code>所在的位置</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: JunBrowserDismissDelegate</span></span><br><span class="line">extension JunTranstionPhotoController: JunBrowserDismissDelegate&#123;</span><br><span class="line">    func imageViewForDismiss() -&gt; <span class="built_in">UIImageView</span> &#123;</span><br><span class="line">        let imageV = <span class="built_in">UIImageView</span>()</span><br><span class="line">        imageV.contentMode = .scaleAspectFill</span><br><span class="line">        imageV.clipsToBounds = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置图片</span></span><br><span class="line">        imageV.image = baseImage.image</span><br><span class="line">        imageV.frame = baseImage.convert(baseImage.frame, to: <span class="built_in">UIApplication</span>.shared.keyWindow)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> imageV</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func indexPathForDismiss() -&gt; IndexPath &#123;</span><br><span class="line">        <span class="keyword">return</span> IndexPath(item: currentIndex, section: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="GitHubDemo地址"><a href="#GitHubDemo地址" class="headerlink" title="GitHubDemo地址"></a>GitHub<a href="https://github.com/coderQuanjun/JunPhotoBrowseDemo" target="_blank" rel="noopener">Demo地址</a></h3><ul><li>注意:  <ul><li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li><li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Swiftk框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> CATransition </tag>
            
            <tag> UIBesizationv </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift开发之3DTouch实用演练</title>
      <link href="/2017/10/23/Swift%E5%BC%80%E5%8F%91%E4%B9%8B3DTouch%E5%AE%9E%E7%94%A8%E6%BC%94%E7%BB%83/"/>
      <content type="html"><![CDATA[<blockquote><p>2015年，苹果发布了iOS9以及<code>iphone6s/iphone6s Plus</code>，其中最具有创新的就是新的触控方式3D Touch,相对于多点触摸在平面二维空间的操作，3D Touch技术增加了对力度和手指面积的感知，可以通过长按快速预览、查看你想要的短信、图片或者超链接等内容，Peek和Pop手势的响应时间可迅捷到 10ms和15ms等。</p></blockquote><a id="more"></a><ul><li>用户现在可以按主屏幕图标立即访问应用程序提供的功能。</li><li>在您的应用程序中，用户现在可以按视图来查看其他内容的预览，并获得对功能的加速访问</li><li>在日常开发中,我们经常需要使用3D Touch中的两个功能<ul><li>在主屏幕上对应用图标使用3DTouch操作</li><li>在应用程序内对某一控件使用3DTouch操作</li></ul></li><li>功能需要iOS9以上系统和<code>iphone6s/iphone6s Plus</code>及以上机型(模拟机现在也是可以的)</li><li><a href="https://github.com/coderQuanjun/DouYuTV" target="_blank" rel="noopener">demo地址</a></li></ul><h2 id="一-效果演练"><a href="#一-效果演练" class="headerlink" title="一. 效果演练"></a>一. 效果演练</h2><h3 id="1-主屏幕快速操作"><a href="#1-主屏幕快速操作" class="headerlink" title="1. 主屏幕快速操作"></a>1. 主屏幕快速操作</h3><ul><li>通过按下iPhone 6s或iPhone 6s Plus上的应用程序图标，用户可以获得一组快速操作。</li><li>当用户选择快速操作时，您的应用程序激活或启动，并跳转到相应界面<br><img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/maps_directions_home_2x.png" alt="主屏幕快速操作"></li></ul><h3 id="2-Peek-and-Pop"><a href="#2-Peek-and-Pop" class="headerlink" title="2. Peek and Pop"></a>2. Peek and Pop</h3><blockquote><ul><li>对界面内某一控件的3DTouch操作</li><li>Peek和Pop是应用内的一种全新交互模式,当用户不断增加力量在控件上按压,会依次进入四个阶段</li></ul><ul><li>轻按控件,除触发Peek的控件外,其他区域全部虚化</li><li>继续用力Peek被触发,展示Pop界面快照</li><li>向上滑动展示快捷选项</li><li>继续用力跳转进入Pop界面</li></ul></blockquote><p><img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/preview_available_2_2x.png" alt="轻按控件,除触发Peek的控件外,其他区域全部虚化"></p><p><img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/peek_2x.png" alt="继续用力Peek被触发,展示Pop界面快照"></p><p><img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/peek_quick_actions_2x.png" alt="向上滑动展示快捷选项"></p><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h3><ul><li>3D Touch仅在3D Touch设备上可用，如果启用。在iOS 9以上，默认情况下启用3D Touch。</li><li>用户可以在设置&gt;常规&gt;辅助功能&gt; 3D触摸中关闭3D触摸。</li><li>当3D Touch可用时，利用其功能。当它不可用时，提供替代方法，例如通过使用触摸和保持。</li><li>3D Touch功能支持VoiceOver。</li></ul><h2 id="二-主屏幕操作"><a href="#二-主屏幕操作" class="headerlink" title="二. 主屏幕操作"></a>二. 主屏幕操作</h2><ul><li><code>ShortcutItem</code>功能允许用户在主屏幕上对应用图标使用<code>3DTouch</code>操作,如果本次操作有效,则会给出几个快捷可选项允许用户进行操作</li><li>主屏幕icon上的快捷标签的实现方式有两种，一种是在工程文件info.plist里静态设置，另一种是代码的动态实现</li><li>优先显示静态添加，总数达到4个不再显示</li></ul><h3 id="1-静态设置"><a href="#1-静态设置" class="headerlink" title="1. 静态设置"></a>1. 静态设置</h3><ul><li>在info.plist中添加<code>UIApplicationShortcutItems</code>关键字,以如下方式配置即可</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-e90081ad823f9859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIApplicationShortcutItems配置"></p><blockquote><p>其中各个关键字释义如下:</p><ul><li><code>UIApplicationShortcutItemType</code>: 快捷可选项的特定字符串(必填)</li><li><code>UIApplicationShortcutItemTitle</code>: 快捷可选项的标题(必填)</li><li><code>UIApplicationShortcutItemSubtitle</code>: 快捷可选项的子标题(可选)</li><li><code>UIApplicationShortcutItemIconType</code>: 快捷可选项的图标(可选)</li><li><code>UIApplicationShortcutItemIconFile</code>: 快捷可选项的自定义图标(可选)</li><li><code>UIApplicationShortcutItemUserInfo</code>: 快捷可选项的附加信息(可选)</li></ul></blockquote><h3 id="2-动态添加UIApplicationShortcutItem"><a href="#2-动态添加UIApplicationShortcutItem" class="headerlink" title="2. 动态添加UIApplicationShortcutItem"></a>2. 动态添加<code>UIApplicationShortcutItem</code></h3><h4 id="2-1-UIApplicationShortcutItem初始化方法"><a href="#2-1-UIApplicationShortcutItem初始化方法" class="headerlink" title="2-1. UIApplicationShortcutItem初始化方法"></a>2-1. <code>UIApplicationShortcutItem</code>初始化方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIApplicationShortcutItem</span>(type: String, localizedTitle: String, localizedSubtitle: String?, icon: <span class="built_in">UIApplicationShortcutIcon</span>?, userInfo: [AnyHashable : Any]?)</span><br></pre></td></tr></table></figure><ul><li>参数介绍<ul><li><code>type</code>: 快捷可选项的特定字符串(必填)</li><li><code>localizedTitle</code>: 快捷可选项的标题(必填)</li><li><code>localizedSubtitle</code>: 快捷可选项的子标题(可选)</li><li><code>icon</code>: 快捷可选项的图标(可选)</li><li><code>userInfo</code>: 快捷可选项的附加信息(可选)</li></ul></li></ul><h4 id="2-1-图标"><a href="#2-1-图标" class="headerlink" title="2-1. 图标"></a>2-1. 图标</h4><h5 id="2-1-1-初始化方式"><a href="#2-1-1-初始化方式" class="headerlink" title="2-1-1. 初始化方式"></a>2-1-1. 初始化方式</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一: 自定义图标</span></span><br><span class="line"><span class="comment">//注: 自定义图标需要使用镂空图标,同时建议1倍图标大小为35*35</span></span><br><span class="line"><span class="built_in">UIApplicationShortcutIcon</span>(templateImageName: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二: 使用系统图标</span></span><br><span class="line"><span class="built_in">UIApplicationShortcutIcon</span>(type: <span class="built_in">UIApplicationShortcutIconType</span>)</span><br></pre></td></tr></table></figure><h5 id="2-1-2-系统图标样式如下"><a href="#2-1-2-系统图标样式如下" class="headerlink" title="2-1-2. 系统图标样式如下"></a>2-1-2. 系统图标样式如下</h5><p><img src="http://upload-images.jianshu.io/upload_images/4122543-50ce942abc9a5174.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统图片一览表"></p><h4 id="2-3-具体实现代码如下"><a href="#2-3-具体实现代码如下" class="headerlink" title="2-3. 具体实现代码如下"></a>2-3. 具体实现代码如下</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func application(_ application: <span class="built_in">UIApplication</span>, didFinishLaunchingWithOptions launchOptions: [<span class="built_in">UIApplicationLaunchOptionsKey</span>: Any]?) -&gt; Bool &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3D Touch</span></span><br><span class="line">    let homeIcon = <span class="built_in">UIApplicationShortcutIcon</span>(type: .compose)</span><br><span class="line">    let homeItem = <span class="built_in">UIApplicationShortcutItem</span>(type: <span class="string">"homeAnchor"</span>, localizedTitle: <span class="string">"首页"</span>, localizedSubtitle: <span class="string">"点击进入首页"</span>, icon: homeIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line">    let playIcon = <span class="built_in">UIApplicationShortcutIcon</span>(type: .play)</span><br><span class="line">    let playItem = <span class="built_in">UIApplicationShortcutItem</span>(type: <span class="string">"play"</span>, localizedTitle: <span class="string">"播放"</span>, localizedSubtitle: <span class="string">""</span>, icon: playIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line">    let userIcon = <span class="built_in">UIApplicationShortcutIcon</span>(type: .search)</span><br><span class="line">    let userItem = <span class="built_in">UIApplicationShortcutItem</span>(type: <span class="string">"username"</span>, localizedTitle: <span class="string">"用户名"</span>, localizedSubtitle: <span class="string">""</span>, icon: userIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIApplication</span>.shared.shortcutItems = [homeItem, playItem, userItem]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-item点击跳转"><a href="#2-4-item点击跳转" class="headerlink" title="2-4. item点击跳转"></a>2-4. item点击跳转</h4><ul><li>可根据<code>type</code>标识判断</li><li>可根据<code>localizedTitle</code>标识判断</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜单跳转</span></span><br><span class="line">func application(_ application: <span class="built_in">UIApplication</span>, performActionFor shortcutItem: <span class="built_in">UIApplicationShortcutItem</span>, completionHandler: @escaping (Bool) -&gt; Void) &#123;</span><br><span class="line">    guard let tabBarVC = window?.rootViewController as? MainViewController <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据type唯一标识进行判断跳转, 或者根据localizedTitle判断</span></span><br><span class="line">    <span class="keyword">switch</span> shortcutItem.type &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"homeAnchor"</span>:</span><br><span class="line">        tabBarVC.selectedIndex = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"play"</span>:</span><br><span class="line">        let username = ShowRoomViewController()</span><br><span class="line">        username.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">        tabBarVC.selectedViewController?.childViewControllers.first?.present(username, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"username"</span>:</span><br><span class="line">        let username = NameViewController()</span><br><span class="line">        username.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">        tabBarVC.selectedViewController?.childViewControllers.last?.navigationController?.pushViewController(username, animated: <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        tabBarVC.selectedIndex = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-Peek-and-Pop"><a href="#三-Peek-and-Pop" class="headerlink" title="三. Peek and Pop"></a>三. Peek and Pop</h2><ul><li>Peek和Pop是应用内的一种全新交互模式,当用户不断增加力量在控件上按压,会依次进入四个阶段</li><li>这里小编将通过ViewController里面的UITableViewCell进行延时功能</li></ul><hr><blockquote><p>注意: 在动态添加快捷可选项前,需要用判断是否支持3D Touch功能,以免在不支持的设备上运行程序导致闪退</p></blockquote><h3 id="1-判断是否支持3D-Touch功能"><a href="#1-判断是否支持3D-Touch功能" class="headerlink" title="1. 判断是否支持3D Touch功能"></a>1. 判断是否支持3D Touch功能</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func tableView(_ tableView: <span class="built_in">UITableView</span>, cellForRowAt indexPath: IndexPath) -&gt; <span class="built_in">UITableViewCell</span> &#123;</span><br><span class="line">    var cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>)</span><br><span class="line">    let model = happyVM.anchorGroups[indexPath.section].anchors[indexPath.row]</span><br><span class="line">    <span class="keyword">if</span> cell == <span class="literal">nil</span> &#123;</span><br><span class="line">        cell = <span class="built_in">UITableViewCell</span>(style: .default, reuseIdentifier: <span class="string">"cell"</span>)</span><br><span class="line">        cell?.textLabel?.text = model.room_name</span><br><span class="line">        cell?.accessoryType = .disclosureIndicator</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是添加判断是否支持3D Touch的代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="meta">#available(iOS 9.0, *) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> traitCollection.forceTouchCapability == .available &#123;</span><br><span class="line">            <span class="comment">//支持3D Touch</span></span><br><span class="line">            <span class="comment">//注册Peek &amp; Pop功能</span></span><br><span class="line">            registerForPreviewing(with: <span class="keyword">self</span>, sourceView: cell!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>检测是否支持3D Touch：UIForceTouchCapability是一个枚举值,取值如下：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> unknown      <span class="comment">//3D Touch检测失败</span></span><br><span class="line"><span class="keyword">case</span> unavailable <span class="comment">//3D Touch不可用</span></span><br><span class="line"><span class="keyword">case</span> available  <span class="comment">//3D Touch可用</span></span><br></pre></td></tr></table></figure><h3 id="2-给对应view注册3Dtouch事件"><a href="#2-给对应view注册3Dtouch事件" class="headerlink" title="2. 给对应view注册3Dtouch事件"></a>2. 给对应view注册3Dtouch事件</h3><ul><li>在判断支持3Dtouch里面注册</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册Peek &amp; Pop功能</span></span><br><span class="line"><span class="keyword">self</span>.registerForPreviewing(with: <span class="keyword">self</span>, sourceView: cell!)</span><br></pre></td></tr></table></figure><h3 id="3-遵守UIViewControllerPreviewingDelegate协议"><a href="#3-遵守UIViewControllerPreviewingDelegate协议" class="headerlink" title="3. 遵守UIViewControllerPreviewingDelegate协议"></a>3. 遵守<code>UIViewControllerPreviewingDelegate</code>协议</h3><ul><li>需要实现Peek &amp; Pop交互的控件所在的控制器遵循协议并实现两个代理方法</li></ul><h4 id="3-1-当进入Peek状态时-系统会回调如下方法"><a href="#3-1-当进入Peek状态时-系统会回调如下方法" class="headerlink" title="3-1. 当进入Peek状态时,系统会回调如下方法"></a>3-1. 当进入Peek状态时,系统会回调如下方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func previewingContext(_ previewingContext: <span class="built_in">UIViewControllerPreviewing</span>, viewControllerForLocation location: <span class="built_in">CGPoint</span>) -&gt; <span class="built_in">UIViewController</span>? &#123;</span><br><span class="line">    <span class="comment">//1. 获取按压的cell所在的行</span></span><br><span class="line">    guard let cell = previewingContext.sourceView as? <span class="built_in">UITableViewCell</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">UIViewController</span>() &#125;</span><br><span class="line">    let indexPath = tableVIew.indexPath(<span class="keyword">for</span>: cell) ?? IndexPath(row: <span class="number">0</span>, section: <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 设定预览界面</span></span><br><span class="line">    let vc = ShowRoomViewController()</span><br><span class="line">    <span class="comment">// 预览区域大小(可不设置), 0为默认尺寸</span></span><br><span class="line">    vc.preferredContentSize = <span class="built_in">CGSize</span>(width: <span class="number">0</span>, height: <span class="number">0</span>)</span><br><span class="line">    vc.showStr =  <span class="string">"我是第\(indexPath.row)行用力按压进来的"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调整不被虚化的范围，按压的那个cell不被虚化（轻轻按压时周边会被虚化，再少用力展示预览，再加力跳页至设定界面）</span></span><br><span class="line">    let rect = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: kScreenWidth, height: <span class="number">44</span>)</span><br><span class="line">    <span class="comment">//设置触发操作的视图的不被虚化的区域</span></span><br><span class="line">    previewingContext.sourceRect = rect</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回预览界面</span></span><br><span class="line">    <span class="keyword">return</span> vc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-当进入Pop状态时-系统会回调如下方法"><a href="#3-2-当进入Pop状态时-系统会回调如下方法" class="headerlink" title="3-2. 当进入Pop状态时,系统会回调如下方法"></a>3-2. 当进入Pop状态时,系统会回调如下方法</h4><ul><li>用力按压进入<code>viewControllerToCommit</code></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func previewingContext(_ previewingContext: <span class="built_in">UIViewControllerPreviewing</span>, commit viewControllerToCommit: <span class="built_in">UIViewController</span>) &#123;</span><br><span class="line">    viewControllerToCommit.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">    show(viewControllerToCommit, sender: <span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>来看看效果</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-e093ea0e213ef573.gif?imageMogr2/auto-orient/strip" alt="3D Touch1演示.gif"></p><h4 id="3-4-当弹出预览时，上滑预览视图，出现预览视图中快捷选项"><a href="#3-4-当弹出预览时，上滑预览视图，出现预览视图中快捷选项" class="headerlink" title="3-4. 当弹出预览时，上滑预览视图，出现预览视图中快捷选项"></a>3-4. 当弹出预览时，上滑预览视图，出现预览视图中快捷选项</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var previewActionItems: [<span class="built_in">UIPreviewActionItem</span>] &#123; get &#125;</span><br></pre></td></tr></table></figure><ul><li><code>previewActionItems</code>用户在3D Touch预览上向上滑动时显示的快速操作</li><li>在将要弹出的页面内重写previewActionItems的get属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">extension ShowRoomViewController &#123;</span><br><span class="line">    <span class="comment">//重写previewActionItems的get方法</span></span><br><span class="line">    override var previewActionItems: [<span class="built_in">UIPreviewActionItem</span>] &#123;</span><br><span class="line">        let action1 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">"跳转"</span>, style: .default) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            let showVC = ShowRoomViewController()</span><br><span class="line">            showVC.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">            previewViewController.navigationController?.pushViewController(showVC, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let action3 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">"取消"</span>, style: .destructive) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">"我是取消按钮"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">////该按钮可以是一个组，点击该组时，跳到组里面的按钮。</span></span><br><span class="line">        let subAction1 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">"测试1"</span>, style: .selected) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">"我是测试按钮1"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        let subAction2 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">"测试2"</span>, style: .selected) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">"我是测试按钮2"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        let subAction3 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">"测试3"</span>, style: .selected) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">"我是测试按钮3"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        let groupAction = <span class="built_in">UIPreviewActionGroup</span>(title: <span class="string">"更多"</span>, style: .default, actions: [subAction1, subAction2, subAction3])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [action1, action3, groupAction]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>action的各种样式</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">enum</span> <span class="built_in">UIPreviewActionStyle</span> : Int &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认样式</span></span><br><span class="line">    <span class="keyword">case</span> `<span class="keyword">default</span>`</span><br><span class="line">    <span class="comment">//右侧有对勾的样式</span></span><br><span class="line">    <span class="keyword">case</span> selected</span><br><span class="line">    <span class="comment">//红色字体的样式</span></span><br><span class="line">    <span class="keyword">case</span> destructive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-force-和-maximumPossibleForce"><a href="#3-5-force-和-maximumPossibleForce" class="headerlink" title="3-5. force 和 maximumPossibleForce"></a>3-5. <code>force</code> 和 <code>maximumPossibleForce</code></h4><blockquote><p>到此，3DTouch在APP中的集成就先介绍这些，3DTouch中还有个重要的属性–压力属性（force 和 maximumPossibleForce）这里简单介绍下</p></blockquote><ul><li>手指在屏幕上慢慢增加力度在减少力度，可以看到view背景色的变化</li><li>程序运行后找到<code>我的</code> -&gt; <code>头像(用户名)</code>查看效果</li><li>代码找到<code>NameViewController.swift</code>查看</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">override func touchesMoved(_ touches: Set&lt;<span class="built_in">UITouch</span>&gt;, with event: <span class="built_in">UIEvent</span>?) &#123;</span><br><span class="line">    let touch = touches.first ?? <span class="built_in">UITouch</span>()</span><br><span class="line">    <span class="comment">//获取重按力度</span></span><br><span class="line">    print(<span class="string">"平均触摸的力--\(touch.force)"</span>)</span><br><span class="line">    print(<span class="string">"触摸的最大可能力--\(touch.maximumPossibleForce)"</span>)</span><br><span class="line">    </span><br><span class="line">    let change = touch.force / touch.maximumPossibleForce</span><br><span class="line">        view.backgroundColor = <span class="built_in">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.5</span>, blue: change, alpha: <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>此外还有以下属性, 详细可参考<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/3DTouchAPIs.html#//apple_ref/doc/uid/TP40016543-CH4-SW1" target="_blank" rel="noopener">3D Touch官方文档</a></p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var tapCount: Int</span><br><span class="line"><span class="comment">//手指触摸此次触摸的次数。</span></span><br><span class="line"></span><br><span class="line">var timestamp: TimeInterval</span><br><span class="line"><span class="comment">//触摸发生的时间或最后一次突变的时间。</span></span><br><span class="line"></span><br><span class="line">var type: <span class="built_in">UITouchType</span></span><br><span class="line"><span class="comment">//触摸的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="built_in">UITouchType</span></span><br><span class="line"><span class="comment">//接收的触摸类型。</span></span><br><span class="line"></span><br><span class="line">var phase: <span class="built_in">UITouchPhase</span></span><br><span class="line"><span class="comment">//触摸的阶段。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="built_in">UITouchPhase</span></span><br><span class="line"><span class="comment">//手指触摸的阶段。</span></span><br><span class="line"></span><br><span class="line">var maximumPossibleForce: <span class="built_in">CGFloat</span></span><br><span class="line"><span class="comment">//触摸的最大可能力。</span></span><br><span class="line"></span><br><span class="line">var force: <span class="built_in">CGFloat</span></span><br><span class="line"><span class="comment">//触摸力，其中值表示平均触摸的力（由系统预定，不是用户特定的）。1.0</span></span><br><span class="line"></span><br><span class="line">var altitudeAngle: <span class="built_in">CGFloat</span></span><br><span class="line"><span class="comment">//手写笔的高度（弧度）。</span></span><br><span class="line"></span><br><span class="line">func azimuthAngle(<span class="keyword">in</span>: <span class="built_in">UIView</span>?)</span><br><span class="line"><span class="comment">//返回触控笔的方位角（弧度）。</span></span><br><span class="line"></span><br><span class="line">func azimuthUnitVector(<span class="keyword">in</span>: <span class="built_in">UIView</span>?)</span><br><span class="line"><span class="comment">//返回指向触控笔方位角方向的单位向量。</span></span><br></pre></td></tr></table></figure><h3 id="最后附上Demo地址"><a href="#最后附上Demo地址" class="headerlink" title="最后附上Demo地址"></a>最后附上<a href="https://github.com/coderQuanjun/DouYuTV" target="_blank" rel="noopener">Demo地址</a></h3><hr><blockquote><p>参考资料</p></blockquote><p><a href="http://liuyanwei.jumppo.com/2016/04/01/iOS-3DTouch-2.html" target="_blank" rel="noopener">iOS 3D touch开发 </a></p><p><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/3DTouchAPIs.html#//apple_ref/doc/uid/TP40016543-CH4-SW1" target="_blank" rel="noopener">3D Touch官方文档</a></p>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 3DTouch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactNaive之CSS和Flex布局</title>
      <link href="/2017/10/23/ReactNaive%E4%B9%8BCSS%E5%92%8CFlex%E5%B8%83%E5%B1%80/"/>
      <content type="html"><![CDATA[<p>ReactNaive之CSS和Flex布局<br><a id="more"></a></p><h2 id="一-和-的使用"><a href="#一-和-的使用" class="headerlink" title="一. {}和()的使用"></a>一. {}和()的使用</h2><h3 id="1-的使用"><a href="#1-的使用" class="headerlink" title="1. {}的使用"></a>1. {}的使用</h3><h4 id="1-1-ReactNative中，使用表达式的时候需要用-包住"><a href="#1-1-ReactNative中，使用表达式的时候需要用-包住" class="headerlink" title="1-1. ReactNative中，使用表达式的时候需要用{}包住"></a>1-1. ReactNative中，使用表达式的时候需要用{}包住</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=&#123;styles.mainStyle&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-ReactNative中-在字符串中使用变量的时候，需要用-包住"><a href="#1-2-ReactNative中-在字符串中使用变量的时候，需要用-包住" class="headerlink" title="1-2. ReactNative中,在字符串中使用变量的时候，需要用{}包住"></a>1-2. ReactNative中,在字符串中使用变量的时候，需要用{}包住</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = 'hello'</span><br><span class="line">&lt;Text&gt;&#123;str&#125;&lt;/Text&gt;</span><br></pre></td></tr></table></figure><h4 id="1-3-ReactNative中，对象，字典需要用-包住"><a href="#1-3-ReactNative中，对象，字典需要用-包住" class="headerlink" title="1-3. ReactNative中，对象，字典需要用{}包住"></a>1-3. ReactNative中，对象，字典需要用{}包住</h4><ul><li><code>style = {}</code>,最外层表达式，用{}包住</li><li><code>{flex:1}</code>,对象，用{}包住</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;&lt;/View&gt;</span><br></pre></td></tr></table></figure><h3 id="2-的使用"><a href="#2-的使用" class="headerlink" title="2. ()的使用"></a>2. ()的使用</h3><ul><li>创建组件<code>&lt;View&gt;&lt;/View&gt;</code>，必须要用()包住<ul><li>因此只要返回组件，都需要用()</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;View style=&#123;styles.mainStyle&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-ReactNative之CSS布局"><a href="#二-ReactNative之CSS布局" class="headerlink" title="二. ReactNative之CSS布局"></a>二. ReactNative之CSS布局</h2><ul><li>ReactNative支持CSS中的布局属性，因此可以使用CSS布局属性</li><li>CSS颜色大全，下面会用到，点击这<a href="http://www.cnblogs.com/axing/archive/2011/04/09/CSS.html" target="_blank" rel="noopener">CSS颜色代码大全</a></li></ul><h3 id="1-视图边框"><a href="#1-视图边框" class="headerlink" title="1. 视图边框"></a>1. 视图边框</h3><ul><li>什么时候使用？想设置自己周边有边框的时候</li><li>注意点：<strong><em>一定要设置边框宽度</em></strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">borderBottomWidth number <span class="comment">//底部边框宽度</span></span><br><span class="line">borderLeftWidth number <span class="comment">//左边框宽度</span></span><br><span class="line">borderRightWidth number <span class="comment">//右边框宽度</span></span><br><span class="line">borderTopWidth number <span class="comment">//顶部边框宽度</span></span><br><span class="line">borderWidth number <span class="comment">//边框宽度</span></span><br><span class="line">border&lt;Bottom|Left|Right|Top&gt;Color <span class="comment">//各方向边框的颜色,&lt;&gt;表示连着一起，例如borderBottomColor</span></span><br><span class="line">borderColor <span class="comment">//边框颜色</span></span><br></pre></td></tr></table></figure><h3 id="2-尺寸"><a href="#2-尺寸" class="headerlink" title="2. 尺寸"></a>2. 尺寸</h3><h4 id="2-1-设置宽高"><a href="#2-1-设置宽高" class="headerlink" title="2-1. 设置宽高"></a>2-1. 设置宽高</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width number</span><br><span class="line">height number</span><br></pre></td></tr></table></figure><h4 id="2-2-外边距"><a href="#2-2-外边距" class="headerlink" title="2-2. 外边距"></a>2-2. 外边距</h4><ul><li>设置组件与组件之间的间距<ul><li>注意：第一个组件比较特殊，参照父组件，与父控件之间的间距。</li><li>其他组件间距，相对于上一个组件</li></ul></li><li>什么时候使用？想设置自己在父控件的位置的时候使用</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">margin number 外边距</span><br><span class="line">marginBottom number 下外边距</span><br><span class="line">marginHorizontal number 左右外边距</span><br><span class="line">marginLeft number 左外边距</span><br><span class="line">marginRight number 右外边距</span><br><span class="line">marginTop number 上外边距</span><br><span class="line">marginVertical number 上下外边距</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意marginRight和width冲突，如果设置了width，marginRight无效。</span></span><br></pre></td></tr></table></figure><h4 id="2-3-内边距"><a href="#2-3-内边距" class="headerlink" title="2-3. 内边距"></a>2-3. 内边距</h4><ul><li>设置子控件与当前控件的位置</li><li>什么时候使用？想设置自己的子控件相对自己的位置的时候使用</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">padding number 内边距</span><br><span class="line">paddingBottom number 下内边距</span><br><span class="line">paddingHorizontal number 左右内边距</span><br><span class="line">paddingLeft number 做内边距</span><br><span class="line">paddingRight number 右内边距</span><br><span class="line">paddingTop number 上内边距</span><br><span class="line">paddingVertical number 上下内边距</span><br></pre></td></tr></table></figure><h4 id="2-4-相对定位和绝对定位"><a href="#2-4-相对定位和绝对定位" class="headerlink" title="2-4. 相对定位和绝对定位"></a>2-4. 相对定位和绝对定位</h4><h4 id="2-4-1-边缘"><a href="#2-4-1-边缘" class="headerlink" title="2-4-1. 边缘"></a>2-4-1. 边缘</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left   number  左边缘。</span><br><span class="line">right  number  右边缘。</span><br><span class="line">top    number  顶部边缘。</span><br><span class="line">bottom number  底部边缘。</span><br></pre></td></tr></table></figure><h4 id="2-4-2-定位-position"><a href="#2-4-2-定位-position" class="headerlink" title="2-4-2. 定位(position):"></a>2-4-2. 定位(position):</h4><ul><li>通过 <code>left</code>, <code>top</code>, <code>right</code> 以及 <code>bottom</code> 边缘属性进行定位。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">absolute：绝对定位，参照父控件位置定位</span><br><span class="line">relative：相对定位，参照当前控件原始位置定位</span><br></pre></td></tr></table></figure><ul><li>什么时候使用绝对定位，当想把一个已经设置了宽度的控件快速的放在左下角，右下角的时候，可以使用绝对定位</li><li>什么时候使用相对定位，当想相对自己做出一些改变的时候，采用相对定位,比如相对自己，往下移动一点</li></ul><h2 id="ReactNative之Flex布局"><a href="#ReactNative之Flex布局" class="headerlink" title="ReactNative之Flex布局"></a>ReactNative之Flex布局</h2><ul><li>一般使用ReactNative开发App,一般都采用Flex布局，使用这套布局就非常快。</li></ul><h3 id="1-Flex简介"><a href="#1-Flex简介" class="headerlink" title="1. Flex简介"></a>1. Flex简介</h3><ul><li>Flex又叫弹性布局，会把当前组件看做一个容器，他的所有子组件都是他容器中的成员，通过Flex，就能迅速的布局容器中的成员。</li><li>使用场景：当想快速布局一个组件中所有子组件的时候，可以使用Flex布局</li></ul><h3 id="2-Flex主轴和侧轴"><a href="#2-Flex主轴和侧轴" class="headerlink" title="2. Flex主轴和侧轴"></a>2. Flex主轴和侧轴</h3><ul><li>Flex中有两个主要的概念：主轴和侧轴</li><li>主轴与侧轴的关系：相互垂直的。</li><li>主轴：决定容器中子组件默认的布局方向：水平，垂直</li><li>侧轴：决定容器中子组件与主轴垂直的布局方向<ul><li>比如主轴水平，那么子组件默认就是水平布局排布，侧轴就是控制子组件在垂直方向的布局</li></ul></li></ul><h3 id="3-flexDirection属性"><a href="#3-flexDirection属性" class="headerlink" title="3. flexDirection属性"></a>3. flexDirection属性</h3><ul><li>flexDirection:决定主轴的方向，水平或者垂直，这样子组件就会水平排布或者垂直排布</li><li>flexDirection共有四个值，在RN中默认为column。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row（默认值）：主轴为水平方向，从左向右。依次排列</span><br><span class="line">row-reverse：主轴为水平方向，从右向左依次排列</span><br><span class="line">column：主轴为垂直方向，默认的排列方式，从上向下排列</span><br><span class="line">column-reverse：主轴为垂直方向，从下向上排列</span><br></pre></td></tr></table></figure><h3 id="4-flexWrap属性"><a href="#4-flexWrap属性" class="headerlink" title="4. flexWrap属性"></a>4. flexWrap属性</h3><ul><li>flexWrap:决定子控件在父视图内是否允许多行排列。</li><li>flexWrap共有两个值，默认为nowrap。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nowrap 组件只排列在一行上，可能导致溢出。</span><br><span class="line">wrap   组件在一行排列不下时，就进行多行排列</span><br></pre></td></tr></table></figure><h3 id="5-justifyContent"><a href="#5-justifyContent" class="headerlink" title="5. justifyContent"></a>5. justifyContent</h3><ul><li><code>justifyContent</code>:决定子组件在主轴中具体布局，是靠左，还是居中等</li><li><code>justifyContent</code>共有五个值，默认为<code>flex-start</code></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start: <span class="comment">//子组件向主轴起点对齐，如果主轴水平，从左开始，主轴垂直，从上开始。</span></span><br><span class="line">flex-end:  <span class="comment">//子组件向主轴终点对齐，如果主轴水平，从右开始，主轴垂直，从下开始。</span></span><br><span class="line">center: <span class="comment">//居中显示，注意：并不是让某一个子组件居中，而是整体有居中效果</span></span><br><span class="line">space-between: <span class="comment">//均匀分配,相邻元素间距离相同。每行第一个组件与行首对齐，每行最后一个组件与行尾对齐。</span></span><br><span class="line">space-around: <span class="comment">//均匀分配,相邻元素间距离相同。每行第一个组件到行首的距离和每行最后一个组件到行尾的距离将会是相邻元素之间距离的一半</span></span><br></pre></td></tr></table></figure><h3 id="6-alignItems"><a href="#6-alignItems" class="headerlink" title="6. alignItems"></a>6. alignItems</h3><ul><li><code>alignItems</code>:决定子组件在测轴中具体布局<br>一直都没有管过侧轴，如果侧轴垂直，决定子组件在上，还是下，或者居中</li><li><code>alignItems</code>共有四个值，默认为<code>stretch</code>。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex-start 子组件向侧轴起点对齐。</span><br><span class="line">flex-end 子组件向侧轴终点对齐。</span><br><span class="line">center 子组件在侧轴居中。</span><br><span class="line">stretch 子组件在侧轴方向被拉伸到与容器相同的高度或宽度。</span><br></pre></td></tr></table></figure><h3 id="7-alignSelf"><a href="#7-alignSelf" class="headerlink" title="7. alignSelf"></a>7. alignSelf</h3><ul><li><code>alignSelf</code>:自定义自己的侧轴布局，用于一个子组件设置。</li><li>注意：当某个子组件不想参照默认的<code>alignItems</code>时，可以设置<code>alignSelf</code>，自定义自己的侧轴布局。</li><li><code>alignSelf</code>共有五个值，默认为<code>auto</code>。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto 继承它的父容器的alignItems属性。如果没有父容器则为 <span class="string">"stretch"</span></span><br><span class="line">flex-start 子组件向侧轴起点对齐。</span><br><span class="line">flex-end 子组件向侧轴终点对齐。</span><br><span class="line">center 子组件在侧轴居中。</span><br><span class="line">stretch 子组件在侧轴方向被拉伸到与容器相同的高度或宽度。</span><br></pre></td></tr></table></figure><h3 id="8-flex"><a href="#8-flex" class="headerlink" title="8. flex"></a>8. flex</h3><ul><li><code>flex</code>: 决定子控件在主轴中占据几等分。</li><li><code>flex</code>: 任意数字，所有子控件<code>flex</code>相加，自己<code>flex</code>占总共多少，就有多少宽度.</li></ul><h2 id="三-ReactNative之组件属性-Props、State"><a href="#三-ReactNative之组件属性-Props、State" class="headerlink" title="三. ReactNative之组件属性(Props、State)"></a>三. ReactNative之组件属性(Props、State)</h2><ul><li>在App开发中，少不了组件之间的传值，在RN中组件之间通信需要用到Props和State。</li></ul><h3 id="1-Props-属性"><a href="#1-Props-属性" class="headerlink" title="1. Props(属性)"></a>1. Props(属性)</h3><ul><li>什么是Props？一般用于自定义组件，大多数组件在创建时就可以使用各种参数来进行定制，用于定制的这些参数就称为props（属性）。</li><li>props不能在自己的组件中修改, 只能在父组件中修改</li><li>如果想在自己的组件中修改属性, 需要用state</li><li><code>name</code>:就是<code>Props</code>，通过<code>this.props.name</code>访问</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Room name=<span class="string">"小码哥"</span> /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：props是在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。</p></blockquote><h3 id="2-State"><a href="#2-State" class="headerlink" title="2. State"></a>2. State</h3><ul><li>State：如果以后想修改某个属性，就修改界面，就需要用state。</li><li>注意:State属性一般在constructor中声明(ES6)，在setState中修改数据.</li><li>定义state属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">    num:<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>修改state属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    num : number</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ReactNaive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Flex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift之Facebook的POP动画使用和实战</title>
      <link href="/2017/10/17/Swift%E4%B9%8BFacebook%E7%9A%84POP%E5%8A%A8%E7%94%BB%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/"/>
      <content type="html"><![CDATA[<ul><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a>是一个来自于Facebook，在iOS与OSX上通用的极具扩展性的动画引擎。它在基本的静态动画的基础上增加的弹簧动画与衰减动画，使之能创造出更真实更具物理性的交互动画。</li><li><code>Pop Animation</code>在使用上和<code>Core Animation</code>很相似，都涉及<code>Animation</code>对象以及<code>Animation</code>的载体的概念</li><li>关于<code>Core Animation</code>的相关详解, 可参考我的上一篇文章<a href="http://blog.csdn.net/ShmilyCoder/article/details/78219044" target="_blank" rel="noopener">Core Animation(核心动画)</a></li><li>不同的是<code>Core Animation</code>的载体只能是<code>CALayer</code>，而<code>Pop Animation</code>可以是任意基于<code>NSObject</code>的对象</li><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a> 使用 <code>Objective-C++</code> 编写，<code>Objective-C++</code> 是对 <code>C++</code> 的扩展</li><li><a href="https://github.com/coderQuanjun/POPAnimationDemo" target="_blank" rel="noopener">GitHub项目地址</a></li></ul><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/4122543-a85faa1b734ebc00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="一-POP自我介绍"><a href="#一-POP自我介绍" class="headerlink" title="一. POP自我介绍"></a>一. POP自我介绍</h2><ul><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a> 目前由四部分组成：1. Animations；2. Engine；3. Utility；4. WebCore。</li><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a> 动画极为流畅，主要在于Enimator 里，POP 通过 CADisplayLink 高达 60 FPS 的特性，打造了一个游戏级的动画引擎。</li><li>CADisplayLink 是类似 NSTimer 的定时器，不同之处在于，NSTimer 用于我们定义任务的执行周期、资料的更新周期，他的执行受到 CPU 的阻塞影响，而 CADisplayLink 则用于定义画面的重绘、动画的演变，他的执行基于 frames 的间隔。<ul><li>通过 CADisplayLink，Apple 允许你将 App 的重绘速度设定到和屏幕刷新频率一致，由此你可以获得非常流畅的交互动画，这项技术的应用在游戏中非常常见，著名的 Cocos-2D 也应用了这个重要的技术。</li><li><a href="https://opensource.apple.com/source/WebCore/" target="_blank" rel="noopener">WebCore</a> 里包含了一些从 Apple 的开源的网页渲染引擎里拿出的源文件，与 Utility 里的组件一并，提供了 POP 的各项复杂计算的基本支持</li></ul></li></ul><h2 id="二-POP参数介绍"><a href="#二-POP参数介绍" class="headerlink" title="二. POP参数介绍"></a>二. POP参数介绍</h2><blockquote><h6 id="POP默认支持三种动画，但同时也支持自定义动画"><a href="#POP默认支持三种动画，但同时也支持自定义动画" class="headerlink" title="POP默认支持三种动画，但同时也支持自定义动画"></a>POP默认支持三种动画，但同时也支持自定义动画</h6><ul><li><code>POPBasicAnimation</code>   //基础动画</li><li><code>POPSpringAnimation</code>  //弹簧动画</li><li><code>POPDecayAnimation</code>   //衰减动画</li><li><code>POPCustomAnimation</code>  //自定义动画</li></ul></blockquote><h3 id="1、相关属性介绍"><a href="#1、相关属性介绍" class="headerlink" title="1、相关属性介绍"></a>1、相关属性介绍</h3><h4 id="1-1、属性简单介绍"><a href="#1-1、属性简单介绍" class="headerlink" title="1-1、属性简单介绍"></a>1-1、属性简单介绍</h4><ul><li>POP动画大部分属性和CoreAnimation(核心动画)的含义和用法一样</li><li>具体可参考<a href="http://blog.csdn.net/ShmilyCoder/article/details/78219044" target="_blank" rel="noopener">Core Animation(核心动画)</a></li><li>每种动画的特殊属性会在下文中继续介绍</li></ul><h4 id="1-2、动画可配置属性"><a href="#1-2、动画可配置属性" class="headerlink" title="1-2、动画可配置属性"></a>1-2、动画可配置属性</h4><ul><li>CALayer层各属性(比较简单,就不加注释了)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common CALayer property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBackgroundColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBounds;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerCornerRadius;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBorderWidth;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBorderColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerOpacity;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPosition;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPositionX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPositionY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotation;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSize;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubscaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationZ;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationZ;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerZPosition;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowOffset;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowOpacity;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowRadius;</span><br></pre></td></tr></table></figure><ul><li>UIVIew层</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UIView property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewAlpha;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewBackgroundColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewBounds;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewCenter;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewFrame;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewScaleX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewScaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewScaleY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewSize;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewTintColor;</span><br></pre></td></tr></table></figure><ul><li>其他层视图层</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UINavigationBar property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPNavigationBarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UIToolbar property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPToolbarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UITabBar property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPTabBarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UILabel property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLabelTextColor;</span><br></pre></td></tr></table></figure><blockquote><p>以上仅仅列出了常用的一些属性,更多控件/更多参考框架里面类<br>POPAnimatableProperty.h</p></blockquote><h4 id="1-3、POPBasicAnimation可配置的属性与默认值为"><a href="#1-3、POPBasicAnimation可配置的属性与默认值为" class="headerlink" title="1-3、POPBasicAnimation可配置的属性与默认值为"></a>1-3、POPBasicAnimation可配置的属性与默认值为</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POPBasicAnimation *basic = [POPBasicAnimation linearAnimation];</span><br><span class="line">basic.fromValue = @(<span class="number">0</span>);<span class="comment">//从0开始    basic.toValue = @(3*60);//180秒后结束</span></span><br><span class="line">basic.duration = <span class="number">3</span>*<span class="number">60</span>;<span class="comment">//持续3分钟</span></span><br><span class="line">[lab pop_addAnimation:basic forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let basic1 = POPBasicAnimation(propertyNamed: kPOPLayerPositionX)</span><br><span class="line">basic1?.fromValue = redView.layer.position.x</span><br><span class="line">basic1?.toValue = <span class="number">300</span></span><br><span class="line">basic1?.beginTime = <span class="built_in">CFTimeInterval</span>() + <span class="number">1.0</span></span><br><span class="line">redView.pop_add(basic1, forKey: <span class="string">"position.x"</span>)</span><br></pre></td></tr></table></figure><h2 id="三-POPBasicAnimation基础动画"><a href="#三-POPBasicAnimation基础动画" class="headerlink" title="三. POPBasicAnimation基础动画"></a>三. POPBasicAnimation基础动画</h2><h4 id="1-先看一下效果-其动画效果如下"><a href="#1-先看一下效果-其动画效果如下" class="headerlink" title="1. 先看一下效果, 其动画效果如下"></a>1. 先看一下效果, 其动画效果如下</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-1efeb167ad71b59d.gif?imageMogr2/auto-orient/strip" alt="image"></p><h4 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let basic1 = POPBasicAnimation(propertyNamed: kPOPLayerPositionX)</span><br><span class="line">basic1?.toValue = <span class="number">300</span></span><br><span class="line"><span class="comment">//开始时间</span></span><br><span class="line">basic1?.beginTime = <span class="built_in">CFTimeInterval</span>() + <span class="number">1.0</span></span><br><span class="line">redView.pop_add(basic1, forKey: <span class="string">"position.x"</span>)</span><br></pre></td></tr></table></figure><h4 id="3-可以看到，添加一个动画最少仅需三步"><a href="#3-可以看到，添加一个动画最少仅需三步" class="headerlink" title="3. 可以看到，添加一个动画最少仅需三步"></a>3. 可以看到，添加一个动画最少仅需三步</h4><ul><li>1）定义一个<code>animation</code>对象，并指定对应的动画属性（<code>kPOPLayerPositionX</code>）</li><li>2）设置初始值结束值(初始值可以不指定，会默认从当前值开始）</li><li>3）添加到想产生动画的对象上</li></ul><h4 id="4-Core-Animation-和-POP-运行动画对比"><a href="#4-Core-Animation-和-POP-运行动画对比" class="headerlink" title="4. Core Animation 和 POP 运行动画对比"></a>4. Core Animation 和 POP 运行动画对比</h4><ul><li>由于 POP 是基于定时器定时刷新添加动画的原理，那么如果将动画库运行在主线程上，会由于线程阻塞的问题导致动画效果出现卡顿、不流畅的情况。</li><li>更为关键的是，你不能将动画效果放在子线程，因为你不能将对 view 和 layer 的操作放到主线程之外</li><li>POP 受主线程阻塞的影响很大，在使用过程中，应避免在有可能发生主线程阻塞的情况下使用 POP ，避免制作卡顿的动画效果，产生不好的用户体验</li></ul><h2 id="四-POPSpringAnimation弹性动画"><a href="#四-POPSpringAnimation弹性动画" class="headerlink" title="四. POPSpringAnimation弹性动画"></a>四. POPSpringAnimation弹性动画</h2><h4 id="1-属性介绍"><a href="#1-属性介绍" class="headerlink" title="1. 属性介绍"></a>1. 属性介绍</h4><ul><li><code>velocity</code>: 设置动画开始速度</li><li><code>springBounciness</code>: 振幅, 可以设置的范围是0-20，默认为4。值越大振动的幅度越大</li><li><code>springSpeed</code>: 速度, 可以设置的范围是0-20，默认为12.值越大速度越快，结束的越快</li><li><code>dynamicsMass</code>: 质量, 质量越大，动画的速度越慢，振动的幅度越大，结束的越慢</li><li><code>dynamicsTension</code>: 拉力 拉力越大，动画的速度越快，结束的越快</li><li><code>dynamicsFriction</code>: 摩擦力, 摩擦力越大，动画的速度越慢，振动的幅度越小。</li></ul><blockquote><p>注意: 以上的六个属性中一般只会设置<code>springBounciness</code>和<code>springSpeed</code>, 如有特殊需求才会设置其他属性</p></blockquote><h4 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let spring = POPSpringAnimation(propertyNamed: kPOPViewScaleXY)</span><br><span class="line"><span class="comment">//注意: 这里改变的是x和y的比例,参数赋值也要传两个; 若只需要其中一个,则可设置</span></span><br><span class="line"><span class="comment">//`spring?.fromValue = 0.4`即可</span></span><br><span class="line">spring?.fromValue = <span class="built_in">CGSize</span>(width: <span class="number">0.3</span>, height: <span class="number">0.3</span>)</span><br><span class="line">spring?.toValue = <span class="built_in">CGSize</span>(width: <span class="number">2</span>, height: <span class="number">2</span>)</span><br><span class="line">spring?.springSpeed = <span class="number">5</span></span><br><span class="line">spring?.springBounciness = <span class="number">15</span></span><br><span class="line">lightBlue.pop_add(spring, forKey: <span class="string">"scale"</span>)</span><br></pre></td></tr></table></figure><h2 id="五-POPDecayAnimation"><a href="#五-POPDecayAnimation" class="headerlink" title="五. POPDecayAnimation"></a>五. POPDecayAnimation</h2><ul><li><code>POPDecayAnimation</code>提供一个过阻尼效果（其实<code>Spring</code>是一种欠阻尼效果）可以实现类似<code>UIScrollView</code>的滑动衰减效果（是的你可以靠它来自己实现一个<code>UIScrollView</code>）</li></ul><blockquote><p>属性介绍</p><ul><li><code>deceleration</code> （负加速度, 衰减系数(越小则衰减得越快)） 是一个你会很少用到的值，默认是就是我们地球的 0.998，如果你开发APP给火星人用，那么这个值你使用 0.376 会更合适</li><li><code>velocity</code> 也是必须和你操作的属性有相同的结构，如果你操作的是 bounds, 传CGRect类型;如果 velocity 是负值，那么就会反向递减</li></ul></blockquote><blockquote><p>代码示例</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let decay = POPDecayAnimation(propertyNamed: kPOPViewSize)</span><br><span class="line">decay?.velocity = <span class="built_in">CGSize</span>(width: <span class="number">300</span>, height: pictureBtn.frame.height)</span><br><span class="line"><span class="comment">//延迟1秒后执行</span></span><br><span class="line">decay?.beginTime = <span class="built_in">CACurrentMediaTime</span>() + <span class="number">1.0</span></span><br><span class="line">pictureBtn.pop_add(decay, forKey: <span class="string">"size"</span>)</span><br></pre></td></tr></table></figure><h2 id="六-自定义属性"><a href="#六-自定义属性" class="headerlink" title="六. 自定义属性"></a>六. 自定义属性</h2><p>POP默认支持的三种动画都继承自<code>POPPropertyAnimation</code>,  <code>POPPropertyAnimation</code>中定义了一个叫<code>property</code>的属性（之前没有用到它是因为POP根据不同的默认动画属性帮你生成了默认的<code>property</code>这个属性则是用来驱动POP的动画效果中的重要一环</p><h3 id="1-实力模块"><a href="#1-实力模块" class="headerlink" title="1. 实力模块"></a>1. 实力模块</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> let proper = POPAnimatableProperty.property(withName: <span class="string">"prop"</span>, initializer: &#123; (prop) <span class="keyword">in</span></span><br><span class="line">    guard let prop = prop <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//read</span></span><br><span class="line">    prop.readBlock = &#123; (obj, values) <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//write</span></span><br><span class="line">    prop.writeBlock = &#123;(obj, values) <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    prop.threshold = <span class="number">0.01</span></span><br><span class="line">            </span><br><span class="line">&#125;) as? POPAnimatableProperty &#123;</span><br><span class="line">    anim.property = proper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-属性介绍"><a href="#2-属性介绍" class="headerlink" title="2. 属性介绍"></a>2. 属性介绍</h3><blockquote><p>其组成就是一个readBlock一个writeBlock和一个threashold</p><ul><li><code>readBlock</code>告诉POP当前的属性值</li><li><code>writeBlock</code>中修改变化后的属性值</li><li><code>threashold</code>决定了动画变化间隔的阈值 值越大<code>writeBlock</code>的调用次数越少</li></ul></blockquote><p>POPAnimatableProperty其实是POP中一个比较重要的东西 像上面提到的POP自带的动画属性 查看源代码可以看到也只是POP自动帮你设置好了POPAnimatableProperty而已 其作用就是当动画的某个时间片被触发时 告诉系统如何根据当前时间片做出变化</p><blockquote><p>还是以一个实际的例子来说明如何使用自定义属性 比如我们要实现一个像系统的时钟APP里秒表计时的一个效果</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-070c23772942ed82.gif?imageMogr2/auto-orient/strip" alt="计时器效果"></p><h3 id="3-完整代码示例"><a href="#3-完整代码示例" class="headerlink" title="3. 完整代码示例"></a>3. 完整代码示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> let proper = POPAnimatableProperty.property(withName: <span class="string">"prop"</span>, initializer: &#123; (prop) <span class="keyword">in</span></span><br><span class="line">    guard let prop = prop <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//read</span></span><br><span class="line">    prop.readBlock = &#123; (obj, values) <span class="keyword">in</span></span><br><span class="line">        guard let array = values <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        print(array[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//write</span></span><br><span class="line">    prop.writeBlock = &#123;(obj, values) <span class="keyword">in</span></span><br><span class="line">        guard let button = obj as? <span class="built_in">UIButton</span>, let array = values <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        let value = array[<span class="number">0</span>]</span><br><span class="line">        button.setTitle(String(format: <span class="string">"%02d:%02d:%02d"</span>, Int(value / <span class="number">60</span>), Int(value.truncatingRemainder(dividingBy: <span class="number">60</span>)), Int((value * <span class="number">100</span>).truncatingRemainder(dividingBy: <span class="number">100</span>))), <span class="keyword">for</span>: .normal)</span><br><span class="line">    &#125;</span><br><span class="line">    prop.threshold = <span class="number">0.01</span></span><br><span class="line">    </span><br><span class="line">&#125;) as? POPAnimatableProperty &#123;</span><br><span class="line">    <span class="keyword">if</span> let popBasic = POPBasicAnimation.linear() &#123;</span><br><span class="line">        <span class="comment">//秒表用线性的时间函数初始化</span></span><br><span class="line">        popBasic.property = proper</span><br><span class="line">        popBasic.fromValue = <span class="number">0</span> <span class="comment">//从0开始</span></span><br><span class="line">        popBasic.toValue = <span class="number">18</span>  <span class="comment">//到18秒</span></span><br><span class="line">        popBasic.duration = <span class="number">18</span> <span class="comment">//持续18秒</span></span><br><span class="line">        popBasic.beginTime = <span class="built_in">CACurrentMediaTime</span>() + <span class="number">2</span> <span class="comment">//延迟2秒开始</span></span><br><span class="line">        pictureBtn.pop_add(popBasic, forKey: <span class="string">"linear"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意:"></a>4. 注意:</h3><ul><li>在Swift4.0版本(4.0之前版本未知)中,初始化出来的对象都是可选类型</li><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a>官方的建议是添加<code>if</code>条件判断,详情可到GitHub上查看示例</li><li>正如上段代码所示: 闭包中涉及的可选类型都添加了<code>guard</code>判断</li></ul><h2 id="七-类似微博中间发布按钮弹出动画"><a href="#七-类似微博中间发布按钮弹出动画" class="headerlink" title="七. 类似微博中间发布按钮弹出动画"></a>七. 类似微博中间发布按钮弹出动画</h2><h4 id="先看一下效果吧"><a href="#先看一下效果吧" class="headerlink" title="先看一下效果吧"></a>先看一下效果吧</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-737cf17a9cb95542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="微博动画效果图"></p><blockquote><p>动画分为两个部分</p></blockquote><ul><li>中间六个按钮依次执行动画弹出</li><li>上面标题图片最后动画落下</li></ul><h4 id="下面来看一下部分的核心代码"><a href="#下面来看一下部分的核心代码" class="headerlink" title="下面来看一下部分的核心代码"></a>下面来看一下部分的核心代码</h4><h5 id="1-六个按钮的弹出和消失动画"><a href="#1-六个按钮的弹出和消失动画" class="headerlink" title="1. 六个按钮的弹出和消失动画"></a>1. 六个按钮的弹出和消失动画</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;titles.count &#123;</span><br><span class="line">    let button = BaseButton()</span><br><span class="line">    button.setTitle(titles[i], <span class="keyword">for</span>: .normal)</span><br><span class="line">    button.setImage(<span class="built_in">UIImage</span>(named: images[i]), <span class="keyword">for</span>: .normal)</span><br><span class="line">    button.addTarget(<span class="keyword">self</span>, action: <span class="meta">#selector(buttonClick(button:)), for: .touchUpInside)</span></span><br><span class="line">    addSubview(button)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算X/Y</span></span><br><span class="line">    let row = i / maxCols</span><br><span class="line">    let col = i % maxCols</span><br><span class="line">    let buttonX = btnStsrtX + <span class="built_in">CGFloat</span>(col) * (xMargin + buttonW)</span><br><span class="line">    let buttonEndY = btnStartY + <span class="built_in">CGFloat</span>(row) * buttonH</span><br><span class="line">    let buttonStartY = buttonEndY - kScreenHeight</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按钮动画</span></span><br><span class="line">    let popSpring = POPSpringAnimation(propertyNamed: kPOPViewFrame)</span><br><span class="line">    popSpring?.fromValue = <span class="built_in">CGRect</span>(x: buttonX, y: buttonStartY, width: buttonW, height: buttonH)</span><br><span class="line">    popSpring?.toValue = <span class="built_in">CGRect</span>(x: buttonX, y: buttonEndY, width: buttonW, height: buttonH)</span><br><span class="line">    popSpring?.springBounciness = kSpringFactor</span><br><span class="line">    popSpring?.springSpeed = kSpringFactor</span><br><span class="line">    popSpring?.beginTime = <span class="built_in">CACurrentMediaTime</span>() + kAnimationDelay * Double(i)</span><br><span class="line">    button.pop_add(popSpring, forKey: <span class="string">"spring"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-最上部分标语的弹出和消失"><a href="#2-最上部分标语的弹出和消失" class="headerlink" title="2. 最上部分标语的弹出和消失"></a>2. 最上部分标语的弹出和消失</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//z执行动画</span></span><br><span class="line">let imagePOP = POPSpringAnimation(propertyNamed: kPOPViewCenter)</span><br><span class="line">imagePOP?.fromValue = <span class="built_in">CGPoint</span>(x: kScreenWidth * <span class="number">0.5</span>, y: <span class="number">0.2</span> * kScreenHeight - kScreenHeight)</span><br><span class="line">imagePOP?.toValue = <span class="built_in">CGPoint</span>(x: kScreenWidth * <span class="number">0.5</span>, y: <span class="number">0.2</span> * kScreenHeight)</span><br><span class="line">imagePOP?.springSpeed = kSpringFactor</span><br><span class="line">imagePOP?.springBounciness = kSpringFactor</span><br><span class="line">imagePOP?.beginTime = <span class="built_in">CACurrentMediaTime</span>() + Double(btnCount) * kAnimationDelay</span><br><span class="line">imagePOP?.completionBlock = &#123; popAnim, finished <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//所有动画执行完毕,回复View点击事件</span></span><br><span class="line">    kRootView?.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">self</span>.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">topImage.pop_add(imagePOP, forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><p>以上是类似微博动画的部分核心代码, 具体代码详见<a href="https://github.com/coderQuanjun/POPAnimationDemo" target="_blank" rel="noopener">GitHub项目</a>, 喜欢请star</p></blockquote><ul><li>折叠图片</li><li>音量震动条</li><li>活动指示器</li><li>微博动画</li><li>倒计时-计时器</li><li>类似QQ信息条数的粘性动画</li><li>类似雷达-水波纹动画</li></ul><blockquote><p>注: 项目持续更新中……</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS动画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Facebook POP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS出门必备之CoreAnimation(核心动画)</title>
      <link href="/2017/10/12/iOS%E5%87%BA%E9%97%A8%E5%BF%85%E5%A4%87%E4%B9%8BCoreAnimation(%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB)/"/>
      <content type="html"><![CDATA[<h1 id="CoreAnimation"><a href="#CoreAnimation" class="headerlink" title="CoreAnimation"></a>CoreAnimation</h1><ul><li>前段时间接触到了一个牛逼的动画框架<a href="https://github.com/facebook/pop" target="_blank" rel="noopener">POP</a>,本来想来装装逼,突然发现,苹果大大的CoreAnimation我还不会用呢!</li><li>依稀记得乔帮主在2007年的WWDC大会上亲自为你演示Core Animation的强大：<a href="http://v.youku.com/v_show/id_XMzQ2MTcwNDQ0.html" target="_blank" rel="noopener">点击查看视频</a>(不好意思,又装逼了)</li><li>言归正传,我只是来温习一下CoreAnimation,还望路过的大神不要吐槽我太low</li></ul><h3 id="GitHub项目地址"><a href="#GitHub项目地址" class="headerlink" title="GitHub项目地址"></a><a href="https://github.com/coderQuanjun/POPAnimationDemo" target="_blank" rel="noopener">GitHub项目地址</a></h3><a id="more"></a><h2 id="一、Core-Animation简介"><a href="#一、Core-Animation简介" class="headerlink" title="一、Core Animation简介"></a>一、Core Animation简介</h2><ul><li><code>Core Animation</code>，中文翻译为核心动画，它是一组非常强大的动画处理API，使用它能做出非常炫丽的动画效果，而且往往是事半功倍。也就是说，使用少量的代码就可以实现非常强大的功能。</li><li><code>Core Animation</code>可以用在<code>Mac OS X和iOS</code>平台。</li><li><code>Core Animation</code>的动画执行过程都是在后台操作的，不会阻塞主线程。</li><li>要注意的是，Core Animation是直接作用在<code>CALayer</code>上的，并非UIView</li><li>通过调用<code>CALayer</code>的<code>addAnimation:forKey:</code>方法增加<code>CAAnimation</code>对象到<code>CALayer</code>中，这样就能开始执行动画了</li><li>通过调用<code>CALayer</code>的<code>removeAnimationForKey:</code>方法可以停止<code>CALayer</code>中的动画</li></ul><h2 id="二-Core-Animation及其相关属性"><a href="#二-Core-Animation及其相关属性" class="headerlink" title="二. Core Animation及其相关属性"></a>二. Core Animation及其相关属性</h2><ul><li>要想执行动画，就必须初始化一个<code>CAAnimation</code>对象。</li><li>一般情况下，我们使用的比较多的是<code>CAAnimation</code>的子类，因此，先大致看看<code>CAAnimation</code>的继承结构</li><li>黑线代表继承，黑色文字代表类名，白色文字代表属性。其中<code>CAMediaTiming</code>是一个协议(<code>protocol</code>)</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-7bc6a9dcfc3ff80f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="Core Animation结构划分.png"></p><blockquote><p>需要注意的是</p><ul><li>CAAnimation是所有动画类的父类，但是它不能直接使用，应该使用它的子类</li><li>CAPropertyAnimation也是不能直接使用的，也要使用它的子类</li><li>能用的动画类只剩下4个：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup</li></ul></blockquote><blockquote><p>常用属性</p></blockquote><p><strong>1). <code>removedOnCompletion</code>：默认为true，代表动画执行完毕后就从图层上移除</strong></p><ul><li>图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为false，不过还要设置<code>fillMode</code>为<code>kCAFillModeForwards</code></li></ul><p><strong>2). timingFunction：控制动画运行的节奏</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** timingFunction可选的值 **/</span></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAMediaTimingFunctionLinear: String</span><br><span class="line"><span class="comment">//1.(匀速): 在整个动画时间内动画都是以一个相同的速度来改变</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAMediaTimingFunctionEaseIn: String</span><br><span class="line"><span class="comment">//2. (渐进): 缓慢进入, 加速离开</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAMediaTimingFunctionEaseOut: String</span><br><span class="line"><span class="comment">//3. (渐出): 快速进入, 减速离开</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAMediaTimingFunctionEaseInEaseOut: String</span><br><span class="line"><span class="comment">//4. (渐进渐出): 缓慢进入, 中间加速, 减速离开</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">3.0</span>, *)</span><br><span class="line">public let kCAMediaTimingFunctionDefault: String</span><br><span class="line"><span class="comment">//5. (默认): 效果基本等同于EaseOut(渐出)</span></span><br></pre></td></tr></table></figure><p><strong>3). fillMode决定当前对象在非active时间段的行为。</strong></p><ul><li>要想fillMode有效，需设置removedOnCompletion = false</li><li>fillMode可选的值</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* `fillMode' options. */</span></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAFillModeForwards: String</span><br><span class="line"><span class="comment">//1. 当动画结束后，layer会一直保持着动画最后的状态</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAFillModeBackwards: String</span><br><span class="line"><span class="comment">//2. 设置为该值，将会立即执行动画的第一帧，不论是否设置了 beginTime属性。观察发现，设置该值，刚开始视图不见，还不知道应用在哪里</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAFillModeBoth: String</span><br><span class="line"><span class="comment">//3. 该值是 kCAFillModeForwards 和 kCAFillModeBackwards的组合状态; 动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAFillModeRemoved: String</span><br><span class="line"><span class="comment">//4. 默认值，动画将在设置的 beginTime 开始执行（如没有设置beginTime属性，则动画立即执行），动画执行完成后会将layer的改变恢复原状</span></span><br></pre></td></tr></table></figure><p><strong>4). <code>delegate</code>：动画代理，用来监听动画的执行过程</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public protocol <span class="built_in">CAAnimationDelegate</span> : <span class="built_in">NSObjectProtocol</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动画开始执行的时候触发这个方法</span></span><br><span class="line">    @available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">    optional public func animationDidStart(_ anim: <span class="built_in">CAAnimation</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动画执行完毕的时候触发这个方法</span></span><br><span class="line">    @available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">    optional public func animationDidStop(_ anim: <span class="built_in">CAAnimation</span>, finished flag: Bool)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5). 其他相关属性</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">duration    动画的时长</span><br><span class="line">repeatCount    重复的次数。不停重复设置为 HUGE_VALF</span><br><span class="line">repeatDuration    设置动画的时间。在该时间内动画一直执行，不计次数。</span><br><span class="line">beginTime    指定动画开始的时间。从开始延迟几秒的话，设置为【<span class="built_in">CACurrentMediaTime</span>() + 秒数】 的方式</span><br><span class="line">timingFunction    设置动画的速度变化</span><br><span class="line">autoreverses    动画结束时是否执行逆动画</span><br><span class="line">fromValue    所改变属性的起始值(Swift中为Any类型,OC中要包装成<span class="built_in">NSValue</span>对象)</span><br><span class="line">toValue    所改变属性的结束时的值(类型与fromValue相同)</span><br><span class="line">byValue    所改变属性相同起始值的改变量(类型与fromValue相同)</span><br></pre></td></tr></table></figure><h2 id="三-CABasicAnimation"><a href="#三-CABasicAnimation" class="headerlink" title="三. CABasicAnimation"></a>三. CABasicAnimation</h2><ul><li>CABasicAnimation是CAPropertyAnimation的子类，使用它可以实现一些基本的动画效果，它可以让CALayer的某个属性从某个值渐变到另一个值。下面就用CABasicAnimation实现几个简单的动画</li></ul><h3 id="1-平移动画"><a href="#1-平移动画" class="headerlink" title="1. 平移动画"></a>1. 平移动画</h3><h4 id="方法一-改变label的position"><a href="#方法一-改变label的position" class="headerlink" title="方法一: 改变label的position"></a>方法一: 改变label的position</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let caBasic = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"position"</span>)</span><br><span class="line">caBasic.duration = <span class="number">2</span></span><br><span class="line">caBasic.fromValue = redLabel.layer.position</span><br><span class="line">caBasic.toValue = <span class="built_in">CGPoint</span>(x: kScreenWidth - <span class="number">50</span>, y: <span class="number">200</span>)</span><br><span class="line">caBasic.delegate = <span class="keyword">self</span></span><br><span class="line">caBasic.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line">caBasic.fillMode = kCAFillModeForwards</span><br><span class="line">redLabel.layer.add(caBasic, forKey: <span class="string">"redLabel1"</span>)</span><br></pre></td></tr></table></figure><ul><li>初始化方法中是@”position”，说明要修改的是CALayer的position属性，也就是会执行平移动画</li><li>默认情况下，动画执行完毕后，动画会自动从CALayer上移除，CALayer又会回到原来的状态。为了保持动画执行后的状态，可以加入第6、7行代码</li><li>第8行后面的@”redLabel1”是给动画对象起个名称，以后可以调用CALayer的removeAnimationForKey:方法根据动画名称停止相应的动画</li><li>遵循的代理方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController: <span class="built_in">CAAnimationDelegate</span> &#123;</span><br><span class="line">    <span class="comment">//开始执行</span></span><br><span class="line">    func animationDidStart(_ anim: <span class="built_in">CAAnimation</span>) &#123;</span><br><span class="line">        print(<span class="string">"开始动画--layer:"</span>, redLabel.layer.position)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束之行</span></span><br><span class="line">    func animationDidStop(_ anim: <span class="built_in">CAAnimation</span>, finished flag: Bool) &#123;</span><br><span class="line">        print(<span class="string">"结束动画--layer:"</span>, redLabel.layer.position)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果为:</span></span><br><span class="line"><span class="comment">//开始动画--layer: (35.0, 213.0)</span></span><br><span class="line"><span class="comment">//结束动画--layer: (35.0, 213.0)</span></span><br></pre></td></tr></table></figure><blockquote><p>从打印信息可以看出，实际上，动画执行完毕后，并没有真正改变CALayer的position属性的值！</p></blockquote><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二."></a>方法二.</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> let basic = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"transform"</span>)</span><br><span class="line">basic.duration = <span class="number">2</span></span><br><span class="line">let form = <span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">350</span>, <span class="number">400</span>, <span class="number">0</span>)</span><br><span class="line">basic.toValue = form</span><br><span class="line">blueLabel.layer.add(basic, forKey: <span class="string">"blueLabel"</span>)</span><br></pre></td></tr></table></figure><h3 id="2-旋转动画"><a href="#2-旋转动画" class="headerlink" title="2. 旋转动画"></a>2. 旋转动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let basic1 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"transform"</span>)</span><br><span class="line">basic1.duration = <span class="number">1</span></span><br><span class="line">basic1.toValue = <span class="built_in">CATransform3DMakeRotation</span>(<span class="number">0.25</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">basic1.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line">basic1.fillMode = kCAFillModeForwards</span><br><span class="line">blueLabel.layer.add(basic1, forKey: <span class="string">"basic1"</span>)</span><br></pre></td></tr></table></figure><ul><li>可以不用设置fromValue，这里只设置了toValue</li></ul><h3 id="3-缩放动画"><a href="#3-缩放动画" class="headerlink" title="3. 缩放动画"></a>3. 缩放动画</h3><ul><li>CALayer的宽度从0.5倍变为2倍</li><li>CALayer的高度从0.5倍变为1.5倍</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let basic1 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"transform"</span>)</span><br><span class="line">basic1.duration = <span class="number">1</span></span><br><span class="line">basic1.toValue = <span class="built_in">CATransform3DMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1</span>)</span><br><span class="line">basic1.toValue = <span class="built_in">CATransform3DMakeScale</span>(<span class="number">2</span>, <span class="number">1.5</span>, <span class="number">1</span>)</span><br><span class="line">basic1.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line">basic1.fillMode = kCAFillModeForwards</span><br><span class="line">blueLabel.layer.add(basic1, forKey: <span class="string">"basic1"</span>)</span><br></pre></td></tr></table></figure><blockquote></blockquote><ul><li>CABasicAnimation虽然能够做很多基本的动画效果，但是有个局限性，只能让CALayer的属性从某个值渐变到另一个值，仅仅是在2个值之间渐变</li><li>总结一些常用的animationKeyPath值的</li></ul><table><thead><tr><th>值</th><th>说明</th><th>使用形式</th></tr></thead><tbody><tr><td>transform.scale</td><td>比例转化</td><td>0.5</td></tr><tr><td>transform.scale.x</td><td>宽的比例</td><td>0.5</td></tr><tr><td>transform.rotation.x</td><td>围绕x轴旋转</td><td>@(M_PI_4)(OC), 0.25(Swift)</td></tr><tr><td>cornerRadius</td><td>圆角的设置</td><td>30</td></tr><tr><td>backgroundColor</td><td>背景颜色的变化</td><td>UIColor.purpleColor.cgColor</td></tr><tr><td>bounds</td><td>大小，中心不变</td><td>CGRect</td></tr><tr><td>position</td><td>位置(中心点的改变)</td><td>CGPoint</td></tr><tr><td>contents</td><td>内容，比如UIImageView的图片</td><td>imageAnima.toValue = UIImage(named: “toImage”)?.cgImage</td></tr><tr><td>opacity</td><td>透明度</td><td>0.7</td></tr><tr><td>contentsRect.size.width</td><td>横向拉伸缩放</td><td>最好是0~1之间的</td></tr></tbody></table><h2 id="四-CAKeyframeAnimation——关键帧动画"><a href="#四-CAKeyframeAnimation——关键帧动画" class="headerlink" title="四. CAKeyframeAnimation——关键帧动画"></a>四. CAKeyframeAnimation——关键帧动画</h2><ul><li>关键帧动画，也是<code>CAPropertyAnimation</code>的子类，与<code>CABasicAnimation</code>的区别是：<ul><li><code>CABasicAnimation</code>只能从一个数值（fromValue）变到另一个数值（toValue）</li><li>而<code>CAKeyframeAnimation</code>会使用一个Array保存这些数值</li></ul></li><li>属性说明：<ul><li><code>values</code>：上述的Array对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧</li><li><code>path</code>：可以设置一个<code>CGPathRef、CGMutablePathRef</code>，让图层按照路径轨迹移动。path只对CALayer的<code>anchorPoint</code>和<code>position</code>起作用。如果设置了path，那么values将被忽略</li><li><code>keyTimes</code>：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的</li><li><code>calculationMode</code>: 该属性决定了物体在每个子路径下是跳着走还是匀速走，跟<code>timeFunctions</code>属性有点类似<ul><li><code>kCAAnimationLinear</code>默认值,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;</li><li><code>kCAAnimationDiscrete</code> 离散的,就是不进行插值计算,所有关键帧直接逐个进行显示;</li><li><code>kCAAnimationPaced</code> 使得动画均匀进行,而不是按<code>keyTimes</code>设置的或者按关键帧平分时间,此时<code>keyTimes</code>和timingFunctions`无效;</li><li><code>kCAAnimationCubic</code> 对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过<code>tensionValues,continuityValues,biasValues</code>来进行调整自定义主要目的是使得运行的轨迹变得圆滑;</li><li><code>kCAAnimationCubicPaced</code> 看这个名字就知道和<code>kCAAnimationCubic</code>有一定联系,其实就是在<code>kCAAnimationCubic</code>的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时<code>keyTimes</code>以及<code>timingFunctions</code>也是无效的.</li></ul></li></ul></li><li><code>CABasicAnimation</code>可看做是只有2个关键帧的<code>CAKeyframeAnimation</code></li></ul><blockquote><p>values方式</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let key = <span class="built_in">CAKeyframeAnimation</span>(keyPath: <span class="string">"position"</span>)</span><br><span class="line">key.duration = <span class="number">3</span></span><br><span class="line">key.repeatCount = HUGE <span class="comment">//无线循环</span></span><br><span class="line">key.calculationMode = kCAAnimationPaced</span><br><span class="line">key.values = [redLabel.frame.origin, <span class="built_in">CGPoint</span>(x: <span class="number">180</span>, y: <span class="number">70</span>), <span class="built_in">CGPoint</span>(x: <span class="number">180</span>, y: <span class="number">200</span>), redLabel.frame.origin]</span><br><span class="line">key.keyTimes = [<span class="built_in">NSNumber</span>(value: <span class="number">0.0</span>), <span class="built_in">NSNumber</span>(value: <span class="number">0.6</span>), <span class="built_in">NSNumber</span>(value: <span class="number">0.7</span>), <span class="built_in">NSNumber</span>(value: <span class="number">0.8</span>)]</span><br><span class="line">redLabel.layer.add(key, forKey: <span class="string">"key"</span>)</span><br></pre></td></tr></table></figure><h2 id="五-CASpringAnimation"><a href="#五-CASpringAnimation" class="headerlink" title="五. CASpringAnimation"></a>五. CASpringAnimation</h2><ul><li><code>CASpringAnimation</code>是iOS 9 新出的</li><li><code>CASpringAnimation</code> 继承于<code>CABaseAnimation</code></li><li><code>CASpringAnimation</code>是苹果专门解决开发者关于弹簧动画的这个需求而封装的类。</li></ul><h3 id="1-CASpringAnimation相关属性"><a href="#1-CASpringAnimation相关属性" class="headerlink" title="1. CASpringAnimation相关属性"></a>1. CASpringAnimation相关属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大, 默认值: 1</span></span><br><span class="line">open var mass: <span class="built_in">CGFloat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快(默认值: 100)</span></span><br><span class="line">open var stiffness: <span class="built_in">CGFloat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快(默认值: 10)</span></span><br><span class="line">open var damping: <span class="built_in">CGFloat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 初始速率，动画视图的初始速度大小, 默认0</span></span><br><span class="line"><span class="comment">//速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反(默认值: 0)</span></span><br><span class="line">open var initialVelocity: <span class="built_in">CGFloat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 估算时间 返回弹簧动画到停止时的估算时间，根据当前的动画参数估算(只读)</span></span><br><span class="line">open var settlingDuration: <span class="built_in">CFTimeInterval</span> &#123; get &#125;</span><br></pre></td></tr></table></figure><h3 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let spring = <span class="built_in">CASpringAnimation</span>(keyPath: <span class="string">"position.y"</span>)</span><br><span class="line">spring.mass = <span class="number">5</span></span><br><span class="line">spring.stiffness = <span class="number">100</span></span><br><span class="line">spring.damping = <span class="number">5</span></span><br><span class="line">spring.initialVelocity = <span class="number">2</span></span><br><span class="line">spring.fromValue = blueLabel.layer.position.y</span><br><span class="line">spring.toValue = kScreenHeight - <span class="number">150</span></span><br><span class="line">spring.duration = spring.settlingDuration</span><br><span class="line">blueLabel.layer.add(spring, forKey: <span class="string">"spring"</span>)</span><br></pre></td></tr></table></figure><h2 id="六-CAAnimationGroup动画组"><a href="#六-CAAnimationGroup动画组" class="headerlink" title="六. CAAnimationGroup动画组"></a>六. CAAnimationGroup动画组</h2><ul><li>是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行</li><li>属性说明：<ul><li>animations：用来保存一组动画对象的Array</li></ul></li><li>默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h3><ul><li>同时执行：平移、缩放、位移动画 -&gt; 使用动画组</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动画组</span></span><br><span class="line">fileprivate func getCAAnimationGroup()&#123;</span><br><span class="line">    <span class="comment">//0. 初始化动画组</span></span><br><span class="line">    let group = <span class="built_in">CAAnimationGroup</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 平移动画</span></span><br><span class="line">    let basic1 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"position"</span>)</span><br><span class="line">    basic1.fromValue = blueLabel.layer.position</span><br><span class="line">    basic1.toValue = <span class="built_in">CGPoint</span>(x: <span class="built_in">CGFloat</span>(arc4random_uniform(<span class="number">200</span>)), y: <span class="built_in">CGFloat</span>(arc4random_uniform(<span class="number">500</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 缩放动画</span></span><br><span class="line">    let basic2 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"transform.scale"</span>)</span><br><span class="line">    var scale: <span class="built_in">CGFloat</span> = <span class="number">0.1</span></span><br><span class="line">    scale = scale &lt; <span class="number">1</span> ? <span class="number">1.5</span> : <span class="number">0.5</span></span><br><span class="line">    basic2.toValue = scale</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 旋转动画</span></span><br><span class="line">    let basic3 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">"transform.rotation"</span>)</span><br><span class="line">    basic3.toValue = <span class="built_in">CGFloat</span>(arc4random_uniform(<span class="number">360</span>)) / <span class="number">180.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 添加到动画组</span></span><br><span class="line">    group.animations = [basic1, basic2, basic3]</span><br><span class="line">    <span class="comment">//取消反弹</span></span><br><span class="line">    group.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line">    group.fillMode = kCAFillModeForwards</span><br><span class="line">    group.duration = <span class="number">0.5</span></span><br><span class="line">    blueLabel.layer.add(group, forKey: <span class="string">"group"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七-转场动画——CATransition"><a href="#七-转场动画——CATransition" class="headerlink" title="七. 转场动画——CATransition"></a>七. 转场动画——CATransition</h2><ul><li><code>CATransition</code>是<code>CAAnimation</code>的子类，用于做转场动画，能够为layer层提供移出屏幕和移入屏幕的动画效果。</li><li>iOS比Mac OS X的转场动画效果少一点<br><code>UINavigationController</code>就是通过<code>CATransition</code>实现了将控制器的视图推入屏幕的动画效果</li><li>动画属性:<ul><li><code>type</code>：动画过渡类型</li><li><code>subtype</code>：动画过渡方向</li><li><code>startProgress</code>：动画起点(在整体动画的百分比)</li><li><code>endProgress</code>：动画终点(在整体动画的百分比)</li></ul></li></ul><h3 id="1-type和subtype属性说明"><a href="#1-type和subtype属性说明" class="headerlink" title="1. type和subtype属性说明"></a>1. <code>type</code>和<code>subtype</code>属性说明</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* type类型 */</span></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionFade: String</span><br><span class="line"><span class="comment">//交叉淡化过渡</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionMoveIn: String</span><br><span class="line"><span class="comment">//新视图移到旧视图上面</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionPush: String</span><br><span class="line"><span class="comment">//新视图把旧视图推出去</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionReveal: String</span><br><span class="line"><span class="comment">//将旧视图移开,显示下面的新视图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* subtypes类型 */</span></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionFromRight: String</span><br><span class="line"><span class="comment">//从右侧转场</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionFromLeft: String</span><br><span class="line"><span class="comment">//从左侧转场</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionFromTop: String</span><br><span class="line"><span class="comment">//从上部转场</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionFromBottom: String</span><br><span class="line"><span class="comment">//从底部转场</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>除了上述四种效果之外,还有很多私有API效果，使用的时候要小心，可能会导致app审核不被通过</li><li>使用的时候要以字符串的形式</li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cube     <span class="comment">//立方体翻滚效果</span></span><br><span class="line">oglFlip  <span class="comment">//上下左右翻转效果</span></span><br><span class="line">suckEffect   <span class="comment">//收缩效果，如一块布被抽走(不支持过渡方向)</span></span><br><span class="line">rippleEffect <span class="comment">//滴水效果(不支持过渡方向)</span></span><br><span class="line">pageCurl     <span class="comment">//向上翻页效果</span></span><br><span class="line">pageUnCurl   <span class="comment">//向下翻页效果</span></span><br><span class="line">cameraIrisHollowOpen  <span class="comment">//相机镜头打开效果(不支持过渡方向)</span></span><br><span class="line">cameraIrisHollowClose <span class="comment">//相机镜头关上效果(不支持过渡方向)</span></span><br></pre></td></tr></table></figure><blockquote><p>效果参考</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-48e5ec518c8f535e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="各参数动画效果.png"></p><h3 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例:"></a>2. 代码示例:</h3><ul><li>展示立方体翻滚效果的图片浏览</li></ul><h4 id="1-初始化变量"><a href="#1-初始化变量" class="headerlink" title="1. 初始化变量"></a>1. 初始化变量</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化变量</span></span><br><span class="line">fileprivate var imageView = <span class="built_in">UIImageView</span>(frame: <span class="built_in">UIScreen</span>.main.bounds)</span><br><span class="line">fileprivate var currentIndex = <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="2-需要在viewDidLoad中调用一下方法"><a href="#2-需要在viewDidLoad中调用一下方法" class="headerlink" title="2. 需要在viewDidLoad中调用一下方法"></a>2. 需要在<code>viewDidLoad</code>中调用一下方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转场动画</span></span><br><span class="line">    fileprivate func imageCATransition()&#123;</span><br><span class="line">        <span class="comment">//0.初始化ImageView</span></span><br><span class="line">        imageView.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">        imageView.image = <span class="built_in">UIImage</span>(named: <span class="string">"0.jpg"</span>)</span><br><span class="line">        view.addSubview(imageView)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. 添加滑动手势</span></span><br><span class="line">        let left = <span class="built_in">UISwipeGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="meta">#selector(leftSwipe(gesture:)))</span></span><br><span class="line">        left.direction = .left</span><br><span class="line">        imageView.addGestureRecognizer(left)</span><br><span class="line">        let right = <span class="built_in">UISwipeGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="meta">#selector(rightSwipe(gesture:)))</span></span><br><span class="line">        right.direction = .right</span><br><span class="line">        imageView.addGestureRecognizer(right)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-滑动后执行的方法"><a href="#3-滑动后执行的方法" class="headerlink" title="3. 滑动后执行的方法"></a>3. 滑动后执行的方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: 手势相关方法</span></span><br><span class="line"><span class="comment">//左滑</span></span><br><span class="line">@objc fileprivate func leftSwipe(gesture: <span class="built_in">UIGestureRecognizer</span>) &#123;</span><br><span class="line">    print(<span class="string">"左滑动"</span>)</span><br><span class="line">    transitionAnimation(isNext: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右滑</span></span><br><span class="line">@objc fileprivate func rightSwipe(gesture: <span class="built_in">UIGestureRecognizer</span>) &#123;</span><br><span class="line">    print(<span class="string">"右滑动"</span>)</span><br><span class="line">    transitionAnimation(isNext: <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置转场动画</span></span><br><span class="line">fileprivate func transitionAnimation(isNext: Bool)&#123;</span><br><span class="line">    let transition = <span class="built_in">CATransition</span>()</span><br><span class="line">    transition.type = kCATransitionFade</span><br><span class="line">    transition.subtype = isNext ? kCATransitionFromRight : kCATransitionFromLeft</span><br><span class="line">    transition.duration = <span class="number">1</span></span><br><span class="line">    imageView.image = getImage(isNext)</span><br><span class="line">    imageView.layer.add(transition, forKey: <span class="string">"transition"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下/上一张图片</span></span><br><span class="line">fileprivate func getImage(_ isNext: Bool) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    currentIndex = isNext ? currentIndex + <span class="number">1</span> : currentIndex - <span class="number">1</span></span><br><span class="line">    currentIndex = currentIndex &lt; <span class="number">0</span> ? <span class="number">7</span> : currentIndex</span><br><span class="line">    currentIndex = currentIndex &gt; <span class="number">7</span> ? <span class="number">0</span> : currentIndex</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(named: <span class="string">"\(currentIndex)"</span> + <span class="string">".jpg"</span>)!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八-总结"><a href="#八-总结" class="headerlink" title="八. 总结"></a>八. 总结</h2><ul><li>核心动画给我们展示的只是一个假象，layer的的frame、bounds、position并不会在动画完毕之后发生改变。</li><li>UIView封装的动画，会使会真实修改view的一些属性</li><li>以上就是小编总结的关于Core Animation核心动画的相关分类</li><li>总结的知识点比较简单, 个人感觉有点low</li><li>如有不足之处,还望路过的大神多多指教</li></ul>]]></content>
      
      <categories>
          
          <category> iOS动画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> CoreAnimation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift+Moya网络请求之项目实战</title>
      <link href="/2017/10/08/RxSwift+Moya%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B9%8B%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
      <content type="html"><![CDATA[<blockquote><p>RxSwift相关基本介绍和用法可参考:</p><ul><li><a href="https://www.titanjun.top/2017/09/15/RxSwift%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A301/" target="_blank" rel="noopener">RxSwift的使用详解01</a></li><li><a href="https://www.titanjun.top/2017/09/21/RxSwift%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A302/" target="_blank" rel="noopener">RxSwift的使用详解02</a></li></ul></blockquote><a id="more"></a><h2 id="一-下面将将进行实战项目"><a href="#一-下面将将进行实战项目" class="headerlink" title="一. 下面将将进行实战项目"></a>一. 下面将将进行实战项目</h2><ul><li>1.登录注册功能<ul><li>输入用户名要大于6个字符，不然密码不能输入</li><li>密码必须大于6个字符，不然重复密码不能输入</li><li>重复密码输入必须和密码一样，不然注册按钮不能点击</li><li>根据输入的字符是否合法,按钮动态的改变颜色</li></ul></li><li>2.UITableView和搜索SertchBar的应用<ul><li>searchBar根据输入的字体展示包含该字体的cell列表</li><li><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>实现tableView列表展示</li></ul></li><li>3.<a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>+<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>实现网络请求<ul><li>应用<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>在UICollectionView中的应用</li><li>用<a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>进行网络请求</li><li><a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a>进行json到model的数据解析</li><li>整个<a href="https://github.com/coderQuanjun/RxSwift-Table-Collection" target="_blank" rel="noopener">Demo</a>的架构使用<a href="http://www.codertian.com/2015/11/13/MVVM-patterns-introduce/" target="_blank" rel="noopener">MVVM</a></li></ul></li></ul><h2 id="二-Demo地址"><a href="#二-Demo地址" class="headerlink" title="二. Demo地址"></a>二. <a href="https://github.com/coderQuanjun/RxSwift-Table-Collection" target="_blank" rel="noopener">Demo地址</a></h2><h3 id="下面简单看一下demo的界面"><a href="#下面简单看一下demo的界面" class="headerlink" title="下面简单看一下demo的界面"></a>下面简单看一下demo的界面</h3><h4 id="1-登录注册"><a href="#1-登录注册" class="headerlink" title="1. 登录注册"></a>1. 登录注册</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-6a3971f8ea4a7622.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="登录注册"></p><h4 id="2-UITableView和SearchBar"><a href="#2-UITableView和SearchBar" class="headerlink" title="2. UITableView和SearchBar"></a>2. UITableView和SearchBar</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-e2cff86052a6aa5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="UITableView和SearchBar"></p><h4 id="3-UICollectionView和Moya"><a href="#3-UICollectionView和Moya" class="headerlink" title="3. UICollectionView和Moya"></a>3. UICollectionView和Moya</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-da346221f1ddcba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="UICollectionView和Moya"></p><h2 id="三-项目结构和框架"><a href="#三-项目结构和框架" class="headerlink" title="三. 项目结构和框架"></a>三. 项目结构和框架</h2><h3 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. 结构</h3><p>demo是使用的纯MVVM模式，因为RxSwift就是为MVVM而生。不懂MVVM的猿友可参考<a href="http://www.codertian.com/2015/11/13/MVVM-patterns-introduce/" target="_blank" rel="noopener">MVVM模式快速入门</a> </p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-b180e89ddba220eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="项目结构"></p><h3 id="2-项目框架"><a href="#2-项目框架" class="headerlink" title="2. 项目框架"></a>2. 项目框架</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift三方库</span></span><br><span class="line">    <span class="comment">// Rx</span></span><br><span class="line">    pod 'RxSwift'  //RxSwift的必备库</span><br><span class="line">    pod 'RxCocoa'  //对 UIKit Foundation 进行 Rx 化</span><br><span class="line">    pod 'RxDataSources'   // 帮助我们优雅的使用tableView的数据源方法</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络请求</span></span><br><span class="line">    pod 'Moya/RxSwift'  // 为RxSwift专用提供，对Alamofire进行封装的一个网络请求库</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图片处理</span></span><br><span class="line">    pod 'Kingfisher'  //图片处理库</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据解析</span></span><br><span class="line">    pod 'ObjectMapper'  //json转模型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// OC库</span></span><br><span class="line">    <span class="comment">// MJRefresh</span></span><br><span class="line">    pod 'MJRefresh'   //MJ上拉下拉刷新</span><br><span class="line">    pod 'SVProgressHUD'  //HUD</span><br></pre></td></tr></table></figure><h2 id="四-注册界面"><a href="#四-注册界面" class="headerlink" title="四. 注册界面"></a>四. 注册界面</h2><ul><li>这里主要使用了Observable的相关知识,不了解的童鞋可参考<a href="http://www.jianshu.com/p/319db438c4d3" target="_blank" rel="noopener">RxSwift的使用详解01</a>,了解Observable的操作</li><li>注册和登录并没有保存已注册的账号和密码, 故登录功能并不完善,后期会在完善,望知晓</li><li>下面将针对注册用户名做简单介绍:</li></ul><h3 id="1-首先在model里处理输入字符串的语法法则和字符个数是否符合规范"><a href="#1-首先在model里处理输入字符串的语法法则和字符个数是否符合规范" class="headerlink" title="1. 首先在model里处理输入字符串的语法法则和字符个数是否符合规范"></a>1. 首先在model里处理输入字符串的语法法则和字符个数是否符合规范</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">extension InputValidator &#123;</span><br><span class="line">    <span class="comment">//判断字符串是否符合语法法则</span></span><br><span class="line">    <span class="keyword">class</span> func isValidEmail(_ email: String) -&gt; Bool &#123;</span><br><span class="line">        let regular = try? <span class="built_in">NSRegularExpression</span>(pattern: <span class="string">"^\\S+@\\S+\\.\\S+$"</span>, options: [])</span><br><span class="line">        <span class="keyword">if</span> let re = regular &#123;</span><br><span class="line">            let range = <span class="built_in">NSRange</span>(location: <span class="number">0</span>, length: email.lengthOfBytes(using: .utf8))</span><br><span class="line">            let result = re.matches(<span class="keyword">in</span>: email, options: [], range: range)</span><br><span class="line">            <span class="keyword">return</span> result.count &gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断密码字符个数&gt;8</span></span><br><span class="line">    <span class="keyword">class</span> func isValidPassword(_ password: String) -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> password.characters.count &gt;= <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断用户名</span></span><br><span class="line">    <span class="keyword">class</span> func validateUserName(_ username: String) -&gt; Result &#123;</span><br><span class="line">        <span class="comment">//判断字符个数是否正确</span></span><br><span class="line">        <span class="keyword">if</span> username.characters.count &lt; <span class="number">6</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.failure(message: <span class="string">"输入的字符个数不能少于6个字符"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//账号可用</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(message: <span class="string">"账号可用"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中Result是一个返回是否成功的枚举值,可传入字符串变量</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Result &#123;</span><br><span class="line">    <span class="keyword">case</span> success(message: String)</span><br><span class="line">    <span class="keyword">case</span> failure(message: String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-根据输入的用户名判断该用户名是否可用"><a href="#2-根据输入的用户名判断该用户名是否可用" class="headerlink" title="2. 根据输入的用户名判断该用户名是否可用"></a>2. 根据输入的用户名判断该用户名是否可用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var usernameObserable: Observable&lt;Result&gt;</span><br><span class="line">var passwordObserable: Observable&lt;Result&gt;</span><br><span class="line">var repeatPassObserable: Observable&lt;Result&gt;</span><br><span class="line">var registerBtnObserable: Observable&lt;Bool&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init()&#123;</span><br><span class="line">    <span class="comment">//检测账号</span></span><br><span class="line">    usernameObserable = username.asObservable().map(&#123; (username) -&gt; Result <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> InputValidator.validateUserName(username)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该返回参数Result,控制器将根据该Result是否成功来改变输入框是否是可编辑状态</li><li>初始化方法中，我们对传入的序列进行处理和转换成相对应的Result序列</li></ul><h3 id="3-controller逻辑-根据用户名输入改变各控件状态"><a href="#3-controller逻辑-根据用户名输入改变各控件状态" class="headerlink" title="3. controller逻辑,根据用户名输入改变各控件状态"></a>3. controller逻辑,根据用户名输入改变各控件状态</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 账号判断逻辑</span></span><br><span class="line">        <span class="comment">//1-1. 检测账号</span></span><br><span class="line">        usernameTextField.rx.text</span><br><span class="line">            .orEmpty <span class="comment">// 将String? 类型转为String型</span></span><br><span class="line">            .bindTo(registerVM.username)</span><br><span class="line">            .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1-2. 根据账号监听提示字体的状态</span></span><br><span class="line">        registerVM.usernameObserable</span><br><span class="line">            .bindTo(usernameHintLabel.rx.validationResult)</span><br><span class="line">            .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1-3. 根据账号监听密码输入框的状态</span></span><br><span class="line">        registerVM.usernameObserable</span><br><span class="line">            .bindTo(passwordTextField.rx.enableResult)</span><br><span class="line">            .addDisposableTo(bag)</span><br></pre></td></tr></table></figure><ul><li>检测输入用户名是否符合规范</li><li>根据账号监听提示字体的状态</li><li>根据账号监听密码输入框的状态</li><li>根据账号监听注册按钮的状态</li></ul><h2 id="五-UITableView和SearchBar"><a href="#五-UITableView和SearchBar" class="headerlink" title="五. UITableView和SearchBar"></a>五. UITableView和SearchBar</h2><ul><li>该UITableView展示界面并未涉及网络请求</li><li>数据来源plist文件</li><li>图片为本地图片,可下载demo,在demo中查找图片</li><li>选用自定义UITableViewCell,故cell不做介绍</li><li>model小编这里也不多做介绍,详情可下载demo看具体代码</li></ul><h3 id="1-viewModel中的代码逻辑"><a href="#1-viewModel中的代码逻辑" class="headerlink" title="1. viewModel中的代码逻辑"></a>1. viewModel中的代码逻辑</h3><h4 id="1-1-读取plist文件-获取模型数组"><a href="#1-1-读取plist文件-获取模型数组" class="headerlink" title="1-1. 读取plist文件,获取模型数组"></a>1-1. 读取plist文件,获取模型数组</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func getHeroData() -&gt; [HeroModel]&#123;</span><br><span class="line">    <span class="comment">// 1.获取路径</span></span><br><span class="line">    let path = Bundle.main.path(forResource: <span class="string">"heros.plist"</span>, ofType: <span class="literal">nil</span>)!</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 2.读取文件内容</span></span><br><span class="line">    let dictArray = <span class="built_in">NSArray</span>(contentsOfFile: path) as! [[String : Any]]</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 3.遍历所有的字典并且转成模型对象</span></span><br><span class="line">    <span class="keyword">return</span> dictArray.map(&#123; HeroModel(dict: $<span class="number">0</span>) &#125;).reversed()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-seachBar"><a href="#1-2-seachBar" class="headerlink" title="1-2. seachBar"></a>1-2. seachBar</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lazy var heroVariable: Variable&lt;[HeroModel]&gt; = &#123;</span><br><span class="line">    <span class="keyword">return</span> Variable(<span class="keyword">self</span>.getHeroData())</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">var searchText: Observable&lt;String&gt;</span><br><span class="line">init(searchText: Observable&lt;String&gt;) &#123;</span><br><span class="line">    <span class="keyword">self</span>.searchText = searchText</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.searchText.subscribe(onNext: &#123; (str: String) <span class="keyword">in</span></span><br><span class="line">        let heros = <span class="keyword">self</span>.getHeroData().filter(&#123; (hero: HeroModel) -&gt; Bool <span class="keyword">in</span></span><br><span class="line">            <span class="comment">//过滤</span></span><br><span class="line">            <span class="keyword">if</span> str.isEmpty &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">            <span class="comment">//model是否包含搜索字符串</span></span><br><span class="line">            <span class="keyword">return</span> hero.name.contains(str)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">self</span>.heroVariable.value = heros</span><br><span class="line">    &#125;).addDisposableTo(bag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中heroVariable是一个数组模型的包装箱,在controller内调用使用前需要asObservable或者asDriver解包装;详细用法可参考:<a href="http://www.jianshu.com/p/319db438c4d3" target="_blank" rel="noopener">RxSwift的使用详解01</a></li><li>searchText搜索框输入的关键字,根据该关键字从数组中过滤出所有包含该关键字的model</li><li>对heroVariable重新赋值,发出事件</li></ul><h3 id="1-3-RxTableViewController-swift主要代码"><a href="#1-3-RxTableViewController-swift主要代码" class="headerlink" title="1-3. RxTableViewController.swift主要代码"></a>1-3. RxTableViewController.swift主要代码</h3><h4 id="1-3-1-searchBar搜索框-输入字符后间隔0-5秒开始搜索"><a href="#1-3-1-searchBar搜索框-输入字符后间隔0-5秒开始搜索" class="headerlink" title="1-3-1.  searchBar搜索框,输入字符后间隔0.5秒开始搜索"></a>1-3-1.  searchBar搜索框,输入字符后间隔0.5秒开始搜索</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var searchText: Observable&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">//输入后间隔0.5秒搜索,在主线程运行</span></span><br><span class="line">    <span class="keyword">return</span> searchBar.rx.text.orEmpty.throttle(<span class="number">0.5</span>, scheduler: MainScheduler.instance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-UITableView的设置"><a href="#1-3-2-UITableView的设置" class="headerlink" title="1-3-2.  UITableView的设置"></a>1-3-2.  UITableView的设置</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.给tableView绑定数据</span></span><br><span class="line"><span class="comment">//注意: 三个参数:row, model, cell三个顺序不可以搞错, 不需要的可省略 </span></span><br><span class="line">heroVM.heroVariable.asDriver().drive(rxTableView.rx.items(cellIdentifier: kCellID, cellType: RxTableViewCell.self)) &#123; (_, hero, cell) <span class="keyword">in</span></span><br><span class="line">    cell.heroModel = hero</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3.监听UITableView的点击</span></span><br><span class="line">rxTableView.rx.modelSelected(HeroModel.self).subscribe &#123; (event: Event&lt;HeroModel&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event.element?.name ?? <span class="string">""</span>)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure><ul><li>将viewModel中的heroVariable进行解包装，如果是Driver序列，我们这里不使用bingTo，而是使用的Driver，用法和bingTo一模一样。</li><li>Deriver的监听一定发生在主线程，所以很适合我们更新UI的操作</li><li>如需设置delegate的代理</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rxTableView.rx.setDelegate(<span class="keyword">self</span>).addDisposableTo(bag)</span><br></pre></td></tr></table></figure><blockquote><p>然后在实现相应的代理方法即可,如: </p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension RxTableViewController: <span class="built_in">UITableViewDelegate</span>&#123;</span><br><span class="line">    func tableView(_ tableView: <span class="built_in">UITableView</span>, heightForRowAt indexPath: IndexPath) -&gt; <span class="built_in">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六-UICollectionView-Moya-ObjectMapper网络请求和数据处理"><a href="#六-UICollectionView-Moya-ObjectMapper网络请求和数据处理" class="headerlink" title="六. UICollectionView+Moya+ObjectMapper网络请求和数据处理"></a>六. UICollectionView+Moya+ObjectMapper网络请求和数据处理</h2><ul><li>与上述UITableView不同的是,这部分将以<a href="https://github.com/RxSwiftCommunity/RxDataSources" target="_blank" rel="noopener">RxDataSources</a>处理数据源</li><li>model数组以sections组集合处理</li><li>结合<a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>进行网络请求</li><li>使用<a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a>进行json数据转模型</li></ul><h3 id="1-配合ObjectMapper"><a href="#1-配合ObjectMapper" class="headerlink" title="1. 配合ObjectMapper"></a>1. 配合ObjectMapper</h3><p><strong>这里再介绍一下ObjectMapper</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AnchorModel: Mappable &#123;</span><br><span class="line"></span><br><span class="line">    var name = <span class="string">""</span>    <span class="comment">//名字</span></span><br><span class="line">    var pic51 = <span class="string">""</span>   <span class="comment">//头像</span></span><br><span class="line">    var pic74 = <span class="string">""</span>   <span class="comment">//大图</span></span><br><span class="line">    var live = <span class="number">0</span></span><br><span class="line">    var push = <span class="number">0</span></span><br><span class="line">    var focus = <span class="number">0</span>    <span class="comment">//关注量</span></span><br><span class="line">    </span><br><span class="line">    required init?(map: Map) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func mapping(map: Map) &#123;</span><br><span class="line">        name  &lt;- map[<span class="string">"name"</span>]</span><br><span class="line">        pic51 &lt;- map[<span class="string">"pic51"</span>]</span><br><span class="line">        pic74 &lt;- map[<span class="string">"pic74"</span>]</span><br><span class="line">        live  &lt;- map[<span class="string">"live"</span>]</span><br><span class="line">        push  &lt;- map[<span class="string">"push"</span>]</span><br><span class="line">        focus &lt;- map[<span class="string">"focus"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 ObjectMapper ，需要让自己的 Model 类使用 Mappable 协议，这个协议包括两个方法：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">required init?(map: Map) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">func mapping(map: Map) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>在 mapping 方法中，用 <code>&lt;-</code> 操作符来处理和映射你的 JSON数据</li><li>详细的 ObjectMapper 教程可以查看它的 <a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">Github 主页</a>，我在这里只做简单的介绍。</li></ul><h3 id="2-Moya的使用"><a href="#2-Moya的使用" class="headerlink" title="2. Moya的使用"></a>2. Moya的使用</h3><ul><li><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>是基于<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>的网络请求库，这里我使用了Moya/Swift，它在Moya的基础上添加了对RxSwift的接口支持。</li><li>Github上的官方介绍罗列了Moya的一些特点：<ul><li>编译时检查正确的API端点访问.   </li><li>使你定义不同端点枚举值对应相应的用途更加明晰. </li><li>提高测试地位从而使单元测试更加容易.</li></ul></li><li>接下来我们来说下Moya的使用</li></ul><h4 id="2-1-创建一个枚举API"><a href="#2-1-创建一个枚举API" class="headerlink" title="2-1. 创建一个枚举API"></a>2-1. 创建一个枚举API</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> JunNetworkTool &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> getNewList</span><br><span class="line">    <span class="keyword">case</span> getHomeList(page: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-为枚举添加扩展"><a href="#2-2-为枚举添加扩展" class="headerlink" title="2-2. 为枚举添加扩展"></a>2-2. 为枚举添加扩展</h4><ul><li>需遵循协议 TargetType</li><li>这个协议的Moya这个库规定的协议，可以单击进入相应的文件进行查看</li><li>这个协议内的每一个参数(除了<code>validate</code>可不重写)都必须重写,否则会报错</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求参数</span></span><br><span class="line">extension JunNetworkTool: TargetType &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统一基本的url</span></span><br><span class="line">    var baseURL: URL &#123;</span><br><span class="line">        <span class="keyword">return</span> (URL(string: <span class="string">"http://qf.56.com/home/v4/moreAnchor.ios"</span>))!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//path字段会追加至baseURL后面</span></span><br><span class="line">    var path: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求的方式</span></span><br><span class="line">    var method: Moya.Method &#123;</span><br><span class="line">        <span class="keyword">return</span> .get</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//参数编码方式(这里使用URL的默认方式)</span></span><br><span class="line">    var parameterEncoding: ParameterEncoding &#123;</span><br><span class="line">        <span class="keyword">return</span> URLEncoding.default</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于单元测试</span></span><br><span class="line">    var sampleData: Data &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"getList"</span>.data(using: .utf8)!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将要被执行的任务(请求：request 下载：upload 上传：download)</span></span><br><span class="line">    var task: Task &#123;</span><br><span class="line">        <span class="keyword">return</span> .request</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求参数(会在请求时进行编码)</span></span><br><span class="line">    var parameters: [String: Any]? &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .getHomeList(let index):</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">"index"</span>: index]</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">"index"</span>: <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否执行Alamofire验证，默认值为false</span></span><br><span class="line">    var validate: Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-定义一个全局变量用于整个项目的网络请求"><a href="#2-3-定义一个全局变量用于整个项目的网络请求" class="headerlink" title="2-3. 定义一个全局变量用于整个项目的网络请求"></a>2-3. 定义一个全局变量用于整个项目的网络请求</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let junNetworkTool = RxMoyaProvider&lt;JunNetworkTool&gt;()</span><br></pre></td></tr></table></figure><p>至此，我们就可以使用这个全局变量来请求数据了</p><h3 id="3-RxDataSources"><a href="#3-RxDataSources" class="headerlink" title="3. RxDataSources"></a>3. <a href="https://github.com/RxSwiftCommunity/RxDataSources" target="_blank" rel="noopener">RxDataSources</a></h3><ul><li>RxDataSources是以section来做为数据结构来传输，这点很重要，比如:在传统的数据源实现的方法中有一个numberOfSection，我们在很多情况下只需要一个section，所以这个方法可实现，也可以不实现，默认返回的就是1，这给我们带来的一个迷惑点：【tableView是由row来组成的】，不知道在坐的各位中有没有是这么想的呢？？有的话那从今天开始就要认清楚这一点，【tableView其实是由section组成的】，所以在使用RxDataSources的过程中，即使你的setion只有一个，那你也得返回一个section的数组出去！！！</li><li>传统方式适用于简单的数据集，但不处理需要将复杂数据集与多个部分进行绑定的情况，或者在添加/修改/删除项目时需要执行动画时。而使用RxDataSources时，它很容易写</li><li>想了解更多关于<a href="https://github.com/RxSwiftCommunity/RxDataSources" target="_blank" rel="noopener">RxDataSources</a>的用法,请参考其GitHub主页</li></ul><h4 id="3-1-Sections自定义"><a href="#3-1-Sections自定义" class="headerlink" title="3-1. Sections自定义"></a>3-1. Sections自定义</h4><ul><li>在我们自定义的Model中创建一个AnchorSection的结构体</li><li>并遵循SectionModelType协议，实现相应的协议方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: SectionModel</span></span><br><span class="line"><span class="keyword">struct</span> AnchorSection &#123;</span><br><span class="line">    <span class="comment">// items就是rows</span></span><br><span class="line">    var items: [Item]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 你也可以这里加你需要的东西，比如 headerView 的 title</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension AnchorSection: SectionModelType &#123;</span><br><span class="line">    <span class="comment">// 重定义 Item 的类型为</span></span><br><span class="line">    typealias Item = AnchorModel</span><br><span class="line">    init(original: AnchorSection, items: [AnchorSection.Item]) &#123;</span><br><span class="line">        <span class="keyword">self</span> = original</span><br><span class="line">        <span class="keyword">self</span>.items = items</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-ViewModel"><a href="#4-ViewModel" class="headerlink" title="4. ViewModel"></a>4. ViewModel</h3><h4 id="4-1-自定义协议BaseViewModel"><a href="#4-1-自定义协议BaseViewModel" class="headerlink" title="4-1. 自定义协议BaseViewModel"></a>4-1. 自定义协议BaseViewModel</h4><p>我们知道MVVM思想就是将原本在ViewController的视图显示逻辑、验证逻辑、网络请求等代码存放于ViewModel中，让我们的ViewController瘦身。这些逻辑由ViewModel负责，外界不需要关心，外界只需要结果，ViewModel也只需要将结果给到外界，基于此，我们定义了一个协议</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protocol JunViewModelType &#123;</span><br><span class="line">    <span class="comment">//associatedtype: 关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定</span></span><br><span class="line">    associatedtype Input</span><br><span class="line">    associatedtype Output</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们通过 transform 方法将input携带的数据进行处理，生成了一个Output</span></span><br><span class="line">    func transform(input: Input) -&gt; Output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-自定义用于网络请求的刷新状态"><a href="#4-2-自定义用于网络请求的刷新状态" class="headerlink" title="4-2. 自定义用于网络请求的刷新状态"></a>4-2. 自定义用于网络请求的刷新状态</h4><ul><li>根据枚举值的判断,改变collection的刷新状态</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷新的状态</span></span><br><span class="line"><span class="keyword">enum</span> JunRefreshStatus &#123;</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">    <span class="keyword">case</span> beingHeaderRefresh</span><br><span class="line">    <span class="keyword">case</span> endHeaderRefresh</span><br><span class="line">    <span class="keyword">case</span> beingFooterRefresh</span><br><span class="line">    <span class="keyword">case</span> endFooterRefresh</span><br><span class="line">    <span class="keyword">case</span> noMoreData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-自定义用于继承的BaseViewModel"><a href="#4-3-自定义用于继承的BaseViewModel" class="headerlink" title="4-3. 自定义用于继承的BaseViewModel"></a>4-3. 自定义用于继承的BaseViewModel</h4><ul><li>定义请求数据的页数index</li><li>定义input和output的结构体</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BaseViewModel: <span class="built_in">NSObject</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前的索引值</span></span><br><span class="line">    var index: Int = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> JunInput &#123;</span><br><span class="line">        <span class="comment">// 网络请求类型</span></span><br><span class="line">        let category: JunNetworkTool</span><br><span class="line">        </span><br><span class="line">        init(category: JunNetworkTool) &#123;</span><br><span class="line">            <span class="keyword">self</span>.category = category</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> JunOutput &#123;</span><br><span class="line">        <span class="comment">// tableView的sections数据</span></span><br><span class="line">        let sections: Driver&lt;[AnchorSection]&gt;</span><br><span class="line">        <span class="comment">// 外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载）</span></span><br><span class="line">        let requestCommond = PublishSubject&lt;Bool&gt;()</span><br><span class="line">        <span class="comment">// 告诉外界的tableView当前的刷新状态</span></span><br><span class="line">        let refreshStatus = Variable&lt;JunRefreshStatus&gt;(.none)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化时,section的数据</span></span><br><span class="line">        init(sections: Driver&lt;[AnchorSection]&gt;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sections = sections</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-自定义AnchorViewModel"><a href="#4-4-自定义AnchorViewModel" class="headerlink" title="4-4. 自定义AnchorViewModel"></a>4-4. 自定义AnchorViewModel</h4><ul><li>1) 继承BaseViewModel</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AnchorViewModel : BaseViewModel&#123;</span><br><span class="line">    <span class="comment">// 存放着解析完成的模型数组</span></span><br><span class="line">    let anchorArr = Variable&lt;[AnchorModel]&gt;([])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2) 遵循JunViewModelType协议</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">extension AnchorViewModel: JunViewModelType &#123;</span><br><span class="line">    typealias Input = JunInput</span><br><span class="line">    typealias Output = JunOutput</span><br><span class="line"></span><br><span class="line">    func transform(input: AnchorViewModel.JunInput) -&gt; AnchorViewModel.JunOutput &#123;</span><br><span class="line">        let sectionArr = anchorArr.asDriver().map &#123; (models) -&gt; [AnchorSection] <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 当models的值被改变时会调用</span></span><br><span class="line">            <span class="keyword">return</span> [AnchorSection(items: models)]</span><br><span class="line">        &#125;.asDriver(onErrorJustReturn: [])</span><br><span class="line">        </span><br><span class="line">        let output = JunOutput(sections: sectionArr)</span><br><span class="line">        </span><br><span class="line">        output.requestCommond.subscribe(onNext: &#123; (isReloadData) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.index = isReloadData ? <span class="number">1</span> : <span class="keyword">self</span>.index + <span class="number">1</span></span><br><span class="line">            <span class="comment">//开始请求数据</span></span><br><span class="line">            junNetworkTool.request(JunNetworkTool.getHomeList(page: <span class="keyword">self</span>.index))</span><br><span class="line">                .mapObjectArray(AnchorModel.self)</span><br><span class="line">                .subscribe(&#123; (event) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">switch</span> event &#123;</span><br><span class="line">                    <span class="keyword">case</span> let .next(modelArr):</span><br><span class="line">                        <span class="keyword">self</span>.anchorArr.value = isReloadData ? modelArr : (<span class="keyword">self</span>.anchorArr.value) + modelArr</span><br><span class="line">                        SVProgressHUD.showSuccess(withStatus: <span class="string">"加载成功"</span>)</span><br><span class="line">                    <span class="keyword">case</span> let .error(error):</span><br><span class="line">                        SVProgressHUD.showError(withStatus: error.localizedDescription)</span><br><span class="line">                    <span class="keyword">case</span> .completed:</span><br><span class="line">                        output.refreshStatus.value = isReloadData ? .endHeaderRefresh : .endFooterRefresh</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;).addDisposableTo(bag)</span><br><span class="line">        &#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sectionArr是将model数组按照section分别存储</li><li>当请求回来的anchorArr数据改变的时候, sectionArr随之会发生改变</li><li>isReloadData用于区分是下拉刷新(true时), 还是上拉加载更多(false时)</li></ul><h3 id="5-RxCollectionViewController控制器中"><a href="#5-RxCollectionViewController控制器中" class="headerlink" title="5. RxCollectionViewController控制器中"></a>5. RxCollectionViewController控制器中</h3><ul><li>创建数据源RxDataSources</li><li>绑定cell</li><li>初始化input和output请求</li><li>绑定section数据</li><li>设置刷新</li></ul><h4 id="5-1-创建数据源RxDataSources"><a href="#5-1-创建数据源RxDataSources" class="headerlink" title="5-1. 创建数据源RxDataSources"></a>5-1. 创建数据源RxDataSources</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个数据源属性，类型为自定义的Section类型</span></span><br><span class="line">let dataSource = RxCollectionViewSectionedReloadDataSource&lt;AnchorSection&gt;()</span><br></pre></td></tr></table></figure><h4 id="5-2-绑定cell-自定义的cell要提前注册"><a href="#5-2-绑定cell-自定义的cell要提前注册" class="headerlink" title="5-2. 绑定cell(自定义的cell要提前注册)"></a>5-2. 绑定cell(自定义的cell要提前注册)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataSource.configureCell = &#123; dataSource, collectionView, indexPath, item <span class="keyword">in</span></span><br><span class="line">    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: kCollecCellID, <span class="keyword">for</span>: indexPath) as! RxCollectionViewCell</span><br><span class="line">    cell.anchorModel = item</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上四个参数的顺序分别为:dataSource, collectionView(或者tableView), indexPath, model, 其对应类型不言而喻,不多做介绍</li></ul><h4 id="5-3-初始化input和output请求"><a href="#5-3-初始化input和output请求" class="headerlink" title="5-3. 初始化input和output请求"></a>5-3. 初始化input和output请求</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let vmInput = AnchorViewModel.JunInput(category: .getNewList)</span><br><span class="line">let vmOutput = anchorVM.transform(input: vmInput)</span><br></pre></td></tr></table></figure><h4 id="5-4-绑定section数据"><a href="#5-4-绑定section数据" class="headerlink" title="5-4. 绑定section数据"></a>5-4. 绑定section数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4-1. 通过dataSource和section的model数组绑定数据(demo的用法, 推荐)</span></span><br><span class="line">vmOutput.sections</span><br><span class="line">    .asDriver()</span><br><span class="line">    .drive(collectionVIew.rx.items(dataSource: dataSource))</span><br><span class="line">    .addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h4 id="5-5-设置刷新"><a href="#5-5-设置刷新" class="headerlink" title="5-5. 设置刷新"></a>5-5. 设置刷新</h4><h4 id="5-5-0-在controller中初始化刷新状态"><a href="#5-5-0-在controller中初始化刷新状态" class="headerlink" title="5-5-0. 在controller中初始化刷新状态"></a>5-5-0. 在controller中初始化刷新状态</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">collectionVIew.mj_header = MJRefreshNormalHeader(refreshingBlock: &#123;</span><br><span class="line">    vmOutput.requestCommond.onNext(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line">collectionVIew.mj_header.beginRefreshing()</span><br><span class="line">        </span><br><span class="line">collectionVIew.mj_footer = MJRefreshAutoNormalFooter(refreshingBlock: &#123;</span><br><span class="line">    vmOutput.requestCommond.onNext(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="5-5-1-添加刷新的序列"><a href="#5-5-1-添加刷新的序列" class="headerlink" title="5-5-1. 添加刷新的序列"></a>5-5-1. 添加刷新的序列</h4><ul><li>在JunOutput的结构体中添加刷新序列</li><li>我们在进行网络请求并得到结果之后，修改refreshStatus的value为相应的JunRefreshStatus项</li><li>MJRefre遍会根据该状态做出相应的刷新事件</li><li>默认状态为none</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 告诉外界的tableView当前的刷新状态</span></span><br><span class="line">let refreshStatus = Variable&lt;JunRefreshStatus&gt;(.none)</span><br></pre></td></tr></table></figure><h4 id="5-5-2-外界订阅output的refreshStatus"><a href="#5-5-2-外界订阅output的refreshStatus" class="headerlink" title="5-5-2. 外界订阅output的refreshStatus"></a>5-5-2. 外界订阅output的refreshStatus</h4><ul><li>外界订阅output的refreshStatus，并且根据接收到的值进行相应的操作</li><li>refreshStatus每次改变都会触发刷新事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5. 设置刷新状态</span></span><br><span class="line">vmOutput.refreshStatus.asObservable().subscribe(onNext: &#123; (status) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> status &#123;</span><br><span class="line">    <span class="keyword">case</span> .beingHeaderRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_header.beginRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .endHeaderRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_header.endRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .beingFooterRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_footer.beginRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .endFooterRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_footer.endRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .noMoreData:                   </span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_footer.endRefreshingWithNoMoreData()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h4 id="5-5-3-output提供一个requestCommond用于控制是否请求数据"><a href="#5-5-3-output提供一个requestCommond用于控制是否请求数据" class="headerlink" title="5-5-3. output提供一个requestCommond用于控制是否请求数据"></a>5-5-3. output提供一个requestCommond用于控制是否请求数据</h4><ul><li>PublishSubject 的特点：即可以作为Observable，也可以作为Observer，说白了就是可以发送信号，也可以订阅信号</li><li>当你订阅PublishSubject的时候，你只能接收到订阅他之后发生的事件。subject.onNext()发出onNext事件，对应的还有onError()和onCompleted()事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载）</span></span><br><span class="line">let requestCommond = PublishSubject&lt;Bool&gt;()</span><br></pre></td></tr></table></figure><h2 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h2><ul><li>为了研究RxSwift相关知识, 工作之余的时间,差不多一个月了</li><li>学习的瓶颈大部分在于网络请求和配合刷新这一模块</li><li>文中如出现self循环引用的问题,还望大神多多指正</li><li>小编目前也还在初学阶段,文中如出现小错误还望多多指正,如有更好的方法,也希望不吝分享</li><li>如果喜欢,可以收藏,也可以在Github上star一下</li></ul><h3 id="最后再一次附上Demo地址"><a href="#最后再一次附上Demo地址" class="headerlink" title="最后再一次附上Demo地址"></a>最后再一次附上<a href="https://github.com/coderQuanjun/RxSwift-Table-Collection" target="_blank" rel="noopener">Demo地址</a></h3><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h4><ul><li><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a></li><li><a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a></li><li><a href="https://github.com/RxSwiftCommunity/RxDataSources" target="_blank" rel="noopener">RxDataSources</a></li><li><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener">Kingfisher</a></li><li><a href="http://www.jianshu.com/p/319db438c4d3" target="_blank" rel="noopener">RxSwift的使用详解01</a></li><li><a href="http://www.jianshu.com/p/bcd0dc328308" target="_blank" rel="noopener">RxSwift的使用详解02</a></li><li><a href="https://www.2cto.com/kf/201703/611678.html" target="_blank" rel="noopener">moya + RxSwift 进行网络请求</a></li><li><a href="http://www.jianshu.com/p/9d536d3a1740" target="_blank" rel="noopener">扒一扒swift中的unowned和weak下</a></li><li><a href="http://mp.weixin.qq.com/s/B-AdatKDkjknKCYorqSfEw" target="_blank" rel="noopener">iOS - RxSwift -项目实战记录</a></li></ul>]]></content>
      
      <categories>
          
          <category> RxSwift框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
            <tag> 响应式编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift的使用详解02</title>
      <link href="/2017/09/21/RxSwift%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A302/"/>
      <content type="html"><![CDATA[<h1 id="一-RxSwift简介"><a href="#一-RxSwift简介" class="headerlink" title="一. RxSwift简介"></a>一. RxSwift简介</h1><blockquote><ul><li>推荐: <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift官方文档</a></li><li>中文: <a href="https://github.com/jhw-dev/RxSwift-CN" target="_blank" rel="noopener">RxSwift官方文档的中文翻译</a></li><li>上一篇: <a href="https://www.titanjun.top/2017/09/15/RxSwift%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A301/" target="_blank" rel="noopener">RxSwift的使用详解01</a></li></ul></blockquote><hr><a id="more"></a><blockquote><p>上一篇主要讲了</p><ul><li>RxSwift简介</li><li>RxSwift简单体验(在控件中的简单使用)</li><li>RxSwift常见操作(never, just, of, empty, creat等10个sequence的使用)</li><li>RxSwift中Subjects</li><li>变换操作(map, flatMap等)和资源释放DisposeBag</li><li>UIBindingObserver创建自己的监听者</li></ul></blockquote><hr><blockquote><p>本文主要内容</p><ul><li>联合操作: 把多个Observable流合成单个Observable流</li><li>elementAt, single, skip等过滤和约束操作</li><li>toArray, reduce, concat等数学操作</li></ul></blockquote><h1 id="二-联合操作"><a href="#二-联合操作" class="headerlink" title="二. 联合操作"></a>二. 联合操作</h1><ul><li>联合操作就是把多个Observable流合成单个Observable流</li></ul><h2 id="1-startWith"><a href="#1-startWith" class="headerlink" title="1. startWith"></a>1. startWith</h2><ul><li>在发出事件消息之前，先发出某个特定的事件消息。</li><li>比如发出事件2 ，3然后我startWith(1)，那么就会先发出1，然后2 ，3.</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未添加startWith</span></span><br><span class="line">Observable.of(<span class="string">"2"</span>, <span class="string">"3"</span>).subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/***输出顺序:</span></span><br><span class="line"><span class="comment">        next(2)</span></span><br><span class="line"><span class="comment">        next(3)</span></span><br><span class="line"><span class="comment">        completed</span></span><br><span class="line"><span class="comment">    ***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用startWith</span></span><br><span class="line">Observable.of(<span class="string">"2"</span>, <span class="string">"3"</span>).startWith(<span class="string">"1"</span>).subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序:</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         next(3)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="meta">## 2. merge</span></span><br><span class="line">- 合并两个Observable流合成单个Observable流，根据时间轴发出对应的事件</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.of(subject1, subject2)</span><br><span class="line">    .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"-------------------------"</span>)</span><br><span class="line"></span><br><span class="line">Observable.of(subject1, subject2)</span><br><span class="line">    .merge()</span><br><span class="line">    .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">subject1.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"jun"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"ya"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"jie"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"tian"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"guo"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         next(quan)</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         next(ya)</span></span><br><span class="line"><span class="comment">         next(jie)</span></span><br><span class="line"><span class="comment">         next(tian)</span></span><br><span class="line"><span class="comment">         next(guo)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="3-zip"><a href="#3-zip" class="headerlink" title="3. zip"></a>3. zip</h2><ul><li>绑定超过最多不超过8个的Observable流，结合在一起处理。</li><li>注意Zip是一个事件对应另一个流一个事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">let subject3 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject4 = PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.zip(subject3, subject4) &#123; (sub3, sub4) -&gt; String <span class="keyword">in</span></span><br><span class="line">        sub3 + <span class="string">"+"</span> + sub4</span><br><span class="line">    &#125;.subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">subject3.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject3.onNext(<span class="string">"jun"</span>)</span><br><span class="line">subject4.onNext(<span class="string">"ya"</span>)</span><br><span class="line">subject4.onNext(<span class="string">"jie"</span>)</span><br><span class="line">subject3.onNext(<span class="string">"tian"</span>)</span><br><span class="line">subject4.onNext(<span class="string">"guo"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         将subject3和subject4压缩到一起共同处理</span></span><br><span class="line"><span class="comment">         next(quan+ya)</span></span><br><span class="line"><span class="comment">         next(jun+jie)</span></span><br><span class="line"><span class="comment">         next(tian+guo)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">```        </span><br><span class="line">        </span><br><span class="line"><span class="meta">## 4. combineLatest</span></span><br><span class="line">- 绑定超过最多不超过<span class="number">8</span>个的Observable流，结合在一起处理。</span><br><span class="line">- 和Zip不同的是combineLatest是一个流的事件对应另一个流的最新的事件，两个事件都会是最新的事件，可将下图与Zip的图进行对比</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">let subject5 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject6 = PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.combineLatest(subject5, subject6) &#123; (sub5, sub6) -&gt; String <span class="keyword">in</span></span><br><span class="line">        sub5 + <span class="string">"+"</span> + sub6</span><br><span class="line">    &#125;.subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line"></span><br><span class="line">subject5.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject5.onNext(<span class="string">"1"</span>)</span><br><span class="line">subject6.onNext(<span class="string">"ya"</span>)</span><br><span class="line">subject6.onNext(<span class="string">"2"</span>)</span><br><span class="line">subject5.onNext(<span class="string">"--"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         将subject3的最新事件和subject4的最新事件一起处理</span></span><br><span class="line"><span class="comment">         next(1+ya)</span></span><br><span class="line"><span class="comment">         next(1+2)</span></span><br><span class="line"><span class="comment">         next(--+2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">```    </span><br><span class="line">        </span><br><span class="line"><span class="meta">## 5. switchLatest</span></span><br><span class="line">- switchLatest可以对事件流进行转换，本来监听的subject1，我可以通过更改variable里面的value更换事件源。变成监听subject2了</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">let subject7 = BehaviorSubject(value: <span class="string">"love"</span>)</span><br><span class="line"><span class="comment">//BehaviorSubject: 接受订阅之前的最后一个事件</span></span><br><span class="line">let subject8 = BehaviorSubject(value: <span class="string">"love to"</span>)</span><br><span class="line">let variable = Variable(subject7)</span><br><span class="line">variable.asObservable()</span><br><span class="line">        .switchLatest()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">subject7.onNext(<span class="string">"ya"</span>)</span><br><span class="line">subject7.onNext(<span class="string">"jie"</span>)</span><br><span class="line"></span><br><span class="line">variable.value = subject8</span><br><span class="line">subject7.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject8.onNext(<span class="string">"jun"</span>)</span><br><span class="line">        </span><br><span class="line">variable.value = subject7</span><br><span class="line">subject8.onNext(<span class="string">"jie"</span>)</span><br><span class="line">subject7.onNext(<span class="string">"guo"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         next(love)</span></span><br><span class="line"><span class="comment">         next(ya)</span></span><br><span class="line"><span class="comment">         next(jie)</span></span><br><span class="line"><span class="comment">         next(love to)</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         next(quan)</span></span><br><span class="line"><span class="comment">         next(guo)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h1 id="二-过滤和约束"><a href="#二-过滤和约束" class="headerlink" title="二. 过滤和约束"></a>二. 过滤和约束</h1><h2 id="1-1-distinctUntilChanged"><a href="#1-1-distinctUntilChanged" class="headerlink" title="1. 1. distinctUntilChanged"></a>1. 1. distinctUntilChanged</h2><ul><li>distinctUntilChanged就是当: 下一个事件与前一个事件是不同事件的事件才进行处理操作</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        .distinctUntilChanged()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(3)</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="2-elementAt"><a href="#2-elementAt" class="headerlink" title="2. elementAt"></a>2. elementAt</h2><ul><li>只处理在指定位置的事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .elementAt(<span class="number">3</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="3-single"><a href="#3-single" class="headerlink" title="3. single"></a>3. single</h2><ul><li>找出在sequence只发出一次的事件，如果超过一个就会发出error错误</li></ul><h3 id="gt-1-多个信号输出的情况"><a href="#gt-1-多个信号输出的情况" class="headerlink" title="&gt;1 多个信号输出的情况"></a>&gt;1 多个信号输出的情况</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(1) //单一信号超过了一个,只会输出第一个,然后输出error</span></span><br><span class="line"><span class="comment">         error(Sequence contains more than one element.)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h3 id="gt-2-指定某唯一信号的情况"><a href="#gt-2-指定某唯一信号的情况" class="headerlink" title="&gt;2 指定某唯一信号的情况"></a>&gt;2 指定某唯一信号的情况</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single(&#123; $<span class="number">0</span> == <span class="number">2</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h3 id="gt-3-指定某不唯一信号的情况"><a href="#gt-3-指定某不唯一信号的情况" class="headerlink" title="&gt;3 指定某不唯一信号的情况"></a>&gt;3 指定某不唯一信号的情况</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Observable.of(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single(&#123; $<span class="number">0</span> == <span class="number">4</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4) //单一信号超过了一个,只会输出第一个,然后输出error</span></span><br><span class="line"><span class="comment">         error(Sequence contains more than one element.)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h3 id="gt-4-找不到该信号的情况"><a href="#gt-4-找不到该信号的情况" class="headerlink" title="&gt;4 找不到该信号的情况"></a>&gt;4 找不到该信号的情况</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single(&#123; $<span class="number">0</span> == <span class="number">2</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         没有对应的参数,然后输出error</span></span><br><span class="line"><span class="comment">         error(Sequence doesn't contain any elements.)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="4-filter"><a href="#4-filter" class="headerlink" title="4. filter"></a>4. filter</h2><ul><li>过滤掉某些不符合要求的事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .filter(&#123; $<span class="number">0</span> &gt; <span class="number">3</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="5-take"><a href="#5-take" class="headerlink" title="5. take"></a>5. take</h2><ul><li>只处理前几个事件信号</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="6-takeLast"><a href="#6-takeLast" class="headerlink" title="6. takeLast"></a>6. takeLast</h2><ul><li>只处理后几个事件信号</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .takeLast(<span class="number">2</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="7-takeWhile"><a href="#7-takeWhile" class="headerlink" title="7. takeWhile"></a>7. takeWhile</h2><ul><li>当条件满足的时候进行处理</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .takeWhile(&#123; $<span class="number">0</span> &gt; <span class="number">3</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="8-takeUntil"><a href="#8-takeUntil" class="headerlink" title="8. takeUntil"></a>8. takeUntil</h2><ul><li>接收事件消息，直到另一个sequence发出事件消息的时候.停止接收消息,输出completed</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class="line">subject1.takeUntil(subject2)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">subject1.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"jun"</span>)</span><br><span class="line"></span><br><span class="line">subject2.onNext(<span class="string">"ya"</span>)<span class="comment">//停止接收消息</span></span><br><span class="line">        </span><br><span class="line">subject1.onNext(<span class="string">"tian"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"guo"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(quan)</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="9-skip"><a href="#9-skip" class="headerlink" title="9. skip"></a>9. skip</h2><ul><li>取消前几个事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .skip(<span class="number">3</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="10-skipWhile"><a href="#10-skipWhile" class="headerlink" title="10. skipWhile"></a>10. skipWhile</h2><ul><li>满足条件的事件消息都取消</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .skipWhile(&#123; $<span class="number">0</span> &lt; <span class="number">4</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="11-skipWhileWithIndex"><a href="#11-skipWhileWithIndex" class="headerlink" title="11. skipWhileWithIndex"></a>11. skipWhileWithIndex</h2><ul><li>满足条件的都被取消，传入的闭包同skipWhile有点区别而已</li><li><code>skipWhile</code>的(&lt;4)和<code>skipWhileWithIndex</code>的(&lt;=3)的效果是一样的</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .skipWhileWithIndex(&#123; (element, index) -&gt; Bool <span class="keyword">in</span></span><br><span class="line">            index &lt;= <span class="number">3</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="12-skipUntil"><a href="#12-skipUntil" class="headerlink" title="12. skipUntil"></a>12. skipUntil</h2><ul><li>直到某个sequence发出了事件消息，才开始接收当前sequence发出的事件消息</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let subject3 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject4 = PublishSubject&lt;String&gt;()</span><br><span class="line">subject3.skipUntil(subject4)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">subject3.onNext(<span class="string">"quan"</span>)</span><br><span class="line">subject4.onNext(<span class="string">"jun"</span>)</span><br><span class="line">        </span><br><span class="line">subject4.onNext(<span class="string">"ya"</span>)<span class="comment">//开始接收消息</span></span><br><span class="line">        </span><br><span class="line">subject3.onNext(<span class="string">"tian"</span>)</span><br><span class="line">subject4.onNext(<span class="string">"guo"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(tian)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h1 id="三-数学操作"><a href="#三-数学操作" class="headerlink" title="三. 数学操作"></a>三. 数学操作</h1><h2 id="1-toArray"><a href="#1-toArray" class="headerlink" title="1. toArray"></a>1. toArray</h2><ul><li>将sequence转换成一个array，并转换成单一事件信号，然后结束</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(start: <span class="number">1</span>, count: <span class="number">5</span>)</span><br><span class="line">        .toArray()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next([1, 2, 3, 4, 5])</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">```        </span><br><span class="line">        </span><br><span class="line"><span class="meta">## 2. reduce</span></span><br><span class="line">- 用一个初始值，对事件数据进行累计操作。reduce接受一个初始值，和一个操作符号</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">Observable.of(<span class="number">10</span>, <span class="number">12</span>, <span class="number">34</span>)</span><br><span class="line">       .reduce(<span class="number">0</span>, accumulator: +)</span><br><span class="line">       .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">       .addDisposableTo(bag)</span><br><span class="line">       </span><br><span class="line">  <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(56)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">```        </span><br><span class="line">        </span><br><span class="line"><span class="meta">## 3. concat</span></span><br><span class="line">- concat会把多个sequence和并为一个sequence，并且当前面一个sequence发出了completed事件，才会开始下一个sequence的事件。</span><br><span class="line">- 在第一sequence发出onCompleted完成之前，第二个sequence发出的事件都会被忽略</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">let subject1 = BehaviorSubject(value: <span class="string">"quan"</span>)</span><br><span class="line">let subject2 = BehaviorSubject(value: <span class="string">"jun"</span>)</span><br><span class="line">let variable = Variable(subject1)</span><br><span class="line">variable.asObservable()</span><br><span class="line">        .concat()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">subject1.onNext(<span class="string">"ya"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"jie"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"jun"</span>)  <span class="comment">//subject2不被输出</span></span><br><span class="line">        </span><br><span class="line">variable.value = subject2  <span class="comment">//subject1发出onCompleted()之前会继续输出subject1</span></span><br><span class="line">        </span><br><span class="line">subject1.onNext(<span class="string">"guo"</span>)</span><br><span class="line">subject2.onNext(<span class="string">"tian"</span>)</span><br><span class="line">        </span><br><span class="line">subject1.onCompleted()  <span class="comment">//subject1结束,开始输出subject2,此时subject2的值接受最后一个("tian")</span></span><br><span class="line">        </span><br><span class="line">subject2.onNext(<span class="string">"love"</span>)</span><br><span class="line">subject1.onNext(<span class="string">"to love"</span>) <span class="comment">//subject1将不再被输出</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">        next(quan)</span></span><br><span class="line"><span class="comment">        next(ya)</span></span><br><span class="line"><span class="comment">        next(jie)</span></span><br><span class="line"><span class="comment">        next(guo)</span></span><br><span class="line"><span class="comment">        next(tian)</span></span><br><span class="line"><span class="comment">        next(love)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h1 id="四-RxSwift的优点"><a href="#四-RxSwift的优点" class="headerlink" title="四. RxSwift的优点"></a>四. RxSwift的优点</h1><ul><li>Composable 可组合，在设计模式中有一种模式叫做组合模式，你可以方便的用不同的组合实现不同的类</li><li>Reusable 代码可重用，原因很简单，对应RxSwift，就是一堆Obserable</li><li>Declarative 响应式的，因为状态不可变，只有数据变化</li><li>Understandable and concise 简洁，容易理解。</li><li>Stable 稳定，因为RxSwift写出的代码，单元测试时分方便</li><li>Less stateful “无”状态性，因为对于响应式编程，你的应用程序就是一堆数据流</li><li>Without leaks 没有泄漏，因为资源管理非常简单</li></ul>]]></content>
      
      <categories>
          
          <category> RxSwift框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
            <tag> 响应式编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxSwift的使用详解01</title>
      <link href="/2017/09/15/RxSwift%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A301/"/>
      <content type="html"><![CDATA[<h2 id="一-RxSwift简介"><a href="#一-RxSwift简介" class="headerlink" title="一. RxSwift简介"></a>一. RxSwift简介</h2><blockquote><ul><li>推荐: <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift官方文档</a></li><li>中文: <a href="https://github.com/jhw-dev/RxSwift-CN" target="_blank" rel="noopener">RxSwift官方文档的中文翻译</a></li></ul></blockquote><a id="more"></a><ul><li><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>是Swift函数响应式编程的一个开源库，由Github的<a href="https://github.com/ReactiveX" target="_blank" rel="noopener">ReactiveX</a>组织开发、维护</li><li>其他语言像C#, Java 和 JS 也有，Rx.Net、RxJava、<a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener">rxjs</a></li><li>RxSwift的目的是让数据/事件流和异步任务能够更方便的序列化处理，能够使用Swift进行响应式编程</li></ul><h3 id="1-RxSwift做了什么"><a href="#1-RxSwift做了什么" class="headerlink" title="1. RxSwift做了什么"></a>1. RxSwift做了什么</h3><ul><li>RxSwift把我们程序中每一个操作都看成一个事件</li><li>比如一个TextField中的文本改变，一个按钮被点击，或者一个网络请求结束等，每一个事件源就可以看成一个管道，也就是sequence</li><li>比如TextField，当我们改变里面的文本的时候，这个TextField就会不断的发出事件，从他的这个sequence中不断的流出，我们只需要监听这个sequence，每流出一个事件就做相应的处理。</li><li>同理，Button也是一个sequence，每点击一次就流出一个事件。</li></ul><h3 id="2-RxSwift的核心思想是-Observable"><a href="#2-RxSwift的核心思想是-Observable" class="headerlink" title="2 RxSwift的核心思想是 Observable"></a>2 RxSwift的核心思想是 Observable<element></element></h3><ul><li>sequence，Observable表示可监听或者可观察，也就是说RxSwift的核心思想是可监听的序列。</li><li><p>并且，Observable sequence可以接受异步信号，也就是说，信号是可以异步给监听者的</p><ul><li>Observable(ObservableType) 和 SequenceType类似</li><li>ObservableType.subscribe 和 SequenceType.generate类似</li><li>由于RxSwift支持异步获得信号，所以用ObservableType.subscribe，这和indexGenerator.next()类似</li></ul></li><li><p>其中SequenceType是Swift(2.3以前版本,之后的版本没有该协议)中的一个协议，比如Swift中的Array就遵循这个协议，通过这个协议，你可以这样的去操作一个Array</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">let array2 = array.filter(&#123;$<span class="number">0</span> &gt; <span class="number">1</span>&#125;).map(&#123;$<span class="number">0</span> * <span class="number">2</span>&#125;)<span class="comment">//4 6 8 10</span></span><br><span class="line">var indexGenerator = array2.generate()</span><br><span class="line">let fisrt = indexGenerator.next() <span class="comment">// 4</span></span><br><span class="line">let seoncd = indexGenerator.next() <span class="comment">//6</span></span><br></pre></td></tr></table></figure><h3 id="3-RxSwift中，ObservableType-subscribe的回调（新的信号到来）一共有三"><a href="#3-RxSwift中，ObservableType-subscribe的回调（新的信号到来）一共有三" class="headerlink" title="3.  RxSwift中，ObservableType.subscribe的回调（新的信号到来）一共有三"></a>3.  RxSwift中，ObservableType.subscribe的回调（新的信号到来）一共有三</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Event&lt;Element&gt;  &#123;</span><br><span class="line">    <span class="keyword">case</span> Next(Element)      <span class="comment">// 新的信号到来</span></span><br><span class="line">    <span class="keyword">case</span> Error(ErrorType)   <span class="comment">// 信号发生错误，序列不会再产生信号</span></span><br><span class="line">    <span class="keyword">case</span> Completed          <span class="comment">// 序列发送信号完成，不会再产生新的信号</span></span><br><span class="line">&#125;</span><br><span class="line">protocol ObserverType &#123;</span><br><span class="line">    func on(event: Event&lt;Element&gt;) <span class="comment">//监听所有的信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-取消监听"><a href="#4-取消监听" class="headerlink" title="4. 取消监听"></a>4. 取消监听</h3><blockquote><p>Observable分为两种</p></blockquote><ul><li>在有限的时间内会自动结束（Completed/Error）,比如一个网络请求当作一个序列，当网络请求完成的时候，Observable自动结束，资源会被释放</li><li>信号不会自己结束，最简单的比如一个Timer，每隔一段时间发送一个新的信号过来，这时候需要手动取消监听，来释放相应的资源</li><li>比如一个label.rx.text是一个Obserable，通常需要这样调用addDisposableTo(disposeBag)来让其在deinit，也就是所有者要释放的时候，自动取消监听<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Observable&lt;Element&gt; &#123;</span><br><span class="line">    func subscribe(observer: Observer&lt;Element&gt;) -&gt; Disposable //调用Disposable的方法来取消</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>当然，除了手动释放，RxSwift提供了一些操作符，比如 takeUntil来根据条件取消</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequence</span><br><span class="line">    .takeUntil(self.rx_deallocated) //当对象要释放的时候，取消监听</span><br><span class="line">    .subscribe &#123;</span><br><span class="line">        print($0)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二-RxSwift简单体验"><a href="#二-RxSwift简单体验" class="headerlink" title="二. RxSwift简单体验"></a>二. RxSwift简单体验</h2><ul><li>首先创建deinit属性，也就是所有者要释放的时候，自动取消监听</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileprivate lazy var bag = DisposeBag()</span><br></pre></td></tr></table></figure><h3 id="1-RxSwift监听按钮的点击"><a href="#1-RxSwift监听按钮的点击" class="headerlink" title="1. RxSwift监听按钮的点击"></a>1. RxSwift监听按钮的点击</h3><ul><li>传统方式: </li><li></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button1.addTarget(<span class="keyword">self</span>, action: <span class="meta">#selector(btn1Click(_:)), for: .touchUpInside)</span></span><br></pre></td></tr></table></figure><ul><li>RxSwift方式</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.rx.tap.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.button1.setTitle(<span class="string">"按钮1"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">    print(<span class="string">"button1"</span>)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">button2.rx.tap.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.textField2.text = <span class="string">"按钮2被点击了"</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h3 id="2-RxSwift监听UITextField的文字改变"><a href="#2-RxSwift监听UITextField的文字改变" class="headerlink" title="2. RxSwift监听UITextField的文字改变"></a>2. RxSwift监听UITextField的文字改变</h3><ul><li>传统做法,设置<code>textField2.delegate = self</code></li><li>RxSwift方式</li></ul><blockquote><p>2-1. 用on方法实现</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe(&lt;<span class="meta">#T##on: (Event<span class="meta-string">&lt;Int&gt;</span>) -&gt; Void##(Event<span class="meta-string">&lt;Int&gt;</span>) -&gt; Void#&gt;)</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">textField1.rx.text.subscribe &#123; (event: Event&lt;String?&gt;) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//将UITextField文字改变的内容显示在Label中</span></span><br><span class="line">    <span class="keyword">self</span>.label1.text = event.element!    </span><br><span class="line">    print(event.element!!)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">textField2.rx.text.subscribe &#123; (event: Event&lt;String?&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event.element)<span class="comment">//报警告</span></span><br><span class="line">    <span class="comment">//输出: Optional(Optional("jun"))</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure><blockquote><p>2-2. 用onNext方法实现</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe(on: (Event&lt;Int&gt;) -&gt; Void)</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">textField1.rx.text.subscribe(onNext: &#123; (str: String?) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.label1.text = str!</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"><span class="meta">### 3. RxSwift改变Label中文字</span></span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">label1.rx.observe(String.self, <span class="string">"text"</span>).subscribe(onNext: &#123; (str: String?) <span class="keyword">in</span></span><br><span class="line">    print(str!)</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">label2.rx.observe(<span class="built_in">CGRect</span>.self, <span class="string">"frame"</span>).subscribe(onNext: &#123; (rect: <span class="built_in">CGRect</span>?) <span class="keyword">in</span></span><br><span class="line">    print(rect!.width)</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h3 id="4-RxSwift监听UIScrollView的滚动"><a href="#4-RxSwift监听UIScrollView的滚动" class="headerlink" title="4. RxSwift监听UIScrollView的滚动"></a>4. RxSwift监听UIScrollView的滚动</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scrollView.contentSize = <span class="built_in">CGSize</span>(width: <span class="number">1000</span>, height: <span class="number">0</span>)</span><br><span class="line">scrollView.rx.contentOffset</span><br><span class="line">            .subscribe(onNext: &#123; (point : <span class="built_in">CGPoint</span>) <span class="keyword">in</span></span><br><span class="line">                print(point)</span><br><span class="line">            &#125;).addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h2 id="三-RxSwift常见操作"><a href="#三-RxSwift常见操作" class="headerlink" title="三. RxSwift常见操作"></a>三. RxSwift常见操作</h2><ul><li>addDisposableTo(disposeBag)方法是让其deinit，也就是所有者要释放的时候，自动取消监听</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建bag</span><br><span class="line">let bag = DisposeBag()</span><br></pre></td></tr></table></figure><h3 id="1-never"><a href="#1-never" class="headerlink" title="1. never"></a>1. never</h3><ul><li>never就是创建一个sequence,但是不发出任何事件信号</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let neverSqu = Observable&lt;String&gt;.never()</span><br><span class="line">neverSqu.subscribe &#123; (_) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//该语句不会执行</span></span><br><span class="line">    print(<span class="string">"This will never be printed"</span>)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line"><span class="comment">//调用Disposable的方法来取消</span></span><br></pre></td></tr></table></figure><h3 id="2-empty"><a href="#2-empty" class="headerlink" title="2. empty"></a>2. empty</h3><ul><li>empty就是创建一个空的sequence,只能发出一个complected事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Int&gt;.empty().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//该语句只会执行一次</span></span><br><span class="line">    <span class="comment">//输出: completed</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h3 id="3-just"><a href="#3-just" class="headerlink" title="3. just"></a>3. just</h3><ul><li>just是创建一个sequence只能发出一种特定的事件，能正常结束</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Int&gt;.just(<span class="number">3</span>).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行两次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(3),语句结果</span></span><br><span class="line"><span class="comment">     2) completed, 结束事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">Observable.just(<span class="string">"jun"</span>).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行两次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(jun),语句结果</span></span><br><span class="line"><span class="comment">     2) completed, 结束事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">```    </span><br><span class="line">        </span><br><span class="line"><span class="meta">### 4.of</span></span><br><span class="line">- of是创建一个sequence能发出很多种事件信号</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">Observable.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"2"</span>, <span class="string">"5.3"</span>)</span><br><span class="line">    .subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">//会分别输出 "a", "b", "2", "5.3"</span></span><br><span class="line"></span><br><span class="line">Observable.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"2"</span>, <span class="string">"5.3"</span>).subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行4次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(a),语句结果</span></span><br><span class="line"><span class="comment">     2) next(b),语句结果</span></span><br><span class="line"><span class="comment">     3) next(2),语句结果</span></span><br><span class="line"><span class="comment">     4) next(3.5),语句结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;, onError: <span class="literal">nil</span>, onCompleted: <span class="literal">nil</span>, onDisposed: <span class="literal">nil</span>).addDisposableTo(bag)</span><br><span class="line">   <span class="comment">//每一个闭包都设置设置了 一个默认值,故可以省略</span></span><br></pre></td></tr></table></figure><h3 id="5-from"><a href="#5-from" class="headerlink" title="5. from"></a>5. from</h3><ul><li>from就是从数组中创建sequence</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Observable.from([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"2"</span>, <span class="string">"5.3"</span>]).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行5次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(a),语句结果</span></span><br><span class="line"><span class="comment">     2) next(b),语句结果</span></span><br><span class="line"><span class="comment">     3) next(2),语句结果</span></span><br><span class="line"><span class="comment">     4) next(3.5),语句结果</span></span><br><span class="line"><span class="comment">     5) completed, 结束事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">```        </span><br><span class="line"><span class="meta">### 6. create</span></span><br><span class="line">- 我们也可以自定义可观察的sequence，那就是使用create</span><br><span class="line">- create操作符传入一个观察者observer，然后调用observer的onNext，onCompleted和onError方法。返回一个可观察的obserable序列</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 1) 自定义方法创建observable的creat</span></span><br><span class="line"><span class="meta">##### 6-1 无参创建creat</span></span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">fileprivate func myobserable() -&gt; Observable&lt;Any&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(&#123; (observal: AnyObserver&lt;Any&gt;) -&gt; Disposable <span class="keyword">in</span></span><br><span class="line">        observal.onNext(<span class="string">"abc"</span>)</span><br><span class="line">        observal.onNext(<span class="string">"12"</span>)</span><br><span class="line">        observal.onCompleted()</span><br><span class="line">        <span class="keyword">return</span> Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-2-添加参数创建creat"><a href="#6-2-添加参数创建creat" class="headerlink" title="6-2 添加参数创建creat"></a>6-2 添加参数创建creat</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func myJunst(element: String) -&gt; Observable&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(&#123; (observal: AnyObserver&lt;String&gt;) -&gt; Disposable <span class="keyword">in</span></span><br><span class="line">        observal.onNext(element)</span><br><span class="line">        observal.onCompleted()</span><br><span class="line">        <span class="keyword">return</span> Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-在函数内调用自定义方法"><a href="#2-在函数内调用自定义方法" class="headerlink" title="2) 在函数内调用自定义方法"></a>2) 在函数内调用自定义方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myobserable().subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line"><span class="comment">//该语句只会执行2次,分别输出"abc", "12"</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line">myJunst(element: <span class="string">"jun"</span>).subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line"><span class="comment">//该语句只会执行2次,分别输出"jun"</span></span><br></pre></td></tr></table></figure><h3 id="7-range-给定范围-依次显示"><a href="#7-range-给定范围-依次显示" class="headerlink" title="7. range(给定范围, 依次显示)"></a>7. range(给定范围, 依次显示)</h3><ul><li>range就是创建一个sequence，他会发出这个范围中的从开始到结束的所有事件</li><li>Observable<int>,必须指定数据类型</int></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Int&gt;.range(start: <span class="number">1</span>, count: <span class="number">4</span>).subscribe &#123; (event: Event&lt;Int&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行5次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(1),语句结果</span></span><br><span class="line"><span class="comment">     2) next(2),语句结果</span></span><br><span class="line"><span class="comment">     3) next(3),语句结果</span></span><br><span class="line"><span class="comment">     4) next(4),语句结果</span></span><br><span class="line"><span class="comment">     5) completed, 结束事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure><h3 id="8-repeatElement-重复执行"><a href="#8-repeatElement-重复执行" class="headerlink" title="8. repeatElement(重复执行)"></a>8. repeatElement(重复执行)</h3><p>创建一个sequence，发出特定的事件n次</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.repeatElement(<span class="string">"quanjun"</span>)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">//该语句只会执行3次,每次都输出"quanjun"</span></span><br></pre></td></tr></table></figure><h3 id="9-generate-类似于for循环"><a href="#9-generate-类似于for循环" class="headerlink" title="9.  generate(类似于for循环)"></a>9.  generate(类似于for循环)</h3><ul><li>generate是创建一个可观察sequence，当初始化的条件为true的时候，他就会发出所对应的事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let generate = Observable.generate(initialState: <span class="number">0</span>, condition: &#123; $<span class="number">0</span> &lt; <span class="number">5</span> &#125;, iterate: &#123; $<span class="number">0</span> + <span class="number">2</span> &#125;)</span><br><span class="line">generate.subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*1&gt; 输出顺序:</span></span><br><span class="line"><span class="comment">         next(0)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         2&gt; 以上代码可以理解为for循环处理逻辑</span></span><br><span class="line"><span class="comment">        for (Int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">            print(i)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br></pre></td></tr></table></figure><h3 id="10-error-发出错误信号"><a href="#10-error-发出错误信号" class="headerlink" title="10.  error(发出错误信号)"></a>10.  error(发出错误信号)</h3><ul><li>创建一个可观察序列，但不发出任何正常的事件，只发出error事件并结束</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> let error = <span class="built_in">NSError</span>(domain: <span class="string">"错误"</span>, code: <span class="number">10</span>, userInfo: <span class="literal">nil</span>) as Error</span><br><span class="line"> Observable&lt;Any&gt;.error(error)</span><br><span class="line">            .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">            .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//输出: error(Error Domain=错误 Code=10 "(null)")</span></span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"><span class="meta">## 四. RxSwift中Subjects</span></span><br><span class="line">- Subjects是什么?</span><br><span class="line">  - Subjet是observable和Observer之间的桥梁，一个Subject既是一个Obserable也是一个Observer，他既可以发出事件，也可以监听事件</span><br><span class="line">  </span><br><span class="line"><span class="meta">## 1. PublishSubject</span></span><br><span class="line">- 当你订阅PublishSubject的时候，你只能接收到订阅他之后发生的事件。subject.onNext()发出onNext事件，对应的还有onError()和onCompleted()事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">let pSubject = PublishSubject&lt;String&gt;()</span><br><span class="line">pSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"2--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">print(<span class="string">"1--------------"</span>)</span><br><span class="line">        </span><br><span class="line">pSubject.onNext(<span class="string">"T"</span>)</span><br><span class="line">pSubject.onNext(<span class="string">"Q"</span>)</span><br><span class="line">        </span><br><span class="line">pSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">         print(<span class="string">"3--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">pSubject.onNext(<span class="string">"J"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         1--------------</span></span><br><span class="line"><span class="comment">         2-- next(T)</span></span><br><span class="line"><span class="comment">         2-- next(Q)</span></span><br><span class="line"><span class="comment">         2-- next(J)</span></span><br><span class="line"><span class="comment">         3-- next(J)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h3 id="2-ReplaySubject"><a href="#2-ReplaySubject" class="headerlink" title="2. ReplaySubject"></a>2. ReplaySubject</h3><ul><li>当你订阅ReplaySubject的时候，你可以接收到订阅他之后的事件，但也可以接受订阅他之前发出的事件，接受几个事件取决与bufferSize的大小</li><li><code>createUnbounded()</code>表示接受所有事件</li><li><code>create(bufferSize: 4)</code> 表示可接受到的订阅他之前的事件的个数,但是订阅他之后的事件一定会触发</li></ul><h4 id="2-1-createUnbounded-表示接受所有事件"><a href="#2-1-createUnbounded-表示接受所有事件" class="headerlink" title="2-1. createUnbounded()表示接受所有事件"></a>2-1. <code>createUnbounded()</code>表示接受所有事件</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let rSubject = ReplaySubject&lt;String&gt;.createUnbounded()</span><br><span class="line">rSubject.onNext(<span class="string">"T"</span>)</span><br><span class="line">rSubject.onNext(<span class="string">"Q"</span>)</span><br><span class="line">rSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">         print(<span class="string">"0--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">rSubject.onNext(<span class="string">"J"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">     0-- next(T)</span></span><br><span class="line"><span class="comment">     0-- next(Q)</span></span><br><span class="line"><span class="comment">     0-- next(J)</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h4 id="2-2-create-bufferSize-4-表示可接受到的订阅他之前的事件的个数"><a href="#2-2-create-bufferSize-4-表示可接受到的订阅他之前的事件的个数" class="headerlink" title="2-2. create(bufferSize: 4) 表示可接受到的订阅他之前的事件的个数"></a>2-2. <code>create(bufferSize: 4)</code> 表示可接受到的订阅他之前的事件的个数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let rSubject1 = ReplaySubject&lt;String&gt;.create(bufferSize: <span class="number">1</span>)</span><br><span class="line">rSubject1.onNext(<span class="string">"T"</span>)</span><br><span class="line">rSubject1.onNext(<span class="string">"Q"</span>)</span><br><span class="line">rSubject1.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">"4--"</span>, event)</span><br><span class="line">        &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">rSubject1.onNext(<span class="string">"J"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">     4-- next(Q)</span></span><br><span class="line"><span class="comment">     4-- next(J)</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="3-BehaviorSubject"><a href="#3-BehaviorSubject" class="headerlink" title="3. BehaviorSubject"></a>3. BehaviorSubject</h3><ul><li>当你订阅了BehaviorSubject，你会接受到订阅之前的最后一个事件,订阅之后的事件一定会触发</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let bSubject = BehaviorSubject(value: <span class="string">"G"</span>)</span><br><span class="line">bSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"5--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">bSubject.onNext(<span class="string">"Y"</span>)</span><br><span class="line">bSubject.onNext(<span class="string">"Q"</span>)</span><br><span class="line">        </span><br><span class="line">bSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"6--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">bSubject.onNext(<span class="string">"J"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         5-- next(G)</span></span><br><span class="line"><span class="comment">         5-- next(Y)</span></span><br><span class="line"><span class="comment">         5-- next(Q)</span></span><br><span class="line"><span class="comment">         6-- next(Q)</span></span><br><span class="line"><span class="comment">         5-- next(J)</span></span><br><span class="line"><span class="comment">         6-- next(J)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="4-Variable"><a href="#4-Variable" class="headerlink" title="4. Variable"></a>4. Variable</h3><ul><li>Variable是BehaviorSubject一个包装箱，就像是一个箱子一样，使用的时候需要调用asObservable()拆箱，里面的value是一个BehaviorSubject，他不会发出error事件，但是会自动发出completed事件。</li><li>1&gt; 相当于对BehaviorSubject进行装箱</li><li>2&gt; 如果想将Variable当成Obserable, 让订阅者进行订阅时, 需要调用asObserable拆箱转成Obserable</li><li>3&gt; 如果Variable打算发出事件, 直接修改对象的value即可</li><li>4&gt; 当事件结束时,Variable会自动发出completed事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let variable = Variable(<span class="string">"S"</span>)</span><br><span class="line">variable.asObservable().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"7--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">variable.value = <span class="string">"D"</span></span><br><span class="line">variable.value = <span class="string">"Q"</span></span><br><span class="line">        </span><br><span class="line">variable.asObservable().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"8--"</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">variable.value = <span class="string">"j"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         7-- next(S)</span></span><br><span class="line"><span class="comment">         7-- next(D)</span></span><br><span class="line"><span class="comment">         7-- next(Q)</span></span><br><span class="line"><span class="comment">         8-- next(Q)</span></span><br><span class="line"><span class="comment">         7-- next(j)</span></span><br><span class="line"><span class="comment">         8-- next(j)</span></span><br><span class="line"><span class="comment">         7-- completed</span></span><br><span class="line"><span class="comment">         8-- completed</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h2 id="五-RxSwift细节理解"><a href="#五-RxSwift细节理解" class="headerlink" title="五. RxSwift细节理解"></a>五. RxSwift细节理解</h2><h3 id="1-变换操作"><a href="#1-变换操作" class="headerlink" title="1. 变换操作"></a>1. 变换操作</h3><h4 id="1-1-map"><a href="#1-1-map" class="headerlink" title="1-1.  map"></a>1-1.  map</h4><ul><li>通过传入一个函数闭包把原来的sequence转变为一个新的sequence的操作</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .map(&#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;)</span><br><span class="line">        .subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line"><span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment">    9</span></span><br><span class="line"><span class="comment">    16</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="1-2-flatMap"><a href="#1-2-flatMap" class="headerlink" title="1-2. flatMap"></a>1-2. flatMap</h4><ul><li>将一个sequence转换为一个sequences，当你接收一个sequence的事件，你还想接收其他sequence发出的事件的话可以使用flatMap，她会将每一个sequence事件进行处理以后，然后再以一个sequence形式发出事件</li></ul><h5 id="首先创建一个struct"><a href="#首先创建一个struct" class="headerlink" title="首先创建一个struct"></a>首先创建一个struct</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    var score: Variable&lt;Double&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="flatMap执行代码"><a href="#flatMap执行代码" class="headerlink" title="flatMap执行代码"></a>flatMap执行代码</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let stu1 = Student(score: Variable(<span class="number">80</span>))</span><br><span class="line">let stu2 = Student(score: Variable(<span class="number">100</span>))</span><br><span class="line">        </span><br><span class="line">let student = Variable(stu1)</span><br><span class="line">student.asObservable().flatMap &#123; (stu: Student) -&gt; Observable&lt;Double&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> stu.score.asObservable()</span><br><span class="line">&#125;.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">student.value = stu2</span><br><span class="line">stu1.score.value = <span class="number">10</span></span><br><span class="line">stu2.score.value = <span class="number">20</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">         next(80.0)</span></span><br><span class="line"><span class="comment">         next(100.0)</span></span><br><span class="line"><span class="comment">         next(10.0)</span></span><br><span class="line"><span class="comment">         next(20.0)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h4 id="1-3-flatMapLatest"><a href="#1-3-flatMapLatest" class="headerlink" title="1-3. flatMapLatest"></a>1-3. flatMapLatest</h4><ul><li>flatMapLatest只会接收最新的value事件，将上例代码改为flatMapLatest</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let stu3 = Student(score: Variable(<span class="number">70</span>))</span><br><span class="line">let stu4 = Student(score: Variable(<span class="number">60</span>))</span><br><span class="line"></span><br><span class="line">let student1 = Variable(stu3)</span><br><span class="line">student1.asObservable().flatMapFirst &#123; (stu) -&gt; Observable&lt;Double&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> stu.score.asObservable()</span><br><span class="line">&#125;.subscribe &#123; (event: Event&lt;Double&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">student1.value = stu4</span><br><span class="line">stu3.score.value = <span class="number">10</span></span><br><span class="line">stu4.score.value = <span class="number">20</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">         next(70.0)</span></span><br><span class="line"><span class="comment">         next(10.0)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h3 id="2-释放资源"><a href="#2-释放资源" class="headerlink" title="2. 释放资源"></a>2. 释放资源</h3><ul><li>当监听一个事件序列的时候，有消息事件来了，我们做某些事情。但是这个事件序列不再发出消息了，我们的监听也就没有什么存在价值了，所以我们需要释放我们这些监听资源，其实也就是每种编程语言中的内存资源释放。</li><li>OC和Swift中也一样，在你不需要用某些变量的时候，你需要把这些变量所占用的内存空间释放掉。</li><li>释放某一个监听的时候我们可以手动调用释放方法</li></ul><h4 id="2-1-dispose"><a href="#2-1-dispose" class="headerlink" title="2-1. dispose"></a>2-1. dispose</h4><ul><li>相当于MRC中手动调用release操作</li><li>注意: 因为观察者已经销毁, 所有后面无法接受事件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let testVariable = Variable(<span class="string">"jun"</span>)</span><br><span class="line">testVariable.asObservable().subscribe &#123; (event : Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.dispose()</span><br><span class="line"></span><br><span class="line">testVariable.value = <span class="string">"tian"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h4 id="2-2-Dispose-Bags"><a href="#2-2-Dispose-Bags" class="headerlink" title="2-2. Dispose Bags"></a>2-2. Dispose Bags</h4><ul><li>除了上面手动的方法，还有一种是自动的方式</li><li>推荐大家使用这种方式，这种方式就好像iOS中的ARC方式似得，会自动去释放资源。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileprivate lazy var bag = DisposeBag()</span><br></pre></td></tr></table></figure></li></ul><blockquote><h4 id="在代码结尾调用-addDisposableTo-bag-方法"><a href="#在代码结尾调用-addDisposableTo-bag-方法" class="headerlink" title="在代码结尾调用.addDisposableTo(bag)方法"></a>在代码结尾调用<code>.addDisposableTo(bag)</code>方法</h4></blockquote><h3 id="3-UIBindingObserver"><a href="#3-UIBindingObserver" class="headerlink" title="3. UIBindingObserver"></a>3. UIBindingObserver</h3><ul><li>UIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa(RxSwiftz中对UIKit的一个扩展库)给的扩展不够我们使用</li><li>比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Reactive where Base: <span class="built_in">UITextField</span> &#123;</span><br><span class="line">    var inputEnabled: <span class="built_in">UIBindingObserver</span>&lt;Base, Result&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIBindingObserver</span>(<span class="built_in">UIElement</span>: base) &#123; textFiled, result <span class="keyword">in</span></span><br><span class="line">            textFiled.isEnabled = result.isValid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后续会继续更新相关方面知识,敬请期待</p></blockquote>]]></content>
      
      <categories>
          
          <category> RxSwift框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> RxSwift </tag>
            
            <tag> 响应式编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS之Scanner字符串扫描类</title>
      <link href="/2017/09/09/iOS%E4%B9%8BScanner%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%AB%E6%8F%8F%E7%B1%BB/"/>
      <content type="html"><![CDATA[<blockquote><p> 注:  本文主要语法为Swift4.0</p></blockquote><ul><li>Scanner继承自NSObject，遵守NSCopying协议。是一个用于扫描指定字符串的抽象类</li><li>可以创建Scanner时制定他的String属性，然后scanner会按照你的要求从头到尾扫描这个字符串的每个字符</li><li>扫描操作从上次扫描的位置开始，并且继续往后扫描直到指定的内容出现为止（如果有的话）</li></ul><a id="more"></a><h2 id="1-部分属性的相关解释"><a href="#1-部分属性的相关解释" class="headerlink" title="1. 部分属性的相关解释"></a>1. 部分属性的相关解释</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> open var string: String &#123; get &#125;</span><br><span class="line"> <span class="comment">// (只读)返回当前被扫描的字符串</span></span><br><span class="line"></span><br><span class="line">open var scanLocation: Int</span><br><span class="line"><span class="comment">// 当前扫描的位置，默认是从0开始的。通过设置这个属性值，可以自定义扫描的位置</span></span><br><span class="line"></span><br><span class="line">open var charactersToBeSkipped: CharacterSet?</span><br><span class="line"><span class="comment">// 这个集合是用来设置我们需要跳过扫描的一个字符集合</span></span><br><span class="line"></span><br><span class="line">open var caseSensitive: Bool</span><br><span class="line"><span class="comment">// 是否大小写敏感</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">public init(string: String)</span><br><span class="line"><span class="comment">// 用给定扫描字符串初始化</span></span><br></pre></td></tr></table></figure><h2 id="2-部分方法的相关解释"><a href="#2-部分方法的相关解释" class="headerlink" title="2. 部分方法的相关解释"></a>2. 部分方法的相关解释</h2><h3 id="2-1-以下方法的作用都是"><a href="#2-1-以下方法的作用都是" class="headerlink" title="2-1 以下方法的作用都是"></a>2-1 以下方法的作用都是</h3><ul><li>扫描该类型的字符串,并将扫描结果赋值给result</li><li>判断该字符串的第一个字符(默认第一个,可根据scanLocation属性设置)是否为该类型</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">open func scanInt32(_ result: UnsafeMutablePointer&lt;Int32&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanInt(_ result: UnsafeMutablePointer&lt;Int&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">open func scanInt64(_ result: UnsafeMutablePointer&lt;Int64&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">7.0</span>, *)</span><br><span class="line">open func scanUnsignedLongLong(_ result: UnsafeMutablePointer&lt;<span class="built_in">UInt64</span>&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">open func scanFloat(_ result: UnsafeMutablePointer&lt;Float&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">open func scanDouble(_ result: UnsafeMutablePointer&lt;Double&gt;?) -&gt; Bool</span><br></pre></td></tr></table></figure><h4 id="2-1-1-包含纯数字的字符串"><a href="#2-1-1-包含纯数字的字符串" class="headerlink" title="2-1-1 包含纯数字的字符串"></a>2-1-1 包含纯数字的字符串</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var int1: Int = <span class="number">0</span></span><br><span class="line">var int64: Int64 = <span class="number">0</span></span><br><span class="line">var int32: Int32 = <span class="number">0</span></span><br><span class="line">var float1: Float = <span class="number">0.0</span></span><br><span class="line">var double1: Double = <span class="number">0.0</span></span><br><span class="line"><span class="comment">//判断字符串包含的类型(输出结果为true)</span></span><br><span class="line">print(Scanner(string: <span class="string">"987"</span>).scanInt(&amp;int1))</span><br><span class="line">print(Scanner(string: <span class="string">"897"</span>).scanInt64(&amp;int64))</span><br><span class="line">print(Scanner(string: <span class="string">"99"</span>).scanInt32(&amp;int32))</span><br><span class="line">print(Scanner(string: <span class="string">"90.99"</span>).scanFloat(&amp;float1))</span><br><span class="line">print(Scanner(string: <span class="string">"98.09"</span>).scanDouble(&amp;double1))</span><br><span class="line"><span class="comment">//输出扫描后的结果</span></span><br><span class="line">int1 = <span class="number">98</span></span><br><span class="line">int64 = <span class="number">897</span></span><br><span class="line">int32 = <span class="number">99</span></span><br><span class="line"><span class="keyword">float</span> = <span class="number">90.99</span></span><br><span class="line"><span class="keyword">double</span> = <span class="number">98.09</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-非纯数字的字符串"><a href="#2-1-2-非纯数字的字符串" class="headerlink" title="2-1-2  非纯数字的字符串"></a>2-1-2  非纯数字的字符串</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var int1: Int = <span class="number">0</span></span><br><span class="line">let scanner = Scanner(string: <span class="string">"m998k23l"</span>)</span><br><span class="line">scanner.scanLocation = <span class="number">1</span></span><br><span class="line">print(scanner.scanInt(&amp;int1)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//int1 = 998</span></span><br><span class="line"></span><br><span class="line">var double1: Double = <span class="number">0.0</span></span><br><span class="line">let scanner = Scanner(string: <span class="string">"ms9.98k45l"</span>)</span><br><span class="line">scanner.scanLocation = <span class="number">1</span></span><br><span class="line">print(scanner.scanDouble(&amp;double1)) <span class="literal">false</span></span><br><span class="line"><span class="comment">//double1 = 0.0</span></span><br></pre></td></tr></table></figure><h3 id="2-2-以下方法的作用都是"><a href="#2-2-以下方法的作用都是" class="headerlink" title="2-2 以下方法的作用都是"></a>2-2 以下方法的作用都是</h3><ul><li>扫描字符串前缀是否是”0x”或者”0X”,返回true或false</li><li>将0x(0X)字符后面符合十六进制数的字符串转化成十进制数(可运用到UIColor关于十六进制数的转化)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">open func scanHexInt32(_ result: UnsafeMutablePointer&lt;<span class="built_in">UInt32</span>&gt;?) -&gt; Bool <span class="comment">// Optionally prefixed with "0x" or "0X"</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanHexInt64(_ result: UnsafeMutablePointer&lt;<span class="built_in">UInt64</span>&gt;?) -&gt; Bool <span class="comment">// Optionally prefixed with "0x" or "0X"</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanHexFloat(_ result: UnsafeMutablePointer&lt;Float&gt;?) -&gt; Bool <span class="comment">// Corresponding to %a or %A formatting. Requires "0x" or "0X" prefix.</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanHexDouble(_ result: UnsafeMutablePointer&lt;Double&gt;?) -&gt; Bool <span class="comment">// Corresponding to %a or %A formatting. Requires "0x" or "0X" prefix.</span></span><br></pre></td></tr></table></figure><h4 id="2-2-1-代码示例"><a href="#2-2-1-代码示例" class="headerlink" title="2-2-1 代码示例"></a>2-2-1 代码示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(Scanner(string: <span class="string">"xdd"</span>).scanHexInt64(&amp;uint64))  <span class="comment">//false</span></span><br><span class="line">print(Scanner(string: <span class="string">"0xdd"</span>).scanHexInt64(&amp;uint64))  <span class="comment">//true</span></span><br><span class="line">print(uint64) <span class="comment">//221</span></span><br><span class="line">print(Scanner(string: <span class="string">"0xax"</span>).scanHexInt32(&amp;uint32))  <span class="comment">//true</span></span><br><span class="line">print(uint32)  <span class="comment">// 10</span></span><br><span class="line">print(Scanner(string: <span class="string">"0X991"</span>).scanHexFloat(&amp;float1))  <span class="comment">//true</span></span><br><span class="line">print(float1)  <span class="comment">//2449.0</span></span><br><span class="line">print(Scanner(string: <span class="string">"0X99"</span>).scanHexDouble(&amp;double1))  <span class="comment">//true</span></span><br><span class="line">print(double1)  <span class="comment">//153.0</span></span><br></pre></td></tr></table></figure><h3 id="2-3-从给定的字符串中找到相同的字符"><a href="#2-3-从给定的字符串中找到相同的字符" class="headerlink" title="2-3 从给定的字符串中找到相同的字符"></a>2-3 从给定的字符串中找到相同的字符</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open func scanString(_ string: String, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br></pre></td></tr></table></figure><blockquote><p>代码示例</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var sstring: <span class="built_in">NSString</span>?</span><br><span class="line">let scan = Scanner(string: <span class="string">"32jingki"</span>)</span><br><span class="line"><span class="keyword">while</span> !scan.isAtEnd&#123; <span class="comment">// 判断是否扫描到最后</span></span><br><span class="line">    scan.scanLocation += <span class="number">1</span></span><br><span class="line">    print(scan.scanLocation)</span><br><span class="line">    scan.scanString(<span class="string">"i"</span>, into: &amp;sstring)</span><br><span class="line">    print(sstring)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Scanner的其他方法"><a href="#2-4-Scanner的其他方法" class="headerlink" title="2-4 Scanner的其他方法"></a>2-4 Scanner的其他方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">open func scanCharacters(from set: CharacterSet, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br><span class="line"><span class="comment">////从scan中扫描出string放入result中，如果不需要存储string，则result传NULL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">open func scanUpTo(_ string: String, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br><span class="line"><span class="comment">//从scan中扫描出string之外的数据放入result中，如果不需要存储string，则result传NULL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">open func scanUpToCharacters(from set: CharacterSet, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br><span class="line"><span class="comment">//从scan中扫描出set之外的数据放入result中，如果不需要存储string，则result传NULL</span></span><br></pre></td></tr></table></figure><h2 id="2-5-关于使用Scanner处理UIColor十六进制数值的问题"><a href="#2-5-关于使用Scanner处理UIColor十六进制数值的问题" class="headerlink" title="2-5  关于使用Scanner处理UIColor十六进制数值的问题"></a>2-5  关于使用Scanner处理UIColor十六进制数值的问题</h2><ul><li>可在UIColor的extension中添加扩展方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 十六进制颜色扩充</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">convenience init?(hex : String, alpha : <span class="built_in">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">//1.判断字符串长度是否符合</span></span><br><span class="line">    guard hex.characters.count &gt;= <span class="number">6</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.将字符串转成大写</span></span><br><span class="line">    var tempHex = hex.uppercased()</span><br><span class="line">    <span class="comment">//3.判断开头</span></span><br><span class="line">    <span class="keyword">if</span> tempHex.hasPrefix(<span class="string">"0x"</span>) || tempHex.hasPrefix(<span class="string">"##"</span>) || tempHex.hasPrefix(<span class="string">"0X"</span>) &#123;</span><br><span class="line">        <span class="comment">//去掉开头</span></span><br><span class="line">        tempHex = tempHex.dropFirst(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> tempHex.hasPrefix(<span class="string">"#"</span>) &#123;</span><br><span class="line">        tempHex = tempHex.dropFirst()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.分别截取RGB</span></span><br><span class="line">    var range = <span class="built_in">NSRange</span>(location: <span class="number">0</span>, length: <span class="number">2</span>)</span><br><span class="line">    let rHex = (tempHex as <span class="built_in">NSString</span>).substring(with: range)</span><br><span class="line">    range.location = <span class="number">2</span></span><br><span class="line">    let gHex = (tempHex as <span class="built_in">NSString</span>).substring(with: range)</span><br><span class="line">    range.location = <span class="number">4</span></span><br><span class="line">    let bHex = (tempHex as <span class="built_in">NSString</span>).substring(with: range)</span><br><span class="line">    <span class="comment">//5.将字符串转化成数字  emoji也是十六进制表示(此处也可用Float类型)</span></span><br><span class="line">    var r : <span class="built_in">UInt32</span> = <span class="number">0</span>, g : <span class="built_in">UInt32</span> = <span class="number">0</span>, b : <span class="built_in">UInt32</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">//创建扫描器,将字符串的扫描结果赋值给:r,g,b</span></span><br><span class="line">    Scanner(string: rHex).scanHexInt32(&amp;r)</span><br><span class="line">    Scanner(string: gHex).scanHexInt32(&amp;g)</span><br><span class="line">    Scanner(string: bHex).scanHexInt32(&amp;b)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.init(r : <span class="built_in">CGFloat</span>(r), g : <span class="built_in">CGFloat</span>(g), b : <span class="built_in">CGFloat</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**RGB三原色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">convenience init(r : <span class="built_in">CGFloat</span>, g : <span class="built_in">CGFloat</span>, b : <span class="built_in">CGFloat</span>, alpha : <span class="built_in">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.init(red: r / <span class="number">255.0</span>, green: g / <span class="number">255.0</span>, blue: b / <span class="number">255.0</span>, alpha: alpha)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Scanner </tag>
            
            <tag> iOS扫描器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>升级Swift4.0遇到的坑</title>
      <link href="/2017/08/25/%E5%8D%87%E7%BA%A7Swift4.0%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <content type="html"><![CDATA[<ul><li>并不是所有库都能做到及时支持<code>Swift4.0</code>，更何况是在现在连<code>Xcode9</code>也还是beta的状态</li><li>所以我们仅能做到将自己的业务代码（主工程代码）部分升级到<code>Swift4.0</code>，然后同时保留各种pod库在<code>Swift3.2</code>版本。</li><li>没办法，谁叫<code>Swift4.0</code>也还无法做到API兼容呢（但愿能在<code>Swift5</code>之前实现吧）。</li><li>至于我说的同时使用两个版本的<code>Swift</code>，这是没问题的，Xcode9支持在项目中同时使用<code>Swift3.2</code>和<code>Swift4.0</code>。</li></ul><a id="more"></a><h2 id="一-修改Swift版本"><a href="#一-修改Swift版本" class="headerlink" title="一. 修改Swift版本"></a>一. 修改Swift版本</h2><h3 id="1-如下图指定主工程的Swift版本为4-0"><a href="#1-如下图指定主工程的Swift版本为4-0" class="headerlink" title="1. 如下图指定主工程的Swift版本为4.0"></a>1. 如下图指定主工程的Swift版本为4.0</h3><p><img src="http://upload-images.jianshu.io/upload_images/4122543-1a9aeacc47b262a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Xcode图示.png"></p><h3 id="2-修改pod库"><a href="#2-修改pod库" class="headerlink" title="2. 修改pod库"></a>2. 修改pod库</h3><ul><li>在Podfile文件的最下方加入如下代码，指定pod库的Swift版本为3.2(这样会使得所有的第三方pod库的Swift版本都为3.2)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> |installer|</span><br><span class="line">  installer.pods_project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">    target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">      config.build_settings['SWIFT_VERSION'] = '3.2'</span><br><span class="line">    end </span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="二-主工程中的代码修改"><a href="#二-主工程中的代码修改" class="headerlink" title="二. 主工程中的代码修改"></a>二. 主工程中的代码修改</h2><h3 id="1-列举一下Swift3-2到Swift4-0的改变-只是我项目中遇到的-："><a href="#1-列举一下Swift3-2到Swift4-0的改变-只是我项目中遇到的-：" class="headerlink" title="1. 列举一下Swift3.2到Swift4.0的改变(只是我项目中遇到的)："></a>1. 列举一下Swift3.2到Swift4.0的改变(只是我项目中遇到的)：</h3><ul><li>1). <code>Swift4.0</code>中对于扩展的属性(包括实例属性、<code>static</code>属性、<code>class</code>属性)，都只能使用get方法，不可使用set方法</li><li>2). <code>Swift4.0</code>中不再允许复写扩展中的方法(包括实例方法、<code>static</code>方法、<code>class</code>方法)<ul><li>比如:自定义的协议方法在<code>extension</code>中实现,若某个类遵循了该协议,其子类便不能重写该协议方法</li><li>解决的方法是: 在每个需要该协议的类里面都重新遵循该协议,实现协议方法</li><li>个人想到的办法,不知道有没有其他解决办法可以提供一下</li></ul></li><li>3). <code>swift3</code>使用<code>#selector</code>指定的方法，只有当方法权限为private时需要加<code>@objc</code>修饰符，现在<code>Swift4.0</code>全都要加<code>@objc</code>修饰符</li><li><p>4). 自定义的<code>protocol</code>协议中,有<code>optional</code>修饰的非必须实现的方法,需要用<code>@objc</code>修饰</p></li><li><p>5). 字体方面的一些重命名</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSFontAttributeName</span> --- .font </span><br><span class="line"><span class="comment">//或者NSAttributedStringKey.font</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSForegroundColorAttributeName</span> --- .foregroundColor</span><br><span class="line"><span class="comment">//NSAttributedStringKey.foregroundColor</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSStrikethroughStyleAttributeName</span> --- .strikethroughStyle</span><br><span class="line"><span class="comment">//NSAttributedStringKey.strikethroughStyle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串类型的,添加rawValue</span></span><br><span class="line"><span class="built_in">NSAttributedStringKey</span>.font.rawValue</span><br><span class="line"></span><br><span class="line"><span class="comment">//等等等等..........</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大部分类似以下,涉及富文本的方法均已改为了NSAttributedStringKey类型</span></span><br><span class="line">addAttributes(_ attrs: [<span class="built_in">NSAttributedStringKey</span> : Any] = [:], range: <span class="built_in">NSRange</span>)</span><br></pre></td></tr></table></figure><h2 id="三-项目中遇到的一些的报错问题"><a href="#三-项目中遇到的一些的报错问题" class="headerlink" title="三. 项目中遇到的一些的报错问题"></a>三. 项目中遇到的一些的报错问题</h2><h3 id="3-1-“Closure-cannot-implicitly-capture-a-mutating-self-parameter”错误"><a href="#3-1-“Closure-cannot-implicitly-capture-a-mutating-self-parameter”错误" class="headerlink" title="3-1. “Closure cannot implicitly capture a mutating self parameter”错误"></a>3-1. “Closure cannot implicitly capture a mutating self parameter”错误</h3><blockquote><p>在struct中，如果我们在闭包中使用self，就会得到Closure cannot implicitly capture a mutating self parameter的错误提示。比如：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> RecordModel &#123;</span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line">    var action: (() -&gt; ())?</span><br><span class="line">    var height = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.action = &#123; </span><br><span class="line">        <span class="keyword">self</span>.height = <span class="number">20</span> </span><br><span class="line">        <span class="comment">//Closure cannot implicitly capture a mutating self parameter报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并且由<code>于RecordModel</code>的类型是<code>struct</code>，我们也没发在<code>action</code>闭包里添加截获列表。那么是不是就必须使用<code>class</code>了？答案是否定的。有两种方式可以解决这个问题。</p></blockquote><h4 id="方案一：为closure增加一个inout类型的参数"><a href="#方案一：为closure增加一个inout类型的参数" class="headerlink" title="方案一：为closure增加一个inout类型的参数"></a>方案一：为<code>closure</code>增加一个inout类型的参数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> RecordModel &#123;</span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line">    var action: ((_ inSelf: <span class="keyword">inout</span> RecordModel) -&gt; ())?</span><br><span class="line">    var height = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.action = &#123; (inSelf) <span class="keyword">in</span></span><br><span class="line">        inSelf.height = <span class="number">20</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure(闭包)中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。</p></blockquote><h4 id="方案二：使用UnsafeMutablePointer-lt-Pointee-gt"><a href="#方案二：使用UnsafeMutablePointer-lt-Pointee-gt" class="headerlink" title="方案二：使用UnsafeMutablePointer&lt;Pointee&gt;"></a>方案二：使用<code>UnsafeMutablePointer&lt;Pointee&gt;</code></h4><ul><li>这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> RecordModel &#123;</span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line">    var action: (() -&gt; ())?</span><br><span class="line">    var height = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    let selfPointer = UnsafeMutablePointer(&amp;<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.action = &#123; </span><br><span class="line">        selfPointer.pointee.height = <span class="number">20</span> </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><code>Closure cannot implicitly capture a mutating self parameter</code>错误的原因是在进出<code>closure(闭包)</code>之后，self的一致性没办法得到保证，所以编译器默认不允许在<code>struct的closure(闭包)</code>中使用self。如果我们确定这么做是安全的，就可以通过上面的两种方式解决这个问题。其中，方法二的性能更好一些。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><h4 id="这里可以记一下指针和swift变量之间的关系："><a href="#这里可以记一下指针和swift变量之间的关系：" class="headerlink" title="这里可以记一下指针和swift变量之间的关系："></a>这里可以记一下指针和swift变量之间的关系：</h4></blockquote><ul><li><code>UnsafePointer对应let</code></li><li><code>UnsafeMutablePointer对应var</code></li><li><code>AutoreleasingUnsafeMutablePointer对应unowned UnsafeMutablePointer</code>，用于inout的参数类型</li><li><code>UnsafeRawPointer对应let Any</code>，raw系列都是对应相应的Any类型</li><li><code>UnsafeBufferPointer是non-owning的类型（unowned</code>），用于collection的elements, buffer系列均如此</li></ul><h3 id="3-2-Declarations-from-extensions-cannot-be-overridden-yet-错误"><a href="#3-2-Declarations-from-extensions-cannot-be-overridden-yet-错误" class="headerlink" title="3-2. Declarations from extensions cannot be overridden yet 错误"></a>3-2. <code>Declarations from extensions cannot be overridden yet</code> 错误</h3><p>这个错误大致是因为,协议方法是在<code>extension</code>里面的,不能被重写</p><blockquote><p>解决办法:(仅供参考,如有更好的建议还望多多指教)</p><ul><li>小编想到的解决办法就是在每一个需要此协议的类里面,重新遵循代理,实现该协议方法</li></ul></blockquote><h3 id="3-3-quot-Method-39-initialize-39-defines-Objective-C-class-method-39-initialize-39-which-is-not-permitted-by-Swift-quot"><a href="#3-3-quot-Method-39-initialize-39-defines-Objective-C-class-method-39-initialize-39-which-is-not-permitted-by-Swift-quot" class="headerlink" title="3-3. &quot;Method &#39;initialize()&#39; defines Objective-C class method &#39;initialize&#39;, which is not permitted by Swift&quot;"></a>3-3. <code>&quot;Method &#39;initialize()&#39; defines Objective-C class method &#39;initialize&#39;, which is not permitted by Swift&quot;</code></h3><p>报错原因: 在于已经废弃的initialize方法,示例如下</p><ul><li>方法交叉(Method Swizzling)</li><li>有时为了方便，也有可能是解决某些框架内的 bug，或者别无他法时，需要修改一个已经存在类的方法的行为。方法交叉可以让你交换两个方法的实现，相当于是用你写的方法来重载原有方法，并且还能够是原有方法的行为保持不变。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">    public override <span class="keyword">class</span> func initialize() &#123;<span class="comment">//此处报错</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//此处省略100行代码</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>initialize该方法已经被Swift4.0废弃</li><li>在Swift3.0还勉强可以使用,但是会有警告;但是在4.0已经被完全废弃</li></ul><blockquote><p>替代方法:</p></blockquote><ul><li>在 app delegate 中实现方法交叉</li><li>像上面通过类扩展进行方法交叉，而是简单地在 app delegate 的 application(_:didFinishLaunchingWithOptions:) 方法调用时调用该方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">    public override <span class="keyword">class</span> func initializeOnceMethod() &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//此处省略100行代码</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AppDelegate的方法中调用:</span></span><br><span class="line">func application(_ application: <span class="built_in">UIApplication</span>, didFinishLaunchingWithOptions launchOptions: [<span class="built_in">UIApplicationLaunchOptionsKey</span> : Any]? = <span class="literal">nil</span>) -&gt; Bool &#123;</span><br><span class="line">    <span class="comment">//此处省略100行代码</span></span><br><span class="line">    <span class="built_in">UIViewController</span>.initializeOnceMethod()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-39-dispatch-once-39-is-unavailable-in-Swift-Use-lazily-initialized-globals-instead"><a href="#3-4-39-dispatch-once-39-is-unavailable-in-Swift-Use-lazily-initialized-globals-instead" class="headerlink" title="3-4. &#39;dispatch_once&#39; is unavailable in Swift: Use lazily initialized globals instead"></a>3-4. <code>&#39;dispatch_once&#39; is unavailable in Swift: Use lazily initialized globals instead</code></h3><blockquote><p>报错原因: <code>dispatch_once在Swift4.0</code>也已经被废弃</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UITableView</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> once&#123;</span><br><span class="line">        <span class="keyword">static</span> var onceTaken:Int = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once.onceTaken) &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//在这里dispatch_once就会报错</span></span><br><span class="line">        <span class="comment">//此处省略1000000行代码    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="解决方法-通过给DispatchQueue添加扩展实现"><a href="#解决方法-通过给DispatchQueue添加扩展实现" class="headerlink" title="解决方法: 通过给DispatchQueue添加扩展实现"></a>解决方法: 通过给DispatchQueue添加扩展实现</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extension DispatchQueue &#123;</span><br><span class="line">    private <span class="keyword">static</span> var _onceTracker = [String]()</span><br><span class="line">    public <span class="keyword">class</span> func once(token: String, block: () -&gt; ()) &#123;</span><br><span class="line">        objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line">        defer &#123;</span><br><span class="line">            objc_sync_exit(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _onceTracker.contains(token) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        _onceTracker.append(token)</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func async(block: @escaping ()-&gt;()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.async(execute: block)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func after(time: DispatchTime, block: @escaping ()-&gt;()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.asyncAfter(deadline: time, execute: block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用字符串token作为once的ID，执行once的时候加了一个锁，避免多线程下的token判断不准确的问题。<br>使用的时候可以传token</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.once(token: <span class="string">"tableViewOnce"</span>) &#123;</span><br><span class="line">    print( <span class="string">"Do This Once!"</span> )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>或者使用UUID也可以：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private let _onceToken = <span class="built_in">NSUUID</span>().uuidString</span><br><span class="line">  </span><br><span class="line">DispatchQueue.once(token: _onceToken) &#123;  </span><br><span class="line">    print( <span class="string">"Do This Once!"</span> )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>后续又遇到别的问题会继续更新</li><li>文章中如有解释不足之处,还望多多指教</li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> 入坑指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift4.0 </tag>
            
            <tag> Error </tag>
            
            <tag> 入坑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript基本语法01</title>
      <link href="/2017/08/09/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%9501/"/>
      <content type="html"><![CDATA[<blockquote><p>JavaScript 是一门高端的、动态的、弱类型的编程语言，适合面向对象和函数式的编程风格。</p></blockquote><blockquote><p>JavaScript 语法源自 Java，一等函数（first-class function）来自于Scheme，基于原型（prototype-based）的继承来自于Self。</p></blockquote><a id="more"></a><h1 id="一、类型、值和变量"><a href="#一、类型、值和变量" class="headerlink" title="一、类型、值和变量"></a>一、类型、值和变量</h1><h2 id="1、数字"><a href="#1、数字" class="headerlink" title="1、数字"></a>1、数字</h2><ul><li>JavaScript 中不区分整数值和浮点数值，所有数字均用浮点数值表示</li><li>JS采用IEEE754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是±1.7976031348623157×10308，最小值是±5×10-324</li><li>按照JS中的数字格式，能够表示的整数范围是-9007199254740992~9007199254740992（即 -253~253）</li><li>需要注意的是，JS中实际的操作（比如数组索引，位操作符）则是基于32位整数。</li></ul><h3 id="1-1、数字展示格式"><a href="#1-1、数字展示格式" class="headerlink" title="1.1、数字展示格式"></a>1.1、数字展示格式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">100000</span></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line"><span class="number">.333333</span></span><br><span class="line"><span class="number">9.02e10</span>    <span class="comment">//9.02 * 10的10次方</span></span><br><span class="line"><span class="number">1.4E-8</span>     <span class="comment">//1.4 * 10的-8次方</span></span><br></pre></td></tr></table></figure><h3 id="1-2、JavaScript中的算术运算符"><a href="#1-2、JavaScript中的算术运算符" class="headerlink" title="1.2、JavaScript中的算术运算符"></a>1.2、JavaScript中的算术运算符</h3><ul><li>JavaScript用Math对象实现复杂的运算</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>,<span class="number">3</span>)   <span class="comment">//8；2的3次幂</span></span><br><span class="line">Math.round(<span class="number">.6</span>)  <span class="comment">//1.0；四舍五入</span></span><br><span class="line">Math.ceil(<span class="number">.6</span>)   <span class="comment">//1.0；向上取整</span></span><br><span class="line">Math.floor(<span class="number">.6</span>)  <span class="comment">//0.0；向下取整</span></span><br><span class="line">Math.abs(<span class="number">-5</span>)    <span class="comment">//5；求绝对值</span></span><br><span class="line">Math.max(x,y,z) <span class="comment">//返回最大值</span></span><br><span class="line">Math.min(x,y,z) <span class="comment">//返回最小值</span></span><br><span class="line">Math.random()   <span class="comment">//生成一个大于等于0小于1.0的伪随机数</span></span><br><span class="line">Math.PI         <span class="comment">//π；圆周率</span></span><br><span class="line">Math.E          <span class="comment">//e；自然对数的底数</span></span><br><span class="line">Math.sqrt(<span class="number">3</span>)    <span class="comment">//3的平方根</span></span><br><span class="line">Math.pow(<span class="number">3</span>,<span class="number">1</span>/<span class="number">3</span>) <span class="comment">//3的立方根</span></span><br><span class="line">Math.sin(<span class="number">0</span>)     <span class="comment">//三角函数。Math.cos(),Math.tan(),Math.sin(30/180*Math.PI) </span></span><br><span class="line">Math.log(<span class="number">10</span>)    <span class="comment">//10的自然对数</span></span><br><span class="line">Math.log(<span class="number">100</span>)/Math.LN10 <span class="comment">//以10为底100的对数</span></span><br><span class="line">Math.log(<span class="number">512</span>)/Math.LN2 <span class="comment">//以2为底512的对数</span></span><br><span class="line">Math.exp(<span class="number">3</span>)     <span class="comment">//e的3次幂</span></span><br></pre></td></tr></table></figure><h3 id="1-3、日期和时间"><a href="#1-3、日期和时间" class="headerlink" title="1.3、日期和时间"></a>1.3、日期和时间</h3><ul><li>Date()构造函数，用于创建表示日期和时间的对象</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var then=new Date(<span class="number">2017</span>,<span class="number">0</span>,<span class="number">1</span>);          <span class="comment">//2017年1月1日</span></span><br><span class="line">var later=new Date(<span class="number">2017</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">30</span>);<span class="comment">//2017年1月1日 17:10:30</span></span><br><span class="line">var now=new Date();   <span class="comment">//当前日期和时间</span></span><br><span class="line">var elapsed=now-then; <span class="comment">//日期减法，计算时间间隔的毫秒数</span></span><br><span class="line">later.getFullYear();  <span class="comment">//获取年份</span></span><br><span class="line">later.getMonth();     <span class="comment">//获取月份，从0开始计数，一月份是0</span></span><br><span class="line">later.getDate();      <span class="comment">//获取日期，从1开始计数，一号是1</span></span><br><span class="line">later.getDay();       <span class="comment">//星期几，0是星期日，5是星期五</span></span><br><span class="line">later.getHours();     <span class="comment">//获取小时</span></span><br><span class="line">later.getMinutes();   <span class="comment">//获取分钟</span></span><br><span class="line">later.getSeconds();   <span class="comment">//获取秒</span></span><br><span class="line">later.getUTCHours();  <span class="comment">//获取使用UTC表示的小时的时间</span></span><br></pre></td></tr></table></figure><h1 id="二、文本字符串"><a href="#二、文本字符串" class="headerlink" title="二、文本字符串"></a>二、文本字符串</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line">var jsString = <span class="string">"Hello,JavaScript"</span>;</span><br><span class="line"><span class="comment">//字符串长度</span></span><br><span class="line">var s0 = jsString.length;  <span class="comment">//16,</span></span><br><span class="line"><span class="comment">// 第一个字符</span></span><br><span class="line">var s1 = jsString.charAt(<span class="number">0</span>) ; <span class="comment">//"H",</span></span><br><span class="line"><span class="comment">// 最后一个字符</span></span><br><span class="line">var s2 = jsString.charAt(s0 - <span class="number">1</span>)  <span class="comment">//"t",</span></span><br><span class="line"><span class="comment">//第2~4个字符</span></span><br><span class="line">var s3 = jsString.substring(<span class="number">1</span>, <span class="number">4</span>) <span class="comment">//"ell",</span></span><br><span class="line"><span class="comment">//第2~4个字符</span></span><br><span class="line">var s4 = jsString.slice(<span class="number">1</span>, <span class="number">4</span>)  <span class="comment">//"ell"</span></span><br><span class="line"><span class="comment">// 最后三个字符</span></span><br><span class="line">var s5 = jsString.slice(<span class="number">-3</span>)  <span class="comment">//"ipt"</span></span><br><span class="line"><span class="comment">// 字符"a"首次出现的位置</span></span><br><span class="line">var s6 = jsString.indexOf(<span class="string">"a"</span>)  <span class="comment">//7</span></span><br><span class="line"><span class="comment">// 字符"a"最后一次出现的位置</span></span><br><span class="line">var s7 = jsString.lastIndexOf(<span class="string">"a"</span>)  <span class="comment">//9</span></span><br><span class="line"><span class="comment">// 字符"a"第二次出现的位置</span></span><br><span class="line">var s8 = jsString.indexOf(<span class="string">"a"</span>, <span class="number">2</span>)  <span class="comment">//7</span></span><br><span class="line"><span class="comment">// 字符串分割成数组</span></span><br><span class="line">var s9 = jsString.split(<span class="string">","</span>)    <span class="comment">//["Hello", "JavaScript"]</span></span><br><span class="line"><span class="comment">// 全文字符替换</span></span><br><span class="line">var s10 = jsString.replace(<span class="string">"e"</span>, <span class="string">"E"</span>)  <span class="comment">//"HEllo,JavaScript"</span></span><br><span class="line"><span class="comment">// 全文转换为大写</span></span><br><span class="line">var s11 = jsString.toUpperCase()  <span class="comment">//"HELLO,JAVASCRIPT"</span></span><br><span class="line"><span class="comment">// 全文转换成小写</span></span><br><span class="line">var s12 = jsString.toLowerCase()  <span class="comment">//"hello,javascript"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试输出结果</span></span><br><span class="line">var sArr = [s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]</span><br><span class="line"><span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; sArr.length; i++) &#123;</span><br><span class="line">    console.log(sArr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、JavaScript之数组"><a href="#三、JavaScript之数组" class="headerlink" title="三、JavaScript之数组"></a>三、JavaScript之数组</h1><ul><li>数组是值的有序集合</li><li>JavaScript数组事务类型的:数组元素可以使任何类型, 同一数组中的不同元素也可以是不同类型</li><li>数组的元素也可以是对象或者其他数组</li><li>JavaScript数组可能是稀疏的: 数组元素的索引不一定是连续的,之间可能有空缺</li><li>稀疏数组的length比任何元素的索引都要大</li></ul><h2 id="1-创建数组-直接量创建"><a href="#1-创建数组-直接量创建" class="headerlink" title="1.创建数组(直接量创建)"></a>1.创建数组(直接量创建)</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.1: 简单数组</span></span><br><span class="line">var empty = [];   <span class="comment">//空数组</span></span><br><span class="line">var pram = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]  <span class="comment">//有三个数值的数组</span></span><br><span class="line">var misc = [<span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">"a"</span>] <span class="comment">//三个不同元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2: 数组中的直接量不一定是常量,也可能是表达式</span></span><br><span class="line">var base = <span class="number">1024</span></span><br><span class="line">var baseArr = [base, base + <span class="number">1</span>, base + <span class="number">2</span>, base + <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.3: 包含对象或数组</span></span><br><span class="line">var array3 = [[<span class="number">1</span>, &#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;], [<span class="number">2</span>, &#123;x: <span class="number">3</span>, y: <span class="number">4</span>&#125;]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.4: 忽略中间量中的某个值,省略的元素将被赋予undefined</span></span><br><span class="line">var undef1 = [<span class="number">1</span>, ,<span class="number">3</span>] <span class="comment">//三个元素,中间的为undefined</span></span><br><span class="line">var undef2 = [, ,] <span class="comment">//2个元素都是undefined</span></span><br><span class="line"><span class="comment">//注: 数组直接量的语法允许游客选的结尾的逗号,故[, ,]只有2个元素</span></span><br></pre></td></tr></table></figure><h2 id="2-Array-创建数组"><a href="#2-Array-创建数组" class="headerlink" title="2. Array()创建数组"></a>2. Array()创建数组</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空数组</span></span><br><span class="line">var a = new Array()</span><br><span class="line"><span class="comment">//指定数组长度</span></span><br><span class="line">var a1 = new  Array(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//显示创建</span></span><br><span class="line">var a2 = new  Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"a"</span>)</span><br></pre></td></tr></table></figure><h2 id="3-数组操作"><a href="#3-数组操作" class="headerlink" title="3. 数组操作"></a>3. 数组操作</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 读写数组元素</span></span><br><span class="line"><span class="comment">//注: 1.数组是对象的特殊形式,故JavaScript的数组不存在越界报错的情况,只会取到undefined</span></span><br><span class="line">var value = a2[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 数组的长度</span></span><br><span class="line"><span class="comment">//length属性为可读可写</span></span><br><span class="line">var arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">var arrLength = arr.length  <span class="comment">//6</span></span><br><span class="line">arr.length = <span class="number">4</span>   <span class="comment">//数组变为[1, 2, 3, 4]</span></span><br><span class="line">arr.length = <span class="number">0</span>  <span class="comment">// 删除所有元素,为[]</span></span><br><span class="line">arr.length = <span class="number">5</span>  <span class="comment">// 长度为5,但是没有元素,相当于new Array(5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 数组元素的添加和删除</span></span><br><span class="line"><span class="comment">//5.1: 索引值添加</span></span><br><span class="line">var a0 = []</span><br><span class="line">a0[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">a0[<span class="number">1</span>] = <span class="string">"one"</span></span><br><span class="line"><span class="comment">//a0为[3, "one"]</span></span><br></pre></td></tr></table></figure><h2 id="6-数组的方法"><a href="#6-数组的方法" class="headerlink" title="6. 数组的方法"></a>6. 数组的方法</h2><ul><li>主要介绍ECMAScript中的方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.1: join()</span></span><br><span class="line"><span class="comment">/*注:</span></span><br><span class="line"><span class="comment">0.不改变原数组</span></span><br><span class="line"><span class="comment">1.将数组所有的元素都转化成字符串,并连接在一起,返回生成后的字符串(如不指定分隔符默认使用逗号)</span></span><br><span class="line"><span class="comment">2.join是String.split()的逆向操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">var arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">var join1 = arr0.join() <span class="comment">// "1,2,3,4"</span></span><br><span class="line">var join2 = arr0.join(<span class="string">""</span>) <span class="comment">//"1234"</span></span><br><span class="line">var join3 = arr0.join(<span class="string">"-"</span>)  <span class="comment">//"1-2-3-4"</span></span><br><span class="line">console.log(join1,join2,join3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.2: reverse()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0.改变原数组</span></span><br><span class="line"><span class="comment">1.将数组中的元素颠倒顺序*/</span></span><br><span class="line">arr0.reverse()  <span class="comment">//现在arr0为[4, 3, 2, 1]</span></span><br><span class="line">console.log(arr0)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.3: sort()排序</span></span><br><span class="line"><span class="comment">/*注:</span></span><br><span class="line"><span class="comment">0.改变原数组</span></span><br><span class="line"><span class="comment">1.不带参数时,以字母表顺序排序</span></span><br><span class="line"><span class="comment">2.如果数组包含undefined,则会被排到数组的末尾</span></span><br><span class="line"><span class="comment">3.字母排序区分大小写,A &lt; a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">var arr1 = new Array(<span class="string">"tian"</span>, <span class="string">"quan"</span>, <span class="string">"jun"</span>)</span><br><span class="line">arr1.sort() <span class="comment">//arr1 = ["jun", "quan", "tian"]</span></span><br><span class="line">console.log(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件比较</span></span><br><span class="line">var  arr2 = new Array(<span class="string">"ant"</span>, <span class="string">"Bug"</span>, <span class="string">"cat"</span>, <span class="string">"Dog"</span>)</span><br><span class="line">arr2.sort()  <span class="comment">//["Bug", "Dog", "ant", "cat"]</span></span><br><span class="line">console.log(arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不区分大小写排序</span></span><br><span class="line">arr2.sort(function (s, t) &#123;</span><br><span class="line">    var a = s.toLowerCase()</span><br><span class="line">    var b = t.toLowerCase()</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2)</span><br><span class="line"><span class="comment">//["ant", "Bug", "cat", "Dog"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.4: concat()创建并返回一个新数组</span></span><br><span class="line"><span class="comment">//0.不改变原数组</span></span><br><span class="line">var arr4 = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">var concat1 = arr4.concat() <span class="comment">//[0, 2, 3]</span></span><br><span class="line">var concat2 = arr4.concat(<span class="number">1</span>, <span class="number">4</span>)  <span class="comment">//[0, 2, 3, 1, 4]</span></span><br><span class="line">var concat3 = arr4.concat([<span class="number">1</span>, <span class="number">4</span>]) <span class="comment">//[0, 2, 3, 1, 4]</span></span><br><span class="line">var concat4 = arr4.concat([<span class="number">1</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]) <span class="comment">//[0, 2, 3, 1, 4, 5, 6]</span></span><br><span class="line">var concat5 = arr4.concat(<span class="number">1</span>, [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]) <span class="comment">//[0, 2, 3, 1, 4, [5, 6]]</span></span><br><span class="line">var concatArr = [concat1, concat2, concat3, concat4, concat5]</span><br><span class="line">console.log(concatArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.5: slice()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意:</span></span><br><span class="line"><span class="comment">* 1.返回数组的部分数组</span></span><br><span class="line"><span class="comment">* 2.不改变原数组</span></span><br><span class="line"><span class="comment">* 3.两个参数,分别表示始末位置,含左不含右</span></span><br><span class="line"><span class="comment">* 4. 1表示第一个元素,-1表示倒数第一个元素</span></span><br><span class="line"><span class="comment">* 5.只有一个参数,默认以此参数开始,到最后一个元素结束</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var slice1 = arr3.slice(<span class="number">0</span>,<span class="number">2</span>) <span class="comment">//[1, 2]</span></span><br><span class="line">var slice2 = arr3.slice(<span class="number">3</span>) <span class="comment">//[4, 5]</span></span><br><span class="line">var slice3 = arr3.slice(<span class="number">1</span>,<span class="number">-2</span>) <span class="comment">//[2, 3]</span></span><br><span class="line">var slice4 = arr3.slice(<span class="number">-3</span>,<span class="number">-2</span>)  <span class="comment">//[3]</span></span><br><span class="line">var sliceArr = [slice1, slice2, slice3, slice4]</span><br><span class="line">console.log(sliceArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.6: splice()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.在数组中插入或删除元素的通用方法</span></span><br><span class="line"><span class="comment">* 2.会修改原数组,会改变数组的索引值</span></span><br><span class="line"><span class="comment">* 3.两个参数,参数一:起始位置;参数二:处理元素的个数(可省略)</span></span><br><span class="line"><span class="comment">* 4.若省略第二个参数,默认从起始位置到最后</span></span><br><span class="line"><span class="comment">* 5.如果没有元素就返回空数组</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var m = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">var splice1 = m.splice(<span class="number">4</span>)  <span class="comment">//返回[5, 6, 7], m 是[1, 2, 3, 4]</span></span><br><span class="line">console.log(m)</span><br><span class="line">var splice2 = m.splice(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">//返回[2, 3], m 是[1, 4]</span></span><br><span class="line">console.log(m)</span><br><span class="line">var splice3 = m.splice(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">//返回[4], m 是[1]</span></span><br><span class="line">console.log(m)</span><br><span class="line">var spliceArr = [splice1, splice2, splice3]</span><br><span class="line">console.log(spliceArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.7: push()和pop()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方法将数组当成栈使用</span></span><br><span class="line"><span class="comment">* 1.push方法在尾部添加一个或者多个元素,返回新的数组长度</span></span><br><span class="line"><span class="comment">* 2.pop删除数组的最后一个元素,减小数组的长度,返回删除的值</span></span><br><span class="line"><span class="comment">* 3.改变原数组的值和长度</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var m0 = []</span><br><span class="line">var pp1 = m0.push(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">//[1, 2], 返回2</span></span><br><span class="line">var pp2 = m0.pop()       <span class="comment">//[1], 返回2</span></span><br><span class="line">var pp3 = m0.push(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment">//[1, 3, 4], 返回3</span></span><br><span class="line">var pp4 = m0.pop()       <span class="comment">//[1, 3],  返回4</span></span><br><span class="line">var pp5 = m0.push([<span class="number">9</span>,<span class="number">0</span>]) <span class="comment">//[1, 3, [9, 0]], 返回3</span></span><br><span class="line">var pp6 = m0.pop()       <span class="comment">//[1, 3], 返回[9, 0]</span></span><br><span class="line">var pp7 = m0.pop()       <span class="comment">//[1], 返回3</span></span><br><span class="line">var ppArr = [pp1, pp2, pp3, pp4, pp5, pp6, pp7]</span><br><span class="line">console.log(ppArr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.8: unshift()和shift()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.unshift在头部添加一个或者多个元素,返回长度</span></span><br><span class="line"><span class="comment">* 2.shift删除数组的第一个元素,返回删除的元素</span></span><br><span class="line"><span class="comment">* 3.改变原数组,改变原数组的索引</span></span><br><span class="line"><span class="comment">* 4.unshift插入多个元素时,试一次性插入的</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var sh = []</span><br><span class="line">var sh1 = sh.unshift(<span class="number">1</span>)  <span class="comment">//sh: [1], 返回: 1</span></span><br><span class="line">var sh2 = sh.unshift(<span class="number">22</span>) <span class="comment">//sh: [1, 22], 返回: 2</span></span><br><span class="line">var sh3 = sh.shift()     <span class="comment">//sh: [22], 返回: 22</span></span><br><span class="line">var sh4 = sh.unshift(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]) <span class="comment">//sh: [3, [4, 5], 1], 返回:  3</span></span><br><span class="line">var sh5 = sh.shift()      <span class="comment">//sh: [[4, 5], 1], 返回: 3</span></span><br><span class="line">var sh6 = sh.shift()      <span class="comment">//sh: [1], 返回: [4, 5]</span></span><br><span class="line">var shiftArr = [sh1, sh2, sh3, sh4, sh5, sh6]</span><br><span class="line">console.log(shiftArr)</span><br><span class="line"><span class="comment">//注: unshift插入多个元素时,试一次性插入的,例如:</span></span><br><span class="line">sh.unshift(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 结果: [3, 4]</span></span><br><span class="line">sh.unshift(<span class="number">3</span>)</span><br><span class="line">sh.unshift(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//结果: [4, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.9: toString()和toLocalString()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.toString()将数组元素转化成字符串后,用都好链接输出</span></span><br><span class="line"><span class="comment">* 2.toString()和join()不加参数的返回的值是一样的</span></span><br><span class="line"><span class="comment">* 3.toLocalString()是toString()的本地化版本</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var str0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString() <span class="comment">//返回: "1,2,3"</span></span><br><span class="line">var str1 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].toString()  <span class="comment">//返回: "a,b,c"</span></span><br><span class="line">var str2 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="string">"c"</span>]].toString()  <span class="comment">//返回: "1,2,c"</span></span><br><span class="line">var str3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toLocaleString()  <span class="comment">//返回: "1,2,3"</span></span><br><span class="line">var strArr = [str0, str1, str2, str3, str4]</span><br><span class="line">console.log(strArr)</span><br></pre></td></tr></table></figure><h3 id="7-ECMAScript5中数组的方法"><a href="#7-ECMAScript5中数组的方法" class="headerlink" title="7. ECMAScript5中数组的方法"></a>7. ECMAScript5中数组的方法</h3><ul><li>1.ECMAScript5定义了九个新的数组方法</li><li>2.大多数ECMAScript5数组方法的第一个参数是一个函数</li><li>2.第二个参数是可选的,如果有,则调用的函数被看作是第二个参数的方法</li><li>3.也就是说在调用函数时,传递进去的第二个参数作为它的this关键字的值来使用</li><li>4.ECMAScript5中的数组方法不会修改他们调用的原始数组</li><li>5.传递给这些方法的函数是可以改变这些数组的</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.1: forEach()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.方法从头到尾遍历数组,为每个元素调用指定的函数</span></span><br><span class="line"><span class="comment">* 2.forEach使用三个参数调用该函数:数组元素,元素索引, 数组本身</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var data1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">var sum = <span class="number">0</span></span><br><span class="line">data1.forEach(function (value) &#123;</span><br><span class="line">    sum += value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每个元素本身自加1</span></span><br><span class="line">data1.forEach(function (value, i, arr) &#123;</span><br><span class="line">    arr[i] = value + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.2: map()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.返回一个新数组,不改变原数组</span></span><br><span class="line"><span class="comment">* 2.原数组若是稀疏数组,返回也是稀疏数组</span></span><br><span class="line"><span class="comment">* 3.具有相同的长度,相同的缺失元素</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var arr2 = data1.map(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [4, 9, 16, 25, 36]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.3: filter()逻辑判定,过滤数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.返回原数组的一个子集</span></span><br><span class="line"><span class="comment">* 2.返回原数组符合条件的元素,组成新数组</span></span><br><span class="line"><span class="comment">* 3.会将稀疏数组压缩,返回的是稠密数组</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var arr3 = data1.filter(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">var data2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var arr4 = data2.filter(function (i) &#123;</span><br><span class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[2, 4]</span></span><br><span class="line"></span><br><span class="line">var data3 = [<span class="number">1</span>, <span class="number">2</span>, , , null, <span class="number">5</span>]</span><br><span class="line">var arr5 = data3.filter(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== undefined &amp;&amp; x != null</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr5)</span><br><span class="line"><span class="comment">//[1, 2, 5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.4: every()和some()数组的逻辑判定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.对数组元素应用指定的函数进行判定</span></span><br><span class="line"><span class="comment">* 2.返回trur或者false</span></span><br><span class="line"><span class="comment">* 2.every()都为true返回true,否则返回false</span></span><br><span class="line"><span class="comment">* 3.some()都为false,返回false;有一个为true,返回true</span></span><br><span class="line"><span class="comment">* 4.一旦该方法确定了返回值,就会停止遍历数组</span></span><br><span class="line"><span class="comment">* 5.空数组,every()返回true,some()返回false</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var data4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var sum1 = data4.every(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//sum1 = true</span></span><br><span class="line">var sum2 = data4.every(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//sum2 = false</span></span><br><span class="line"></span><br><span class="line">var sum3 = data4.some(function (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//sum3 = true</span></span><br><span class="line">var sum4 = data4.some(isNaN)</span><br><span class="line"><span class="comment">//sum4 = false, data4不包含非整数值元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.5: reduce()和reduceRigh()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 作用: 将数组元素进行组合生成单个值</span></span><br><span class="line"><span class="comment">* 1.reduce()需要两个参数;参数一:执行操作的函数;参数二:传递给函数的初始值</span></span><br><span class="line"><span class="comment">* 2.reduceRight()是倒叙操作,功能与reduce相同</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var data5 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var sn0 = data5.reduce(function (x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"></span><br><span class="line">var sn1 = data5.reduce(function (x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line">&#125;, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//120</span></span><br><span class="line"></span><br><span class="line">var sn2 = data5.reduce(function (x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.6: indexOf()和lastIndexOf()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.搜索整个数组中具有给定值的元素,返回找到的第一个元素的索引,如果没有找到就返回-1</span></span><br><span class="line"><span class="comment">* 2.indexOf(),从前向后搜索,lastIndexOf()从后向前搜索</span></span><br><span class="line"><span class="comment">* 3.参数一:元素值; 参数二: 搜索的起始位置(可省略,默认从头开始)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">var data6 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">var index1 = data6.indexOf(<span class="number">1</span>) <span class="comment">//1, data6[1] = 1</span></span><br><span class="line">var index2 = data6.indexOf(<span class="number">3</span>) <span class="comment">//-1, 没有值为3的元素</span></span><br><span class="line">var index3 = data6.lastIndexOf(<span class="number">1</span>) <span class="comment">//3, data6[3] = 1</span></span><br><span class="line">var index4 = data6.indexOf(<span class="number">2</span>, <span class="number">1</span>)<span class="comment">//2, data6[2] = 2</span></span><br><span class="line">var index5 = data6.lastIndexOf(<span class="number">2</span>, <span class="number">-1</span>)<span class="comment">//2, data6[2] = 2</span></span><br></pre></td></tr></table></figure><h2 id="8-判定一个位置对象是否为数组"><a href="#8-判定一个位置对象是否为数组" class="headerlink" title="8. 判定一个位置对象是否为数组"></a>8. 判定一个位置对象是否为数组</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var data = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// var isA = data.isArray()</span></span><br><span class="line">console.log(data.isArray())</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift4.0新特性之String、Array和Dictionary</title>
      <link href="/2017/07/19/Swift4.0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BString%E3%80%81Array%E5%92%8CDictionary/"/>
      <content type="html"><![CDATA[<blockquote><ul><li>推荐: <a href="https://www.cnswift.org" target="_blank" rel="noopener">Swift 编程语言</a></li><li>原文链接: <a href="https://www.raywenderlich.com/163857/whats-new-swift-4" target="_blank" rel="noopener">What’s New in Swift 4?</a></li><li>Guards翻译组: <a href="http://www.jianshu.com/p/3bedf1de5cb3" target="_blank" rel="noopener">中文地址</a></li><li>Swift 4是苹果计划在2017年秋季推出的最新版本，值得关注的是其提供了与Swift 3代码很好的兼容性，并最大限度的保持了ABI稳定性.</li></ul></blockquote><a id="more"></a><hr><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><blockquote><p>字符串已经像之前的2.0版一样, 改为了Collection类型 。此变化消除了字符串对字符数组的依赖</p></blockquote><h3 id="0-创建空字符串的两种方式-可用isEmpty判断是否为空"><a href="#0-创建空字符串的两种方式-可用isEmpty判断是否为空" class="headerlink" title="0.创建空字符串的两种方式,可用isEmpty判断是否为空"></a>0.创建空字符串的两种方式,可用isEmpty判断是否为空</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let SwiftString = <span class="string">"Hello"</span></span><br><span class="line">var emptyString = <span class="string">""</span>               <span class="comment">// empty string literal</span></span><br><span class="line">var anotherEmptyString = String()</span><br></pre></td></tr></table></figure><h3 id="1-字符和字符串"><a href="#1-字符和字符串" class="headerlink" title="1.字符和字符串"></a>1.字符和字符串</h3><h4 id="1-1-遍历字符串"><a href="#1-1-遍历字符串" class="headerlink" title="1.1 遍历字符串"></a>1.1 遍历字符串</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> <span class="keyword">in</span> SwiftString &#123;</span><br><span class="line">    print(<span class="keyword">char</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2通过-Character类型创建单个字符"><a href="#1-2通过-Character类型创建单个字符" class="headerlink" title="1.2通过 Character类型创建单个字符"></a>1.2通过 Character类型创建单个字符</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">char</span> : Character = <span class="string">"H"</span></span><br></pre></td></tr></table></figure><h4 id="1-3-String值可以通过传入-Character来构造："><a href="#1-3-String值可以通过传入-Character来构造：" class="headerlink" title="1.3 String值可以通过传入 Character来构造："></a>1.3 String值可以通过传入 Character来构造：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let charArr : [Character] = [<span class="string">"H"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span>]</span><br><span class="line">print(String(<span class="keyword">char</span>)) <span class="comment">// H</span></span><br><span class="line">print(String(charArr)) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><h4 id="1-4-拼接字符串"><a href="#1-4-拼接字符串" class="headerlink" title="1.4 拼接字符串"></a>1.4 拼接字符串</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:</span></span><br><span class="line">let addString = String(charArr) + String(<span class="keyword">char</span>) <span class="comment">//HelloH</span></span><br><span class="line"><span class="comment">//方式二:</span></span><br><span class="line">var addString2 = <span class="string">"Why"</span></span><br><span class="line">addString2 += String(charArr) <span class="comment">//"WhyHello"</span></span><br></pre></td></tr></table></figure><h3 id="2-字符串个数"><a href="#2-字符串个数" class="headerlink" title="2.字符串个数"></a>2.字符串个数</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let count1 = SwiftString.count <span class="comment">//5(类型: String.CharacterView.IndexDistance)</span></span><br><span class="line">let count2 = SwiftString.characters.count <span class="comment">// 5(Int型)</span></span><br><span class="line">count1:</span><br></pre></td></tr></table></figure><h3 id="3-是否为空"><a href="#3-是否为空" class="headerlink" title="3.是否为空"></a>3.是否为空</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let isStr = SwiftString.isEmpty <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="4-去掉某一个或几个字符"><a href="#4-去掉某一个或几个字符" class="headerlink" title="4.去掉某一个或几个字符"></a>4.去掉某一个或几个字符</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let text1 = SwiftString.dropFirst()<span class="comment">//"ello"</span></span><br><span class="line">let text2 = SwiftString.dropLast()<span class="comment">//"Hell"</span></span><br><span class="line">let text3 = SwiftString.dropFirst(<span class="number">2</span>)<span class="comment">//"llo"</span></span><br><span class="line">let text4 = SwiftString.dropLast(<span class="number">2</span>)<span class="comment">//"Hel"</span></span><br><span class="line"><span class="comment">//注:以上皆为String.SubSequence类型</span></span><br><span class="line">let text5 = String(text1) <span class="comment">//"ello"---text5为String类型</span></span><br></pre></td></tr></table></figure><h3 id="5-倒叙"><a href="#5-倒叙" class="headerlink" title="5.倒叙"></a>5.倒叙</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let text6 = String(SwiftString.reversed()) <span class="comment">//"olleH"</span></span><br></pre></td></tr></table></figure><h3 id="6-字符串分割数组"><a href="#6-字符串分割数组" class="headerlink" title="6.字符串分割数组"></a>6.字符串分割数组</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let swiftString2 = <span class="string">"one two three"</span></span><br><span class="line">let StrArr = swiftString2.split(separator: <span class="string">" "</span>) <span class="comment">//["one", "two", "three"]</span></span><br><span class="line"><span class="comment">//let StrArr: [String.SubSequence]</span></span><br></pre></td></tr></table></figure><h3 id="7-删除不符合ASCII编码的字符"><a href="#7-删除不符合ASCII编码的字符" class="headerlink" title="7.删除不符合ASCII编码的字符"></a>7.删除不符合ASCII编码的字符</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let swiftString3 = <span class="string">"quanjun 🐷,"</span></span><br><span class="line">let qj = swiftString3.filter &#123; (<span class="keyword">char</span>) -&gt; Bool <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">char</span>.unicodeScalars.reduce(<span class="literal">true</span>, &#123; $<span class="number">0</span> &amp;&amp; $<span class="number">1.</span>isASCII &#125;)</span><br><span class="line">&#125;</span><br><span class="line">print(qj)  <span class="comment">//"quanjun ,"</span></span><br></pre></td></tr></table></figure><h3 id="8-字符串索引"><a href="#8-字符串索引" class="headerlink" title="8. 字符串索引"></a>8. 字符串索引</h3><ul><li>Swift 的字符串不能通过整数值索引</li><li>使用 index(before:) 和 index(after:) 方法来访问给定索引的前后。要访问给定索引更远的索引，你可以使用 index(_:offsetBy:) 方法而不是多次调用这两个方法。</li><li>Swift 4添加了Substring类型，用于引用String的子序列。</li><li>String和Substring都实现了StringProtocol，两者几乎具有相同的功能：</li></ul><h4 id="8-1-startIndex和endIndex"><a href="#8-1-startIndex和endIndex" class="headerlink" title="8.1 startIndex和endIndex"></a>8.1 startIndex和endIndex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let greeting = &quot;Guten Tag!&quot;</span><br><span class="line">//startIndex属性来访问 String中第一个 Character的位置</span><br><span class="line">print(greeting[greeting.startIndex])</span><br><span class="line">print(greeting[greeting.index(after: greeting.startIndex)])</span><br><span class="line">//endIndex属性就是 String中最后一个字符后的位置。endIndex属性并不是字符串下标脚本的合法实际参数</span><br><span class="line">//greeting[greeting.endIndex] //会报错</span><br><span class="line">print(greeting[greeting.index(before: greeting.endIndex)])</span><br><span class="line">//注: 如果 String为空，则 startIndex与 endIndex相等</span><br><span class="line"></span><br><span class="line">let index = greeting.index(greeting.startIndex, offsetBy: 2)</span><br><span class="line">print(greeting[index])</span><br><span class="line">let indesString = greeting[greeting.startIndex...index]  //&quot;Gut&quot;</span><br><span class="line">//注:indesString : Substring类型</span><br><span class="line">print(String(indesString)) //&quot;Gut&quot;</span><br></pre></td></tr></table></figure><h4 id="8-2使用-characters属性的-indices属性来创建所有能够用来访问字符串中独立字符的索引范围-Range。"><a href="#8-2使用-characters属性的-indices属性来创建所有能够用来访问字符串中独立字符的索引范围-Range。" class="headerlink" title="8.2使用 characters属性的 indices属性来创建所有能够用来访问字符串中独立字符的索引范围 Range。"></a>8.2使用 characters属性的 indices属性来创建所有能够用来访问字符串中独立字符的索引范围 Range。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.characters.indices &#123;</span><br><span class="line">    print(<span class="string">"\(greeting[index]) "</span>, terminator: <span class="string">""</span>)<span class="comment">//不换行输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-多行字符串"><a href="#9-多行字符串" class="headerlink" title="9.多行字符串"></a>9.多行字符串</h3><ul><li>注:你可以在多行字面量中使用单个双引号 “ 。要在多行字符串中包含 “”” ，你必须用反斜杠（ \ ）转义至少其中一个双引号</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let rowsString = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                我是一只小鸭子</span></span><br><span class="line"><span class="string">                咿呀咿呀哟</span></span><br><span class="line"><span class="string">                \""</span><span class="string">"</span></span><br><span class="line"><span class="string">                "</span><span class="string">""</span></span><br><span class="line">print(rowsString)</span><br></pre></td></tr></table></figure><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul><li>Swift 的 Array类型被桥接到了基础框架的 NSArray类上。</li><li>Swift 数组的类型完整写法是 Array<element>， Element是数组允许存入的值的类型。你同样可以简写数组的类型为 [Element]。</element></li></ul><h3 id="1-创建确定大小且元素都设定为相同默认值的数组。"><a href="#1-创建确定大小且元素都设定为相同默认值的数组。" class="headerlink" title="1. 创建确定大小且元素都设定为相同默认值的数组。"></a>1. 创建确定大小且元素都设定为相同默认值的数组。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Array*/</span></span><br><span class="line"><span class="comment">//默认值（叫做 repeating）和新数组元素的数量（叫做 count)</span></span><br><span class="line">var array1 = Array(repeating: <span class="number">1</span>, count: <span class="number">2</span>)</span><br><span class="line">var array2 = Array(repeating: <span class="number">3</span>, count: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="2-连接两个数组来创建数组-类型必须一致"><a href="#2-连接两个数组来创建数组-类型必须一致" class="headerlink" title="2. 连接两个数组来创建数组(类型必须一致)"></a>2. 连接两个数组来创建数组(类型必须一致)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array3 = array1 + array2</span><br><span class="line">print(array3) <span class="comment">//[1, 1, 3, 3]</span></span><br></pre></td></tr></table></figure><h4 id="3-数组个数"><a href="#3-数组个数" class="headerlink" title="3. 数组个数"></a>3. 数组个数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(array3.count)  <span class="comment">//5</span></span><br></pre></td></tr></table></figure><h4 id="4-判断数组个数是否为0"><a href="#4-判断数组个数是否为0" class="headerlink" title="4. 判断数组个数是否为0"></a>4. 判断数组个数是否为0</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(array3.isEmpty)  <span class="comment">//false</span></span><br><span class="line">print(array3.count == <span class="number">0</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="5-添加"><a href="#5-添加" class="headerlink" title="5. 添加"></a>5. 添加</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array3.append(<span class="number">4</span>) <span class="comment">//[1, 1, 3, 3, 4]</span></span><br><span class="line">array3 += [<span class="number">5</span>]  <span class="comment">//[1, 1, 3, 3, 4, 5]</span></span><br><span class="line">array3 += [<span class="number">6</span>, <span class="number">5</span>]  <span class="comment">//[1, 1, 3, 3, 4, 5, 6, 5]</span></span><br></pre></td></tr></table></figure><h4 id="6-取值"><a href="#6-取值" class="headerlink" title="6. 取值"></a>6. 取值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(array3[<span class="number">0</span>]) <span class="comment">// 1</span></span><br><span class="line">array3[<span class="number">1</span>] = <span class="number">9</span> <span class="comment">// [1, 9, 3, 3, 4, 5, 6, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用下标改变一个范围的值，就算替换与范围长度不同的值的合集也行</span></span><br><span class="line">array3[<span class="number">2.</span>.<span class="number">.4</span>] = [<span class="number">0</span>, <span class="number">8</span>] <span class="comment">//[1, 9, 0, 8, 5, 6, 5]</span></span><br></pre></td></tr></table></figure><h4 id="7-遍历"><a href="#7-遍历" class="headerlink" title="7.遍历"></a>7.遍历</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> array3 &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//元组输出</span></span><br><span class="line"><span class="keyword">for</span> (index, item) <span class="keyword">in</span> array3.enumerated() &#123;</span><br><span class="line">    print(<span class="string">"\(index)---\(item)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒叙输出</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> array3.reversed() &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//forEach遍历,如同for-in</span></span><br><span class="line">let arr = [<span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">arr.forEach &#123; (x) <span class="keyword">in</span></span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-删除和插入"><a href="#8-删除和插入" class="headerlink" title="8. 删除和插入"></a>8. 删除和插入</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array3.remove(at: <span class="number">1</span>)  <span class="comment">//[1, 0, 8, 5, 6, 5]</span></span><br><span class="line">array3.removeFirst()  <span class="comment">//[0, 8, 5, 6, 5]</span></span><br><span class="line">array3.removeLast()   <span class="comment">//[0, 8, 5, 6]</span></span><br><span class="line">array3.removeFirst(<span class="number">2</span>) <span class="comment">//[5,6]</span></span><br><span class="line">array3.removeLast(<span class="number">1</span>)  <span class="comment">//[5]</span></span><br><span class="line">array3.removeAll()    <span class="comment">//[]</span></span><br></pre></td></tr></table></figure><h2 id="Dictionary-and-Set"><a href="#Dictionary-and-Set" class="headerlink" title="Dictionary and Set"></a>Dictionary and Set</h2><ul><li>至于Collection类型，Set和Dictionary并不那么最直观的</li><li>Swift 的 Dictionary桥接到了基础框架的 NSDictionary类。</li></ul><h4 id="1-首先列表可以是从一系列键值对（元组）创建一个字典"><a href="#1-首先列表可以是从一系列键值对（元组）创建一个字典" class="headerlink" title="1.首先列表可以是从一系列键值对（元组）创建一个字典:"></a>1.首先列表可以是从一系列键值对（元组）创建一个字典:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dictionary</span></span><br><span class="line">let keyNames = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>]</span><br><span class="line">let valueNames = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//public init&lt;S&gt;(uniqueKeysWithValues keysAndValues: S) where S : Sequence, S.Element == (Key, Value)</span></span><br><span class="line"><span class="comment">//对于该方法的具体解释,可以点进去看一下官方的讲解</span></span><br><span class="line">let nameDic = Dictionary(uniqueKeysWithValues: zip(keyNames, valueNames))</span><br><span class="line">print(nameDic)</span><br><span class="line"><span class="comment">//["b": 2, "e": 6, "a": 1, "d": 5, "c": 4]</span></span><br></pre></td></tr></table></figure><h4 id="2-在初始化Dictionary时-你现在可以使用你喜欢的方式来处理重复的键-同时避免覆盖键值对，且不会出现任何问题："><a href="#2-在初始化Dictionary时-你现在可以使用你喜欢的方式来处理重复的键-同时避免覆盖键值对，且不会出现任何问题：" class="headerlink" title="2.在初始化Dictionary时, 你现在可以使用你喜欢的方式来处理重复的键,同时避免覆盖键值对，且不会出现任何问题："></a>2.在初始化Dictionary时, 你现在可以使用你喜欢的方式来处理重复的键,同时避免覆盖键值对，且不会出现任何问题：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let keyNames2 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//public init&lt;S&gt;(_ keysAndValues: S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value) rethrows where S : Sequence, S.Element == (Key, Value)</span></span><br><span class="line"><span class="comment">//对于该方法的具体解释,可以点进去看一下官方的讲解</span></span><br><span class="line">let nameDic2 = Dictionary(zip(keyNames2, repeatElement(<span class="number">1</span>, count: keyNames2.count)), uniquingKeysWith: +)</span><br><span class="line">print(nameDic2)</span><br><span class="line"><span class="comment">//["b": 2, "a": 2, "c": 1]</span></span><br></pre></td></tr></table></figure><h4 id="3-Dictionary-和-Set现在都可以将结果-通过filter函数-过滤到原始类型的新对象中："><a href="#3-Dictionary-和-Set现在都可以将结果-通过filter函数-过滤到原始类型的新对象中：" class="headerlink" title="3.Dictionary 和 Set现在都可以将结果 通过filter函数 过滤到原始类型的新对象中："></a>3.Dictionary 和 Set现在都可以将结果 通过filter函数 过滤到原始类型的新对象中：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let nameDic3 = nameDic.filter(&#123; $<span class="number">0.</span>value &lt; <span class="number">5</span> &#125;)</span><br><span class="line">print(nameDic3)</span><br><span class="line"><span class="comment">//["b": 2, "a": 1, "c": 4]</span></span><br></pre></td></tr></table></figure><h4 id="4-Dictionary为直接映射其值提供了一种非常有用的方法-："><a href="#4-Dictionary为直接映射其值提供了一种非常有用的方法-：" class="headerlink" title="4.Dictionary为直接映射其值提供了一种非常有用的方法:："></a>4.Dictionary为直接映射其值提供了一种非常有用的方法:：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将value值Int转化为字符串</span></span><br><span class="line">let nameDic4 = nameDic3.mapValues(&#123; <span class="string">"\($0)"</span> &#125;)</span><br><span class="line">print(nameDic4)</span><br><span class="line"><span class="comment">//["b": "2", "a": "1", "c": "4"]</span></span><br></pre></td></tr></table></figure><h4 id="5-在Dictionary上访问某个值时，常见的做法是使用nil-coalescing-operator给出默认值"><a href="#5-在Dictionary上访问某个值时，常见的做法是使用nil-coalescing-operator给出默认值" class="headerlink" title="5.在Dictionary上访问某个值时，常见的做法是使用nil-coalescing operator给出默认值"></a>5.在Dictionary上访问某个值时，常见的做法是使用nil-coalescing operator给出默认值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let nameDic5 = nameDic4[<span class="string">"d"</span>, <span class="keyword">default</span> : <span class="string">"unknown"</span>]</span><br></pre></td></tr></table></figure><h4 id="6-我们可以从Sequence”中初始化Dictionary，并将其分组为bucket-："><a href="#6-我们可以从Sequence”中初始化Dictionary，并将其分组为bucket-：" class="headerlink" title="6.我们可以从Sequence”中初始化Dictionary，并将其分组为bucket:："></a>6.我们可以从Sequence”中初始化Dictionary，并将其分组为bucket:：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注: 当通过特定模式对数据进行分组时，这相当方便。</span></span><br><span class="line">let name2 = [<span class="string">"Proxima"</span>, <span class="string">"Centauri A"</span>, <span class="string">"Centauri B"</span>, <span class="string">"Barnard"</span>, <span class="string">"Wolf"</span>]</span><br><span class="line">let nameDic6 = Dictionary(grouping: name2, by: &#123; $<span class="number">0.</span>first! &#125;)</span><br><span class="line">print(nameDic6)</span><br><span class="line"><span class="comment">//["B": ["Barnard"], "W": ["Wolf"], "P": ["Proxima"], "C": ["Centauri A", "Centauri B"]]</span></span><br></pre></td></tr></table></figure><blockquote><p>涉及Zip的用法,详见<a href="http://www.jianshu.com/p/8c39bbacceb2" target="_blank" rel="noopener">Swift语法之Zip详解</a></p></blockquote><h4 id="7-预留空间"><a href="#7-预留空间" class="headerlink" title="7.预留空间"></a>7.预留空间</h4><ul><li>Sequence和Dictionary现在都具有明确保留容量的能力</li><li>在这些类型上，Reallocation可能是一项代价高昂的任务。</li><li>如果你知道需要存储的数据量时, 使用reserveCapacity(_:)可以提高性能且便捷</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name3 : [String : Int] = [ : ]</span><br><span class="line">print(name3.capacity) <span class="comment">// 0</span></span><br><span class="line">name3.reserveCapacity(<span class="number">10</span>) <span class="comment">//储备 10元素的能力</span></span><br><span class="line">print(name3.capacity) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift4.0 </tag>
            
            <tag> String </tag>
            
            <tag> Array </tag>
            
            <tag> Dictionary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift版-H5页面实现长按保存图片</title>
      <link href="/2017/07/10/Swift%E7%89%88-H5%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0%E9%95%BF%E6%8C%89%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/"/>
      <content type="html"><![CDATA[<ul><li>刚开始拿到需求的第一反应是:H5页面还可以保存图片??</li><li>随即想了一下,好像微信里好多H5页面都有这样的功能</li><li>然后查阅了一下相关资料,有咨询了前端大神发现两行核心代码</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取长按所在点</span></span><br><span class="line">let urlString = <span class="string">"document.elementFromPoint(\(touchPoint.x), \(touchPoint.y)).src"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据该点的参数获取对应图片的链接</span></span><br><span class="line">let saveUrl = webView.stringByEvaluatingJavaScriptFromString(urlString)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="下面来一起啊看一下完整的代码步骤"><a href="#下面来一起啊看一下完整的代码步骤" class="headerlink" title="下面来一起啊看一下完整的代码步骤"></a>下面来一起啊看一下完整的代码步骤</h3><blockquote><h4 id="首先给UiWebView加一个长按手势"><a href="#首先给UiWebView加一个长按手势" class="headerlink" title="首先给UiWebView加一个长按手势"></a>首先给UiWebView加一个长按手势</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加长按手势</span></span><br><span class="line">let longPressGes = <span class="built_in">UILongPressGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="meta">#selector(longPressedGesture(_:)))</span></span><br><span class="line"><span class="comment">//一定要遵循代理</span></span><br><span class="line">longPressGes.delegate = <span class="keyword">self</span></span><br><span class="line">webView.addGestureRecognizer(longPressGes)</span><br></pre></td></tr></table></figure><blockquote><h4 id="实现代理方法"><a href="#实现代理方法" class="headerlink" title="实现代理方法"></a>实现代理方法</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//不实现该代理方法,长按无效</span></span><br><span class="line">func gestureRecognizer(gestureRecognizer: <span class="built_in">UIGestureRecognizer</span>, shouldRecognizeSimultaneouslyWithGestureRecognizer otherGestureRecognizer: <span class="built_in">UIGestureRecognizer</span>) -&gt; Bool &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="接着在手势响应方法里面实现相应的功能"><a href="#接着在手势响应方法里面实现相应的功能" class="headerlink" title="接着在手势响应方法里面实现相应的功能"></a>接着在手势响应方法里面实现相应的功能</h4></blockquote><ul><li>注意:<ul><li>一定要判断手势的state属性</li><li>判断saveUrl是否是一个nil值</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@objc func longPressedGesture(recognizer: UILongPressGestureRecognizer)&#123;</span><br><span class="line">    if recognizer.state != .Began &#123; return &#125;</span><br><span class="line">        </span><br><span class="line">    let touchPoint = recognizer.locationInView(webView)</span><br><span class="line">    </span><br><span class="line">    //核心代码</span><br><span class="line">    let urlString = &quot;document.elementFromPoint(\(touchPoint.x), \(touchPoint.y)).src&quot;</span><br><span class="line">    if let saveUrl = webView.stringByEvaluatingJavaScriptFromString(urlString) &#123;</span><br><span class="line">        //判断图片的链接是否为空,长度是否为o</span><br><span class="line">        if saveUrl.characters.count == 0 &#123; return &#125;</span><br><span class="line">        addAlertAction(saveUrl)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="调用保存图片功能按钮"><a href="#调用保存图片功能按钮" class="headerlink" title="调用保存图片功能按钮"></a>调用保存图片功能按钮</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func addAlertAction(imageStr: String)&#123;</span><br><span class="line">    let alertV = <span class="built_in">UIAlertController</span>()</span><br><span class="line">    let saveAction = <span class="built_in">UIAlertAction</span>(title: <span class="string">"保存图片"</span>, style: .Default) &#123; (alertV) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.saveImageToPhoto(imageStr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取消保存不作处理</span></span><br><span class="line">    let cancelAction = <span class="built_in">UIAlertAction</span>(title: <span class="string">"取消"</span>, style: .Cancel, handler: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">    alertV.addAction(saveAction)</span><br><span class="line">    alertV.addAction(cancelAction)</span><br><span class="line">    controller.presentViewController(alertV, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="使用SDWebImage保存图片"><a href="#使用SDWebImage保存图片" class="headerlink" title="使用SDWebImage保存图片"></a>使用SDWebImage保存图片</h4></blockquote><ul><li>注意使用SDWebImage的缓存机制</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fileprivate func saveImageToPhoto(imageStr: String)&#123;</span><br><span class="line">    guard let imageUrl = <span class="built_in">NSURL</span>(string: imageStr) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">    let sdManager = SDWebImageManager.sharedManager()</span><br><span class="line">        </span><br><span class="line">    var image : <span class="built_in">UIImage</span>!</span><br><span class="line">    <span class="keyword">if</span> sdManager.diskImageExistsForURL(imageUrl) &#123;</span><br><span class="line">        <span class="comment">//先判断缓存中的图片</span></span><br><span class="line">        image = sdManager.imageCache.imageFromDiskCacheForKey(imageUrl.absoluteString)</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//缓存没有在进行下载</span></span><br><span class="line">        let data = <span class="built_in">NSData</span>(contentsOfURL: imageUrl)</span><br><span class="line">        image = <span class="built_in">UIImage</span>(data: data!)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保存图片到相册中</span></span><br><span class="line">    <span class="built_in">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>, <span class="meta">#selector(self.image(_:didFinishSavingWithError:contextInfo:)), nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="最后是一个保存成功与否的回调方法"><a href="#最后是一个保存成功与否的回调方法" class="headerlink" title="最后是一个保存成功与否的回调方法"></a>最后是一个保存成功与否的回调方法</h4></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func image(image: <span class="built_in">UIImage</span>, didFinishSavingWithError: <span class="built_in">NSError</span>?, contextInfo: AnyObject) &#123;</span><br><span class="line">    <span class="keyword">if</span> didFinishSavingWithError != <span class="literal">nil</span> &#123;</span><br><span class="line">        MBProgressHUD.show(string: <span class="string">"请开启访问相册权限后使用此功能"</span>, inView: <span class="keyword">self</span>.view)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MBProgressHUD.show(string: <span class="string">"图片保存成功"</span>, inView: <span class="keyword">self</span>.view)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 以上如有不妥之处还望多多指正 </p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Swift </tag>
            
            <tag> WebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5学习笔记之音视频标签</title>
      <link href="/2017/06/16/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%87%E7%AD%BE/"/>
      <content type="html"><![CDATA[<p>HTML5学习笔记之音视频标签</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/647982-0d0c0be17835a633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="一-video标签"><a href="#一-video标签" class="headerlink" title="一. video标签"></a>一. video标签</h2><h3 id="1-作用-播放视频"><a href="#1-作用-播放视频" class="headerlink" title="1. 作用: 播放视频"></a>1. 作用: 播放视频</h3><h3 id="2-video标签格式1"><a href="#2-video标签格式1" class="headerlink" title="2. video标签格式1:"></a>2. video标签格式1:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src=<span class="string">""</span>&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h3 id="3-video标签的属性"><a href="#3-video标签的属性" class="headerlink" title="3. video标签的属性"></a>3. video标签的属性</h3><ul><li>src: 告诉video标签需要播放的视频地址</li><li>autoplay: 告诉video标签是否需要自动播放视频</li><li>controls:告诉video标签是否需要显示控制条</li><li>poster: 告诉video标签视频没有播放之前显示的占位图片</li><li>loop: 告诉video标签循环播放视频. 一般用于做广告视频</li><li>preload: 告诉video标签预加载视频, 但是需要注意preload和autoplay相冲, 如果设置了autoplay属性, 那么preload属性就会失效</li><li>muted:告诉video标签视频静音</li><li>width/height: 和img标签中的一模一样</li></ul><h3 id="4-video标签格式2"><a href="#4-video标签格式2" class="headerlink" title="4. video标签格式2"></a>4. video标签格式2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line">  &lt;source src="" type=""&gt;&lt;/source&gt;</span><br><span class="line">  &lt;source src="" type=""&gt;&lt;/source&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><ul><li><p>第二种格式存在的意义</p><ul><li>由于视频数据非常非常的重要, 所以五大浏览器厂商都不愿意支持别人的视频格式, 所以导致了没有一种视频格式是所有浏览器都支持的这个时候W3C为了解决这个问题, 所以推出了第二个video标签的格式</li><li>video标签的第二种格式存在的意义就是为了解决浏览器适配问题. video 元素支持三种视频格式, 我们可以把这三种格式都通过source标签指定给video标签, 那么以后当浏览器播放视频时它就会从这三种中选择一种自己支持的格式来播放</li></ul></li><li><p>注意点:</p><ul><li>当前通过video标签的第二种格式虽然能够指定所有浏览器都支持的视频格式, 但是想让所有浏览器都通过video标签播放视频还有一个前提条件, 就是浏览器必须支持HTML5标签, 否则同样无法播放</li><li>在过去的一些浏览器是不支持HTML5标签的, 所以为了让过去的一些浏览器也能够通过video标签来播放视频, 那么我们以后可以通过一个JS的框架叫做html5media来实现</li></ul></li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;video width=<span class="string">"200"</span> height=<span class="string">"100"</span> poster=<span class="string">"http://www.youname.com/images/first.png"</span> autoplay=<span class="string">"autoplay"</span> preload=<span class="string">"none"</span> controls=<span class="string">"controls"</span>&gt;</span><br><span class="line">    &lt;!--楚乔传,好像是第<span class="number">4</span>集--&gt;</span><br><span class="line">    &lt;source src=<span class="string">"https://v.qq.com/x/cover/dhzimk1qzznf301/t0024jjys1q.html?ptag=baidu.aladdin.tv"</span> &gt;</span><br><span class="line">    &lt;source src=<span class="string">"http://www.youname.com/images/first.ogg"</span> /&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h2 id="二-audio标签"><a href="#二-audio标签" class="headerlink" title="二.audio标签"></a>二.audio标签</h2><h3 id="1-作用-播放音频"><a href="#1-作用-播放音频" class="headerlink" title="1. 作用: 播放音频"></a>1. 作用: 播放音频</h3><h3 id="2-格式"><a href="#2-格式" class="headerlink" title="2. 格式:"></a>2. 格式:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio src=<span class="string">""</span>&gt;</span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"></span><br><span class="line">&lt;audio&gt;</span><br><span class="line">&lt;source src=<span class="string">""</span> type=<span class="string">""</span>&gt;</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure><h3 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3. 注意点:"></a>3. 注意点:</h3><ul><li>audio标签的使用和video标签的使用基本一样</li><li>video中能够使用的属性在audio标签中大部分都能够使用, 并且功能都一样</li><li>只不过有3个属性不能用,<code>height/width/poster</code></li></ul><h2 id="三-详情和概要标签"><a href="#三-详情和概要标签" class="headerlink" title="三.详情和概要标签"></a>三.详情和概要标签</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用:"></a>1. 作用:</h3><ul><li>利用summary标签来描述概要信息, 利用details标签来描述详情信息</li><li>默认情况下是折叠展示, 想看见详情必须点击</li></ul><h3 id="2-格式-1"><a href="#2-格式-1" class="headerlink" title="2. 格式:"></a>2. 格式:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;概要信息&lt;/summary&gt;</span><br><span class="line">    详情信息</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--详情和概要标签--&gt;</span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;概要信息&lt;/summary&gt;</span><br><span class="line">    这里是详情: 是假的呢举案说法南石道街开发病那都是独守空房技能速度加快非农数据的看法山东矿机第三方看似简单妇女节看电视呢房间看电视开始的减肥纳斯达克今年初vdsfw的看法今年圣诞节开放男</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-3bd310e521eed10e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_9.png"></p><h2 id="四-marquee标签"><a href="#四-marquee标签" class="headerlink" title="四. marquee标签"></a>四. marquee标签</h2><h3 id="1-作用-跑马灯效果"><a href="#1-作用-跑马灯效果" class="headerlink" title="1. 作用: 跑马灯效果"></a>1. 作用: 跑马灯效果</h3><h3 id="2-格式-2"><a href="#2-格式-2" class="headerlink" title="2. 格式:"></a>2. 格式:</h3><p><code>&lt;marquee&gt;内容&lt;/marquee&gt;</code></p><h3 id="3-属性"><a href="#3-属性" class="headerlink" title="3. 属性:"></a>3. 属性:</h3><ul><li>direction: 设置滚动方向 left/right/up/down</li><li>scrollamount: 设置滚动速度, 值越大就越快</li><li>loop: 设置滚动次数, 默认是-1, 也就是无限滚动</li><li>behavior: 设置滚动类型 slide滚动到边界就停止, alternate滚动到边界就弹回</li></ul><h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4. 注意点:"></a>4. 注意点:</h3><ul><li>marquee标签不是W3C推荐的标签, 在W3C官方文档中也无法查询这个标签, 但是各大浏览器对这个标签的支持非常好</li></ul><h4 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5. 示例代码"></a>5. 示例代码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--跑马灯-marquee标签--&gt;</span><br><span class="line">&lt;marquee direction="left" scrollamount="5"&gt;跑马灯&lt;/marquee&gt;</span><br><span class="line">&lt;marquee direction="right" scrollamount="3"&gt;marquee&lt;/marquee&gt;</span><br><span class="line">&lt;marquee direction="up" scrollamount="1"&gt;标签&lt;/marquee&gt;</span><br><span class="line">&lt;marquee direction="down" scrollamount="1"&gt;down&lt;/marquee&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-6bc10b374b5e362e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_10.png"></p><blockquote><p>注: 实际的效果中,这三个是一直在滚动的,只是图片看不到效果,自己亲自实践感受下吧!</p></blockquote><h2 id="五-HTML中被废弃的标签"><a href="#五-HTML中被废弃的标签" class="headerlink" title="五. HTML中被废弃的标签"></a>五. HTML中被废弃的标签</h2><blockquote><p>由于HTML现在只负责语义而不负责样式.但是HTML一开始有一部分标签连样式也包揽了, 所以这部分标签都被废弃了</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b、u、i、s </span><br><span class="line">- 以上标签自己带有样式, 有浓厚的样式作用, 今后一般都只作为CSS钩子使用</span><br><span class="line">- 原则: 不到万不得已,切记不要使用如上标签. 大家可以到BAT的网站查看源代码, 几乎看不到以上标签</span><br></pre></td></tr></table></figure><ul><li>b(Bold)作用: 将文本字体加粗<ul><li>格式:<code>&lt;b&gt;将文本字体加粗&lt;/b&gt;</code></li></ul></li><li>u(Underlined)作用: 为文本添加下划线<ul><li>格式: <code>&lt;u&gt;为文本添加下划线&lt;/u&gt;</code></li></ul></li><li>i(Italic)作用: 显示斜体文本效果<ul><li>格式: <code>&lt;i&gt;显示斜体文本效果&lt;/i&gt;</code></li></ul></li><li>s(Strikethrough)作用: 为文本添加删除线<ul><li>格式: <code>&lt;s&gt;为文本添加删除线&lt;/s&gt;</code></li></ul></li></ul><blockquote><p>为了弥补 b、u、i、s标签的不足, W3C又推出了一组新的标签, 这些标签在显示上看似和buis没什么区别, 但是在语义上却有重大区别</p></blockquote><ul><li>strong作用: 着重内容<ul><li>格式:<code>&lt;strong&gt;着重内容&lt;/strong&gt;</code></li></ul></li><li>ins(Inserted)作用: 新插入的文本<ul><li>格式:<code>&lt;ins&gt;新插入的文本&lt;/ins&gt;</code></li></ul></li><li>em(Emphasized)作用:强调内容<ul><li>格式:<code>&lt;em&gt;强调内容&lt;/em&gt;</code></li></ul></li><li>del(Deleted)作用: 已删除的文本<ul><li>格式:<code>&lt;del&gt;已删除的文本&lt;/del&gt;</code></li></ul></li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--新增标签--&gt;</span><br><span class="line">&lt;strong&gt;着重内容&lt;/strong&gt;</span><br><span class="line">&lt;ins&gt;新插入的内容&lt;/ins&gt;</span><br><span class="line">&lt;em&gt;强调的内容&lt;/em&gt;</span><br><span class="line">&lt;del&gt;已经删除的内容&lt;/del&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-595238b7fcc8c71f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_11.png"></p><blockquote><ul><li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040" target="_blank" rel="noopener">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5标签 </tag>
            
            <tag> CSS </tag>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5学习笔记之表单标签</title>
      <link href="/2017/06/15/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE/"/>
      <content type="html"><![CDATA[<p>HTML5学习笔记之表单标签</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/647982-9f6f2cfcfdf04c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li><p>1.作用: </p><ul><li>用于收集用户信息, 让用户填写、选择相关信息</li></ul></li><li><p>2.格式:</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    所有的表单内容，都要写在form标签里面</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ul><li>3.注意事项:<ul><li>所有的表单内容，都要写在form标签里面<br>form标签中有两个比较重要的属性action和method</li></ul></li></ul><h2 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h2><ul><li><p>如果说td是表格最核心的标签, 那么input就是表单最核心的标签. nput标签有一个type属性, 这个属性有很多类型的取值, 取值的不同就决定了input标签的功能和外观不同</p><h3 id="1-输入框"><a href="#1-输入框" class="headerlink" title="1.输入框"></a>1.输入框</h3><h4 id="1-1-明文输入框"><a href="#1-1-明文输入框" class="headerlink" title="1.1 明文输入框"></a>1.1 明文输入框</h4></li><li><p>作用: 用户可以在输入框内输入内容</p></li><li>账号: <code>&lt;input type=&quot;text&quot;/&gt;</code><h4 id="1-2-暗文输入框"><a href="#1-2-暗文输入框" class="headerlink" title="1.2 暗文输入框"></a>1.2 暗文输入框</h4></li><li>作用: 用户可以在输入框内输入内容</li><li>密码: <code>&lt;input type=&quot;password&quot;/&gt;</code><h4 id="1-3-给输入框设置默认值"><a href="#1-3-给输入框设置默认值" class="headerlink" title="1.3 给输入框设置默认值"></a>1.3 给输入框设置默认值</h4></li><li>账号: <code>&lt;input type=&quot;text&quot;  value=&quot;tqj&quot;/&gt;</code></li><li>密码: <code>&lt;input type=&quot;password&quot; value=&quot;0929&quot;/&gt;</code><h4 id="1-4-规定输入字段中的字符的最大长度"><a href="#1-4-规定输入字段中的字符的最大长度" class="headerlink" title="1.4 规定输入字段中的字符的最大长度"></a>1.4 规定输入字段中的字符的最大长度</h4></li><li>账号: <code>&lt;input type=&quot;text&quot; name=&quot;fullname&quot; maxlength=&quot;8&quot; /&gt;</code></li></ul><h4 id="1-5-代码"><a href="#1-5-代码" class="headerlink" title="1.5 代码"></a>1.5 代码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;!--明文输入框--&gt;</span><br><span class="line">    &lt;p&gt;账号: &lt;input type="text" /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;!--暗文输入框--&gt;</span><br><span class="line">    &lt;p&gt;密码: &lt;input type="password" /&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--p标签换行--&gt;</span><br><span class="line">    &lt;p&gt;账号: &lt;input type="text" value="tqj" /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;密码: &lt;input type="password" value="0929" /&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;p&gt;最大长度: &lt;input type="text" maxlength="5"/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-39cbc042f6cfbdb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_22.png"></p><h3 id="2-单选框-radio"><a href="#2-单选框-radio" class="headerlink" title="2. 单选框(radio)"></a>2. 单选框(radio)</h3><ul><li>作用: 用户只能从众多选项中选择其中一个</li><li>单选按钮，天生是不互斥的，如果想互斥，必须要有相同的name属性</li></ul><h3 id="3-多选框-checkbox"><a href="#3-多选框-checkbox" class="headerlink" title="3. 多选框(checkbox)"></a>3. 多选框(checkbox)</h3><ul><li>作用: 用户只能从众多选项中选择多个</li><li>复选框，最好也是有相同的name（虽然他不需要互斥，但是也要有相同的name）</li></ul><h3 id="4-label标签"><a href="#4-label标签" class="headerlink" title="4. label标签"></a>4. label标签</h3><ul><li>作用: label标签不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性</li><li>注意事项:<br>表单元素要有一个id，然后label标签就有一个for属性，for属性和id相同就表示绑定了<br>所有表单元素都可以通过label绑定</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--单选框--&gt;</span><br><span class="line">&lt;!--checked属性,为默认值--&gt;</span><br><span class="line">&lt;label for="sex"&gt;性别: &lt;/label&gt;</span><br><span class="line">&lt;input type="radio" name="sex" checked /&gt; &lt;label for="sex"&gt;男&lt;/label&gt;</span><br><span class="line">&lt;input type="radio" name="sex" /&gt; &lt;label for="sex"&gt;女&lt;/label&gt;</span><br><span class="line">&lt;input type="radio" name="sex" /&gt; &lt;label for="sex"&gt;妖&lt;/label&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--多选框--&gt;</span><br><span class="line">&lt;label for="课程"&gt;课程: &lt;/label&gt;</span><br><span class="line">&lt;input type="checkbox" name="课程" checked /&gt; &lt;label for="课程"&gt;HTML5 &lt;/label&gt;</span><br><span class="line">&lt;input type="checkbox" name="课程" checked /&gt; &lt;label for="课程"&gt;Swift &lt;/label&gt;</span><br><span class="line">&lt;input type="checkbox" name="课程" /&gt; &lt;label for="课程"&gt;OC &lt;/label&gt;</span><br><span class="line">&lt;input type="checkbox" name="课程" /&gt; &lt;label for="课程"&gt;CSS &lt;/label&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-141c73672aca00ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_1.png"></p><h3 id="5-按钮"><a href="#5-按钮" class="headerlink" title="5. 按钮"></a>5. 按钮</h3><h4 id="5-1-普通按钮"><a href="#5-1-普通按钮" class="headerlink" title="5.1 普通按钮"></a>5.1 普通按钮</h4><ul><li>作用: 定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）<br><code>&lt;input type=&quot;button&quot; value=&quot;点我丫&quot; /&gt;</code></li></ul><h4 id="5-2-图片按钮"><a href="#5-2-图片按钮" class="headerlink" title="5.2 图片按钮"></a>5.2 图片按钮</h4><ul><li>作用:定义图像形式的提交按钮<br><code>&lt;input type=&quot;image&quot; src=&quot;1.png&quot; /&gt;</code></li></ul><h4 id="5-3-还原按钮"><a href="#5-3-还原按钮" class="headerlink" title="5.3 还原按钮"></a>5.3 还原按钮</h4><ul><li>作用: 定义还原按钮。还原按钮会清除表单中的所有数据<br><code>&lt;input type=&quot;reset&quot; /&gt;</code></li><li>注意事项:<br>这个按钮不需要写value自动就有“还原”文字<br>reset只对form表单中表单项有效果</li></ul><h4 id="5-4-提交按钮"><a href="#5-4-提交按钮" class="headerlink" title="5.4 提交按钮"></a>5.4 提交按钮</h4><ul><li>作用:定义提交按钮。提交按钮会把表单数据发送到action属性指定的页面<br><code>&lt;input type=&quot;submit&quot; /&gt;</code></li><li>注意事项:<ul><li>这个按钮不需要写value自动就有“提交”文字</li><li>要想通过submit提交数据到服务器, 被提交的表单项都必须设置name属性</li><li>默认明文传输(GET)不安全, 可以将method属性设置为POST改为非明文传输(学到Ajax再理解)</li></ul></li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--按钮--&gt;</span><br><span class="line">&lt;!--普通按钮--&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"点我有奖"</span>&gt;</span><br><span class="line">&lt;!--图片按钮--&gt;</span><br><span class="line">&lt;input type=<span class="string">"image"</span> src=<span class="string">"http://note.youdao.com/favicon.ico"</span>&gt;</span><br><span class="line">&lt;!--还原按钮--&gt;</span><br><span class="line">&lt;input type=<span class="string">"reset"</span>&gt;</span><br><span class="line">&lt;!--提交按钮--&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-df3952d22685cb6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_3.png"></p><h3 id="6-隐藏域"><a href="#6-隐藏域" class="headerlink" title="6. 隐藏域"></a>6. 隐藏域</h3><ul><li>作用: 定义隐藏的输入字段<input type="hidden"></li><li>暂时不用掌握, 在Ajax中对数据的CRUD操作有非常大的作用</li></ul><h3 id="7-取色器和日期选择器"><a href="#7-取色器和日期选择器" class="headerlink" title="7.取色器和日期选择器"></a>7.取色器和日期选择器</h3><ul><li>取色器: <code>&lt;input type=&quot;color&quot;&gt;</code></li><li>日期选色器: <code>&lt;input type=&quot;date&quot;&gt;</code></li><li>HTML5中input类型增加了很多type类型, 例如color、date但是都不兼容, 后面讲到浏览器兼容时会重点讲解<blockquote><ul><li>亲自测试,在Mac电脑的Safari浏览器不兼容,只能用谷歌浏览器</li></ul></blockquote></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--取色器--&gt;</span><br><span class="line">&lt;label&gt;颜色: &lt;/label&gt; &lt;input type="color"&gt;</span><br><span class="line">&lt;!--换行--&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--日期选色器--&gt;</span><br><span class="line">&lt;label&gt;时间: &lt;/label&gt; &lt;input type="date"&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-af39ca426f317aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_5.png"></p><h3 id="8-数据列表"><a href="#8-数据列表" class="headerlink" title="8. 数据列表"></a>8. 数据列表</h3><ul><li><p>作用: 给输入框绑定待选项</p></li><li><p>格式:</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">datalist&gt;</span><br><span class="line">  &lt;option&gt;待选项内容&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure><ul><li><p>如何给输入框绑定待选列表</p><ul><li>搞一个输入框</li><li>搞一个datalist列表</li><li>给datalist列表标签添加一个id</li><li>给输入框添加一个list属性,将datalist的id对应的值赋值给list属性即可</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--数据列表--&gt;</span><br><span class="line">请选择车型: &lt;input type=<span class="string">"text"</span> list=<span class="string">"cars"</span>&gt;</span><br><span class="line">&lt;datalist <span class="keyword">id</span>=<span class="string">"cars"</span>&gt;</span><br><span class="line">    &lt;option&gt;奔驰&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;宝马&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;奥迪&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;别克&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;奔腾&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;奔跑&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-5e9e1c3b75a16426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_6.png"></p><ul><li>当输入某一个字符时,会自动根据datalist列表查询,并显示对应的列表,如图:</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-4973010e14b7d6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_7.png"></p><h2 id="三-多行文本框-文本域"><a href="#三-多行文本框-文本域" class="headerlink" title="三. 多行文本框(文本域)"></a>三. 多行文本框(文本域)</h2><ul><li><p>作用: textarea标签用于在表单中定义多行的文本输入控件</p><ul><li>cols属性表示columns“列”, 规定文本区内的可见宽度</li><li>rows属性表示rows“行”, 规定文本区内的可见高度</li></ul></li><li><p>格式:<br><code>&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;</code>默认<code>&lt;/textarea&gt;</code></p></li><li><p>注意点:</p><ul><li>可以通过cols和rows来指定输入框的宽度和高度</li><li>默认情况下输入框是可以手动拉伸的</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--禁止手动拉伸--&gt;</span><br><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">  textarea&#123;</span><br><span class="line">      resize: none;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="四-下拉列表"><a href="#四-下拉列表" class="headerlink" title="四. 下拉列表"></a>四. 下拉列表</h2><ul><li>作用: select标签和ul、ol、dl一样，都是组标签. 用于创建表单中的待选列表<ul><li>和radio、checkbox一样select也可以设置默认值, 通过selected属性设置(本身默认是第一个选项)</li></ul></li><li>给下拉列表添加分组</li></ul><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--给下拉表添加分组--&gt;</span><br><span class="line">&lt;select&gt;</span><br><span class="line">    &lt;optgroup label=<span class="string">"杭州市"</span>&gt;</span><br><span class="line">        &lt;option&gt;江干区&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;西湖区&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;滨江区&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;下城区&lt;/option&gt;</span><br><span class="line">    &lt;/optgroup&gt;</span><br><span class="line">    &lt;optgroup label=<span class="string">"烟台市"</span>&gt;</span><br><span class="line">        &lt;option&gt;莱山区&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;芝罘区&lt;/option&gt;</span><br><span class="line">    &lt;/optgroup&gt;</span><br><span class="line">    &lt;option selected&gt;北京市&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-c9638bcbcf8e60f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_8.png"></p><blockquote><ul><li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040" target="_blank" rel="noopener">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5标签 </tag>
            
            <tag> CSS </tag>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5学习笔记之表格标签</title>
      <link href="/2017/06/15/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE/"/>
      <content type="html"><![CDATA[<p>HTML5学习笔记之表格标签<br><a id="more"></a></p><h3 id="一-表格标签"><a href="#一-表格标签" class="headerlink" title="一.表格标签"></a>一.表格标签</h3><p><img src="http://upload-images.jianshu.io/upload_images/647982-151e7c132c68a833.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用:"></a>1.作用:</h3><ul><li>以表格形式将数据显示出来, 当数据量非常大的时候, 表格这种展现形式被认为是最为清晰的一种展现形式</li></ul><h3 id="2-格式"><a href="#2-格式" class="headerlink" title="2.格式:"></a>2.格式:</h3><ul><li>table定义表格</li><li>tr定义行</li><li>td定义单元格</li></ul><h3 id="3-表格中的属性"><a href="#3-表格中的属性" class="headerlink" title="3.表格中的属性"></a>3.表格中的属性</h3><ul><li><p>border: 默认情况下表格的边框宽度为0看不到, 通过border属性给表格指定边框宽度</p></li><li><p>width: 默认情况下表格的宽度是由内容自动计算出来的, 可以通过width属性指定表格的宽度</p></li><li><p>height:默认情况下表格的高度是由内容自动计算出来的, 可以通过height属性指定表格的高度</p></li><li><p>cellspacing: 外边距. 默认情况下单元格之间有2个像素的间隙, 可以通过cellpadding指定表格之间的间隙</p></li><li><p>cellpadding: 内边距. 默认情况下单元格边缘距离内容有1个像素的内边距, 可以通过cellpadding属性指定单元格边缘和内容之间的内边距</p></li><li><p>align: 规定表格相对周围元素的对齐方式, 它的取值有center、left、right</p><ul><li>给table设置align属性, 是让表格在浏览器中居左/居右/居中</li><li>给tr设置align属性, 是让当前行中所有内容居左/居右/居中</li><li>给td设置align属性,是让当前单元格中所有内容居左/居右/居中</li><li>该属性仅仅作为了解, 企业开发中用css代替, 因为HTML仅仅用于说明语义</li><li>如果td中设置了align属性, tr中也设置了align属性, 那么单元格中的内容会按照td中设置的来对齐</li></ul></li><li><p>valign: 规定表格相对周围元素的对齐方式, 它的取值有center、left、right</p><ul><li>给table设置valign属性, 无效<br>给tr设置valign属性, 是让当前行中所有内容居上/居中/居下</li><li>给td设置valign属性,是让当前单元格中所有内容居上/居中/居下</li><li>如果td中设置了valign属性, tr中也设置了valign属性, 那么单元格中的内容会按照td中设置的来对齐</li></ul></li><li><p>bgcolor:规定表格的背景颜色</p><ul><li>给table设置bgcolor属性, 是给整个表格设置背景颜色</li><li>给tr设置bgcolor属性, 是给当前行设置背景颜色</li><li>给td设置bgcolor属性, 是给当前单元格设置背景颜色</li><li>该属性仅仅作为了解, 企业开发中用css代替, 因为HTML仅仅用于说明语义</li></ul></li></ul><h4 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1) 示例代码"></a>1) 示例代码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--表格标签--&gt;</span><br><span class="line">&lt;!--先定义一个表格, 然后通过tr告诉浏览器这个表格中一共有多少行, 然后再通过td告诉浏览器这一行中一共有多少个元素(一共有多少列)--&gt;</span><br><span class="line">&lt;table border=<span class="string">"1"</span> width=<span class="string">"500"</span> cellpadding=<span class="string">"5"</span> cellspacing=<span class="string">"10"</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h4 id="2-展示样式"><a href="#2-展示样式" class="headerlink" title="2) 展示样式"></a>2) 展示样式</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-cac6e5756352e691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_17.png"></p><h3 id="4-表格中的其它标签"><a href="#4-表格中的其它标签" class="headerlink" title="4.表格中的其它标签"></a>4.表格中的其它标签</h3><ul><li><p>表单中有两种类型的单元格, 一种是标准单元格td, 一种是表头单元格th</p></li><li><p>th标签: 给每一列设置标题, 单元格中的内容会自动加粗，居中</p></li><li><p>caption标签:给整个表格设置标题</p><ul><li>一定要嵌套在talbe标签内部才有效</li></ul></li></ul><h4 id="1-示例代码-1"><a href="#1-示例代码-1" class="headerlink" title="1) 示例代码"></a>1) 示例代码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;table bgcolor=<span class="string">"#5f9ea0"</span> cellspacing=<span class="string">"1px"</span> width=<span class="string">"1000"</span> align=<span class="string">"center"</span>&gt;</span><br><span class="line">    &lt;caption&gt;</span><br><span class="line">        &lt;h2&gt;这周代码量排行榜&lt;/h2&gt;</span><br><span class="line">    &lt;/caption&gt;</span><br><span class="line">    &lt;tr bgcolor=<span class="string">"#8a2be2"</span>&gt;</span><br><span class="line">        &lt;th&gt;排名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;关键词&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;趋势&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;今日搜索&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;最近一天&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;最近一天相关链接&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr bgcolor=<span class="string">"#f0ffff"</span> align=<span class="string">"center"</span>&gt;</span><br><span class="line">        &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;穷爸爸富爸爸&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;上涨&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;456&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;234214&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;a href="#"&gt;贴吧&lt;/a&gt;</span><br><span class="line">            &lt;a href="#"&gt;百度&lt;/a&gt;</span><br><span class="line">            &lt;a href="#"&gt;杭州&lt;/a&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr bgcolor=<span class="string">"#f0ffff"</span> align=<span class="string">"center"</span>&gt;</span><br><span class="line">        &lt;td&gt;2&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;穷爸爸富爸爸&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;上涨&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;234&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;3423542&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;a href="#"&gt;贴吧&lt;/a&gt;</span><br><span class="line">            &lt;a href="#"&gt;百度&lt;/a&gt;</span><br><span class="line">            &lt;a href="#"&gt;杭州&lt;/a&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br></pre></td></tr></table></figure><h4 id="2-展示样式-1"><a href="#2-展示样式-1" class="headerlink" title="2) 展示样式"></a>2) 展示样式</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-70f5e09e43e7df60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_19.png"></p><h3 id="5-表格的结构"><a href="#5-表格的结构" class="headerlink" title="5.表格的结构"></a>5.表格的结构</h3><ul><li><p>thead标签:用来存放当前列的表头, 如果没有加css页面默认将表头中的高度设置变小</p></li><li><p>tbody标签:一般用来存放页面中的主体数据, 如果不写会自动加上</p></li><li><p>tfoot标签:用来存放表格的页脚（脚注或表注), 如果没有加css页面默认将表头中的高度设置变小, 一般不会出现</p></li></ul><h4 id="1-示例代码-2"><a href="#1-示例代码-2" class="headerlink" title="1) 示例代码"></a>1) 示例代码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;table bgcolor=<span class="string">"#7fffd4"</span> width=<span class="string">"800"</span> cellspacing=<span class="string">"2"</span> align=<span class="string">"center"</span>&gt;</span><br><span class="line">    &lt;caption&gt;我是表格标题&lt;/caption&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">    &lt;tr align=<span class="string">"center"</span>&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">    &lt;tr align=<span class="string">"center"</span>&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">    &lt;tfoot&gt;</span><br><span class="line">    &lt;tr align=<span class="string">"center"</span>&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/tfoot&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h4 id="2-展示样式-2"><a href="#2-展示样式-2" class="headerlink" title="2) 展示样式"></a>2) 展示样式</h4><p><img src="http://upload-images.jianshu.io/upload_images/4122543-00a3d46f21a7cce7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_20.png"></p><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h3><ul><li>表格结构的意义主要是用于SEO, 便于搜索引擎指定哪部分的内容是需要抓取的重要内容, 一般情况下搜索引擎会优先抓取tbody中的内容</li><li>由于有一部分浏览器对talbe的这种结构支持不是很好, 所以在企业开发中一般都不用严格的按照这种结构来编写</li></ul><blockquote><ul><li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040" target="_blank" rel="noopener">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5标签 </tag>
            
            <tag> CSS </tag>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5学习笔记之基础标签</title>
      <link href="/2017/06/15/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A0%87%E7%AD%BE/"/>
      <content type="html"><![CDATA[<p>HTML5学习笔记之基础标签<br><a id="more"></a></p><h2 id="一-列表标签"><a href="#一-列表标签" class="headerlink" title="一.列表标签"></a>一.列表标签</h2><h3 id="1-无序列表-unordered-list"><a href="#1-无序列表-unordered-list" class="headerlink" title="1.无序列表(unordered list)"></a>1.无序列表(unordered list)</h3><ul><li>无序 : 没有先后之分</li></ul><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1) 作用:"></a>1) 作用:</h4><ul><li>给一堆内容添加无序列表语义(一个没有先后顺序整体), 列表中的条目是不分先后</li></ul><h4 id="2-格式"><a href="#2-格式" class="headerlink" title="2) 格式:"></a>2) 格式:</h4><ul><li>li 英文是 list item, 翻译为列表项</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    &lt;h4&gt;中国城市列举(CN)&lt;/h4&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;北京&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;上海&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;广州&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;杭州&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-6170aa7da4bd362f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_4.png"></p><h4 id="3-ul应用场景"><a href="#3-ul应用场景" class="headerlink" title="3) ul应用场景:"></a>3) ul应用场景:</h4><ul><li>导航条</li><li>商品列表等</li><li>新闻列表</li><li><h4 id="4-注意"><a href="#4-注意" class="headerlink" title="4) 注意:"></a>4) 注意:</h4></li><li>其实ul还有一个type属性, 可以修改先导符号的样式, 取值有disc、square、circle几种<ul><li>但是由于样式将来都是通过css来完成, 所以这里就不给大家介绍了</li></ul></li><li>ul是一个组标签, 一定是一坨一坨的出现, 也就是说li标签不能单独存在, 必须包裹在ul里面</li><li>由于ul和li是一个整体, 所以ul里面不推荐包裹其它标签, 永远记住ul里面最好只写li标签</li><li>虽然ul中推荐只能写li标签, 但是li标签是一个容器标签, li标签中可以添加任意标签, 甚至可以添加ul标签</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4&gt;课程安排&lt;/h4&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        上午</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;HTML5&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;CSS&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        下午</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;OC&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;Swift&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-3e921651c9eb3c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_5.png"></p><h3 id="2-有序列表-ordered-list"><a href="#2-有序列表-ordered-list" class="headerlink" title="2.有序列表(ordered list)"></a>2.有序列表(ordered list)</h3><h4 id="1-作用-给一堆内容添加有序列表语义-一个有顺序整体-列表中的条目有先后之分"><a href="#1-作用-给一堆内容添加有序列表语义-一个有顺序整体-列表中的条目有先后之分" class="headerlink" title="1) 作用: 给一堆内容添加有序列表语义(一个有顺序整体), 列表中的条目有先后之分"></a>1) 作用: 给一堆内容添加有序列表语义(一个有顺序整体), 列表中的条目有先后之分</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4&gt;中国房价排行榜&lt;/h4&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;北京&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;上海&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;杭州&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;广州&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;深圳&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-13f9b32478195bac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_6.png"></p><h4 id="2-ol应用场景"><a href="#2-ol应用场景" class="headerlink" title="2) ol应用场景:"></a>2) ol应用场景:</h4><ul><li>xxx排行榜</li><li>其实ol应用场景并不多, 因为能用ol做的用ul都能做</li><li>ul的常见属性start、type属性, 可以修改先导符号的样式和序号</li></ul><h2 id="二-定义列表-definition-list"><a href="#二-定义列表-definition-list" class="headerlink" title="二.定义列表(definition list)"></a>二.定义列表(definition list)</h2><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1) 作用:"></a>1) 作用:</h4><ul><li><p>给一堆内容添加列表语义, 通过dt罗列出列表的条目, 然后再通过dd给每个条目进行相应的描述</p><h4 id="2-格式-1"><a href="#2-格式-1" class="headerlink" title="2) 格式:"></a>2) 格式:</h4></li><li><p>dt英文definition title, 翻译为定义标题</p></li><li>dd英文definition description, 翻译为定义描述信息</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;北京&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;国家的首都&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;杭州&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;坑爹,房价上涨最快的地方&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br><span class="line"></span><br><span class="line">![Snip20170614_7.png](http:<span class="comment">//upload-images.jianshu.io/upload_images/4122543-2d304b7b5f58b8c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br></pre></td></tr></table></figure><h4 id="3-dl应用场景"><a href="#3-dl应用场景" class="headerlink" title="3) dl应用场景:"></a>3) dl应用场景:</h4><ul><li>网站底部相关信息<ul><li>但凡看到一堆内容都是用于描述某一个内容的时候就要想到dl</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-4429f20791990a71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_9.png"></p><h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4) 注意事项:"></a>4) 注意事项:</h4><ul><li>dl是一个<code>组标签</code>, 一定是一坨一坨的出现, 也就是说<code>dt</code>和<code>dd</code>标签不能单独存在, 必须包裹在<code>dl</code>里面</li><li>由于<code>dl</code>和<code>dt</code>、<code>dd</code>是一个整体, 所以<code>dl</code>里面不推荐包裹其它标签</li><li><code>dd</code>和<code>dt</code>和<code>li</code>标签一样是容器标签, 里面可以添加任意标签</li><li>定义列表非常灵活, 可以给一个<code>dt</code>配置多个<code>dd</code>, 但是最好不要出现多个<code>dt</code>对应一个<code>dd</code>, <code>dd</code>的语义是描述离它最近的一个<code>dt</code>, 所以其它<code>dt</code>相当于没有描述, 而定义列表存在的意义就是既可以列出每一个条目又可以对每一个条目进行描述</li><li>定义列表非常灵活, 可以将多个<code>dt+dd</code>组合拆分为多个<code>dl</code></li></ul><h2 id="三-H系列标签-Header-1-Header-6"><a href="#三-H系列标签-Header-1-Header-6" class="headerlink" title="三.H系列标签(Header 1~Header 6)"></a>三.H系列标签(Header 1~Header 6)</h2><h4 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1.作用:"></a>1.作用:</h4><ul><li>用于给文本添加标题语义</li><li>格式:</li><li><code>&lt;h1&gt;xxxxxx&lt;/h1&gt;</code><h4 id="2-注意点"><a href="#2-注意点" class="headerlink" title="2.注意点:"></a>2.注意点:</h4></li><li>H标签是用来给文本添加标题语义的, 而不是用来修改文本的样式的</li><li>H标签一共有6个, 从H1~H6, 最多就只能到6, 超过6则无效</li><li>被H系列标签包裹的内容会独占一行</li><li>在H系列的标签中, H1最大, H6最小</li><li>在企业开发中, 一定要慎用H系列的标签, 特别是H1标签. 在企业开发中一般情况下一个界面中只能出现一个H1标签(和SEO有关)</li></ul><h2 id="四-P标签-Paragraph"><a href="#四-P标签-Paragraph" class="headerlink" title="四.P标签(Paragraph)"></a>四.P标签(Paragraph)</h2><h4 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1.作用:"></a>1.作用:</h4><ul><li>告诉浏览器哪些文字是一个段落</li><li>格式:</li><li><p>xxxxxxxx</p><h4 id="2-注意点-1"><a href="#2-注意点-1" class="headerlink" title="2.注意点:"></a>2.注意点:</h4></li><li>在浏览器中会单独占一行</li></ul><h2 id="五-Hr标签-Horizontal-Rule"><a href="#五-Hr标签-Horizontal-Rule" class="headerlink" title="五.Hr标签(Horizontal Rule)"></a>五.Hr标签(Horizontal Rule)</h2><h4 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1.作用:"></a>1.作用:</h4><ul><li>在浏览器上显示一条分割线</li><li>格式:</li><li><code>&lt;hr /&gt;</code><h4 id="2-注意点-2"><a href="#2-注意点-2" class="headerlink" title="2.注意点:"></a>2.注意点:</h4></li><li>在浏览器中会单独占一行</li><li>通过我的观察发现HR标签可以写/也可以不写<ul><li>如果不写/那么就是按照HTML的规范来编写</li><li>如果写上/那么就是按照XHTML的规范来编写.</li></ul></li><li>由于hr标签是用来修改样式的, 所以不推荐使用. 今后开发中添加水平线一般都使用CSS盒子来做</li></ul><h2 id="六-HTML注释-Annotation"><a href="#六-HTML注释-Annotation" class="headerlink" title="六.HTML注释(Annotation)"></a>六.HTML注释(Annotation)</h2><h4 id="1-什么是注释"><a href="#1-什么是注释" class="headerlink" title="1.什么是注释?"></a>1.什么是注释?</h4><h4 id="1-注释格式"><a href="#1-注释格式" class="headerlink" title="1.注释格式"></a>1.注释格式</h4><p><code>&lt;!--被注释的内容--&gt;</code></p><h4 id="2-注意点-3"><a href="#2-注意点-3" class="headerlink" title="2.注意点:"></a>2.注意点:</h4><ul><li>被注释的内容不会在浏览器中显示, 注释是写给我们自己看的<ul><li>注释不能嵌套使用</li></ul></li></ul><p><code>&lt;!--&lt;!--被注释的内容--&gt;--&gt;</code></p><h4 id="3-快捷键-ctrl"><a href="#3-快捷键-ctrl" class="headerlink" title="3.快捷键: ctrl + /"></a>3.快捷键: <code>ctrl + /</code></h4><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;标题1&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;标题2&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;标题3&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;标题4&lt;/h4&gt;</span><br><span class="line">&lt;h5&gt;标题5&lt;/h5&gt;</span><br><span class="line">&lt;h6&gt;标题6&lt;/h6&gt;</span><br><span class="line">&lt;h7&gt;我是假的,标题7&lt;/h7&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--我是注释--&gt;</span><br><span class="line">&lt;hr /&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;告诉浏览器哪些文字是一个段落&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--下面是分割线--&gt;</span><br><span class="line">&lt;hr /&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-1ebb54835bf8f28b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_10.png"></p><h2 id="七-img标签-image"><a href="#七-img标签-image" class="headerlink" title="七.img标签(image)"></a>七.img标签(image)</h2><h3 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1) 作用:"></a>1) 作用:</h3><ul><li>在网页上插入一张图片</li></ul><h3 id="2-格式-2"><a href="#2-格式-2" class="headerlink" title="2) 格式:"></a>2) 格式:</h3><ul><li><code>![image](http://note.youdao.com/favicon.ico)</code></li></ul><h3 id="3-标签的属性"><a href="#3-标签的属性" class="headerlink" title="3) 标签的属性"></a>3) 标签的属性</h3><ul><li>写在标签中K=”V”这种格式的文本我们称之为标签属性</li></ul><table><thead><tr><th>属性名称</th><th>作用</th></tr></thead><tbody><tr><td>src(source)</td><td>告诉浏览器需要插入的图片路径, 以便于浏览器到该路径下找到需要插入的图片</td></tr><tr><td>alt(alternate)</td><td>规定图像的替代文本, 只有在src指定的路径下找不到图片,才会显示alt指定的文本</td></tr><tr><td>title</td><td>悬停文本(介绍这张图片, 只有在鼠标移动到图片上时才会显示)</td></tr><tr><td>height</td><td>设置图片显示的高度</td></tr><tr><td>width</td><td>设置图片显示的宽度</td></tr></tbody></table><h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4) 注意点:"></a>4) 注意点:</h3><ul><li>img标签添加的图片默认不是占一整行空间<br>如果想让图片等比拉伸,只写高度或者宽度即可</li></ul><h3 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5) 示例代码"></a>5) 示例代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--图片标签--&gt;</span><br><span class="line">![](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">![有道云笔记](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">![有道云笔记](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">![有道云笔记](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">![有道云笔记](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">![有道云笔记](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">&lt;img src=<span class="string">""</span> alt=<span class="string">"找不到图片"</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5) 运行结果"></a>5) 运行结果</h3><p><img src="http://upload-images.jianshu.io/upload_images/4122543-9ff009b644bc64cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_12.png"></p><h2 id="八-br标签-Break"><a href="#八-br标签-Break" class="headerlink" title="八.br标签(Break)"></a>八.br标签(Break)</h2><h3 id="1-作用-6"><a href="#1-作用-6" class="headerlink" title="1) 作用:"></a>1) 作用:</h3><ul><li>让内容换行<h3 id="2-格式-3"><a href="#2-格式-3" class="headerlink" title="2) 格式:"></a>2) 格式:</h3></li><li><code>&lt;br/&gt;</code><h3 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3) 注意点:"></a>3) 注意点:</h3></li><li>br的意思是不另起一个段落进行换行, 而网页中99.99%需要换行时都是因为另起了一个段落, 所以应该用p来做</li></ul><h2 id="九-a标签-anchor"><a href="#九-a标签-anchor" class="headerlink" title="九.a标签(anchor)"></a>九.a标签(anchor)</h2><h3 id="1-格式"><a href="#1-格式" class="headerlink" title="1) 格式:"></a>1) 格式:</h3><ul><li><code>&lt;a href=&quot;http://www.jianshu.com/u/5bd5e9ed569e&quot;&gt;我的简书&lt;/a&gt;</code><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2) 作用:"></a>2) 作用:</h3></li><li>用于从一个页面链接到另一个页面<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3) 注意事项:"></a>3) 注意事项:</h3></li><li>在a标签之间一定要写上文字, 如果没有, 那么在页面上找不到这个标签<br>a标签也叫做超级链接或超链接<h3 id="4-a标签的属性"><a href="#4-a标签的属性" class="headerlink" title="4) a标签的属性"></a>4) a标签的属性</h3></li></ul><table><thead><tr><th>属性名称</th><th>作用</th></tr></thead><tbody><tr><td>href(hypertext reference)</td><td>指定跳转的目标地址</td></tr><tr><td>target</td><td>告诉浏览器是否保留原始界面, _blank保留, _self不保留</td></tr><tr><td>title</td><td>悬停文本(介绍这个链接, 只有在鼠标移动到超链接上时才会显示)</td></tr></tbody></table><h4 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4) 代码示例"></a>4) 代码示例</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--a标签--&gt;</span><br><span class="line">&lt;a href="http://www.jianshu.com/u/5bd5e9ed569e"&gt;我的简书&lt;/a&gt;</span><br><span class="line">&lt;a href="http://www.jianshu.com/u/5bd5e9ed569e" title="我的简书"&gt;我的简书&lt;/a&gt;</span><br><span class="line">&lt;a href="http://www.jianshu.com/u/5bd5e9ed569e" title="我的简书" target="_blank"&gt;我的简书&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4122543-b60bbd6bcf56af2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_13.png"></p><h3 id="5-base标签和a标签结合使用"><a href="#5-base标签和a标签结合使用" class="headerlink" title="5) base标签和a标签结合使用"></a>5) base标签和a标签结合使用</h3><ul><li>如果每个a标签都想在新页面中打开,那么逐个设置a标签的<code>target</code>属性比较麻烦, 这时我们可以使用base和a标签结合的方式,一次性设置有a标签都在新页面中打开<ul><li>格式: <code>&lt;base target=&quot;_blank&quot; /&gt;</code></li></ul></li><li>注意事项:<ul><li><code>base</code>必须嵌套在<code>head</code>标签里面</li><li>如果标签上指定了<code>target</code>,<code>base</code>中也指定了<code>target</code>,那么会按照标签上指定的来执行<h3 id="6-a标签其它用法"><a href="#6-a标签其它用法" class="headerlink" title="6) a标签其它用法"></a>6) a标签其它用法</h3></li></ul></li><li>假链接(本质是跳转到当前页面)<ul><li>格式<code>&lt;a href=&quot;#&quot;&gt;我的简书&lt;/a&gt;</code></li><li>格式<code>&lt;a href=&quot;javascript:&quot;&gt;我的简书&lt;/a&gt;</code><ul><li>跳转到当前页面指定位置(锚点链接)</li><li>1.格式<code>&lt;a href=&quot;#location&quot;&gt;</code>跳转到指定位置<code>&lt;/a&gt;</code></li><li>2.在页面的指定位置给任意标签添加一个id属性<ul><li>例如 <code>&lt;p id=&quot;location&quot;&gt;</code>这个是目标<code>&lt;/p&gt;</code></li></ul></li></ul></li><li>跳转到指定页面的指定位置<ul><li>格式: <code>&lt;a href=&quot;01-锚点链接.html#location&quot;&gt;跳转到指定位置&lt;/a&gt;</code></li><li>只需要在01-锚点链接.html页面添加一个id位置即可</li></ul></li><li>下载(极力不推荐使用)<ul><li>例如<code>&lt;a href=&quot;girl.zip&quot;&gt;</code>下载福利资源<code>&lt;a/&gt;</code></li></ul></li></ul></li></ul><blockquote><ul><li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040" target="_blank" rel="noopener">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5标签 </tag>
            
            <tag> CSS </tag>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5基本介绍</title>
      <link href="/2017/06/15/HTML5%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
      <content type="html"><![CDATA[<h2 id="一-网页固定格式"><a href="#一-网页固定格式" class="headerlink" title="一.网页固定格式"></a>一.网页固定格式</h2><h3 id="1-编写网页的步骤"><a href="#1-编写网页的步骤" class="headerlink" title="1.编写网页的步骤:"></a>1.编写网页的步骤:</h3><ul><li>新建一个文本文档</li><li>利用记事本打开</li><li>编写THML代码</li><li>保存并且修改纯文本文档的扩展名为.html</li><li>利用浏览器打开编写好的文件</li></ul><a id="more"></a><h2 id="一-网页固定格式-1"><a href="#一-网页固定格式-1" class="headerlink" title="一.网页固定格式"></a>一.网页固定格式</h2><h3 id="1-编写网页的步骤-1"><a href="#1-编写网页的步骤-1" class="headerlink" title="1.编写网页的步骤:"></a>1.编写网页的步骤:</h3><ul><li>新建一个文本文档</li><li>利用记事本打开</li><li>编写THML代码</li><li>保存并且修改纯文本文档的扩展名为.html</li><li>利用浏览器打开编写好的文件</li></ul><blockquote><p>一款强大的编辑软件  <a href="http://www.sdifen.com/?s=webstorm+&amp;submit=搜索" target="_blank" rel="noopener">Webstorm</a>或者 <a href="http://www.pc6.com/mac/112553.html" target="_blank" rel="noopener">WebStorm</a></p></blockquote><h4 id="1-1-WebStorm常见快捷键"><a href="#1-1-WebStorm常见快捷键" class="headerlink" title="1.1 WebStorm常见快捷键"></a>1.1 WebStorm常见快捷键</h4><ul><li><p>如何在<code>WebStorm</code>中利用快捷键创建一个新的<code>.html</code>的文件</p><ul><li>同时按下键盘上的<code>Ctrl + Alt + Insert</code></li></ul></li><li><p>如何在<code>WebStorm</code>中让光标移动到当前行的末尾</p><ul><li>按下键盘上的<code>End</code>键即可</li></ul></li><li><p>如何在<code>WebStorm</code>中让光标移动到当前行的最前面</p><ul><li>按下键盘上的<code>Home</code>键即可</li></ul></li><li><p>如何在<code>WebStorm</code>中让光标在多行中闪烁</p><ul><li>按住键盘上的Alt键不放, 然后再按住鼠标的左键不放, 然后再拖动鼠标即可</li></ul></li><li><p>如何在<code>WebStorm</code>中快速的复制光标所在的那一行</p><ul><li>按下键盘上的<code>Ctrl + D</code></li></ul></li><li><p>如何在<code>WebStorm</code>中快速的删除光标所在的那一行</p><ul><li>按下键盘上的<code>Ctrl + X</code></li></ul></li><li><p>如何在<code>WebStorm</code>中让标签包裹一段内容, 也就是自动在一段内容前后加上标签</p><ul><li>按下键盘上的<code>Ctrl + Alt + T</code>, 然后按下回车, 然后输入对应的标签即可</li></ul></li></ul><h3 id="2-网页基本结构"><a href="#2-网页基本结构" class="headerlink" title="2.网页基本结构"></a>2.网页基本结构</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;音视频测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>通过观察我们发现, HTML基本结构中所有的标签都是成对出现的, 这些成对出现的标签中有一个带/有一个不带/, 那么这些不带/的标签我们称之为开始标签, 这些带/的我们称之为结束标签</li></ul><h2 id="二-网页标签"><a href="#二-网页标签" class="headerlink" title="二.网页标签"></a>二.网页标签</h2><h3 id="1-HTML标签"><a href="#1-HTML标签" class="headerlink" title="1.HTML标签"></a>1.HTML标签</h3><ul><li>作用: 用于告诉浏览器这是一个网页, 也就是说告诉浏览器我是一个HTML文档<blockquote><p>注意点: 其它所有的标签都必须写在html标签里面, 也就是写在html开始标签和结束标签中间</p></blockquote></li></ul><h3 id="2-head标签"><a href="#2-head标签" class="headerlink" title="2.head标签"></a>2.head标签</h3><ul><li>作用:<br>用于给网站添加一些配置信息</li><li>例如:<ul><li>指定网站的标题 / 指定网站的小图片</li><li>添加网站的SEO相关的信息(指定网站的关键字/指定网站的描述信息)</li><li>外挂一些外部的css/js文件</li><li>添加一些浏览器适配相关的内容<blockquote><p>注意点:<br>一般情况下, 写在head标签内部的内容都不会显示给用户查看, 也就是说一般情况下写在head标签内部的内容我们都看不到</p></blockquote></li></ul></li></ul><h3 id="3-title标签"><a href="#3-title标签" class="headerlink" title="3.title标签"></a>3.title标签</h3><ul><li>作用:<br>专门用于指定网站的标题, 并且这个指定的标题将来还会作为用户保存网站的默认标题<blockquote><p>注意点:<br>title标签必须写在head标签里面</p></blockquote></li></ul><h3 id="4-body标签"><a href="#4-body标签" class="headerlink" title="4.body标签"></a>4.body标签</h3><ul><li>作用:<br>专门用于定义HTML文档中需要显示给用户查看的内容(文字/图片/音频/视频)<blockquote><p>注意点:<br>虽然说有时候你可能将内容写到了别的地方在网页中也能看到, 但是千万不要这么干, 一定要将需要显示的内容写在body中<br>一对html标签中(一个html开始标签和一个html结束标签)只能有一对body标签</p></blockquote></li></ul><h3 id="5-meta标签"><a href="#5-meta标签" class="headerlink" title="5.meta标签"></a>5.meta标签</h3><ul><li>作用 : 在编写网页的时候指定字符集,可避免出现乱码现象</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="GBK-GB2312-和UTF-8区别"><a href="#GBK-GB2312-和UTF-8区别" class="headerlink" title="GBK(GB2312)和UTF-8区别"></a>GBK(GB2312)和UTF-8区别</h4><ul><li>GBK(GB2312)里面存储的字符比较少, 仅仅存储了汉字和一些常用外文<br>体积比较小</li><li>UTF-8里面存储的世界上所有的文字,提交比较大<blockquote><h4 id="个人推荐-所有一律都写UTF-8"><a href="#个人推荐-所有一律都写UTF-8" class="headerlink" title="个人推荐:所有一律都写UTF-8"></a>个人推荐:所有一律都写UTF-8</h4></blockquote></li></ul><h2 id="3-HTML标签分类"><a href="#3-HTML标签分类" class="headerlink" title="3.HTML标签分类"></a>3.HTML标签分类</h2><h3 id="1-单标签"><a href="#1-单标签" class="headerlink" title="1.单标签"></a>1.单标签</h3><ul><li>只有开始标签没有结束标签, 也就是由一个&lt;&gt;组成的</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="2-双标签"><a href="#2-双标签" class="headerlink" title="2.双标签"></a>2.双标签</h3><p> 有开始标签和结束标签, 也就是由一个&lt;&gt;和一个&lt;/&gt;组成的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="4-HTML标签关系分类"><a href="#4-HTML标签关系分类" class="headerlink" title="4.HTML标签关系分类"></a>4.HTML标签关系分类</h2><h3 id="1-并列关系-兄弟-平级"><a href="#1-并列关系-兄弟-平级" class="headerlink" title="1.并列关系(兄弟/平级)"></a>1.并列关系(兄弟/平级)</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="2-嵌套关系-父子-上下级"><a href="#2-嵌套关系-父子-上下级" class="headerlink" title="2.嵌套关系(父子/上下级)"></a>2.嵌套关系(父子/上下级)</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">"UTF-8"</span> /&gt;</span><br><span class="line">      &lt;title&gt;音视频测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><blockquote><ul><li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040" target="_blank" rel="noopener">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5标签 </tag>
            
            <tag> CSS </tag>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift项目创建桥接文件</title>
      <link href="/2017/06/15/Swift%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%A1%A5%E6%8E%A5%E6%96%87%E4%BB%B6/"/>
      <content type="html"><![CDATA[<h2 id="一-创建具体步骤参考"><a href="#一-创建具体步骤参考" class="headerlink" title="一.创建具体步骤参考"></a>一.创建具体步骤参考</h2><p><a href="http://www.jianshu.com/p/aa27548ce9e1" target="_blank" rel="noopener">Object-C 和 swift桥接文件</a></p><a id="more"></a><h2 id="二-报错"><a href="#二-报错" class="headerlink" title="二.报错"></a>二.报错</h2><blockquote><p>如出现 xxx file not found 的错误</p></blockquote><h3 id="参考解决-文中解释比较详细"><a href="#参考解决-文中解释比较详细" class="headerlink" title="参考解决(文中解释比较详细)"></a>参考解决(文中解释比较详细)</h3><p><a href="http://www.cnblogs.com/XYQ-208910/p/6252744.html" target="_blank" rel="noopener"><a href="http://www.cnblogs.com/XYQ-208910/p/6252744.html" target="_blank" rel="noopener">Swift: 在Swift中桥接OC文件（自己创建的类文件、第三方库文件）</a></a></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 桥接 </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift仿网易新闻首页左右滑动切换页面</title>
      <link href="/2017/06/12/Swift%E4%BB%BF%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BB%E9%A6%96%E9%A1%B5%E5%B7%A6%E5%8F%B3%E6%BB%91%E5%8A%A8%E5%88%87%E6%8D%A2%E9%A1%B5%E9%9D%A2/"/>
      <content type="html"><![CDATA[<blockquote><p>顶部标题左右滑动切换控制器是一种非常用的左右滚动切换效果,几乎每一个APP都有用到,在这里介绍一下我自己封装的一个Swift版本的简单框架;代码中注释相对详细,故文中没有做过多的解释;废话不多少,直接上效果图:</p></blockquote><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/4122543-91d007e59b3a6ce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图1.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/4122543-047cf052039633e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图2.png"></p><h2 id="一-框架介绍"><a href="#一-框架介绍" class="headerlink" title="一.框架介绍"></a>一.框架介绍</h2><h2 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a><a href="https://github.com/coderQuanjun/TJPageView" target="_blank" rel="noopener">github地址</a></h2><p><img src="http://upload-images.jianshu.io/upload_images/4122543-7f8bb034a432d133.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170612_18.png"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TJTitleStyle.swift  <span class="comment">//控制框架所有显示样式的参数值</span></span><br><span class="line"></span><br><span class="line">TJTitleView.swift <span class="comment">//顶部标题的处理view</span></span><br><span class="line"></span><br><span class="line">TJContentView.swift <span class="comment">//处理所有控制器的view</span></span><br><span class="line"></span><br><span class="line">TJPageView.swift  <span class="comment">//控制整体框架的总试图View</span></span><br></pre></td></tr></table></figure><h3 id="TJTitleStyle-swift"><a href="#TJTitleStyle-swift" class="headerlink" title="TJTitleStyle.swift"></a>TJTitleStyle.swift</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// 是否是滚动的Title</span></span><br><span class="line">var isScrollEnable : Bool = <span class="literal">false</span></span><br><span class="line"><span class="comment">/// 普通Title颜色</span></span><br><span class="line">var normalColor : <span class="built_in">UIColor</span> = <span class="built_in">UIColor</span>(r: <span class="number">0</span>, g: <span class="number">0</span>, b: <span class="number">0</span>)</span><br><span class="line"><span class="comment">/// 选中Title颜色</span></span><br><span class="line">var selectedColor : <span class="built_in">UIColor</span> = <span class="built_in">UIColor</span>(r: <span class="number">255</span>, g: <span class="number">127</span>, b: <span class="number">0</span>)</span><br><span class="line"><span class="comment">/// Title字体大小</span></span><br><span class="line">var font : <span class="built_in">UIFont</span> = <span class="built_in">UIFont</span>.systemFont(ofSize: <span class="number">14.0</span>)</span><br><span class="line"><span class="comment">/// 滚动Title的字体间距</span></span><br><span class="line">var titleMargin : <span class="built_in">CGFloat</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">/// title的高度</span></span><br><span class="line">var titleHeight : <span class="built_in">CGFloat</span> = <span class="number">44</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否显示底部滚动条</span></span><br><span class="line">var isShowBottomLine : Bool = <span class="literal">false</span></span><br><span class="line"><span class="comment">/// 底部滚动条的颜色</span></span><br><span class="line">var bottomLineColor : <span class="built_in">UIColor</span> = <span class="built_in">UIColor</span>.orange</span><br><span class="line"><span class="comment">/// 底部滚动条的高度</span></span><br><span class="line">var bottomLineH : <span class="built_in">CGFloat</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否进行缩放</span></span><br><span class="line">var isNeedScale : Bool = <span class="literal">false</span></span><br><span class="line">var scaleRange : <span class="built_in">CGFloat</span> = <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否显示遮盖</span></span><br><span class="line">var isShowCover : Bool = <span class="literal">false</span></span><br><span class="line"><span class="comment">/// 遮盖背景颜色</span></span><br><span class="line">var coverBgColor : <span class="built_in">UIColor</span> = <span class="built_in">UIColor</span>.lightGray</span><br><span class="line"><span class="comment">/// 文字&amp;遮盖间隙</span></span><br><span class="line">var coverMargin : <span class="built_in">CGFloat</span> = <span class="number">5</span></span><br><span class="line"><span class="comment">/// 遮盖的高度</span></span><br><span class="line">var coverH : <span class="built_in">CGFloat</span> = <span class="number">25</span></span><br><span class="line"><span class="comment">/// 设置圆角大小</span></span><br><span class="line">var coverRadius : <span class="built_in">CGFloat</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="TJPageCollectionLayout-swift自定义布局"><a href="#TJPageCollectionLayout-swift自定义布局" class="headerlink" title="TJPageCollectionLayout.swift自定义布局"></a>TJPageCollectionLayout.swift自定义布局</h3><blockquote><p>代码如下,注释比较详尽,不做赘述</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    在该方法中设定一些必要的layout的结构和初始需要的参数</span></span><br><span class="line">override func prepare() &#123;</span><br><span class="line">    <span class="keyword">super</span>.prepare()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//0.计算item的宽度和高度</span></span><br><span class="line">    let itemW = ((collectionView?.bounds.width)! - sectionInset.left - sectionInset.right - minimumInteritemSpacing * <span class="built_in">CGFloat</span>(cols - <span class="number">1</span>)) / <span class="built_in">CGFloat</span>(cols)</span><br><span class="line">    let itemH = ((collectionView?.bounds.height)! - sectionInset.top - sectionInset.bottom - minimumLineSpacing * <span class="built_in">CGFloat</span>(rows - <span class="number">1</span>)) / <span class="built_in">CGFloat</span>(rows)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.获取一共多少个组</span></span><br><span class="line">    let sectionCount = collectionView!.numberOfSections</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.获取每个组中有多少个item</span></span><br><span class="line">    var prePageCount : Int = <span class="number">0</span>    <span class="comment">//页数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;sectionCount &#123;</span><br><span class="line">        let itemCount = collectionView!.numberOfItems(inSection: i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0.</span>.&lt;itemCount &#123;</span><br><span class="line">            <span class="comment">//2.1获取cell对应的indexPath</span></span><br><span class="line">            let indexpath = IndexPath(item: j, section: i)</span><br><span class="line">            <span class="comment">//2.2根据indexPath创建UICollectionViewLayoutAttributes</span></span><br><span class="line">            let attr = <span class="built_in">UICollectionViewLayoutAttributes</span>(forCellWith: indexpath)</span><br><span class="line">            <span class="comment">// 2.3.计算j在该组中第几页</span></span><br><span class="line">            let page = j / (cols * rows)</span><br><span class="line">            let index = j % (cols * rows)</span><br><span class="line">            <span class="comment">//2.4设置attrs的frame</span></span><br><span class="line">            let itemY = sectionInset.top + (itemH + minimumLineSpacing) * <span class="built_in">CGFloat</span>(index / cols)</span><br><span class="line">            let itemX = <span class="built_in">CGFloat</span>(prePageCount + page) * collectionView!.bounds.width +  sectionInset.left + (itemW + minimumInteritemSpacing) * <span class="built_in">CGFloat</span>(index % cols)</span><br><span class="line">            attr.frame = <span class="built_in">CGRect</span>(x: itemX, y: itemY, width: itemW, height: itemH)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2.5加入到数组中</span></span><br><span class="line">            cellAttrs.append(attr)</span><br><span class="line">        &#125;</span><br><span class="line">        prePageCount += (itemCount - <span class="number">1</span>) / (cols * rows) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算最大宽度</span></span><br><span class="line">    maxWidth = <span class="built_in">CGFloat</span>(prePageCount) * collectionView!.bounds.width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TJPageCollectionView-swift"><a href="#TJPageCollectionView-swift" class="headerlink" title="TJPageCollectionView.swift"></a>TJPageCollectionView.swift</h3><blockquote><p>创建collectionView显示布局内容,设置代理方法和对外暴露的方法</p></blockquote><h4 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protocol TJPageCollectionViewDateSource : <span class="keyword">class</span> &#123;</span><br><span class="line">   <span class="comment">//返回section的个数</span></span><br><span class="line">    func numberOfSections(<span class="keyword">in</span> pageCollectionView : TJPageCollectionView) -&gt; Int</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回每个section中item的个数</span></span><br><span class="line">    func pageCollectionView(_ collectionView : TJPageCollectionView, numberOfItemsInSection section : Int) -&gt; Int</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cell</span></span><br><span class="line">    func pageCollectionView(_ pageCollectionView : TJPageCollectionView, _ collectionView : <span class="built_in">UICollectionView</span>, cellForItemAt indexPath : IndexPath) -&gt; <span class="built_in">UICollectionViewCell</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol TJPageCollectionViewDelegate : <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">//cell点击事件处理</span></span><br><span class="line">    func pageCollectionView(_ pageCollectionView : TJPageCollectionView, didSelectorItemAt indexPath : IndexPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-首页左右滑动调用方法"><a href="#二-首页左右滑动调用方法" class="headerlink" title="二.首页左右滑动调用方法"></a>二.首页左右滑动调用方法</h2><h4 id="1-设置显示样式"><a href="#1-设置显示样式" class="headerlink" title="1.设置显示样式"></a>1.设置显示样式</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let style  = TJTitleStyle()</span><br><span class="line"><span class="comment">//是否可以滚动</span></span><br><span class="line">style.isScrollEnable = <span class="literal">true</span></span><br><span class="line"><span class="comment">//是否显示下划线</span></span><br><span class="line">style.isShowBottomLine = <span class="literal">true</span></span><br><span class="line"><span class="comment">//是否显示遮挡试图view</span></span><br><span class="line">style.isShowCover = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="2-初始化方法"><a href="#2-初始化方法" class="headerlink" title="2.初始化方法"></a>2.初始化方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**初始化方法</span></span><br><span class="line"><span class="comment">* frame    : 坐标</span></span><br><span class="line"><span class="comment">* titles   : 标题数组</span></span><br><span class="line"><span class="comment">* style    : 样式</span></span><br><span class="line"><span class="comment">* childVcs : 自控制器数组</span></span><br><span class="line"><span class="comment">* parentVc : 父控制器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">let pageView = TJPageView(frame: frame, titles: titles, style: style, childVcs: childVcs, parentVc: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">view.addSubview(pageView)</span><br></pre></td></tr></table></figure><h2 id="三-底部类似表情键盘布局调用方法"><a href="#三-底部类似表情键盘布局调用方法" class="headerlink" title="三.底部类似表情键盘布局调用方法"></a>三.底部类似表情键盘布局调用方法</h2><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.设置显示样式</span></span><br><span class="line">let style = TJTitleStyle()</span><br><span class="line">style.isShowBottomLine = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//2.设置cell布局Layout</span></span><br><span class="line">let layout = TJPageCollectionLayout()</span><br><span class="line">layout.cols = <span class="number">7</span> <span class="comment">// 列</span></span><br><span class="line">layout.rows = <span class="number">3</span> <span class="comment">// 行</span></span><br><span class="line">layout.minimumLineSpacing = <span class="number">0</span></span><br><span class="line">layout.minimumInteritemSpacing = <span class="number">0</span></span><br><span class="line">layout.sectionInset = <span class="built_in">UIEdgeInsets</span>(top: <span class="number">10</span>, left: <span class="number">10</span>, bottom: <span class="number">10</span>, right: <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//3.创建collectionView</span></span><br><span class="line">let pageCollection = TJPageCollectionView(frame: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="built_in">UIScreen</span>.main.bounds.height - <span class="number">250</span>, width: <span class="built_in">UIScreen</span>.main.bounds.width, height: <span class="number">250</span>), style: style, titles: [<span class="string">"普通"</span>, <span class="string">"粉丝"</span>], isTitleInTop: <span class="literal">false</span>, layout: layout)</span><br><span class="line">pageCollection.delegate = <span class="keyword">self</span></span><br><span class="line">pageCollection.dataSource = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.注册cell</span></span><br><span class="line">pageCollection.register(nib: <span class="built_in">UINib</span>(nibName: <span class="string">"EmoticonViewCell"</span>, bundle: <span class="literal">nil</span>), identifier: kEmoticonCellID)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.添加到视图中</span></span><br><span class="line">view.addSubview(pageCollection)</span><br></pre></td></tr></table></figure><h4 id="2-遵循协议"><a href="#2-遵循协议" class="headerlink" title="2.遵循协议"></a>2.遵循协议</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: TJCollectionViewDateSource</span></span><br><span class="line">extension NextViewController : TJPageCollectionViewDateSource&#123;</span><br><span class="line">    func numberOfSections(<span class="keyword">in</span> pageCollectionView: TJPageCollectionView) -&gt; Int &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    func pageCollectionView(_ collectionView: TJPageCollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">40</span></span><br><span class="line">    &#125;</span><br><span class="line">    func pageCollectionView(_ pageCollectionView: TJPageCollectionView, _ collectionView: <span class="built_in">UICollectionView</span>, cellForItemAt indexPath: IndexPath) -&gt; <span class="built_in">UICollectionViewCell</span> &#123;</span><br><span class="line">        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: kEmoticonCellID, <span class="keyword">for</span>: indexPath) as! EmoticonViewCell</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK: TJPageCollectionViewDelegate</span></span><br><span class="line">extension NextViewController : TJPageCollectionViewDelegate&#123;</span><br><span class="line">    func pageCollectionView(_ pageCollectionView: TJPageCollectionView, didSelectorItemAt indexPath: IndexPath) &#123;</span><br><span class="line">        print(indexPath)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><ul><li>框架代码中可能还有不足之处,还望大神多多指教.</li></ul></blockquote><blockquote><ul><li>菜鸟一枚,多多交流.</li></ul></blockquote><blockquote><ul><li><a href="https://github.com/coderQuanjun/TJPageView" target="_blank" rel="noopener">github地址</a></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> Swiftk框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS9之UIStackView的使用</title>
      <link href="/2017/06/10/iOS9%E4%B9%8BUIStackView%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <content type="html"><![CDATA[<p>苹果在iOS9新增了一个简易的布局控件UIStackView,它是一个基于 Auto Layout 的抽象层从而使布局属性的创建简单化,它可以将一组 UIView 视图进行垂直或水平方向的排列。</p><ul><li>UIStackView 既可以用代码编写也可以在 Interface Builder 中设计(简易xib更方便适用)。</li><li>你可以在一个主 UIStackView 中嵌套 UIStackView 从而让视图精确放置到相应的位置</li></ul><a id="more"></a><blockquote><p>下面就具体介绍一下UIStackView的一些方法和属性</p></blockquote><h2 id="一-方法"><a href="#一-方法" class="headerlink" title="一.方法"></a>一.方法</h2><h3 id="1-初始化数组"><a href="#1-初始化数组" class="headerlink" title="1.初始化数组"></a>1.初始化数组</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//OC中</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithArrangedSubviews:(<span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">UIView</span> *&gt; *)views;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift</span></span><br><span class="line"></span><br><span class="line">let stackView1 = <span class="built_in">UIStackView</span>(arrangedSubviews: subViews)</span><br></pre></td></tr></table></figure><h3 id="2-添加子视图"><a href="#2-添加子视图" class="headerlink" title="2.添加子视图"></a>2.添加子视图</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//OC</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addArrangedSubview:(<span class="built_in">UIView</span> *)view;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift</span></span><br><span class="line"></span><br><span class="line">stackView.addArrangedSubview(<span class="built_in">UIView</span>)</span><br></pre></td></tr></table></figure><h3 id="3-移除子视图"><a href="#3-移除子视图" class="headerlink" title="3.移除子视图"></a>3.移除子视图</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//OC</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeArrangedSubview:(<span class="built_in">UIView</span> *)view;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift</span></span><br><span class="line"></span><br><span class="line">stackView1.removeArrangedSubview(<span class="built_in">UIView</span>)</span><br></pre></td></tr></table></figure><h3 id="4-根据下标插入子视图"><a href="#4-根据下标插入子视图" class="headerlink" title="4.根据下标插入子视图"></a>4.根据下标插入子视图</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//OC</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)insertArrangedSubview:(<span class="built_in">UIView</span> *)view atIndex:(<span class="built_in">NSUInteger</span>)stackIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift</span></span><br><span class="line"></span><br><span class="line">stackView1.insertArrangedSubview(<span class="built_in">UIView</span>, atIndex: Int)</span><br></pre></td></tr></table></figure><h2 id="二-属性"><a href="#二-属性" class="headerlink" title="二.属性"></a>二.属性</h2><h3 id="1-布局方向"><a href="#1-布局方向" class="headerlink" title="1.布局方向"></a>1.布局方向</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">stackView.axis = .Horizontal</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************/</span></span><br><span class="line"></span><br><span class="line">Horizontal -&gt; <span class="built_in">UILayoutConstraintAxisHorizontal</span></span><br><span class="line"></span><br><span class="line">水平方向布局</span><br><span class="line"></span><br><span class="line">Vertical  -&gt; <span class="built_in">UILayoutConstraintAxisVertical</span></span><br><span class="line"></span><br><span class="line">垂直方向布局</span><br></pre></td></tr></table></figure><h3 id="2-内容物填充样式"><a href="#2-内容物填充样式" class="headerlink" title="2.内容物填充样式"></a>2.内容物填充样式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">stackView.distribution = .FillEqually</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************/</span></span><br><span class="line"></span><br><span class="line">Fill -&gt; <span class="built_in">UIStackViewDistributionFill</span></span><br><span class="line"></span><br><span class="line">填充整个<span class="built_in">UIStackView</span>，并且根据内部子视图尺寸对子视图尺寸进行动态调整。</span><br><span class="line"></span><br><span class="line">Fill Equally -&gt; <span class="built_in">UIStackViewDistributionFillEqually</span></span><br><span class="line"></span><br><span class="line">根据视图大小平均分配<span class="built_in">UIStackView</span>尺寸，等比例填充<span class="built_in">UIStackView</span>，过程中会根据分配的大小改变子视图尺寸。</span><br><span class="line"></span><br><span class="line">Fill Proportionally -&gt; <span class="built_in">UIStackViewDistributionFillProportionally</span></span><br><span class="line"></span><br><span class="line">根据之前的比例填充<span class="built_in">UIStackView</span>。</span><br><span class="line"></span><br><span class="line">Equal Spacing -&gt; <span class="built_in">UIStackViewDistributionEqualSpacing</span></span><br><span class="line"></span><br><span class="line">填充整个<span class="built_in">UIStackView</span>，子视图没有占满<span class="built_in">UIStackView</span>将会用空白平均填充子视图中间的间距，超出<span class="built_in">UIStackView</span>将会根据arrangedSubviews数组下标压缩子视图。</span><br><span class="line"></span><br><span class="line">Equal Centering -&gt; <span class="built_in">UIStackViewDistributionEqualCentering</span></span><br><span class="line"></span><br><span class="line">平均分配子视图得到每个视图的中心点，使用这个中心点来布局每个子视图，并且保持spacing距离，超出将会重新布局子视图，并压缩部分子视图。</span><br></pre></td></tr></table></figure><h3 id="3-视图填充样式"><a href="#3-视图填充样式" class="headerlink" title="3.视图填充样式"></a>3.视图填充样式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">stackView.alignment = .Fill</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************/</span></span><br><span class="line"></span><br><span class="line">Fill -&gt; <span class="built_in">UIStackViewAlignmentFill</span></span><br><span class="line"></span><br><span class="line">视图纵向填充</span><br><span class="line"></span><br><span class="line">Top -&gt; <span class="built_in">UIStackViewAlignmentTop</span></span><br><span class="line"></span><br><span class="line">视图向上对其(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">Center -&gt; <span class="built_in">UIStackViewAlignmentCenter</span></span><br><span class="line"></span><br><span class="line">视图居中对其</span><br><span class="line"></span><br><span class="line">Bottom -&gt; <span class="built_in">UIStackViewAlignmentBottom</span></span><br><span class="line"></span><br><span class="line">视图向下对其(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">First Baseline -&gt; <span class="built_in">UIStackViewAlignmentFirstBaseline</span></span><br><span class="line"></span><br><span class="line">根据上方基线布局所有子视图的y值(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">Last Baseline -&gt; <span class="built_in">UIStackViewAlignmentLastBaseline</span></span><br><span class="line"></span><br><span class="line">根据下方基线布局所有子视图的y值(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">trailing -&gt; <span class="built_in">UIStackViewAlignmentTrailing</span></span><br><span class="line"></span><br><span class="line">视图向左对齐(适用于Vertical模式)</span><br><span class="line"></span><br><span class="line">leading -&gt; <span class="built_in">UIStackViewAlignmentLeading</span></span><br><span class="line"></span><br><span class="line">视图向右对齐(适用于Vertical模式)</span><br></pre></td></tr></table></figure><h3 id="4-子控件之间最小距离"><a href="#4-子控件之间最小距离" class="headerlink" title="4.子控件之间最小距离"></a>4.子控件之间最小距离</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">stackView.spacing = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************/</span></span><br><span class="line"></span><br><span class="line">spacing -&gt; <span class="built_in">CGFloat</span> spacing</span><br></pre></td></tr></table></figure><h3 id="5-基线相对布局"><a href="#5-基线相对布局" class="headerlink" title="5.基线相对布局"></a>5.基线相对布局</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public var baselineRelativeArrangement: Bool</span><br></pre></td></tr></table></figure><blockquote><p>如果YES，则从顶视图的最后基线到底视图的顶部测量两个视图之间的垂直间距。</p></blockquote><h3 id="6-边界相对布局"><a href="#6-边界相对布局" class="headerlink" title="6.边界相对布局"></a>6.边界相对布局</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public var layoutMarginsRelativeArrangement: Bool</span><br></pre></td></tr></table></figure><blockquote><p>决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距，选中 Layout Margins Relative 将相对于标准边界空白来调整subview位置</p></blockquote><p>##Xib创建</p><ul><li>择UIStackView控件直接拖到XIB中。可以选择Horizontal和Vertical两个方向的UIStackView，也可以在拖到XIB中之后手动修改。</li><li>父视图可以将UIStackView作为子视图来进行多层UIStackView嵌套，这也是苹果推荐的做法。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4122543-477dcb03e40d295a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图片1.png"></p><blockquote><ul><li>打开右侧设置面板来设置UIStackView的一些对应属性，达到更好的布局效果。</li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-002b7b5799b9aeee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图片2.png"></p><blockquote><ul><li>除了上面的方法也可以在XIB中直接选择多个View，然后点击右下方的Stack按钮，系统会自动推断布局方式,平均分配空间布局，帮我们自动布局子视图，我们可以在系统布局之后在手动进行调整。</li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4122543-304660a3ee85070d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图片3.png"></p><blockquote><p>作为一枚小菜鸟,不足之处还望大家多多指正,互相学起,共同进步!</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> UIStackView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NSMutableAttributedString富文本</title>
      <link href="/2017/05/19/NSMutableAttributedString%E5%AF%8C%E6%96%87%E6%9C%AC/"/>
      <content type="html"><![CDATA[<p>在iOS开发中，常常会有一段文字显示不同的颜色和字体，或者给某几个文字加删除线或下划线的需求。以及一些直播界面中包含图片和字体的弹幕效果，大部分都是由NSMuttableAttstring（带属性的字符串）实现的。</p><a id="more"></a><h2 id="一、简易使用方法"><a href="#一、简易使用方法" class="headerlink" title="一、简易使用方法"></a>一、简易使用方法</h2><blockquote><p>1、示例代码</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func addAttributeString() -&gt; <span class="built_in">NSMutableAttributedString</span>&#123;</span><br><span class="line">    </span><br><span class="line">    let time = <span class="string">"还剩 19 时 30 分 40 秒 开售"</span></span><br><span class="line">    let timeAtt = <span class="built_in">NSMutableAttributedString</span>(string: time)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字典中存放一些属性名和属性值</span></span><br><span class="line">    let timeDic = [<span class="built_in">NSFontAttributeName</span> : <span class="built_in">UIFont</span>.systemFont(ofSize: <span class="number">18</span>), <span class="built_in">NSForegroundColorAttributeName</span> : <span class="built_in">UIColor</span>.red, <span class="built_in">NSBackgroundColorAttributeName</span> : <span class="built_in">UIColor</span>.orange]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为某一范围内的文字设置多个属性</span></span><br><span class="line">    timeAtt.setAttributes(timeDic, range: <span class="built_in">NSMakeRange</span>(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="comment">//为某一范围内的文字添加单个属性</span></span><br><span class="line">    timeAtt.addAttribute(<span class="built_in">NSFontAttributeName</span>, value: <span class="built_in">UIFont</span>.systemFont(ofSize: <span class="number">18</span>), range: <span class="built_in">NSMakeRange</span>(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="comment">//为某一范围内的文字添加多个属性</span></span><br><span class="line">    timeAtt.addAttributes(timeDic, range: <span class="built_in">NSMakeRange</span>(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="comment">//为某一范围内的文字移除某个属性</span></span><br><span class="line">    timeAtt.removeAttribute(<span class="built_in">NSFontAttributeName</span>, range: <span class="built_in">NSMakeRange</span>(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> timeAtt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符串处理</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拼接字符串</span></span><br><span class="line">timeAtt.append(<span class="built_in">NSAttributedString</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入字符串</span></span><br><span class="line">timeAtt.insert(<span class="built_in">NSAttributedString</span>, at: Int)</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">timeAtt.replaceCharacters(<span class="keyword">in</span>: <span class="built_in">NSRange</span>, with: <span class="built_in">NSAttributedString</span>)</span><br><span class="line">timeAtt.replaceCharacters(<span class="keyword">in</span>: <span class="built_in">NSRange</span>, with: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">timeAtt.removeAttribute(String, range: <span class="built_in">NSRange</span>)</span><br></pre></td></tr></table></figure><blockquote><p>2、常见属性及说明</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSFontAttributeName</span>                设置字体属性，默认值：字体：Helvetica(Neue) 字号：<span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSForegroundColorAttributeNam</span>      设置字体颜色，取值为 <span class="built_in">UIColor</span>对象，默认值为黑色</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSBackgroundColorAttributeName</span>     设置字体所在区域背景颜色，取值为 <span class="built_in">UIColor</span>对象，默认值为<span class="literal">nil</span>, 透明色</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLigatureAttributeName</span>            设置连体属性，取值为<span class="built_in">NSNumber</span> 对象(整数)，<span class="number">0</span> 表示没有连体字符，<span class="number">1</span> 表示使用默认的连体字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSKernAttributeName</span>                设定字符间距，取值为 <span class="built_in">NSNumber</span> 对象（整数），正值间距加宽，负值间距变窄</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSStrikethroughStyleAttributeName</span>  设置删除线，取值为 <span class="built_in">NSNumber</span> 对象（整数）</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSStrikethroughColorAttributeName</span>  设置删除线颜色，取值为 <span class="built_in">UIColor</span> 对象，默认值为黑色</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUnderlineStyleAttributeName</span>      设置下划线，取值为<span class="built_in">NSNumber</span>对象（整数），枚举常量<span class="built_in">NSUnderlineStyle</span>中的值，与删除线类似</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUnderlineColorAttributeName</span>      设置下划线颜色，取值为 <span class="built_in">UIColor</span> 对象，默认值为黑色</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSStrokeWidthAttributeName</span>         设置笔画宽度，取值为 <span class="built_in">NSNumber</span> 对象（整数），负值填充效果，正值中空效果</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSStrokeColorAttributeName</span>         填充部分颜色，不是字体颜色，取值为 <span class="built_in">UIColor</span> 对象</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSShadowAttributeName</span>              设置阴影属性，取值为 <span class="built_in">NSShadow</span> 对象</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSTextEffectAttributeName</span>          设置文本特殊效果，取值为 <span class="built_in">NSString</span> 对象，目前只有图版印刷效果可用：</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSBaselineOffsetAttributeName</span>      设置基线偏移值，取值为 <span class="built_in">NSNumber</span> （<span class="keyword">float</span>）,正值上偏，负值下偏</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSObliquenessAttributeName</span>         设置字形倾斜度，取值为 <span class="built_in">NSNumber</span> （<span class="keyword">float</span>）,正值右倾，负值左倾</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSExpansionAttributeName</span>           设置文本横向拉伸属性，取值为 <span class="built_in">NSNumber</span> （<span class="keyword">float</span>）,正值横向拉伸文本，负值横向压缩文本</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSWritingDirectionAttributeName</span>    设置文字书写方向，从左向右书写或者从右向左书写</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSVerticalGlyphFormAttributeName</span>   设置文字排版方向，取值为 <span class="built_in">NSNumber</span> 对象(整数)，<span class="number">0</span> 表示横排文本，<span class="number">1</span> 表示竖排文本</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLinkAttributeName</span>                设置链接属性，点击后调用浏览器打开指定URL地址</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSAttachmentAttributeName</span>          设置文本附件,取值为<span class="built_in">NSTextAttachment</span>对象,常用于文字图片混排</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSParagraphStyleAttributeName</span>      设置文本段落排版格式，取值为 <span class="built_in">NSParagraphStyle</span> 对象</span><br></pre></td></tr></table></figure><blockquote><h2 id="更多方法和属性说明详见苹果官方说明文档"><a href="#更多方法和属性说明详见苹果官方说明文档" class="headerlink" title="更多方法和属性说明详见苹果官方说明文档"></a><a href="https://developer.apple.com/reference/foundation/nsmutableattributedstring#//apple_ref/doc/uid/TP40003689" target="_blank" rel="noopener">更多方法和属性说明详见苹果官方说明文档</a></h2></blockquote><h2 id="二实现图文混排"><a href="#二实现图文混排" class="headerlink" title="二实现图文混排"></a>二实现图文混排</h2><blockquote><p>效果如图</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/2092665-fa45440126fc57c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><p>实例代码</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,富文本字符串</span></span><br><span class="line">let attText = <span class="built_in">NSMutableAttributedString</span>(string: <span class="string">"你好不好"</span>)</span><br><span class="line">attText.setAttributes([<span class="built_in">NSForegroundColorAttributeName</span> : <span class="built_in">UIColor</span>.orange], range: <span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2,图片处理</span></span><br><span class="line">let attachment = <span class="built_in">NSTextAttachment</span>()</span><br><span class="line">attachment.image = <span class="built_in">UIImage</span>(named: <span class="string">"tt1"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//3,计算文字高度</span></span><br><span class="line">let lineHeight = label.font.lineHeight</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4,设置图片的显示大小</span></span><br><span class="line">attachment.bounds = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: lineHeight, height: lineHeight)</span><br><span class="line"><span class="comment">//5,图片转成富文本</span></span><br><span class="line">let picAtt = <span class="built_in">NSAttributedString</span>(attachment: attachment)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//6,插入到原字符串中</span></span><br><span class="line">attText.insert(picAtt, at: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>菜鸟一枚,文中如有不妥之处还望多多指正;互相学习共同进步!</p></blockquote><blockquote><p>喜欢的朋友可以点下喜欢,并关注下!</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 富文本 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift函数式编程之Map&amp;Reduce&amp;Filter</title>
      <link href="/2017/05/19/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8BMap&amp;Reduce&amp;Filter/"/>
      <content type="html"><![CDATA[<ul><li>什么是函数式编程呢?<ul><li>函数式编程其实是一种编程思想, 代码写出来只是它的表现形式.</li><li>在面向对象的编程思想中, 我们将要解决的一个个问题, 抽象成一个个类, 通过给类定义属性和方法, 让类帮助我们解决需要处理的问题.(其实面向对象也叫命令式编程, 就像给对象下一个个命令)</li><li>而在函数式编程中, 我们则通过函数描述我们要解决的问题, 以及解决问题需要怎样的方案.</li><li>函数本身可以作为变量, 作为参数, 作为返回值(这样说有一点抽象, 下面的解决方案中就是将函数作为函数的参数)</li></ul></li></ul><a id="more"></a><h3 id="1-Map的介绍"><a href="#1-Map的介绍" class="headerlink" title="1. Map的介绍"></a>1. Map的介绍</h3><blockquote><p>map用于将每个数组元素通过某个方法进行转换</p></blockquote><ul><li>Map在此处并非地图的意思, 它的含义是映射<ul><li>将一个元素映射成另外一种元素(类似于字典中的Key/Value映射)</li><li>其实Swift系统本身是有映射的函数, 可以将一个集合映射成另外一个集合</li><li>map 方法接受一个闭包作为参数， 然后它会遍历整个数组，并对数组中每一个元素执行闭包中定义的操作。然后再返回一个操作后的数组；相当于对数组中的所有元素做了一个映射</li></ul></li></ul><blockquote><h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析:"></a>示例分析:</h4></blockquote><h5 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">let arr2 = arr.map(&#123; $<span class="number">0</span> * <span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">//[3, 6, 9, 12, 15, 18]</span></span><br><span class="line">let arr3 = arr.flatMap(&#123; $<span class="number">0</span> + <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">//[3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h3 id="2-flatMap"><a href="#2-flatMap" class="headerlink" title="2. flatMap"></a>2. flatMap</h3><ul><li>我们对同样的数组使用 flatMap 进行处理， 得到了同样的结果。 那 flatMap 和 map 到底有什么区别呢？</li></ul><h4 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let numbersCompound = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]];</span><br><span class="line">var res = numbersCompound.map &#123; $<span class="number">0.</span>map&#123; $<span class="number">0</span> + <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="comment">// [[3, 4, 5], [6, 7, 8]]</span></span><br><span class="line">var flatRes = numbersCompound.flatMap &#123; $<span class="number">0.</span>map&#123; $<span class="number">0</span> + <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="comment">// [3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><ul><li>flatMap 依然会遍历数组的元素，并对这些元素执行闭包中定义的操作。 但唯一不同的是，它对最终的结果进行了所谓的 “降维” 操作。 本来原始数组是一个二维的， 但经过 flatMap 之后，它变成一维的了。</li></ul><blockquote><p>下面咱们再来看一下 flatMap 的定义, 还是抛去 @noescape, rethrows 这些无关逻辑的关键字：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func flatMap(transform: (Self.Generator.Element) throws -&gt; T?) -&gt; [T]</span><br><span class="line">func flatMap(transform: (Self.Generator.Element) -&gt; S) -&gt; [S.Generator.Element]</span><br></pre></td></tr></table></figure><ul><li>和 map 不同， flatMap 有两个重载。 参照我们刚才的示例， 我们调用的其实是第二个重载：flatMap 的闭包接受的是数组的元素，但返回的是一个 SequenceType 类型，也就是另外一个数组<blockquote><p>下面让我们来看看flatMap 的另一种重载情况</p></blockquote></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func flatMap</span><br><span class="line">(transform: (Self.Generator.Element) -&gt; T?) -&gt; [T]</span><br></pre></td></tr></table></figure><ul><li>从定义中我们看出， 它的闭包接收的是 Self.Generator.Element 类型， 返回的是一个 T? 。 我们都知道，在 Swift 中类型后面跟随一个 ?， 代表的是 Optional 值。 也就是说这个重载中接收的闭包返回的是一个 Optional 值。 更进一步来说，就是闭包可以返回 nil。</li></ul><h4 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let optionalArray: [String?] = [<span class="string">"AA"</span>, <span class="literal">nil</span>, <span class="string">"BB"</span>, <span class="string">"CC"</span>];</span><br><span class="line">print（optionalArray）</span><br><span class="line"><span class="comment">//[Optional("AA"), nil, Optional("BB"), Optional("CC")]</span></span><br><span class="line"></span><br><span class="line">var optionalResult = optionalArray.flatMap&#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// ["AA", "BB", "CC"]</span></span><br></pre></td></tr></table></figure><ul><li>flatMap 的返回结果中， 成功的将原数组中的 nil 值过滤掉了。 再仔细观察，你会发现更多。 使用 flatMap 调用之后， 数组中的所有元素都被解包了</li></ul><h4 id="关于-0的解释"><a href="#关于-0的解释" class="headerlink" title="关于$0的解释"></a>关于$0的解释</h4><ul><li>$0代表传入的元素本身，而不是下标</li><li>$0.0代表传入的元组的第一个值，如果元组被命名过了，则可以直接带名字</li><li>$0.age代表传入的模型的age属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元组类型</span></span><br><span class="line">let a1 = [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">6</span>),(<span class="number">6</span>,<span class="number">7</span>)]</span><br><span class="line">let a2 = a1.map(&#123; $<span class="number">0.0</span> * <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//模型类型</span></span><br><span class="line">let ageArr = modelArr.map(&#123; $<span class="number">0.</span>age &#125;)</span><br><span class="line">let nameArr = modelArr.map(&#123; $<span class="number">0.</span>name &#125;)</span><br></pre></td></tr></table></figure><h3 id="3-zip的使用"><a href="#3-zip的使用" class="headerlink" title="3. zip的使用"></a>3. zip的使用</h3><blockquote><p>3-1. zip 是将两个序列的元素，一一对应合并成元组，生成一个新序列。比如</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">let b = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>]</span><br><span class="line">let c = zip(a, b).map &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// c = [(1, "a"), (2, "b"), (3, "c"), (4, "d")]</span></span><br></pre></td></tr></table></figure><p>生成的序列，如同原始两个序列的相互咬合，因此函数的名字为 zip。zip 的英文有拉链的意思。生成的序列 count 为原始序列的最小值。</p><blockquote><p>3-2. zip 生成的序列通常会进行下一步处理。比如</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func loadColors(colors: [<span class="built_in">UIColor</span>]) &#123;</span><br><span class="line">    zip(<span class="keyword">self</span>.colorButtons, colors).forEach &#123; (bt, color) <span class="keyword">in</span></span><br><span class="line">        bt.color = color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段的语句，为颜色按钮分别赋予颜色值。相当于：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func loadColors(colors: [<span class="built_in">UIColor</span>]) &#123;</span><br><span class="line">    let minCount = min(colors.count, <span class="keyword">self</span>.colorButtons.count)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; minCount &#123;</span><br><span class="line">        <span class="keyword">self</span>.colorButtons[i].color = colors[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举一段代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let colors = [<span class="built_in">UIColor</span>.red, <span class="built_in">UIColor</span>.blue, <span class="built_in">UIColor</span>.white]</span><br><span class="line">let buttons = zip(<span class="number">0</span> ..&lt; colors.count, colors).map &#123; (i, color) <span class="keyword">in</span></span><br><span class="line">    let button = ColorButton(color: color)</span><br><span class="line">    button.tag = i</span><br><span class="line">    <span class="keyword">return</span> button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，创建了颜色按钮，并用索引设置了对应的 tag。</p><p>最后</p><blockquote><p>3-3. 这些简单的函数，配合起来可以达到一些高级的功能。比如:</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line">let b = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]</span><br><span class="line">let c = zip(a, b).flapMap &#123; [$<span class="number">0</span>, $<span class="number">1</span>] &#125;</span><br><span class="line"><span class="comment">// c = ["a", "A", "b", "B", "c", "C", "d", "D"]</span></span><br></pre></td></tr></table></figure><p>这里将两个序列的元素，间隔地插入，合并成一个序列。</p><blockquote><p>3-4. zip和速记+来通过添加两个冲突的值来解析重复的键</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let keyNames2 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>]</span><br><span class="line">let dict = Dictionary(zip(keyNames2, repeatElement(<span class="number">1</span>, count: keyNames2.count)), uniquingKeysWith: +)</span><br><span class="line"><span class="comment">//["b": 2, "a": 2, "c": 1]</span></span><br></pre></td></tr></table></figure><h3 id="二、Filter的使用"><a href="#二、Filter的使用" class="headerlink" title="二、Filter的使用"></a>二、Filter的使用</h3><blockquote><p>filter用于选择数组元素中满足某种条件的元素</p></blockquote><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">let arr2 = arr.filter(&#123; $<span class="number">0</span> &lt; <span class="number">5</span> &#125;)</span><br><span class="line"><span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="三、Reduce的使用"><a href="#三、Reduce的使用" class="headerlink" title="三、Reduce的使用"></a>三、Reduce的使用</h3><blockquote><p>reduce方法把数组元素组合计算为一个值</p><ul><li>先看一段传统代码</li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let moneyArray = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">10</span>] </span><br><span class="line">var sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> money <span class="keyword">in</span> moneyArray &#123;</span><br><span class="line">    sum = sum + money</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再看看数字相乘</span></span><br><span class="line">var product = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> money <span class="keyword">in</span> moneyArray &#123;</span><br><span class="line">    product = product * money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Swift中reduct在Array类中的定义为</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(initial: T, combine: (T, Int) throws -&gt; T)</span><br></pre></td></tr></table></figure><ul><li>接收两个参数，一个为类型U的初始值，另一个为把类型为U的元素和类型为T的元素组合成一个类型为U的值的函数。最终结果整个数组就变成了一个类型为U的值。</li></ul><h4 id="reduce简化代码"><a href="#reduce简化代码" class="headerlink" title="reduce简化代码"></a>reduce简化代码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = moneyArray.reduce(<span class="number">0</span>,&#123;$<span class="number">0</span> + $<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift中操作符可用着函数，可简化成：</span></span><br><span class="line">sum = moneyArray.reduce(<span class="number">0</span>,+)</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是combine函数的两参数类型不同，$0为计算结果类型，$1为数组元素类型</p></blockquote><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><blockquote><p>1、需要说明的是数据比较大的时候，高阶函数会比传统实现更快，因为它可以并行执行（如运行在多核上），除非真的需要更高定制版本的map，reduce和filter，否则可以一直使用它们以获得更快的执行速度。</p></blockquote><blockquote><p>2、我确信当你使用map，filter，reduct的代码质量会更好。但也需要在合适的场景中使用它们，不要指望用它们来解决任何问题。没有放之四海而皆准的真理。</p></blockquote><blockquote><p>详情参考<a href="http://blog.csdn.net/fish_yan_/article/details/51785441" target="_blank" rel="noopener">http://blog.csdn.net/fish_yan_/article/details/51785441</a><br>详情参考<a href="http://www.cocoachina.com/swift/20150619/12173.html" target="_blank" rel="noopener">http://www.cocoachina.com/swift/20150619/12173.html</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift3.0基本语法03</title>
      <link href="/2016/12/30/Swift3.0%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%9503/"/>
      <content type="html"><![CDATA[<h2 id="willSet和didSet"><a href="#willSet和didSet" class="headerlink" title="willSet和didSet"></a>willSet和didSet</h2><ul><li>属性观察器控制和响应属性的变化，当属性被设置的时候回调用属性观察器，主要有以下几个特点：<ul><li>属性改变之前触发willSet方法，属性改变之后触发didSet方法</li><li>在给属性添加观察者之前必须要明确申明属性的类型，否则编译器会报错</li><li>属性初始化时，willSet和didSet都不会调用，只有在设置属性值时才会调用</li><li>当设置的值和原来的值一样时，willSet和didSet也会被调用</li><li>willSet有一个newValue参数，didSet有一个oldvalue参数<br><excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a></excerpt></li></ul></li></ul><blockquote><p>代码如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var age:Int = 18&#123;</span><br><span class="line">    didSet&#123;</span><br><span class="line">        print(&quot;didSet   \(oldValue)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    willSet&#123;</span><br><span class="line">        print(&quot;willSet  \(newValue)&quot;)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  age重新赋值并打印     */</span><br><span class="line">age = 10;</span><br><span class="line">print(&quot;   \(age)&quot;)</span><br><span class="line">/*输出</span><br><span class="line">willSet 10</span><br><span class="line">didSet  18</span><br><span class="line">10</span><br><span class="line">*/</span><br><span class="line">age = 100</span><br><span class="line">print(&quot;   \(age)&quot;)</span><br><span class="line">/*输出</span><br><span class="line">willSet 100</span><br><span class="line">didSet  10</span><br><span class="line">100</span><br><span class="line">*/</span><br><span class="line">age = 200</span><br><span class="line">print(&quot;   \(age)&quot;)</span><br><span class="line">/*输出</span><br><span class="line">willSet 200</span><br><span class="line">didSet  100</span><br><span class="line">200</span><br><span class="line">*/</span><br><span class="line">age = 18</span><br><span class="line">print(&quot;    \(age)&quot;)</span><br><span class="line">/*输出</span><br><span class="line">willSet 18</span><br><span class="line">didSet  200</span><br><span class="line">18</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><blockquote><p>实例应用</p><ul><li>cell内部,模型赋值</li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> HomeViewCell: <span class="built_in">UICollectionViewCell</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: 控件属性</span></span><br><span class="line">    @IBOutlet <span class="keyword">weak</span> var albumImageView: <span class="built_in">UIImageView</span>!</span><br><span class="line">    @IBOutlet <span class="keyword">weak</span> var liveImageView: <span class="built_in">UIImageView</span>!</span><br><span class="line">    @IBOutlet <span class="keyword">weak</span> var nickNameLabel: <span class="built_in">UILabel</span>!</span><br><span class="line">    @IBOutlet <span class="keyword">weak</span> var onlinePeopleLabel: <span class="built_in">UIButton</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: 定义属性</span></span><br><span class="line">    var anchorModel : AnchorModel?&#123;</span><br><span class="line">        didSet&#123;</span><br><span class="line">            albumImageView.setImage(anchorModel!.isEvenIndex ? anchorModel?.pic74 : anchorModel?.pic51, <span class="string">"home_pic_default"</span>)</span><br><span class="line">            liveImageView.isHidden = anchorModel?.live == <span class="number">0</span></span><br><span class="line">            nickNameLabel.text = anchorModel?.name</span><br><span class="line">            onlinePeopleLabel.setTitle(<span class="string">"\(anchorModel?.focus ?? 0)"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swift中的set和get方法"><a href="#Swift中的set和get方法" class="headerlink" title="Swift中的set和get方法"></a>Swift中的set和get方法</h2><ul><li>OC中我们常重写set和get方法来改变UI，Swift中重写set和get方法是下面这种。<ul><li>先定义一个变量，当调用set方法的时候，系统会有一个newValue，将newVaule赋值给我们定义的变量，然后从get方法里面返回去。</li><li>Swift中一般重写比较少</li></ul></li></ul><blockquote><p>代码示例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//定义一个变量</span><br><span class="line">var _tittle: String?</span><br><span class="line"></span><br><span class="line">    var tittle: String?&#123;</span><br><span class="line"></span><br><span class="line">        get&#123;</span><br><span class="line">            return  _tittle + &quot;123&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            _tittle = newValue + &quot;789&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>## </p><blockquote><p>Swift3.0语法其他相关文章</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift基本语法02</title>
      <link href="/2016/12/28/Swift3.0%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%9502/"/>
      <content type="html"><![CDATA[<blockquote><p>上一篇介绍了Swift的常量/变量和循环,详情见: <a href="http://www.jianshu.com/p/35696abdaf0f" target="_blank" rel="noopener">Swift3.0基本语法01</a></p></blockquote><a id="more"></a><h2 id="一、字符串的介绍"><a href="#一、字符串的介绍" class="headerlink" title="一、字符串的介绍"></a>一、字符串的介绍</h2><ul><li>字符串在任何的开发中使用都是非常频繁的<ul><li>OC和Swift中字符串的区别<ul><li>在OC中字符串类型时NSString,在Swift中字符串类型是String</li><li>OC中字符串@””,Swift中字符串””</li></ul></li><li>使用 String 的原因<ul><li>String 是一个结构体，性能更高</li><li>NSString 是一个 OC 对象，性能略差</li><li>String 支持直接遍历</li><li>Swift 提供了 String 和 NSString 之间的无缝转换<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1&gt; 定义不可变字符串 : 使用let修饰</span></span><br><span class="line"><span class="comment">// let str : String = "hello swift"</span></span><br><span class="line">let str = <span class="string">"Hello Swift"</span></span><br><span class="line"><span class="comment">// str = "hello Objective-C"</span></span><br><span class="line"><span class="comment">// 2&gt; 定义可变字符串 : 使用var修饰</span></span><br><span class="line">var strM = <span class="string">"Hello World"</span></span><br><span class="line">strM = <span class="string">"Hello China"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>##二、 字符串的使用</p><ul><li>获取字符串的长度<ul><li>获取字符集合,再获取集合的count属性</li></ul></li></ul><blockquote><p>let length = str.characters.count</p></blockquote><ul><li>字符串拼接<ul><li>两个字符串的拼接</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str1 = <span class="string">"字符串"</span></span><br><span class="line">let str2 = <span class="string">"拼接"</span></span><br><span class="line"><span class="comment">// OC拼接方式 NSString stringwithFormat:@"%@%@", str1, str2</span></span><br><span class="line">let str3 = str1 + str2</span><br></pre></td></tr></table></figure><ul><li>字符串和其他数据类型的拼接</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let name = <span class="string">"tqj"</span></span><br><span class="line">let age = <span class="number">19</span></span><br><span class="line">let height = <span class="number">1.87</span></span><br><span class="line"></span><br><span class="line">let infoStr = <span class="string">"my nams is \(name), age is \(age), height is \(height)"</span></span><br></pre></td></tr></table></figure><ul><li>字符串的格式化::比如时间:01:02</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let min = <span class="number">3</span></span><br><span class="line">let second = <span class="number">4</span></span><br><span class="line">let timeStr = String(format: <span class="string">"%02d:%02d"</span>, min, second)</span><br></pre></td></tr></table></figure><h4 id="字符串的判断"><a href="#字符串的判断" class="headerlink" title="字符串的判断"></a>字符串的判断</h4><blockquote><p>判断字符串是否为空</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str = <span class="string">"1"</span></span><br><span class="line"><span class="comment">//输出false</span></span><br><span class="line">print(str.isEmpty)</span><br><span class="line"></span><br><span class="line">let str = <span class="string">""</span></span><br><span class="line"><span class="comment">//输出为true</span></span><br><span class="line">print(str.isEmpty)</span><br></pre></td></tr></table></figure><blockquote><p>其他判断和操作(Swift3.0特性)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//判断是否包含某字符</span><br><span class="line">let str = &quot;Hello, playground&quot;</span><br><span class="line">let is1 = str.contains(&quot;ell&quot;)</span><br><span class="line">//输出true</span><br><span class="line">print(is1)</span><br><span class="line"></span><br><span class="line">//指定字符串的替换</span><br><span class="line">let str2 = str.replacingOccurrences(of: &quot;Hello&quot;, with: &quot;HELLO&quot;)</span><br><span class="line">print(str2)   </span><br><span class="line">//输出HELLO, playground</span><br><span class="line"></span><br><span class="line">//转为大写</span><br><span class="line">let s1 = str.localizedUppercase</span><br><span class="line">//转为小写</span><br><span class="line">let s2 = str.localizedLowercase</span><br></pre></td></tr></table></figure><h4 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h4><ul><li>Swift中提供了特殊的截取方式<ul><li>该方式非常麻烦</li><li>Index创建较为麻烦</li></ul></li><li>简单的方式是将String转成NSString来使用<ul><li>在标识符后加:as NSString即可</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let urlString = <span class="string">"www.520it.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.1.方式一:</span></span><br><span class="line"><span class="comment">// 将String类型转成NSString类型,再进行截取: as NSString</span></span><br><span class="line">let header1 = (urlString as <span class="built_in">NSString</span>).substring(to: <span class="number">3</span>)</span><br><span class="line">let range1 = <span class="built_in">NSMakeRange</span>(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">let middle1 = (urlString as <span class="built_in">NSString</span>).substring(with: range1)</span><br><span class="line">let footer1 = (urlString as <span class="built_in">NSString</span>).substring(from: <span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li>swift截取方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 4.2.方式二:</span><br><span class="line">let headerIndex = urlString.index(urlString.startIndex, offsetBy: 3)</span><br><span class="line">let header2 = urlString.substring(to: headerIndex)</span><br><span class="line"></span><br><span class="line">let startIndex = urlString.index(urlString.startIndex, offsetBy: 4)</span><br><span class="line">let endIndex = urlString.index(urlString.startIndex, offsetBy: 9)</span><br><span class="line">let range = Range(startIndex..&lt;endIndex)</span><br><span class="line">let middle2 = urlString.substring(with: range)</span><br><span class="line"></span><br><span class="line">let footerIndex = urlString.index(urlString.endIndex, offsetBy: -3)</span><br><span class="line">let footer2 = urlString.substring(from: footerIndex)</span><br></pre></td></tr></table></figure><h2 id="三、数组的使用"><a href="#三、数组的使用" class="headerlink" title="三、数组的使用"></a>三、数组的使用</h2><h3 id="数组的介绍"><a href="#数组的介绍" class="headerlink" title="数组的介绍"></a>数组的介绍</h3><ul><li>数组（Array）是一串有序的由相同类型元素构成的集合<ul><li>数组中的集合元素是有序的，可以重复出现</li><li>Swift中的数组<ul><li>swift数组类型是Array，是一个泛型集合<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3></li></ul></li></ul></li><li>数组分成:可变数组和不可变数组<ul><li>使用let修饰的数组是不可变数组</li><li>使用var修饰的数组是可变数组<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1&gt; 定义不可变数组</span></span><br><span class="line">let array : [Any] = [<span class="string">"why"</span>, <span class="number">18</span>, <span class="number">1.88</span>]</span><br><span class="line"><span class="comment">// 2&gt; 定义可变数组: 使用var修饰</span></span><br><span class="line">var arrayM = [Any]()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="对数组的基本操作"><a href="#对数组的基本操作" class="headerlink" title="对数组的基本操作"></a>对数组的基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 增删改查</span><br><span class="line">// 2.1.添加元素</span><br><span class="line">arrayM.append(&quot;why&quot;)</span><br><span class="line">// 2.2.删除元素</span><br><span class="line">arrayM.remove(at: 0)</span><br><span class="line">// 2.3.修改元素</span><br><span class="line">arrayM[0] = &quot;yz&quot;</span><br><span class="line">// 2.4.获取元素</span><br><span class="line">let item = arrayM[1]</span><br></pre></td></tr></table></figure><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 3.1.获取数组的长度</span><br><span class="line">let count = array.count</span><br><span class="line"></span><br><span class="line">// 3.2.对数组进行遍历(可以获取到下标值)</span><br><span class="line">for i in 0..&lt; count &#123;</span><br><span class="line">    print(array[i])</span><br><span class="line">&#125;</span><br><span class="line">// 3.3.对数组进行遍历(设置遍历区间)</span><br><span class="line">for item in array &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br><span class="line">// 3.3.对数组进行遍历(不需要获取下标值)</span><br><span class="line">for item in array[0..&lt;2] &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br><span class="line">// 3.5.对数组进行遍历(既获取下标值,又获取元素)</span><br><span class="line">for (index, item) in array.enumerated() &#123;</span><br><span class="line">    print(index)</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的合并"><a href="#数组的合并" class="headerlink" title="数组的合并"></a>数组的合并</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个数组中存放的是相同的元素,那么在swift中可以对两个数组进行相加,直接合并</span></span><br><span class="line">let array1 = [<span class="string">"why"</span>, <span class="string">"yz"</span>]</span><br><span class="line">let array2 = [<span class="string">"lmj"</span>, <span class="string">"lnj"</span>]</span><br><span class="line">let array3 = [<span class="number">12</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">let resultArray = array1 + array2</span><br><span class="line"><span class="comment">// let result = array1 + array3 错误写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不建议一个数组中存放多种类型的数据</span></span><br><span class="line">var array3 = [<span class="number">2</span>, <span class="number">3</span>, <span class="string">"why"</span>]</span><br><span class="line">var array4 = [<span class="string">"yz"</span>, <span class="number">23</span>]</span><br><span class="line">array3 + array4</span><br></pre></td></tr></table></figure><h2 id="四、字典"><a href="#四、字典" class="headerlink" title="四、字典"></a>四、字典</h2><h3 id="字典的介绍"><a href="#字典的介绍" class="headerlink" title="字典的介绍"></a>字典的介绍</h3><ul><li>字典允许按照某个键来访问元素<ul><li>字典是由两部分集合构成的，一个是键（key）集合，一个是值（value）集合</li><li>键集合是不能有重复元素的，而值集合是可以重复的，键和值是成对出现的</li><li>Swift中的字典<ul><li>Swift字典类型是Dictionary，也是一个泛型集合<h3 id="字典的初始化"><a href="#字典的初始化" class="headerlink" title="字典的初始化"></a>字典的初始化</h3></li></ul></li></ul></li><li>Swift中的可变和不可变字典<ul><li>使用let修饰的数组是不可变字典</li><li>使用var修饰的数组是可变字典<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个可变字典</span></span><br><span class="line">var dict1 : [String : Any] = [String : Any]()</span><br><span class="line"><span class="comment">// 定义一个不可变字典</span></span><br><span class="line">let dict2 : [String : Any] = [<span class="string">"name"</span> : <span class="string">"why"</span>, <span class="string">"age"</span> : <span class="number">18</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="字典的基本使用"><a href="#字典的基本使用" class="headerlink" title="字典的基本使用"></a>字典的基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 2.1.添加元素</span><br><span class="line">dictM[&quot;name&quot;] = &quot;why&quot;</span><br><span class="line">dictM[&quot;age&quot;] = 18</span><br><span class="line">dictM[&quot;height&quot;] = 1.88</span><br><span class="line"></span><br><span class="line">// 2.2.删除元素</span><br><span class="line">dictM.removeValue(forKey: &quot;height&quot;)</span><br><span class="line">dictM</span><br><span class="line">// 2.3.修改元素</span><br><span class="line">dictM[&quot;name&quot;] = &quot;lmj&quot;</span><br><span class="line">dictM.updateValue(&quot;lnj&quot;, forKey: &quot;name&quot;)</span><br><span class="line">dictM</span><br><span class="line">// 2.4.查找元素</span><br><span class="line">dictM[&quot;age&quot;]</span><br></pre></td></tr></table></figure><h3 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.1.遍历字典中所有的key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict.keys &#123;</span><br><span class="line">    print(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2.遍历字典中所有的value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict.values &#123;</span><br><span class="line">    print(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3.遍历字典中所有的key/value</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict &#123;</span><br><span class="line">    print(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典的合并"><a href="#字典的合并" class="headerlink" title="字典的合并"></a>字典的合并</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var dict1 : [String : Any] = [<span class="string">"name"</span> : <span class="string">"why"</span>, <span class="string">"age"</span> : <span class="number">18</span>]</span><br><span class="line">let dict2 : [String : Any] = [<span class="string">"height"</span> : <span class="number">1.88</span>, <span class="string">"phoneNum"</span> : <span class="string">"+86 110"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//let resultDict = dict1 + dict2字典不可以相加合并，只能遍历</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict2 &#123;</span><br><span class="line">    dict1[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、元组的使用"><a href="#五、元组的使用" class="headerlink" title="五、元组的使用"></a>五、元组的使用</h2><h3 id="元组的介绍"><a href="#元组的介绍" class="headerlink" title="元组的介绍"></a>元组的介绍</h3><ul><li>元组是Swift中特有的,OC中并没有相关类型</li><li>它是什么呢?<ul><li>它是一种数据结构，在数学中应用广泛<br>  类似于数组或者字典</li><li>可以用于定义一组数据</li><li>组成元组类型的数据可以称为“元素”<h3 id="元组的定义"><a href="#元组的定义" class="headerlink" title="元组的定义"></a>元组的定义</h3></li></ul></li><li>元组的常见写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 3.使用元组保存信息(取出数据时,更加方便)</span><br><span class="line">// 3.1.写法一:</span><br><span class="line">let infoTuple0 = (&quot;why&quot;, 18, 1.88)</span><br><span class="line">let tupleName = infoTuple0.0</span><br><span class="line">let tupleAge = infoTuple0.1</span><br><span class="line">infoTuple0.0</span><br><span class="line">infoTuple0.1</span><br><span class="line">infoTuple0.2</span><br><span class="line"></span><br><span class="line">// 3.2.写法二:</span><br><span class="line">let infoTuple1 = (name : &quot;why&quot;,age : 18, height : 1.88)</span><br><span class="line">infoTuple1.age</span><br><span class="line">infoTuple1.name</span><br><span class="line">infoTuple1.height</span><br><span class="line"></span><br><span class="line">// 3.3.写法三:</span><br><span class="line">let (name, age, height) = (&quot;why&quot;, 18, 1.88)</span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line">height</span><br></pre></td></tr></table></figure><h2 id="六、可选类型"><a href="#六、可选类型" class="headerlink" title="六、可选类型"></a>六、可选类型</h2><h3 id="可选类型的介绍"><a href="#可选类型的介绍" class="headerlink" title="可选类型的介绍"></a>可选类型的介绍</h3><ul><li>注意:<ul><li>可选类型时swift中较理解的一个知识点</li><li>暂时先了解,多利用Xcode的提示来使用</li><li>随着学习的深入,慢慢理解其中的原理和好处</li></ul></li><li>概念:<ul><li>在OC开发中,如果一个变量暂停不使用,可以赋值为0(基本属性类型)或者赋值为空(对象类型)</li><li>在swift开发中,nil也是一个特殊的类型.因为和真实的类型不匹配是不能赋值的(swift是强类型语言)</li><li>但是开发中赋值nil,在所难免.因此推出了可选类型</li></ul></li><li>可选类型的取值:<ul><li>空值</li><li>有值<h3 id="定义可选类型"><a href="#定义可选类型" class="headerlink" title="定义可选类型"></a>定义可选类型</h3></li></ul></li><li>定义一个可选类型有两种写法<ul><li>最基本的写法</li><li>语法糖(常用)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 错误写法</span><br><span class="line">// let string : String = nil</span><br><span class="line">// 正确写法:</span><br><span class="line">// 注意:name的类型是一个可选类型,但是该可选类型中可以存放字符串.</span><br><span class="line">// 写法一:定义可选类型</span><br><span class="line">let name : Optional&lt;String&gt; = nil</span><br><span class="line">// 写法二:定义可选类型,语法糖(常用)</span><br><span class="line">let name : String? = nil</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="可选类型的使用"><a href="#可选类型的使用" class="headerlink" title="可选类型的使用"></a>可选类型的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 演练一:给可选类型赋值</span><br><span class="line">// 定义可选类型</span><br><span class="line">var string : Optional&lt;String&gt; = nil</span><br><span class="line">// 给可选类型赋值</span><br><span class="line">// 错误写法:因此该可选类型中只能存放字符串</span><br><span class="line">string = 123</span><br><span class="line">// 正确写法:</span><br><span class="line">string = &quot;Hello world&quot;</span><br><span class="line">// 打印结果</span><br><span class="line">print(string)</span><br><span class="line">// 结果:Optional(&quot;Hello world&quot;)\n</span><br><span class="line">// 因为打印出来的是可选类型,所有会带Optional</span><br><span class="line">// 演练二:取出可选类型的值</span><br><span class="line">// 取出可选类型的真实值(解包)</span><br><span class="line">print(string!)</span><br><span class="line">// 结果:Hello world\n</span><br><span class="line">// 注意:如果可选类型为nil,强制取出其中的值(解包),会出错</span><br><span class="line">string = nil</span><br><span class="line">print(string!) // 报错</span><br><span class="line">// 正确写法:</span><br><span class="line">if string != nil &#123;</span><br><span class="line">    print(string!)</span><br><span class="line">&#125;</span><br><span class="line">// 简单写法:为了让在if语句中可以方便使用string</span><br><span class="line">// 可选绑定</span><br><span class="line">if let str = string &#123;</span><br><span class="line">    print(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="真实应用场景"><a href="#真实应用场景" class="headerlink" title="真实应用场景"></a>真实应用场景</h4><ul><li>目的:让代码更加严谨<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1.将字符串类型转成Int类型</span><br><span class="line">let str = &quot;123&quot;</span><br><span class="line">let result : Int? = Int(str) // nil/Int</span><br><span class="line">// 2.根据文件名称,读取路径</span><br><span class="line">let path : String? = Bundle.main.path(forResource: &quot;123.plist&quot;, ofType: nil)</span><br><span class="line">// 3.根据string,创建URL</span><br><span class="line">let url = URL(string: &quot;http://www.520it.com/小码哥&quot;)</span><br><span class="line">// 4.从字典中取内容</span><br><span class="line">let dict : [String : Any] = [&quot;name&quot; : &quot;why&quot;, &quot;age&quot; : 18]</span><br><span class="line">dict[&quot;name&quot;]</span><br><span class="line">dict[&quot;height&quot;]</span><br></pre></td></tr></table></figure></li></ul><h2 id="七、类型转化"><a href="#七、类型转化" class="headerlink" title="七、类型转化"></a>七、类型转化</h2><h3 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h3><ul><li>常见的类型转化符号<ul><li>as : 将实例转成某一种类型<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义数组</span></span><br><span class="line">let array : [AnyObject] = [<span class="number">12</span>, <span class="string">"why"</span>, <span class="number">1.88</span>]</span><br><span class="line"><span class="comment">// 2.取出第二个元素</span></span><br><span class="line">let objc = array[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 3.将objc转成真正的类型来使用</span></span><br><span class="line"><span class="comment">// 3.1.as? 将AnyObject转成可选类型,通过判断可选类型是否有值,来决定是否转化成功了</span></span><br><span class="line">let age = objc as? Int</span><br><span class="line">print(age) <span class="comment">// 结果:Optional(12)</span></span><br><span class="line"><span class="comment">// 3.2.as! 将AnyObject转成具体的类型,但是注意:如果不是该类型,那么程序会崩溃</span></span><br><span class="line">let age1 = objc as! Int</span><br><span class="line">print(age1) <span class="comment">// 结果:12</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="八、try-throw-代码实践"><a href="#八、try-throw-代码实践" class="headerlink" title="八、try throw 代码实践"></a>八、try throw 代码实践</h2><blockquote><p>throw catch 是 Xcode 7.0 对错误处理的一个非常大的变化</p><ul><li>代码示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 2. 反序列化</span><br><span class="line">// 1.获取json文件路径</span><br><span class="line">        let jsonPath = NSBundle.mainBundle().pathForResource(&quot;MainVCSettings.json&quot;, ofType: nil)</span><br><span class="line">        // 2.加载json数据</span><br><span class="line">        let jsonData = NSData(contentsOfFile: jsonPath!)</span><br><span class="line">        // 3.序列化json</span><br><span class="line">        do&#123;//解析成功</span><br><span class="line">             // throw是Xcode7最明显的一个变化, Xcode7之前都是通过传入error指针捕获异常, Xocode7开始通过try/catch捕获异常</span><br><span class="line">            let dictArray = try NSJSONSerialization.JSONObjectWithData(jsonData!, options: NSJSONReadingOptions.MutableContainers)</span><br><span class="line"></span><br><span class="line">            // 遍历字典时候需要明确指明数组中的数据类型</span><br><span class="line">            for dict in dictArray  as! [[String:String]]</span><br><span class="line">            &#123;</span><br><span class="line">                 // 由于addChildVC方法参数不能为nil, 但是字典中取出来的值可能是nil, 所以需要加上!</span><br><span class="line">                addChildViewController(dict[&quot;vcName&quot;]!, title: dict[&quot;title&quot;]!, imageName: dict[&quot;imageName&quot;]!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch&#123;//解析失败</span><br><span class="line">            print(error)</span><br><span class="line">            addChildViewController(&quot;HomeTableViewController&quot;, title: &quot;首页&quot;, imageName: &quot;tabbar_home&quot;)</span><br><span class="line">            addChildViewController(&quot;MessageTableViewController&quot;, title: &quot;消息&quot;, imageName: &quot;tabbar_message_center&quot;)</span><br><span class="line">            addChildViewController(&quot;DiscoverTableViewController&quot;, title: &quot;发现&quot;, imageName: &quot;tabbar_discover&quot;)</span><br><span class="line">            addChildViewController(&quot;ProfileTableViewController&quot;, title: &quot;我&quot;, imageName: &quot;tabbar_profile&quot;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li>如果能确保代码执行正确，可以强行 try!<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let array = try! NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions.MutableContainers)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>不过需要注意的是，一旦解析错误，程序会直接崩溃！</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> Swift3.0 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift3.0之基本语法01</title>
      <link href="/2016/12/25/Swift3.0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%9501/"/>
      <content type="html"><![CDATA[<h2 id="常量-amp-变量"><a href="#常量-amp-变量" class="headerlink" title="常量&amp;变量"></a>常量&amp;变量</h2><ul><li>在Swift中规定：在定义一个标识符时必须明确说明该标识符是一个常量还是变量</li><li>使用let来定义常量，定义之后不可以修改</li><li>使用var来定义变量，定义之后可以修改</li></ul><a id="more"></a><h3 id="变量的基本使用"><a href="#变量的基本使用" class="headerlink" title="变量的基本使用"></a>变量的基本使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line">let a : Int = <span class="number">10</span></span><br><span class="line"><span class="comment">// 错误写法,当一个标识符定义为常量时是不可以修改的</span></span><br><span class="line"><span class="comment">// a = 20</span></span><br><span class="line">var b : Int = <span class="number">20</span></span><br><span class="line"><span class="comment">//因为b定义为变量,因此是可以修改的</span></span><br><span class="line">b = <span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="常量和变量的使用注意"><a href="#常量和变量的使用注意" class="headerlink" title="常量和变量的使用注意:"></a>常量和变量的使用注意:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 常量使用注意：</span></span><br><span class="line"><span class="comment">    1&gt; 优先使用常量</span></span><br><span class="line"><span class="comment">    2&gt; 常量的本质</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 1.注意一：在开发中let/var在选择时优先使用常量，防止不小被修改掉（let）</span></span><br><span class="line"><span class="comment">// 如果一个标识符不需要修改，但是声明称了变量，那么编译器会报警告</span></span><br><span class="line"><span class="comment">// 2.常量的本质：</span></span><br><span class="line"><span class="comment">// 含义：指向的内存地址不可以修改，但是可以通过内存地址，找到对应的对象，之后修改对象内部的属性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> OC中创建对象：</span></span><br><span class="line"><span class="comment">    UIView *view = [[UIView alloc] init];</span></span><br><span class="line"><span class="comment">    view = [[UIView alloc] init];</span></span><br><span class="line"><span class="comment"> Swift中创建对象：</span></span><br><span class="line"><span class="comment">    var view : UIView = UIView()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 变量的做法</span></span><br><span class="line"><span class="comment">    var view : UIView = UIView()</span></span><br><span class="line"><span class="comment">    view = UIView()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 创建常量View</span></span><br><span class="line">let view = <span class="built_in">UIView</span>()</span><br><span class="line"><span class="comment">// view = UIView() 错误做法</span></span><br><span class="line">view.alpha = <span class="number">0.5</span></span><br><span class="line"><span class="comment">// Swift中创建结构体：结构体类型()</span></span><br><span class="line">view.frame = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="comment">// Swift中调用方法，统一使用点语法</span></span><br><span class="line">view.backgroundColor = <span class="built_in">UIColor</span>.red</span><br></pre></td></tr></table></figure><h3 id="创建对象补充"><a href="#创建对象补充" class="headerlink" title="创建对象补充"></a>创建对象补充</h3><ul><li>创建UIView对象，并且在UIView中添加UIButton</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"><span class="comment">// 1.创建UIView对象</span></span><br><span class="line"><span class="comment">// OC : [[UIView alloc] initWithFrame:CGRect]</span></span><br><span class="line">let viewRect = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">let view : <span class="built_in">UIView</span> = <span class="built_in">UIView</span>(frame: viewRect)</span><br><span class="line"><span class="comment">// 2.设置UIView的属性</span></span><br><span class="line">view.backgroundColor = <span class="built_in">UIColor</span>.orange</span><br><span class="line"><span class="comment">// 3.创建UIButton</span></span><br><span class="line">let btn : <span class="built_in">UIButton</span> = <span class="built_in">UIButton</span>(type: .custom)</span><br><span class="line"><span class="comment">// 4.设置UIButton的属性</span></span><br><span class="line">btn.frame = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line">btn.backgroundColor = <span class="built_in">UIColor</span>.purple</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Swift中枚举类型：</span></span><br><span class="line"><span class="comment"> 1&gt; 如果可以根据上下文推导出类型可以直接.具体的类型</span></span><br><span class="line"><span class="comment"> 2&gt; 如果根据上下文推导不出具体的类型，则需要：类型.具体的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">btn.setTitle(<span class="string">"按钮"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">btn.setTitleColor(<span class="built_in">UIColor</span>.white, <span class="keyword">for</span>: .normal)</span><br><span class="line"><span class="comment">// 5.将btn添加到UIView中</span></span><br><span class="line">view.addSubview(btn)</span><br></pre></td></tr></table></figure><h2 id="Swift中数据类型"><a href="#Swift中数据类型" class="headerlink" title="Swift中数据类型"></a>Swift中数据类型</h2><h3 id="Swift类型的介绍"><a href="#Swift类型的介绍" class="headerlink" title="Swift类型的介绍"></a>Swift类型的介绍</h3><ul><li>Swift中的数据类型也有:整型/浮点型/对象类型/结构体类型等等<ul><li>先了解整型和浮点型</li><li>整型<ul><li>有符号<ul><li>Int8 : 有符号8位整型</li><li>Int16 : 有符号16位整型</li><li>Int32 : 有符号32位整型</li><li>Int64 : 有符号64位整型</li><li>Int ： 和平台相关(默认,相当于OC的NSInteger)</li></ul></li><li>无符号<ul><li>UInt8 : 无符号8位整型</li><li>UInt16 : 无符号16位整型</li><li>UInt32 : 无符号32位整型</li><li>UInt64 : 无符号64位整型</li><li>UInt : 和平台相关(常用,相当于OC的NSUInteger)(默认)</li></ul></li></ul></li><li>浮点型<ul><li>Float : 32位浮点型</li><li>Double : 64浮点型(默认)</li></ul></li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个Int类型的变量m,并且赋值为10</span></span><br><span class="line">var m : Int = <span class="number">10</span></span><br><span class="line"><span class="comment">// 定义一个Double类型的常量n,并且赋值为3.14</span></span><br><span class="line">let n : Double = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><h3 id="Swift中的类型推导"><a href="#Swift中的类型推导" class="headerlink" title="Swift中的类型推导"></a>Swift中的类型推导</h3><ul><li>Swift是强类型的语言<ul><li>Swift中任何一个标识符都有明确的类型</li><li>注意:<ul><li>如果定义一个标识符时有直接进行赋值,那么标识符后面的类型可以省略.</li><li>因为Swift有类型推导,会自动根据后面的赋值来决定前面的标识符的数据类型</li><li>可以通过option+鼠标左键来查看变量的数据类型</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">let m = 20</span><br><span class="line">let n = 30.5</span><br><span class="line">// 错误写法 :</span><br><span class="line">// Swift中没有隐式转化，不会自动将一个Int类型转成Double类型，因此不同类型之间不能进行运算</span><br><span class="line">// let result = m + n</span><br><span class="line">// 正确做法</span><br><span class="line">// 1&gt; 将Int类型转成Double ： Double(标识符)</span><br><span class="line">// 2&gt; 将Double类型转成Int ： Int(标识符)</span><br><span class="line">let result1 = Double(m) + n</span><br><span class="line">let result2 = m + Int(n)</span><br></pre></td></tr></table></figure><h2 id="逻辑分支"><a href="#逻辑分支" class="headerlink" title="逻辑分支"></a>逻辑分支</h2><h3 id="一-分支的介绍"><a href="#一-分支的介绍" class="headerlink" title="一. 分支的介绍"></a>一. 分支的介绍</h3><ul><li>分支即if/switch/三目运算符等判断语句</li><li>通过分支语句可以控制程序的执行流程</li></ul><h3 id="二-if分支语句"><a href="#二-if分支语句" class="headerlink" title="二. if分支语句"></a>二. if分支语句</h3><ul><li>和OC中if语句有一定的区别<ul><li>判断句可以不加()</li><li>在Swift的判断句中必须有明确的真假<ul><li>不再有非0即真</li><li>必须有明确的Bool值</li><li>Bool有两个取值:false/true</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 演练一:</span><br><span class="line">let a = 10</span><br><span class="line">// 错误写法:</span><br><span class="line">//if a &#123;</span><br><span class="line">//    print(&quot;a&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">// 正确写法</span><br><span class="line">if a &gt; 9 &#123;</span><br><span class="line">    print(a)</span><br><span class="line">&#125;</span><br><span class="line">// 演练二:</span><br><span class="line">let score = 87</span><br><span class="line">if score &lt; 60 &#123;</span><br><span class="line">    print(&quot;不及格&quot;)</span><br><span class="line">&#125; else if score &lt;= 70 &#123;</span><br><span class="line">    print(&quot;及格&quot;)</span><br><span class="line">&#125; else if score &lt;= 80 &#123;</span><br><span class="line">    print(&quot;良好&quot;)</span><br><span class="line">&#125; else if score &lt;= 90 &#123;</span><br><span class="line">    print(&quot;优秀&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;完美&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-guard的使用"><a href="#三-guard的使用" class="headerlink" title="三.guard的使用"></a>三.guard的使用</h3><ul><li>guard是Swift2.0新增的语法<ul><li>它与if语句非常类似，它设计的目的是提高程序的可读性</li><li>guard语句必须带有else语句，它的语法如下：<ul><li>当条件表达式为true时候跳过else语句中的内容，执行语句组内容</li><li>条件表达式为false时候执行else语句中的内容，跳转语句一般是return、break、continue和throw</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">guard 条件表达式 else &#123;</span><br><span class="line">    // 条换语句</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br><span class="line">语句组</span><br><span class="line">//---例子---</span><br><span class="line">    var age = 18</span><br><span class="line">func online(age : Int) -&gt; Void &#123;</span><br><span class="line">    guard age &gt;= 18 else &#123;</span><br><span class="line">        print(&quot;回家去&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;可以上网&quot;)</span><br><span class="line">&#125;</span><br><span class="line">online(age)</span><br></pre></td></tr></table></figure><h3 id="四-switch分支"><a href="#四-switch分支" class="headerlink" title="四.switch分支"></a>四.switch分支</h3><h5 id="switch的介绍"><a href="#switch的介绍" class="headerlink" title="switch的介绍"></a>switch的介绍</h5><ul><li>Switch作为选择结构中必不可少的语句也被加入到了Swift中<ul><li>只要有过编程经验的人对Switch语句都不会感到陌生</li><li>但苹果对Switch进行了大大的增强，使其拥有其他语言中没有的特性<h5 id="switch的简单使用"><a href="#switch的简单使用" class="headerlink" title="switch的简单使用"></a>switch的简单使用</h5></li></ul></li><li>基本用法和OC用法一致<ul><li>不同之处:<ul><li>switch后可以不跟()</li><li>case后可以不跟break(默认会有break)</li></ul></li><li>例子:</li></ul></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;     let sex = 0</span><br><span class="line">&gt;     switch sex &#123;</span><br><span class="line">&gt;     case 0 :</span><br><span class="line">&gt;         print(&quot;男&quot;)</span><br><span class="line">&gt;     case 1 :</span><br><span class="line">&gt;         print(&quot;女&quot;)</span><br><span class="line">&gt;     default :</span><br><span class="line">&gt;         print(&quot;其他&quot;)</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>简单使用补充:</p><ul><li>一个case判断中,可以判断多个值</li><li>多个值以,隔开<blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;     let sex = <span class="number">0</span></span><br><span class="line">&gt;     <span class="keyword">switch</span> sex &#123;</span><br><span class="line">&gt;     <span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:</span><br><span class="line">&gt;         print(<span class="string">"正常人"</span>)</span><br><span class="line">&gt;     <span class="keyword">default</span>:</span><br><span class="line">&gt;         print(<span class="string">"其他"</span>)</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>简单使用补充:</p><ul><li>如果希望出现之前的case穿透,则可以使用关键字fallthrough</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let sex = 0</span><br><span class="line">switch sex &#123;</span><br><span class="line">case 0:</span><br><span class="line">    fallthrough</span><br><span class="line">case 1:</span><br><span class="line">    print(&quot;正常人&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;其他&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="switch支持区间判断"><a href="#switch支持区间判断" class="headerlink" title="switch支持区间判断"></a>switch支持区间判断</h5><ul><li>什么是区间?<ul><li>通常我们指的是数字区间:0~10,100~200<br>swift中的区间常见有两种</li><li>半开半闭区间:0..&lt;10 表示:0~9,不包括10<br>  闭区间:0…10 表示:0~10</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let score = 88</span><br><span class="line">switch score &#123;</span><br><span class="line">case 0..&lt;60:</span><br><span class="line">    print(&quot;不及格&quot;)</span><br><span class="line">case 60..&lt;80:</span><br><span class="line">    print(&quot;几个&quot;)</span><br><span class="line">case 80..&lt;90:</span><br><span class="line">    print(&quot;良好&quot;)</span><br><span class="line">case 90..&lt;100:</span><br><span class="line">    print(&quot;优秀&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;满分&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环使用"><a href="#循环使用" class="headerlink" title="循环使用"></a>循环使用</h2><h3 id="循环的介绍"><a href="#循环的介绍" class="headerlink" title="循环的介绍"></a>循环的介绍</h3><ul><li>在开发中经常会需要循环</li><li>常见的循环有:for/while/do while.</li><li>这里我们只介绍for/while,因为for/while最常见<h3 id="for循环的写法"><a href="#for循环的写法" class="headerlink" title="for循环的写法"></a>for循环的写法</h3></li><li>区间for循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in 0..&lt;10 &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line">for i in 0...10 &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line">//特殊写法:如果在for循环中不需要用到下标i</span><br><span class="line">for _ in 0..&lt;10 &#123;</span><br><span class="line">print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><a href="http://www.jianshu.com/p/0f75c23773b5" target="_blank" rel="noopener">Swift中遍历方法for in 和 forEach的区别</a></p></blockquote><h3 id="while和do-while循环"><a href="#while和do-while循环" class="headerlink" title="while和do while循环"></a>while和do while循环</h3><ul><li>while循环<ul><li>while的判断句必须有正确的真假,没有非0即真</li><li>while后面的()可以省略<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 0</span><br><span class="line">while a &lt; 10 &#123;</span><br><span class="line">    a++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//--do while循环:使用repeat关键字来代替了do--</span><br><span class="line">    let b = 0</span><br><span class="line">repeat &#123;</span><br><span class="line">    print(b)</span><br><span class="line">    b++</span><br><span class="line">&#125; while b &lt; 20</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS之NSDate的Category</title>
      <link href="/2016/11/25/iOS%E4%B9%8BNSDate%E7%9A%84Category/"/>
      <content type="html"><![CDATA[<h4 id="判断日期是是否是今年？今天？"><a href="#判断日期是是否是今年？今天？" class="headerlink" title="判断日期是是否是今年？今天？"></a>判断日期是是否是今年？今天？</h4><a id="more"></a><h5 id="NSDate-Extension-h"><a href="#NSDate-Extension-h" class="headerlink" title="NSDate+Extension.h"></a>NSDate+Extension.h</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较from和self的时间差值</span></span><br><span class="line">- (<span class="built_in">NSDateComponents</span> *)deltaFrom:(<span class="built_in">NSDate</span> *)from;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//是否为今年</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isThisYear;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为今天</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isToday;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为昨天</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isYesterday;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为明天</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isTomorrow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h5 id="NSDate-Extension-m"><a href="#NSDate-Extension-m" class="headerlink" title="NSDate+Extension.m"></a>NSDate+Extension.m</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSDate+Extension.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSDate</span> (<span class="title">Extension</span>)</span></span><br><span class="line">- (<span class="built_in">NSDateComponents</span> *)deltaFrom:(<span class="built_in">NSDate</span> *)from</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 日历</span></span><br><span class="line">    <span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较时间</span></span><br><span class="line">    <span class="built_in">NSCalendarUnit</span> unit = <span class="built_in">NSCalendarUnitDay</span> | <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitYear</span> | <span class="built_in">NSCalendarUnitHour</span> | <span class="built_in">NSCalendarUnitMinute</span> | <span class="built_in">NSCalendarUnitSecond</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [calendar components:unit fromDate:from toDate:<span class="keyword">self</span> options:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isThisYear</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 日历</span></span><br><span class="line">    <span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> nowYear = [calendar component:<span class="built_in">NSCalendarUnitYear</span> fromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    <span class="built_in">NSInteger</span> selfYear = [calendar component:<span class="built_in">NSCalendarUnitYear</span> fromDate:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nowYear == selfYear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isToday</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *fmt = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    fmt.dateFormat = <span class="string">@"yyyy-MM-dd"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *nowString = [fmt stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    <span class="built_in">NSString</span> *selfString = [fmt stringFromDate:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [nowString isEqualToString:selfString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isYesterday</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2014-12-31 23:59:59 -&gt; 2014-12-31</span></span><br><span class="line">    <span class="comment">// 2015-01-01 00:00:01 -&gt; 2015-01-01</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 日期格式化类</span></span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *fmt = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    fmt.dateFormat = <span class="string">@"yyyy-MM-dd"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDate</span> *nowDate = [fmt dateFromString:[fmt stringFromDate:[<span class="built_in">NSDate</span> date]]];</span><br><span class="line">    <span class="built_in">NSDate</span> *selfDate = [fmt dateFromString:[fmt stringFromDate:<span class="keyword">self</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    <span class="built_in">NSDateComponents</span> *cmps = [calendar components:<span class="built_in">NSCalendarUnitDay</span> | <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitYear</span> fromDate:selfDate toDate:nowDate options:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cmps.year == <span class="number">0</span></span><br><span class="line">    &amp;&amp; cmps.month == <span class="number">0</span></span><br><span class="line">    &amp;&amp; cmps.day == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isTomorrow&#123;</span><br><span class="line">     <span class="built_in">NSDateFormatter</span> *fmt = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    fmt.dateFormat = <span class="string">@"yyyy-MM-dd"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDate</span> *nowDate = [fmt dateFromString:[fmt stringFromDate:[<span class="built_in">NSDate</span> date]]];</span><br><span class="line">    <span class="built_in">NSDate</span> *selfDate = [fmt dateFromString:[fmt stringFromDate:<span class="keyword">self</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    <span class="built_in">NSDateComponents</span> *cmps = [calendar components:<span class="built_in">NSCalendarUnitDay</span> | <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitYear</span> fromDate:nowDate toDate:selfDate options:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cmps.year == <span class="number">0</span></span><br><span class="line">    &amp;&amp; cmps.month == <span class="number">0</span></span><br><span class="line">    &amp;&amp; cmps.day == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="简单使用TopicModel"><a href="#简单使用TopicModel" class="headerlink" title="简单使用TopicModel"></a>简单使用TopicModel</h3><h5 id="import-“TopicModel-m”文件中"><a href="#import-“TopicModel-m”文件中" class="headerlink" title="#import “TopicModel.m”文件中"></a>#import “TopicModel.m”文件中</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)create_time</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 日期格式化类</span></span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *fmt = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    <span class="comment">// 设置日期格式(y:年,M:月,d:日,H:时,m:分,s:秒)</span></span><br><span class="line">    fmt.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">    <span class="comment">// 帖子的创建时间</span></span><br><span class="line">    <span class="built_in">NSDate</span> *create = [fmt dateFromString:_create_time];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (create.isThisYear) &#123; <span class="comment">// 今年</span></span><br><span class="line">        <span class="keyword">if</span> (create.isToday) &#123; <span class="comment">// 今天</span></span><br><span class="line">            <span class="built_in">NSDateComponents</span> *cmps = [[<span class="built_in">NSDate</span> date] deltaFrom:create];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cmps.hour &gt;= <span class="number">1</span>) &#123; <span class="comment">// 时间差距 &gt;= 1小时</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%zd小时前"</span>, cmps.hour];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmps.minute &gt;= <span class="number">1</span>) &#123; <span class="comment">// 1小时 &gt; 时间差距 &gt;= 1分钟</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%zd分钟前"</span>, cmps.minute];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1分钟 &gt; 时间差距</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">@"刚刚"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (create.isYesterday) &#123; <span class="comment">// 昨天</span></span><br><span class="line">            fmt.dateFormat = <span class="string">@"昨天 HH:mm:ss"</span>;</span><br><span class="line">            <span class="keyword">return</span> [fmt stringFromDate:create];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(creat.isTomorrow)&#123;</span><br><span class="line">            fmt.dateFormat = <span class="string">@"明天 HH:mm:ss"</span>;</span><br><span class="line">            <span class="keyword">return</span> [fmt stringFromDate:create];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 其他</span></span><br><span class="line">            fmt.dateFormat = <span class="string">@"MM-dd HH:mm:ss"</span>;</span><br><span class="line">            <span class="keyword">return</span> [fmt stringFromDate:create];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非今年</span></span><br><span class="line">        <span class="keyword">return</span> _create_time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> Category </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS之UIMenuController的简单使用</title>
      <link href="/2016/11/22/iOS%E4%B9%8BUIMenuController%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <content type="html"><![CDATA[<h2 id="UIMenuController须知"><a href="#UIMenuController须知" class="headerlink" title="UIMenuController须知"></a>UIMenuController须知</h2><ul><li>默认情况下, 有以下控件已经支持UIMenuController<ul><li>UITextField</li><li>UITextView</li><li>UIWebView</li></ul></li></ul><a id="more"></a><h2 id="让其他控件也支持UIMenuController-比如UILabel"><a href="#让其他控件也支持UIMenuController-比如UILabel" class="headerlink" title="让其他控件也支持UIMenuController(比如UILabel)"></a>让其他控件也支持UIMenuController(比如UILabel)</h2><ol><li>自定义UILabel</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUp &#123; </span><br><span class="line">  <span class="comment">// 1.设置label可以交互 </span></span><br><span class="line">  <span class="keyword">self</span>.userInteractionEnabled = <span class="literal">YES</span>;  </span><br><span class="line">  <span class="comment">// 2.添加点击手势 </span></span><br><span class="line">  [<span class="keyword">self</span> addGestureRecognizer:[[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(lableClick)]];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)lableClick &#123; </span><br><span class="line">  <span class="comment">// 3.设置label为第一响应者,只有成为响应者才能够将MenuController显示在其上面 </span></span><br><span class="line">  [<span class="keyword">self</span> becomeFirstResponder]; </span><br><span class="line">  <span class="comment">// 4.初始化UIMenuController </span></span><br><span class="line">  <span class="built_in">UIMenuController</span> *menuController = [<span class="built_in">UIMenuController</span> sharedMenuController];  </span><br><span class="line">  <span class="comment">// 5.设置UIMenuController显示的位置 </span></span><br><span class="line">  <span class="comment">// targetRect : 将要显示所在label的frame; </span></span><br><span class="line">  <span class="comment">// view : targetRect所在的坐标系参照物(父view或self)</span></span><br><span class="line">  [menuController setTargetRect:<span class="keyword">self</span>.frame inView:<span class="keyword">self</span>.superview];</span><br><span class="line">  <span class="comment">// [menuController setTargetRect:self.bounds inView:self];作用同上  </span></span><br><span class="line">  <span class="comment">// 6.显示UIMenuController </span></span><br><span class="line">  [menuController setMenuVisible:<span class="literal">YES</span> animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在UILable内重写2个方法</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 让label有资格成为第一响应者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * label能执行哪些操作(比如copy, paste等等)</span></span><br><span class="line"><span class="comment"> * @return  YES:支持这种操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(cut:) || action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:) || action == <span class="keyword">@selector</span>(paste:)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.实现各种操作方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cut:(<span class="built_in">UIMenuController</span> *)menu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将自己的文字复制到粘贴板</span></span><br><span class="line">    <span class="built_in">UIPasteboard</span> *board = [<span class="built_in">UIPasteboard</span> generalPasteboard];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空文字</span></span><br><span class="line">    <span class="keyword">self</span>.text = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="keyword">copy</span>:(<span class="built_in">UIMenuController</span> *)menu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将自己的文字复制到粘贴板</span></span><br><span class="line">    <span class="built_in">UIPasteboard</span> *board = [<span class="built_in">UIPasteboard</span> generalPasteboard];</span><br><span class="line">    board.string = <span class="keyword">self</span>.text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)paste:(<span class="built_in">UIMenuController</span> *)menu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将粘贴板的文字 复制 到自己身上</span></span><br><span class="line">    <span class="built_in">UIPasteboard</span> *board = [<span class="built_in">UIPasteboard</span> generalPasteboard];</span><br><span class="line">    <span class="keyword">self</span>.text = board.string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="自定义UIMenuController内部的Item-在cell中"><a href="#自定义UIMenuController内部的Item-在cell中" class="headerlink" title="自定义UIMenuController内部的Item(在cell中)"></a>自定义UIMenuController内部的Item(在cell中)</h2><ul><li>由于手动添加的MenuItem默认触发控制器中的方法,所以将MenuController的显示/隐藏,添加MenuItem写到控制器</li></ul><ol><li>添加item</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123; </span><br><span class="line">  <span class="comment">// 点击cell弹出UIMenuController </span></span><br><span class="line">  <span class="comment">// 1.如果menuController已经在显示,就隐藏他</span></span><br><span class="line">  <span class="comment">// 注意,如果有一个cell正在显示menuController,这时再点击另外一个cell,上一个cell的menuController会消失,当前点击cell会显示,这是因为上一个cell不再是第一响应者了,menuController会自动释放 </span></span><br><span class="line">  <span class="built_in">UIMenuController</span> *menuController = [<span class="built_in">UIMenuController</span> sharedMenuController]; </span><br><span class="line">  <span class="keyword">if</span> (menuController.isMenuVisible) &#123; </span><br><span class="line">    [menuController setMenuVisible:<span class="literal">NO</span> animated:<span class="literal">YES</span>];  </span><br><span class="line">  &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 2.显示MenuController </span></span><br><span class="line">    <span class="comment">// 先设置cell为第一响应者,同时不要忘记在cell中重写canBecomeFirstResponder和canPerformAction:withSender: </span></span><br><span class="line">    JCMTopicCommentCell *cell = [tableView cellForRowAtIndexPath:indexPath]; </span><br><span class="line">    [cell becomeFirstResponder]; </span><br><span class="line">    <span class="comment">// 添加menuItem </span></span><br><span class="line">    <span class="built_in">UIMenuItem</span> *item01 = [[<span class="built_in">UIMenuItem</span> alloc]initWithTitle:<span class="string">@"赞"</span> action:<span class="keyword">@selector</span>(zanClick:)]; </span><br><span class="line">    <span class="built_in">UIMenuItem</span> *item02 = [[<span class="built_in">UIMenuItem</span> alloc]initWithTitle:<span class="string">@"回复"</span> action:<span class="keyword">@selector</span>(responseClick:)]; </span><br><span class="line">    <span class="built_in">UIMenuItem</span> *item03 = [[<span class="built_in">UIMenuItem</span> alloc]initWithTitle:<span class="string">@"举报"</span> action:<span class="keyword">@selector</span>(reportClick:)]; </span><br><span class="line">    menuController.menuItems = @[item01,item02,item03]; </span><br><span class="line">    <span class="comment">// 设置menuControoler显示位置 </span></span><br><span class="line">     <span class="built_in">CGRect</span> showRect = <span class="built_in">CGRectMake</span>(cell.x, cell.y + cell.height/<span class="number">2</span>, cell.width, cell.height); </span><br><span class="line">     [menuController setTargetRect:showRect inView:cell.superview]; </span><br><span class="line">    <span class="comment">// 显示menuController [menuController setMenuVisible:YES animated:YES];  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>cell中实现两个方法</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 让label有资格成为第一响应者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * label能执行哪些操作(比如copy, paste等等)</span></span><br><span class="line"><span class="comment"> * @return  YES:支持这种操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(cut:) || action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:) || action == <span class="keyword">@selector</span>(paste:)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>处理方法的实现</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - MenuControllerClick</span></span><br><span class="line"><span class="comment">// MenuController手动添加的item的方法实现必须放在controller中</span></span><br><span class="line">- (<span class="keyword">void</span>)zanClick:(<span class="built_in">UIMenuController</span> *)menu &#123; </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.tableView indexPathForSelectedRow]; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="keyword">self</span> commentInIndexPath:indexPath].content);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)responseClick:(<span class="built_in">UIMenuController</span> *)menu &#123; </span><br><span class="line">  <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.tableView indexPathForSelectedRow]; </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="keyword">self</span> commentInIndexPath:indexPath].content);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)reportClick:(<span class="built_in">UIMenuController</span> *)menu &#123; </span><br><span class="line">  <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.tableView indexPathForSelectedRow]; </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="keyword">self</span> commentInIndexPath:indexPath].content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> UIMenuController </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS之UITableView设置全屏分隔线</title>
      <link href="/2016/11/20/iOS%E4%B9%8BUITableView%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E5%88%86%E9%9A%94%E7%BA%BF/"/>
      <content type="html"><![CDATA[<h2 id="UICollectionView基础"><a href="#UICollectionView基础" class="headerlink" title="UICollectionView基础"></a>UICollectionView基础</h2><h4 id="首先系统的分隔线有以下几种"><a href="#首先系统的分隔线有以下几种" class="headerlink" title="首先系统的分隔线有以下几种"></a>首先系统的分隔线有以下几种</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tableView.separatorStyle = UITableViewCellSeparatorStyleNone;</span><br><span class="line"></span><br><span class="line">-UITableViewCellSeparatorStyleNone //隐藏系统分隔线</span><br><span class="line">-UITableViewCellSeparatorStyleSingleLine //单分隔线</span><br><span class="line">-UITableViewCellSeparatorStyleSingleLineEtched //被侵蚀的单分隔线</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="自定义分隔线（首先要隐藏系统的分隔线）"><a href="#自定义分隔线（首先要隐藏系统的分隔线）" class="headerlink" title="自定义分隔线（首先要隐藏系统的分隔线）"></a>自定义分隔线（首先要隐藏系统的分隔线）</h4><ol><li>通过xib或者代码在cell底部添加一条高度为1的UIView或者UILable分隔线。</li><li>通过drawRect：方法自绘一条分割线</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 自绘分割线</span><br><span class="line">- (void)drawRect:(CGRect)rect&#123;</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line">    CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor);</span><br><span class="line">    CGContextFillRect(context, rect);</span><br><span class="line"></span><br><span class="line">    CGContextSetStrokeColorWithColor(context, [UIColor colorWithRed:0xE2/255.0f green:0xE2/255.0f blue:0xE2/255.0f alpha:1].CGColor);</span><br><span class="line">    CGContextStrokeRect(context, CGRectMake(0, rect.size.height - 1, rect.size.width, 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.重写cell的setFrame：方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFrame:(CGRect)frame&#123;</span><br><span class="line">    frame.size.height -= 1;//设置分隔线</span><br><span class="line">    </span><br><span class="line">    //设置cell的左右间距</span><br><span class="line">    frame.origin.x = 5;//左间距为5</span><br><span class="line">    frame.size.width = [UIScreen mainScreen].bounds.size.width - 2 * frame.origin.x;</span><br><span class="line">    </span><br><span class="line">    // 给cellframe赋值</span><br><span class="line">    [super setFrame:frame];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.利用系统属性设置(separatorInset, layoutMargins)设置</p><ul><li><p>对tableView的separatorInset, layoutMargins属性的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidLoad &#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line">  //1.调整(iOS7以上)表格分隔线边距</span><br><span class="line">  if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) &#123;</span><br><span class="line">      self.tableView.separatorInset = UIEdgeInsetsZero;</span><br><span class="line">  &#125;</span><br><span class="line">  //2.调整(iOS8以上)view边距(或者在cell中设置preservesSuperviewLayoutMargins,二者等效)</span><br><span class="line">  if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) &#123;</span><br><span class="line">      self.tableView.layoutMargins = UIEdgeInsetsZero;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对cell的LayoutMargins属性的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//对cell的设置可以写在cellForRowAtIndexPath里,也可以写在willDisplayCell方法里</span><br><span class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    static NSString *ID = @&quot;cell&quot;;</span><br><span class="line">    FSDiscoverSpecialCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];</span><br><span class="line">    if (cell == nil) &#123;</span><br><span class="line">        cell = [[FSDiscoverSpecialCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //2.调整(iOS8以上)tableView边距(与上面第2步等效,二选一即可)</span><br><span class="line">    if ([cell respondsToSelector:@selector(setPreservesSuperviewLayoutMargins:)]) &#123;</span><br><span class="line">        cell.preservesSuperviewLayoutMargins = NO;</span><br><span class="line">    &#125;</span><br><span class="line">   //3.调整(iOS8以上)view边距</span><br><span class="line">    if ([cell respondsToSelector:@selector(setLayoutMargins:)]) &#123;</span><br><span class="line">        [cell setLayoutMargins:UIEdgeInsetsZero];</span><br><span class="line">    &#125;</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三种方法优缺点比较："><a href="#三种方法优缺点比较：" class="headerlink" title="三种方法优缺点比较："></a>三种方法优缺点比较：</h2><ul><li><p>方法1一般使用系统的cell，或者对cell没有特殊要求的情况下使用系统的分隔线；</p></li><li><p>方法2是比较好用的,但是有些情况下系统自带的cell就足够用了,仅仅为了分隔线却还必须再自定义cell,添加一个view,设置背景颜色和frame,又显得麻烦;</p></li><li><p>方法3比较取巧,但是也需要自定义cell,在某些情况下不允许改变tableView的背景色,使用场景有限;</p></li><li><p>方法4不需要自定义cell,对系统(iOS7,iOS8以上)做个简单判断即可.</p></li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS之UICollectionView自定义布局</title>
      <link href="/2016/11/15/iOS%E4%B9%8BUICollectionView%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/"/>
      <content type="html"><![CDATA[<h2 id="UICollectionView基础"><a href="#UICollectionView基础" class="headerlink" title="UICollectionView基础"></a>UICollectionView基础</h2><ul><li><code>UICollectionViewFlowLayout</code>：视图布局对象（流水布局：一行排满，自动排到下行），继承自<code>UICollectionViewLayout</code>。<code>UICollectionViewLayout</code>内有一个<code>collectionView</code>属性，所有的视图布局对象都继承自<code>UICollectionViewLayout</code>。</li><li>若我们要自定义布局对象，我们一般继承<code>UICollectionViewFlowLayout</code>，然后重写里面的一些方法就可以了。</li><li>需要实现三个协议: <code>UICollectionViewDataSource</code>（数据源）、<code>UICollectionViewDelegateFlowLayout</code>（视图布局），自定义布局需要实现<code>UICollectionViewDataSource</code>、<code>UICollectionViewDelegate</code>两个协议即可。</li></ul><a id="more"></a><h4 id="一、自定义线性布局"><a href="#一、自定义线性布局" class="headerlink" title="一、自定义线性布局"></a>一、自定义线性布局</h4><ul><li><strong>首先要继承与流水布局UICollectionViewFlowLayout</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LineCollectionViewLayout</span> : <span class="title">UICollectionViewFlowLayout</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li><strong>重写相应的方法</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"LineCollectionViewLayout.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LineCollectionViewLayout</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来做布局的初始化操作（不建议在init方法中进行布局的初始化操作）</span></span><br><span class="line"><span class="comment"> - 注意：一定要调用[super prepareLayout]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)prepareLayout&#123;</span><br><span class="line">    [<span class="keyword">super</span> prepareLayout];</span><br><span class="line">    <span class="comment">// 水平滚动</span></span><br><span class="line">    <span class="keyword">self</span>.scrollDirection = <span class="built_in">UICollectionViewScrollDirectionHorizontal</span>;</span><br><span class="line">    <span class="comment">// 设置内边距</span></span><br><span class="line">    <span class="built_in">CGFloat</span> inset = (<span class="keyword">self</span>.collectionView.frame.size.width - <span class="keyword">self</span>.itemSize.width) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">self</span>.sectionInset = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, inset, <span class="number">0</span>, inset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法的返回值是一个数组（数组里面存放着rect范围内所有元素的布局属性）</span></span><br><span class="line"><span class="comment"> * 这个数组中存放的都是UICollectionViewLayoutAttributes对象</span></span><br><span class="line"><span class="comment"> * 这个方法的返回值决定了rect范围内所有元素的排布（frame）*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> UICollectionViewLayoutAttributes *attrs;</span></span><br><span class="line"><span class="comment"> 1.一个cell对应一个UICollectionViewLayoutAttributes对象</span></span><br><span class="line"><span class="comment"> 2.UICollectionViewLayoutAttributes对象决定了cell的frame</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)layoutAttributesForElementsInRect:(<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    <span class="comment">// 获得super已经计算好的布局属性</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array = [<span class="keyword">super</span> layoutAttributesForElementsInRect:rect];</span><br><span class="line">    <span class="comment">// 计算collectionView最中心点的x值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> centerX = <span class="keyword">self</span>.collectionView.contentOffset.x + <span class="keyword">self</span>.collectionView.frame.size.width * <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 在原有布局属性的基础上，进行微调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UICollectionViewLayoutAttributes</span> *attrs <span class="keyword">in</span> array) &#123;</span><br><span class="line">        <span class="comment">// cell的中心点x 和 collectionView最中心点的x值 的间距</span></span><br><span class="line">        <span class="built_in">CGFloat</span> delta = ABS(attrs.center.x - centerX);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据间距值 计算 cell的缩放比例</span></span><br><span class="line">        <span class="built_in">CGFloat</span> scale = <span class="number">1</span> - delta / <span class="keyword">self</span>.collectionView.frame.size.width;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置缩放比例</span></span><br><span class="line">        attrs.transform = <span class="built_in">CGAffineTransformMakeScale</span>(scale, scale);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当collectionView的显示范围发生改变的时候，是否需要重新刷新布局</span></span><br><span class="line"><span class="comment"> * 一旦重新刷新布局，就会重新调用下面的方法：</span></span><br><span class="line"><span class="comment"> 1.prepareLayout</span></span><br><span class="line"><span class="comment"> 2.layoutAttributesForElementsInRect:方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class="built_in">CGRect</span>)newBounds&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法的返回值，就决定了collectionView停止滚动时的偏移量</span></span><br><span class="line"><span class="comment"> * proposedContentOffset：原本情况下，collectionView停止滚动时最终的偏移量</span></span><br><span class="line"><span class="comment"> * velocity：滚动速率，通过这个参数可以了解滚动的方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)targetContentOffsetForProposedContentOffset:(<span class="built_in">CGPoint</span>)proposedContentOffset withScrollingVelocity:(<span class="built_in">CGPoint</span>)velocity&#123;</span><br><span class="line">    <span class="comment">// 计算出最终显示的矩形框</span></span><br><span class="line">    <span class="built_in">CGRect</span> rect;</span><br><span class="line">    rect.origin.y = <span class="number">0</span>;</span><br><span class="line">    rect.origin.x = proposedContentOffset.x;</span><br><span class="line">    rect.size = <span class="keyword">self</span>.collectionView.frame.size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得super已经计算好的布局属性</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array = [<span class="keyword">super</span> layoutAttributesForElementsInRect:rect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算collectionView最中心点的x值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> centerX = proposedContentOffset.x + <span class="keyword">self</span>.collectionView.frame.size.width * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存放最小的间距值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> minDelta = MAXFLOAT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UICollectionViewLayoutAttributes</span> *attrs <span class="keyword">in</span> array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ABS(minDelta) &gt; ABS(attrs.center.x - centerX)) &#123;</span><br><span class="line">            minDelta = attrs.center.x - centerX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改原有的偏移量</span></span><br><span class="line">    proposedContentOffset.x += minDelta;</span><br><span class="line">    <span class="keyword">return</span> proposedContentOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="自定义环形布局"><a href="#自定义环形布局" class="headerlink" title="自定义环形布局"></a>自定义环形布局</h4><ul><li><strong>同样要继承与流水布局UICollectionViewFlowLayout</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CircleCollectionViewLayout</span> : <span class="title">UICollectionViewFlowLayout</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li><strong>重写相应的方法</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CircleCollectionViewLayout.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CircleCollectionViewLayout</span>()</span></span><br><span class="line"><span class="comment">/** 布局属性 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *attrsArray;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CircleCollectionViewLayout</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 懒加载 */</span></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)attrsArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_attrsArray) &#123;</span><br><span class="line">        _attrsArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _attrsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)prepareLayout</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> prepareLayout];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.attrsArray removeAllObjects];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> count = [<span class="keyword">self</span>.collectionView numberOfItemsInSection:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">NSIndexPath</span> *indexPath = [<span class="built_in">NSIndexPath</span> indexPathForItem:i inSection:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">UICollectionViewLayoutAttributes</span> *attrs = [<span class="keyword">self</span> layoutAttributesForItemAtIndexPath:indexPath];</span><br><span class="line">        [<span class="keyword">self</span>.attrsArray addObject:attrs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)layoutAttributesForElementsInRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.attrsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法需要返回indexPath位置对应cell的布局属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> *)layoutAttributesForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> count = [<span class="keyword">self</span>.collectionView numberOfItemsInSection:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> radius = <span class="number">70</span>;</span><br><span class="line">    <span class="comment">// 圆心的位置</span></span><br><span class="line">    <span class="built_in">CGFloat</span> oX = <span class="keyword">self</span>.collectionView.frame.size.width * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> oY = <span class="keyword">self</span>.collectionView.frame.size.height * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UICollectionViewLayoutAttributes</span> *attrs = [<span class="built_in">UICollectionViewLayoutAttributes</span> layoutAttributesForCellWithIndexPath:indexPath];</span><br><span class="line">    </span><br><span class="line">    attrs.size = <span class="built_in">CGSizeMake</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">        attrs.center = <span class="built_in">CGPointMake</span>(oX, oY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> angle = (<span class="number">2</span> * M_PI / count) * indexPath.item;</span><br><span class="line">        <span class="built_in">CGFloat</span> centerX = oX + radius * sin(angle);</span><br><span class="line">        <span class="built_in">CGFloat</span> centerY = oY + radius * cos(angle);</span><br><span class="line">        attrs.center = <span class="built_in">CGPointMake</span>(centerX, centerY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> attrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="对自定义布局的使用"><a href="#对自定义布局的使用" class="headerlink" title="对自定义布局的使用"></a>对自定义布局的使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 创建布局</span></span><br><span class="line">    CircleCollectionViewLayout *layout = [[CircleCollectionViewLayout alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建CollectionView</span></span><br><span class="line">    <span class="built_in">CGFloat</span> collectionW = <span class="keyword">self</span>.view.frame.size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> collectionH = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">150</span>, collectionW, collectionH);</span><br><span class="line">    <span class="built_in">UICollectionView</span> *collectionView = [[<span class="built_in">UICollectionView</span> alloc] initWithFrame:frame collectionViewLayout:layout];</span><br><span class="line">    collectionView.dataSource = <span class="keyword">self</span>;</span><br><span class="line">    collectionView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:collectionView];</span><br><span class="line">    <span class="keyword">self</span>.collectionView = collectionView;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    [collectionView registerNib:[<span class="built_in">UINib</span> nibWithNibName:<span class="built_in">NSStringFromClass</span>([PhotoCell <span class="keyword">class</span>]) bundle:<span class="literal">nil</span>] forCellWithReuseIdentifier:photoId];</span><br><span class="line"> ```  </span><br><span class="line"> </span><br><span class="line">- 增加 touchesBegan：方法，通过点击让两种布局相互转换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.collectionView.collectionViewLayout isKindOfClass:[LineCollectionViewLayout <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.collectionView setCollectionViewLayout:[[CircleCollectionViewLayout alloc] init] animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LineCollectionViewLayout *layout = [[LineCollectionViewLayout alloc] init];</span><br><span class="line">        layout.itemSize = <span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">        [<span class="keyword">self</span>.collectionView setCollectionViewLayout:layout animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac破解版软件大全</title>
      <link href="/2016/10/10/Mac%E7%A0%B4%E8%A7%A3%E7%89%88%E8%BD%AF%E4%BB%B6%E5%A4%A7%E5%85%A8/"/>
      <content type="html"><![CDATA[<blockquote><p>转自<a href="http://www.sdifenzhou.com/page/6/" target="_blank" rel="noopener">史蒂芬周的博客</a></p></blockquote><blockquote><p>转自<a href="http://www.pc6.com/mac/soft/" target="_blank" rel="noopener">苹果网 PC6 </a></p></blockquote><a id="more"></a>]]></content>
      
      
        <tags>
            
            <tag> Mac 工具 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
