{"meta":{"title":"RunningTitan","subtitle":"技术博客","description":"我还年轻，我渴望上路。带着最初的激情，追寻着最初的梦想，感受着最初的体验，我们上路吧!","author":"RunningTitan","url":"https://titanjun.top"},"pages":[{"title":"","date":"2018-04-08T08:36:28.808Z","updated":"2018-04-08T08:36:28.808Z","comments":true,"path":"404.html","permalink":"https://titanjun.top/404.html","excerpt":"","text":""},{"title":"关于我","date":"2017-01-10T14:20:12.000Z","updated":"2018-04-09T02:29:09.360Z","comments":true,"path":"about/index.html","permalink":"https://titanjun.top/about/index.html","excerpt":"","text":"前言 该网站为个人技术博客网站, 主要用于记录个人的一些学习心得和技术笔记, 偶尔也会吐槽吐槽 个人网站成立差不多刚好一个月, 之前所有文章都是放在简书和CSDN, 因为我个人也比较喜欢逛一个技术论坛和博客, 所以自己也经常写点东西, 以后也会继续坚持下去 个人简介 90后程序猿(93年) iOS开发工程师 毕业于非一流本科大学 目前工作于杭州, 很喜欢的城市, 准备落户于此 学习历程作为一名iOS开发程序猿, 总喜欢折腾, 喜欢研究和学习一些开发语言或框架 C 和 C++ Objective-C 和 Cocoa Reactive Swift 和 RxSwift HTML5 JavaScript React Native Python (正在学习中…) 短期计划 继续学习Python 机器学习或者人工智能 考研(在职硕士) 本来打算三月份报名同等学力申硕 实在没有合适的专业和上课地点(杭州) 还有就是五月份的同等学力申硕没有毕业证, 所以就算毕业了, 也还是本科学历, 故暂时放弃 目前在考虑非全日制在职研究生(12月份全国联考) 联系我 简书: https://www.jianshu.com/u/5bd5e9ed569e CSDN: https://blog.csdn.net/shmilycoder Github: https://github.com/CoderTitan 掘金: https://juejin.im/user/5a7a64ae6fb9a0636323fd06 MyMusic"},{"title":"所有分类","date":"2017-01-11T09:00:30.000Z","updated":"2018-04-01T08:46:56.462Z","comments":true,"path":"categories/index.html","permalink":"https://titanjun.top/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-01-10T14:54:00.000Z","updated":"2018-03-05T11:42:48.632Z","comments":true,"path":"tags/index.html","permalink":"https://titanjun.top/tags/index.html","excerpt":"","text":"JavaScript"}],"posts":[{"title":"Python数据类型详解","slug":"Python数据类型详解","date":"2018-04-10T08:45:56.000Z","updated":"2018-04-10T09:31:23.317Z","comments":true,"path":"2018/04/10/Python数据类型详解/","link":"","permalink":"https://titanjun.top/2018/04/10/Python数据类型详解/","excerpt":"Python（英语发音：/ˈpaɪθən/）, 是一种面向对象、解释型计算机程序设计语言，由Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。 Python是纯粹的自由软件， 源代码和解释器CPython遵循 GPL(GNU General Public License)协议 。 Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进 Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言 Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序 Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术 Python是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏","text":"Python（英语发音：/ˈpaɪθən/）, 是一种面向对象、解释型计算机程序设计语言，由Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。 Python是纯粹的自由软件， 源代码和解释器CPython遵循 GPL(GNU General Public License)协议 。 Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进 Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言 Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序 Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术 Python是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏 一. Mac系统下搭建Python环境 首先到Python官网 下载安装最新版本的Python, 安装比较无脑,一路按下去就OK 具体可参考在Mac OS上搭建Python的开发环境 安装Python开发软件, 推荐两款开发软件Pycharm和Sublime Text, 这里只介绍Pycharm的安装和破解方法 首先到这里下载Pycharm软件 然后到这里找软件的相关破解方法 Python的开发环境和开发软件都搞定之后,下面我们就来看看Python的基本语法吧 测试代码详见 GitHub地址 二. 基本语法1. 输出格式Python的输出语法和Swift的输出一样 12# 输出print(\"Hello Python\") 2. 注释 python中单行注释采用 # 开头。 python 中多行注释使用三个单引号 &#39;&#39;&#39; 或三个双引号 &quot;&quot;&quot; 123456789101112131415# 这里是单行注释'''这是多行注释，使用单引号。这是多行注释，使用单引号。这是多行注释，使用单引号。'''\"\"\"这是多行注释，使用双引号。这是多行注释，使用双引号。这是多行注释，使用双引号。\"\"\" 3. 变量Python中的变量不需要声明，变量的赋值操作既是变量声明和定义的过程。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建 123counter = 100 # 赋值整型变量miles = 1000.0 # 浮点型name = \"John\" # 字符串 Python允许你同时为多个变量赋值, 也可以为多个对象指定多个变量。例如： 1234a = b = c = 1 # 多变量赋值a, b, c = 1, 2, \"jun\" 三. 标准数据类型 Python有五个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） 1. Numbers（数字） Number是不可被改变的数据类型, 当你指定一个值时，Number对象就会被创建 Python支持四种不同的数值类型： int（有符号整型） long（长整型[也可以代表八进制和十六进制]） float（浮点型） complex（复数） 复数: 和数学中的复数含义一样, 复数由实数部分和虚数部分构成，可以用a + bj, 或者complex(a, b)表示， 复数的实部a和虚部b都是浮点型 int long float complex 10 51924361L 0.0 3.14j 100 -0x19323L 15.20 45.j -786 0122L -21.9 9.322e-36j 080 0xDEFABCECBDAECBFBAEl 32.3+e18 .876j -0490 535633629843L -90. -.6545+0J -0x260 -052318172735L -32.54e100 3e+26J 0x69 -4721885298529L 70.2-E12 4.53e-7j 2. Python字符串 字符串或串(String)是由数字、字母、下划线组成的一串字符 和Swift中的字符串一样, 每一个字符都有一个与之对应的索引 python的字串列表有2种取值顺序: 从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头 获取某一部分字符串的格式: [头下标:尾下标] 1234567891011121314151617181920212223242526272829# 字符串str = 'Hello Python'# 1. 输出完整字符串print(\"完整字符串--\" + str)# 结果输出:# 2. 输出第一个字符print(\"第一个字符--\" + str[0])# 3. 输出第三到七个字符print(\"第3-7个字符--\" + str[2:6])# 4. 输出低2个字符开始的所有字符print(\"第2个开始的所有字符--\" + str[1:])# 5. 拼接字符串# 像上面一样, 字符串用 `+`拼接print(\"拼接--\" + str)# 6. 输出3次# `*` 表示重复操作, 需要重复操作几次, 后面跟上次数即可print(str * 3)# 7. 输出最后一个字符print(\"最后一个字符--\" + str[-1])# 8. 输出倒数第二个字符print(\"倒数第二个字符--\" + str[-2]) 下面是以上语法的输出结果 12345678910/*完整字符串--Hello Python第一个字符--H第3-7个字符--llo 第2个开始的所有字符--ello Python拼接--Hello PythonHello PythonHello PythonHello Python最后一个字符--n倒数第二个字符--o*/ 3. List（列表） List（列表） 是 Python 中使用最频繁的数据类型, 和C语言中的数组一样, 语法操作和上述字符串类似 列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（所谓嵌套）。 列表用[ ]标识。是python最通用的复合数据类型 列表中的值得分割也可以用到变量[头下标:尾下标]，就可以截取相应的列表 从左到右索引默认0开始的 从右到左索引默认-1开始 下标可以为空表示取到头或尾。 加号（+）是列表连接运算符，星号（*）是重复操作 123456789101112131415161718192021222324252627282930# List 列表list1 = [12, 34, 3.14, 5.3, 'titan']list2 = [10, 'jun']# 1.完整列表print(list1)# 2.列表第一个元素print(list1[0])# 3.获取第2-3个元素print(list1[1:2])# 4.获取第三个到最后的所有元素print(list1[2:])# 5.获取最后一个元素print(list1[-1])# 6.获取倒数第二个元素print(list1[-2])# 7.获取最后三个元素print(list1[-3:-1])# 8.合并列表print(list1 + list2)# 9.重复操作两次print(list2 * 2) 上述语句输出结果如下 123456789[12, 34, 3.14, 5.3, 'titan']12[34][3.14, 5.3, 'titan']titan5.3[3.14, 5.3][12, 34, 3.14, 5.3, 'titan', 10, 'jun'][10, 'jun', 10, 'jun'] 4. 元组 元组是另一个数据类型(Python中的元组和Swift中的元组类似) 元组用”()”标识。内部元素用逗号隔开 元素不能二次赋值，相当于只读列表 123456789101112131415161718192021222324252627282930# 元组tuple1 = (12, 34, 3.14, 5.3, 'titan')tuple2 = (10, 'jun')# 1.完整元组print(tuple1)# 2.元组一个元素print(tuple1[0])# 3.获取第2-3个元素print(tuple1[2:3])# 4.获取第三个到最后的所有元素print(tuple1[2:])# 5.获取最后一个元素print(tuple1[-1])# 6.获取倒数第二个元素print(tuple1[-2])# 7.获取最后三个元素print(tuple1[-3:-1])# 8.合并元组print(tuple1 + tuple2)# 9.重复操作两次print(tuple2 * 2) 输出结果 123456789(12, 34, 3.14, 5.3, 'titan')12(3.14,)(3.14, 5.3, 'titan')titan5.3(3.14, 5.3)(12, 34, 3.14, 5.3, 'titan', 10, 'jun')(10, 'jun', 10, 'jun') 这里注意下, 当截取某一范围的数据时, 类似[2:3], [-3:-1], 实际的取值范围是含左不含右, 等同于数学中的半开半闭区间(左闭右开)–[2, 3) 1234# 因元组的元素是只读的, 不能二次赋值, 所以请注意, 以下写法是错误的# 运行会报错: TypeError: 'tuple' object does not support item assignmenttuple2[0] = 20tuple2[1] = \"titan\" 5. 字典 字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。 列表是有序的对象集合，字典是无序的对象集合。 两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过索引存取。 字典用”{ }”标识。字典由索引(key)和它对应的值value组成 这里的字典的key值, 不仅仅可以用字符串, 还可以用Number类型 123456789101112131415161718192021222324252627282930313233343536# 字典dict1 = &#123;'name': 'jun', 'age': 18, 'score': 90.98&#125;dict2 = &#123;'name': 'titan'&#125;# 完整字典print(dict2)# 1.修改或添加字典元素dict2['name'] = 'brother'dict2['age'] = 20dict2[3] = '完美'dict2[0.9] = 0.9print(dict2)# 2.根据键值获取valueprint(dict1['score'])# 3.获取所有的键值print(dict1.keys())# 4.获取所有的value值print(dict1.values())# 5.删除字典元素del dict1['name']print(dict1)# 6.清空字典所有条目dict1.clear()print(dict1)# 7.删除字典dict3 = &#123;2: 3&#125;del dict3# 当该数组呗删除之后, 在调用会报错# print(dict3) 上述语句的输出结果如下 1234567&#123;'name': 'titan'&#125;&#123;'name': 'brother', 'age': 20, 3: '完美', 0.9: 0.9&#125;90.98dict_keys(['name', 'age', 'score'])dict_values(['jun', 18, 90.98])&#123;'age': 18, 'score': 90.98&#125;&#123;&#125; 6. 集合 集合对象是由一组无序排列的值组成的序列，集合成员可以做字典中的键 集合sets有两种不同的类型：可变集合set和不可变集合frozenset 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 集合s = &#123;1, 2, 3, 4&#125;# 1. 输出print(s)# 2. 用set转化已存在的类型, 可以去重# 集合不会存在相同的元素myList = [1, 2, 3, 3, 4, 4, 4]mySet = set(myList)print(mySet)# 3. 添加元素(已经存在的元素, 无法添加)mySet.add(2)print(mySet)mySet.add(6)print(mySet)# 4.删除元素mySet.remove(2)print(mySet)# 5.方法differenceset1 = &#123;1, 2, 4&#125;set2 = &#123;1, 2, 5, 6&#125;# 用set1和set2做differencediff = set1.difference(set2)print(diff)# 输出: &#123;4&#125;# 用set2和set1做differencediff2 = set2.difference(set1)print(diff2)# 输出: &#123;5, 6&#125;# 6. 返回相同的元素inter = set1.intersection(set2)print(inter)# 输出: &#123;1, 2&#125;# 7.合并集合union1 = set1.union(set2)print(union1)# 输出: &#123;1, 2, 4, 5, 6&#125; 7. 数据类型转换 有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值 函数 描述 int(x) 将x转换为一个整数 long(x) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 使用示例如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 数据类型转换dic = &#123;'name': 'jun', 'age': 18&#125;# 1.将x转换为一个整数print(int(9.89))print(int('9'))# print(int('8.89')) # 这样的写法会报错# 2.创建一个复数print(complex(1, 2))print(complex('3'))print(complex(-2, -4))# 3.转换为一个浮点型print(float(9))print(float('12.45'))# 4.转换为字符串print(str(9))print(str(9.09))print(str('89'))print(str(dic))# 5.转换为表达式字符串print(repr(9.09))print(repr(9 + 10))print(repr(dic))# 6.用来计算在字符串中的有效Python表达式,并返回一个对象print(eval('3*9'))print(eval(\"dic['age']*2\"))# 7.将序列转换为一个元组list7 = [1, 2, 3]print(tuple(list7))# 8.将序列转换为一个列表tuple8 = ('a', 's', 'd')print(list(tuple8))# 9.转换为可变集合print(set(list7))# 10.创建一个字典dic10 = dict([('name', 'titan'), ('age', 17)])print(dic10)# 11.转换为不可变集合print(frozenset(&#123;1, 2&#125;))# 12.将一个整数转换为一个字符# 48对应字符'0'(参照ASCII码表)print(chr(122))# 13.将一个字符转换为它的整数值print(ord('0'))# 14.将一个整数转换为一个十六进制字符串print(hex(10))# 15.将一个整数转换为一个八进制字符串print(oct(10)) 对于Python语言, 我也是小白, 正在努力学习中, 文中如有不足之处, 还望多多指教 测试代码详见 GitHub地址 后期会持续更新相关文章","categories":[{"name":"Python基础","slug":"Python基础","permalink":"https://titanjun.top/categories/Python基础/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://titanjun.top/tags/Python/"},{"name":"数据类型","slug":"数据类型","permalink":"https://titanjun.top/tags/数据类型/"},{"name":"MacOS","slug":"MacOS","permalink":"https://titanjun.top/tags/MacOS/"}]},{"title":"NexT主题配置优化-出土指南","slug":"NexT主题配置优化-出土指南","date":"2018-04-03T07:03:13.000Z","updated":"2018-04-10T09:00:09.391Z","comments":true,"path":"2018/04/03/NexT主题配置优化-出土指南/","link":"","permalink":"https://titanjun.top/2018/04/03/NexT主题配置优化-出土指南/","excerpt":"前段时间, 辛辛苦苦花了一周的时间搭建了属于自己的 个人技术博客 , 当然也是各种采坑各种跳, 大家如果在搭建过程中遇到什么问题, 可以参考 基于GitHub和Hexo搭建个人博客 博客搭建好之后就是选择博客主题的问题了, 刚开始我用的是 Yelee主题 , 这个主题总体来说还是不错的, 动画效果还是很炫酷的, 星级评价也达到了1107个 这两天看到很多人都在用 NexT主题 , 而且网上分享的关于个性化的配置也有很多, 还是很推荐使用的, 所以我 就尝试着配置了一下 这是作者提供的 NexT主题中文配置 下面我把集成NexT主题配置时遇到的坑给大家总结分享一下","text":"前段时间, 辛辛苦苦花了一周的时间搭建了属于自己的 个人技术博客 , 当然也是各种采坑各种跳, 大家如果在搭建过程中遇到什么问题, 可以参考 基于GitHub和Hexo搭建个人博客 博客搭建好之后就是选择博客主题的问题了, 刚开始我用的是 Yelee主题 , 这个主题总体来说还是不错的, 动画效果还是很炫酷的, 星级评价也达到了1107个 这两天看到很多人都在用 NexT主题 , 而且网上分享的关于个性化的配置也有很多, 还是很推荐使用的, 所以我 就尝试着配置了一下 这是作者提供的 NexT主题中文配置 下面我把集成NexT主题配置时遇到的坑给大家总结分享一下 文章主要介绍的优化方面主要有以下34种配置 集成Mob社会化分享 在右上角或者左上角实现fork me on github 添加RSS 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加网易云跟帖(跟帖关闭，已失效，改为来必力) 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 自定义鼠标样式 为博客加上萌萌的宠物 DaoVoice 在线联系 点击爆炸效果 1. https技术博客配置社会化分享大家应该知道像一些JiaThis分享和百度分享并不支持https, 这里给大家推荐一个, 支持https的社会化分享-Mob 1-1. 获取App Key博客集成Mod分享组件, 参考 Mob官方文档 , 获取到App Key 1-2. 在主题配置文件中添加配置： 123mob_share: enable: true appkey: ******** 1-3. 在next/layout/_partials/share/里面添加mob_share.swig文件, 并在mob_share.swig内输入一下内容: 这里需要注意的一点: 以下代码只支持http开头的网址, 在https中点击分享按钮会没有任何反应 如果需要支持https的网址, 在最后一行src=http://f1.webshare.mob.com, 需要把这里的http同样改成https, 这样你就可以实现分享功能了 1234567891011121314151617181920212223242526272829303132333435&lt;!--MOB SHARE BEGIN--&gt;&lt;div class=\"-hoofoo-share-title\"&gt;分享到：&lt;/div&gt;&lt;div class=\"-hoofoo-share-buttons\"&gt; &lt;div class=\"-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button\"&gt;&lt;i class=\"fa fa-weibo\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=\"-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button\"&gt;&lt;i class=\"fa fa-weixin\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=\"-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button\"&gt;&lt;i class=\"fa fa-qq\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=\"-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button\"&gt;&lt;i class=\"fa fa-twitter\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=\"-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open\"&gt;&lt;i class=\"fa fa-ellipsis-h\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"-mob-share-ui\" style=\"display: none\"&gt; &lt;ul class=\"-mob-share-list\"&gt; &lt;li class=\"-mob-share-weibo\"&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-weixin\"&gt;&lt;p&gt;微信&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-qzone\"&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-qq\"&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-tencentweibo\"&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-renren\"&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-kaixin\"&gt;&lt;p&gt;开心网&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-douban\"&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-youdao\"&gt;&lt;p&gt;有道云笔记&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-mingdao\"&gt;&lt;p&gt;明道&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-pengyou\"&gt;&lt;p&gt;朋友网&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-facebook\"&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-twitter\"&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-pocket\"&gt;&lt;p&gt;Pocket&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-google\"&gt;&lt;p&gt;Google+&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-tumblr\"&gt;&lt;p&gt;Tumblr&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-instapaper\"&gt;&lt;p&gt;Instapaper&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-linkedin\"&gt;&lt;p&gt;Linkedin&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"-mob-share-close\"&gt;取消&lt;/div&gt;&lt;/div&gt;&lt;div class=\"-mob-share-ui-bg\"&gt;&lt;/div&gt;&lt;script id=\"-mob-share\" src=\"http://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123;theme.mob_share.appkey&#125;&#125;\"&gt;&lt;/script&gt;&lt;!--MOB SHARE END--&gt; 1-4. 在next/layout/post.swig中添加条件分支： 1234567891011&#123;% if theme.jiathis %&#125; &#123;% include '_partials/share/jiathis.swig' %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include '_partials/share/baidushare.swig' %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include '_partials/share/add-this.swig' %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include '_partials/share/duoshuo_share.swig' %&#125; &#123;% elseif theme.mob_share.enable %&#125; &#123;% include '_partials/share/mob_share.swig' %&#125;&#123;% endif %&#125; 1-5. 在next/source/css/_common/components/third-party/里添加样式文件mob_share.styl： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980.-hoofoo-share-buttons&#123; display: inline-block;&#125;.-hoofoo-share-title&#123; font-size: 1.1em; font-weight: 200;&#125;.-hoofoo-share-ui-button&#123; cursor: pointer; background-color: #555; color: #fff; font-size: 24px; line-height: 40px; width: 40px; height: 40px; margin: 10px; border-radius: 25px; float: left; transition: background 0.4s; -moz-transition: background 0.4s; /* Firefox 4 */ -webkit-transition: background 0.4s; /* Safari 和 Chrome */ -o-transition: background 0.4s;&#125;.-hoofoo-share-weibo:hover&#123; background-color: #cf3f41;&#125;.-hoofoo-share-weixin:hover&#123; background-color: #18a01a;&#125;.-hoofoo-share-qq:hover&#123; background-color: #950c0c;&#125;.-hoofoo-share-twitter:hover&#123; background-color: #2ab3e6;&#125;.-hoofoo-share-more:hover&#123; background-color: #777;&#125;.-mob-share-weixin-qrcode-content&#123; border-radius: 4px; -webkit-box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); -moz-box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); -o-box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);&#125;.-mob-share-weixin-qrcode&#123; margin: 5% !important; width: 90% !important; height: auto !important;&#125;.-mob-share-weixin-qrcode-close &#123; background-image: url('/lib/fancybox/source/fancybox_sprite.png') !important;//因为兼容问题把vendor改成了lib，根据自己的路径修改&#125;.-mob-share-weixin-qrcode-close &#123; overflow: hidden; line-height: 100px !important; position: absolute !important; top: -18px !important; right: -18px !important; width: 36px !important; height: 36px !important; cursor: pointer !important; z-index: 8040 !important;&#125;/*Retina graphics!*/@media only screen and (-webkit-min-device-pixel-ratio: 1.5), only screen and (min--moz-device-pixel-ratio: 1.5), only screen and (min-device-pixel-ratio: 1.5)&#123; .-mob-share-weixin-qrcode-close &#123; background-image: url('/lib/fancybox/source/fancybox_sprite@2x.png') !important;//因为兼容问题把vendor改成了lib，根据自己的路径修改 background-size: 44px 152px !important; /*The size of the normal image, half the size of the hi-res image*/ &#125;&#125;.-mob-share-close&#123; height: 4em !important; font-size: 0.8em !important; line-height: 4em !important; background: #555 !important; color: #fff !important;&#125; 1-6. 同一目录下的 third-party.styl 中添加： 1@import \"mob_share\"; 1-7. 在next/layout/_scripts/third-party/里添加脚本文件mob_share.swig： 12345678&#123;% if theme.mob_share.enable %&#125;&lt;script type=\"text/javascript\"&gt; //微信二维码点击背景关闭 $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function()&#123; $(\".-mob-share-weixin-qrcode-close\").trigger(\"click\"); &#125;); &lt;/script&gt;&#123;% endif %&#125; 1-8. 在next/layout/_layout.swig的body标签结束前添加： 1&#123;% include '_scripts/third-party/mob_share.swig' %&#125; 剩下的优化配置, 大家可以参考以下博客 2. 关于next主题个性化配置这里给大家推荐, 提供33中炫酷效果的文章 hexo的next主题个性化配置教程 3. leanCloud统计通过leanCloud统计您网站的文章阅读量 leanCloud,实现文章阅读量统计 4. 使用CloudFlare配置https参考 使用 CloudFlare 为 hexo 博客实现 HTTPS 使用 cloudflare 为网站添加免费 CDN 并获取免费 SSL 服务 为自定义域名的GitHub Pages添加SSL 完整方案","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://titanjun.top/categories/Hexo博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://titanjun.top/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"https://titanjun.top/tags/NexT/"}]},{"title":"ReactiveCocoa 的一些高级用法","slug":"ReactiveCocoa 的一些高级用法","date":"2018-03-31T11:14:40.000Z","updated":"2018-04-10T08:50:01.514Z","comments":true,"path":"2018/03/31/ReactiveCocoa 的一些高级用法/","link":"","permalink":"https://titanjun.top/2018/03/31/ReactiveCocoa 的一些高级用法/","excerpt":"之前已经有两篇文章介绍了ReactiveCocoa的一些见解和用法, 这里也就不再作介绍了 其中第一篇文章介绍了ReactiveCocoa关于RACSingle的使用详解 第二篇文章介绍了ReactiveCocoa之集合使用详解 有兴趣的可以先去看看这两篇文章 接下来我们就着重介绍一些Map, concat等高级用法","text":"之前已经有两篇文章介绍了ReactiveCocoa的一些见解和用法, 这里也就不再作介绍了 其中第一篇文章介绍了ReactiveCocoa关于RACSingle的使用详解 第二篇文章介绍了ReactiveCocoa之集合使用详解 有兴趣的可以先去看看这两篇文章 接下来我们就着重介绍一些Map, concat等高级用法 一. ReactiveCocoa常见操作介绍1. ReactiveCocoa操作须知 所有的信号RACSignal都可以进行操作处理，因为所有操作方法都定义在RACStream.h中，因此只要继承RACStream就有了操作处理方法。 2. ReactiveCocoa操作思想 运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术. Hook用处：截获API调用的技术。 Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出 二. 高级操作1. ReactiveCocoa核心方法bind ReactiveCocoa操作的核心方法是bind（绑定）,而且RAC中核心开发方式，也是绑定，之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。 在开发中很少使用bind方法，bind属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单. bind方法简单介绍和使用 需求: 监听文本框的内容, 每次输出的时候, 在内容后面品尚字符串&quot;jun&quot;, 并显示在label上 方式一: 在返回结果后, 拼接字符串12345@weakify(self)[_textField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; @strongify(self) self.showLabel.text = [NSString stringWithFormat:@\"%@+%@\", x, @\"jun\"];&#125;]; 方式二: 在返回结果前, 拼接字符串, 用bind方法操作 1234567[[_textField.rac_textSignal bind:^RACSignalBindBlock _Nonnull&#123; return ^RACSignal *(id value, BOOL *stop)&#123; return [RACReturnSignal return:[NSString stringWithFormat:@\"输出: %@\", value]]; &#125;;&#125;] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x);&#125;]; bind方法介绍 bind方法参数:需要传入一个返回值是RACStreamBindBlock的block参数 RACStreamBindBlock是一个block的类型，返回值是信号，参数（value,stop），因此参数的block返回值也是一个block 如下: 1typedef RACSignal * _Nullable (^RACSignalBindBlock)(ValueType _Nullable value, BOOL *stop); RACStreamBindBlock: 参数一(value): 表示接收到信号的原始值，还没做处理 参数二*stop: 用来控制绑定Block，如果*stop = yes,那么就会结束绑定。 返回值：信号，做好处理，在通过这个信号返回出去，一般使用RACReturnSignal,需要手动导入头文件RACReturnSignal.h 12345@interface RACReturnSignal&lt;__covariant ValueType&gt; : RACSignal&lt;ValueType&gt;+ (RACSignal&lt;ValueType&gt; *)return:(ValueType)value;@end bind方法使用步骤: 传入一个返回值RACStreamBindBlock的block 描述一个RACStreamBindBlock类型的bindBlock作为block的返回值。 描述一个返回结果的信号，作为bindBlock的返回值。 注意：在bindBlock中做信号结果的处理 bind底层实现: 源信号调用bind,会重新创建一个绑定信号。 当绑定信号被订阅，就会调用绑定信号中的didSubscribe，生成一个bindingBlock。 当源信号有内容发出，就会把内容传递到bindingBlock处理，调用bindingBlock(value,stop) 调用bindingBlock(value,stop)，会返回一个内容处理完成的信号（RACReturnSignal）。 订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来 2. 映射(flattenMap,Map) flattenMap，Map用于把源信号内容映射成新的内容 在Swift中系统API就已经有了这些函数的用法, 详情可参考我的这篇文章Swift函数式编程之Map&amp;Reduce&amp;Filter 2-1. flattenMap把源信号的内容映射成一个新的信号，信号可以是任意类型 flattenMap使用步骤: 传入一个block，block类型是返回值RACStream，参数value 参数value就是源信号的内容，拿到源信号的内容做处理 包装成RACReturnSignal信号，返回出去 flattenMap底层实现: 0.flattenMap内部调用bind方法实现的,flattenMap中block的返回值，会作为bind中bindBlock的返回值。 1.当订阅绑定信号，就会生成bindBlock。 2.当源信号发送内容，就会调用bindBlock(value, *stop) 3.调用bindBlock，内部就会调用flattenMap的block，flattenMap的block作用：就是把处理好的数据包装成信号 4.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。 5.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来 123456789101112- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block &#123; Class class = self.class; return [[self bind:^&#123; return ^(id value, BOOL *stop) &#123; id stream = block(value) ?: [class empty]; NSCAssert([stream isKindOfClass:RACStream.class], @\"Value returned from -flattenMap: is not a stream: %@\", stream); return stream; &#125;; &#125;] setNameWithFormat:@\"[%@] -flattenMap:\", self.name];&#125; 简单使用1234567891011@weakify(self)[[_textField.rac_textSignal flattenMap:^__kindof RACSignal * _Nullable(NSString * _Nullable value) &#123; //源信号发出的时候，就会调用这个block。 // 返回值：绑定信号的内容. return [RACReturnSignal return:[NSString stringWithFormat:@\"flat输出: %@\", value]];&#125;] subscribeNext:^(id _Nullable x) &#123; @strongify(self) //订阅绑定信号, 每当原信号发送内容, 处理后, 就会调用这个black self.showLabel.text = x; NSLog(@\"%@\", x);&#125;]; 2-2. MapMap作用:把源信号的值映射成一个新的值 Map使用步骤: 传入一个block,类型是返回对象，参数是value value就是源信号的内容，直接拿到源信号的内容做处理 把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。 Map底层实现: Map底层其实是调用flatternMap, Map中block中的返回的值会作为flatternMap中block中的值。 当订阅绑定信号，就会生成bindBlock。 当源信号发送内容，就会调用bindBlock(value, *stop) 调用bindBlock，内部就会调用flattenMap的block flattenMap的block内部会调用Map中的block，把Map中的block返回的内容包装成返回的信号。 返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。 订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来 123456789- (__kindof RACStream *)map:(id (^)(id value))block &#123; NSCParameterAssert(block != nil); Class class = self.class; return [[self flattenMap:^(id value) &#123; return [class return:block(value)]; &#125;] setNameWithFormat:@\"[%@] -map:\", self.name];&#125; 简单使用 12345678910111213141516171819202122232425//Map[[_textField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return [NSString stringWithFormat:@\"map输出: %@\", value];&#125;] subscribeNext:^(id _Nullable x) &#123; @strongify(self) self.showLabel.text = x; NSLog(@\"%@\", x);&#125;];//对数组的处理NSArray *arr = @[@\"2\", @\"3\", @\"a\", @\"g\"];RACSequence *sequence = [arr.rac_sequence map:^id _Nullable(id _Nullable value) &#123; return [NSString stringWithFormat:@\"-%@-\", value];&#125;];NSLog(@\"%@\", [sequence array]);/*输出: 2018-03-24 14:13:32.421337+0800 ReactiveObjc[9043:492929] ( \"-2-\", \"-3-\", \"-a-\", \"-g-\")*/ 2-3. FlatternMap 和 Map的区别 FlatternMap中的Block返回信号。 Map中的Block返回对象。 开发中，如果信号发出的值不是信号，映射一般使用Map 开发中，如果信号发出的值是信号，映射一般使用FlatternMap 信号中信号 当一个信号需要返回另一个信号中的值的时候 让我们来看看下面这个例子 12345678910111213141516171819#pragma 信号中信号- (void)singleAndSingle &#123; //创建信号中信号 RACSubject *sonSingle = [RACSubject subject]; RACSubject *single = [RACSubject subject]; [[sonSingle flattenMap:^__kindof RACSignal * _Nullable(id _Nullable value) &#123; //sonSingle发送信号时, 才会调用 return value; &#125;] subscribeNext:^(id _Nullable x) &#123; //只有sonSingle的子信号, 大宋消息时, 才会调用 NSLog(@\"输出: %@\", x); &#125;]; //信号中信号发送子信号 [sonSingle sendNext:single]; //子信号发送内容 [single sendNext:@123];&#125; 3. 组合3-1. concat按照某一固定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号 123456789101112131415161718192021222324//让我们先看一下一般的正常操作- (void)setConcatAction &#123; //当需要按顺序执行的时候: 先执行A, 在执行B RACSubject *subjectA = [RACSubject subject]; RACSubject *subjectB = [RACReplaySubject subject]; NSMutableArray *array = [NSMutableArray array]; //订阅信号 [subjectA subscribeNext:^(id _Nullable x) &#123; [array addObject:x]; &#125;]; [subjectB subscribeNext:^(id _Nullable x) &#123; [array addObject:x]; &#125;]; //发送信号 [subjectB sendNext:@\"B\"]; [subjectA sendNext:@\"A\"]; [subjectA sendCompleted]; //输出: [B, A] NSLog(@\"%@\", array);&#125; 很明显, 上述的结果并未达到我们的需求: 限制性A, 在执行B 下面我们看看使用concat后的执行情况 1234567891011121314151617181920- (void)setConcatAction &#123; //当需要按顺序执行的时候: 先执行A, 在执行B RACSubject *subC = [RACSubject subject]; RACSubject *subD = [RACReplaySubject subject]; NSMutableArray *array2 = [NSMutableArray array]; //订阅信号 [[subC concat:subD] subscribeNext:^(id _Nullable x) &#123; [array2 addObject:x]; &#125;]; //发送信号 [subD sendNext:@\"D\"]; [subC sendNext:@\"C\"]; [subC sendCompleted]; //输出: [C, D] NSLog(@\"%@\", array2);&#125; 可以看到, 输出的结果和我们预想的一样, 顺序输出 那么, concat的底层到底是如何实现的呢? 1234567891011121314151617- (RACSignal *)concat:(RACSignal *)signal &#123; return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123; RACCompoundDisposable *compoundDisposable = [[RACCompoundDisposable alloc] init]; RACDisposable *sourceDisposable = [self subscribeNext:^(id x) &#123; [subscriber sendNext:x]; &#125; error:^(NSError *error) &#123; [subscriber sendError:error]; &#125; completed:^&#123; RACDisposable *concattedDisposable = [signal subscribe:subscriber]; [compoundDisposable addDisposable:concattedDisposable]; &#125;]; [compoundDisposable addDisposable:sourceDisposable]; return compoundDisposable; &#125;] setNameWithFormat:@\"[%@] -concat: %@\", self.name, signal];&#125; concat底层实现: 当拼接信号被订阅，就会调用拼接信号的didSubscribe didSubscribe中，会先订阅第一个源信号subjectA 会执行第一个源信号subjectA的didSubscribe 第一个源信号subjectA的didSubscribe中发送值，就会调用第一个源信号subjectA订阅者的nextBlock, 通过拼接信号的订阅者把值发送出来. 第一个源信号subjectA的didSubscribe中发送完成，就会调用第一个源信号subjectA订阅者的completedBlock,订阅第二个源信号subjectB这时候才激活subjectB 订阅第二个源信号subjectB,执行第二个源信subjectB号的didSubscribe 第二个源信号subjectB的didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来. 3-2. then用于连接两个信号，当第一个信号完成，才会连接then返回的信号 123456789101112131415- (RACSignal *)then:(RACSignal * (^)(void))block &#123; NSCParameterAssert(block != nil); return [[[self ignoreValues] concat:[RACSignal defer:block]] setNameWithFormat:@\"[%@] -then:\", self.name];&#125;//ignoreValues底层实现- (RACSignal *)ignoreValues &#123; return [[self filter:^(id _) &#123; return NO; &#125;] setNameWithFormat:@\"[%@] -ignoreValues\", self.name];&#125; 实现原理 底层会调用filter过滤掉本身信号发出的值(filter后面会讲到) 然后再使用concat连接then返回的信号 下面是测试用例 12345678910111213141516171819- (void)setThenAction &#123; RACSubject *subjectA = [RACReplaySubject subject]; RACSubject *subjectB = [RACReplaySubject subject]; //发送信号 [subjectA sendNext:@\"A\"]; [subjectA sendCompleted]; [subjectB sendNext:@\"B\"]; //订阅信号 [[subjectA then:^RACSignal * _Nonnull&#123; return subjectB; &#125;] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x); &#125;]; //这里只会输出: B //不会输出: A&#125; 3-3. merge把多个信号合并为一个信号，任何一个信号有新值的时候就会调用 123456789101112131415161718192021222324- (RACSignal *)merge:(RACSignal *)signal &#123; return [[RACSignal merge:@[ self, signal ]] setNameWithFormat:@\"[%@] -merge: %@\", self.name, signal];&#125;+ (RACSignal *)merge:(id&lt;NSFastEnumeration&gt;)signals &#123; NSMutableArray *copiedSignals = [[NSMutableArray alloc] init]; for (RACSignal *signal in signals) &#123; [copiedSignals addObject:signal]; &#125; return [[[RACSignal createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) &#123; for (RACSignal *signal in copiedSignals) &#123; [subscriber sendNext:signal]; &#125; [subscriber sendCompleted]; return nil; &#125;] flatten] setNameWithFormat:@\"+merge: %@\", copiedSignals];&#125; 底层实现 1.合并信号被订阅的时候，就会遍历所有信号，并且发出这些信号。 2.每发出一个信号，这个信号就会被订阅 3.也就是合并信号一被订阅，就会订阅里面所有的信号。 4.只要有一个信号被发出就会被监听。 123456789101112131415161718192021- (void)setMergeAction &#123; // 只要想无序的整合信号数据 RACSubject *subjectA = [RACSubject subject]; RACSubject *subjectB = [RACSubject subject]; RACSubject *subjectC = [RACSubject subject]; //合并信号 RACSignal *single = [[subjectA merge:subjectB] merge:subjectC]; //订阅信号 [single subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x); &#125;]; //发出消息 [subjectA sendNext:@\"A\"]; [subjectC sendNext:@\"C\"]; [subjectB sendNext:@\"B\"];&#125;//输出结果(分别输出): A, C, B 3-4. zipWith把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件 底层实现: 1.定义压缩信号，内部就会自动订阅subjectA，subjectB 2.每当subjectA或者subjectB发出信号，就会判断subjectA，subjectB有没有发出个信号，有就会把最近发出的信号都包装成元组发出。 123456789101112131415161718192021- (void)setZipwithAction &#123; // 只要想无序的整合信号数据 RACSubject *subjectA = [RACSubject subject]; RACSubject *subjectB = [RACSubject subject]; //合并信号 RACSignal *single = [subjectA zipWith:subjectB]; //订阅信号 [single subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x); &#125;]; //发出消息 [subjectA sendNext:@\"A\"]; [subjectB sendNext:@\"B\"]; /* 输出: (A, B) */&#125; 3-5. combineLatest 将多个信号合并起来，并且拿到各个信号的最新的值 必须每个合并的信号至少都有过一次sendNext，才会触发合并的信号 这里我们考虑这样一个需求: 在登录页面, 只有在账号密码都输入的情况下, 登录按钮才可点击, 否则不可点击 正常情况下我们需要监听每一个文本框的输入 下面我们来看一下combineLatest控制登录按钮是否可点击 12345678910- (void)setCombineLatest &#123; //把两个信号组合成一个信号,跟zip一样，没什么区别 RACSignal *single = [_accountText.rac_textSignal combineLatestWith:_passwordText.rac_textSignal]; [single subscribeNext:^(id _Nullable x) &#123; RACTupleUnpack(NSString *account, NSString *password) = x; _loginButton.enabled = account.length &gt; 0 &amp;&amp; password.length &gt; 0; &#125;];&#125; 底层实现： 1.当组合信号被订阅，内部会自动订阅两个信号,必须两个信号都发出内容，才会被触发。(而zip, 是两个信号同事发出内容, 才会触发) 2.把两个信号组合成元组发出。 3-6. reduce聚合:用于信号发出是元组的内容，把信号发出元组的值聚合成一个值 这里我们把上面的代码, 使用RACSingle的一个类方法优化一下 12345678910- (void)setReduceAction &#123; // reduce:把多个信号的值,聚合为一个值 RACSignal *single = [RACSignal combineLatest:@[_accountText.rac_textSignal, _passwordText.rac_textSignal] reduce:^id (NSString *account, NSString *password)&#123; return @(account.length &gt; 0 &amp;&amp; password.length &gt; 0); &#125;]; [single subscribeNext:^(id _Nullable x) &#123; _loginButton.enabled = [x boolValue]; &#125;];&#125; RACSingle类方法 参数一: (id&lt;NSFastEnumeration&gt;)类型 NSFastEnumeration我们在上一篇文章ReactiveCocoa之集合使用详解02中简单介绍过 NSFastEnumeration: 是一个协议, 所有遵循该协议的类, 均可视为一个数组, 例如NSArray 故这里, 应该传一个包含RACSingle信号的数组 参数二: (RACGenericReduceBlock)reduceBlock是一个black 123typedef ValueType _Nonnull (^RACGenericReduceBlock)();//reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容 这里用一个宏, 急需将上面的代码简化一下 123456- (void)setReduceAction &#123; RAC(_loginButton, enabled) = [RACSignal combineLatest:@[_accountText.rac_textSignal, _passwordText.rac_textSignal] reduce:^id (NSString *account, NSString *password)&#123; return @(account.length &gt; 0 &amp;&amp; password.length &gt; 0); &#125;];&#125; 上面用到了一个宏RAC, 这里暂不赘述, 以后会集中整理一下 RAC中的宏, 具体实现如下 12345678#define RAC(TARGET, ...) \\ metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__)) \\ (RAC_(TARGET, __VA_ARGS__, nil)) \\ (RAC_(TARGET, __VA_ARGS__))/// Do not use this directly. Use the RAC macro above.#define RAC_(TARGET, KEYPATH, NILVALUE) \\ [[RACSubscriptingAssignmentTrampoline alloc] initWithTarget:(TARGET) nilValue:(NILVALUE)][@keypath(TARGET, KEYPATH)] 4. 过滤4-1. filter过滤信号, 过滤掉不符合条件的信号 1234567891011- (void) filterAction&#123; //filter //截取等于11位的字符 [[_accountText.rac_textSignal filter:^BOOL(NSString * _Nullable value) &#123; //类似手机号的输入, 只有等于11位的时候才返回true return value.length == 11; &#125;]subscribeNext:^(NSString * _Nullable x) &#123; //这里只会返回等于11位的字符 NSLog(@\"filter = %@\", x); &#125;];&#125; filter底层是调用的flatMap方法, 如下: 12345678910111213- (__kindof RACStream *)filter:(BOOL (^)(id value))block &#123; NSCParameterAssert(block != nil); Class class = self.class; return [[self flattenMap:^ id (id value) &#123; if (block(value)) &#123; return [class return:value]; &#125; else &#123; return class.empty; &#125; &#125;] setNameWithFormat:@\"[%@] -filter:\", self.name];&#125; 4-2. ignore忽略掉某些特定值的信号 123456789101112- (void)setIgnoreAction &#123; ///ignore //这里的测试只有第一个字符位: m的时候能看到效果 [[_accountText.rac_textSignal ignore:@\"m\"] subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@\"ignore = %@\", x); &#125;]; //ignoreValues: 忽略所有信号 [[_passwordText.rac_textSignal ignoreValues] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"allIgnore = %@\", x); &#125;];&#125; ignore方法的底层都是调用的filter方法 12345678910111213//ignore- (__kindof RACStream *)ignore:(id)value &#123; return [[self filter:^ BOOL (id innerValue) &#123; return innerValue != value &amp;&amp; ![innerValue isEqual:value]; &#125;] setNameWithFormat:@\"[%@] -ignore: %@\", self.name, RACDescription(value)];&#125;//ignoreValues- (RACSignal *)ignoreValues &#123; return [[self filter:^(id _) &#123; return NO; &#125;] setNameWithFormat:@\"[%@] -ignoreValues\", self.name];&#125; 4-3. distinctUntilChanged 当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。 在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新 12345678910111213141516171819//distinctUntilChanged- (void)setdistinctUntilChanged &#123; //创建信号 RACSubject *subject = [RACSubject subject]; //订阅 [[subject distinctUntilChanged] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"distinctUntilChanged = %@\", x); &#125;]; [subject sendNext:@12]; [subject sendNext:@12]; [subject sendNext:@23]; /*输出结果:只会输出两次 distinctUntilChanged = 12 distinctUntilChanged = 23 */&#125; distinctUntilChanged底层是调用的bind高级用法 12345678910111213141516- (__kindof RACStream *)distinctUntilChanged &#123; Class class = self.class; return [[self bind:^&#123; __block id lastValue = nil; __block BOOL initial = YES; return ^(id x, BOOL *stop) &#123; if (!initial &amp;&amp; (lastValue == x || [x isEqual:lastValue])) return [class empty]; initial = NO; lastValue = x; return [class return:x]; &#125;; &#125;] setNameWithFormat:@\"[%@] -distinctUntilChanged\", self.name];&#125; 4-4. take从开始一共取N次的信号, 当遇到sendCompleted语句执行时, 会提前停止发送信号 12345678910111213141516171819202122- (void)setTakeAndTakeLast &#123; //take RACSubject *subject1 = [RACSubject subject]; [[subject1 take:2] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x); &#125;]; [subject1 sendNext:@1]; [subject1 sendNext:@2]; [subject1 sendCompleted]; [subject1 sendNext:@3]; //分别输出: 1, 2&#125;//如果上面发送信号的代码调整为 [subject1 sendNext:@1]; [subject1 sendCompleted]; [subject1 sendNext:@2]; [subject1 sendNext:@3]; //那么输出结果将会,只输出: 1 4-5. takeLast取调用sendCompleted之前的N次信号,前提条件，订阅者必须调用sendCompleted，否则不会执行任何操作 123456789101112- (void)setTakeAndTakeLast &#123; //takeLast RACSubject *subject1 = [RACSubject subject]; [[subject1 takeLast:2] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x); &#125;]; [subject1 sendNext:@1]; [subject1 sendNext:@2]; [subject1 sendNext:@3]; [subject1 sendCompleted];&#125; 4-6. takeUntil只要传入的信号发送完成或者subject2开始发送信号的时候,就不会再接收信号的内容 12345678910111213141516171819- (void)setTakeAndTakeLast &#123; //takeUntil RACSubject *subject1 = [RACSubject subject]; RACSubject *subject2 = [RACSubject subject]; [[subject1 takeUntil:subject2] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x); &#125;]; [subject1 sendNext:@11]; [subject1 sendNext:@12];// [subject1 sendCompleted]; [subject1 sendNext:@13]; [subject2 sendNext:@\"21\"]; [subject2 sendNext:@\"22\"]; //这样会输出: 11, 12, 13 //当sendCompleted取消注释的时候, 只会输出: 11, 12&#125; 4-7. switchToLatest 主要用于信号的信号, 有时候也会发出信号, 会在信号的信号中获取其发送的最新的信号 方法的底层是调用了flattenMap方法 123456789101112131415161718192021- (RACSignal *)switchToLatest &#123; return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123; RACMulticastConnection *connection = [self publish]; RACDisposable *subscriptionDisposable = [[connection.signal flattenMap:^(RACSignal *x) &#123; NSCAssert(x == nil || [x isKindOfClass:RACSignal.class], @\"-switchToLatest requires that the source signal (%@) send signals. Instead we got: %@\", self, x); // -concat:[RACSignal never] prevents completion of the receiver from // prematurely terminating the inner signal. return [x takeUntil:[connection.signal concat:[RACSignal never]]]; &#125;] subscribe:subscriber]; RACDisposable *connectionDisposable = [connection connect]; return [RACDisposable disposableWithBlock:^&#123; [subscriptionDisposable dispose]; [connectionDisposable dispose]; &#125;]; &#125;] setNameWithFormat:@\"[%@] -switchToLatest\", self.name];&#125; 下面我们看一下具体的使用示例 12345678910111213141516- (void)setswitchToLatest &#123; //信号的信号 RACSubject *subject1 = [RACSubject subject]; RACSubject *subject2 = [RACSubject subject]; //获取信号中信号最近发出信号，订阅最近发出的信号 [[subject1 switchToLatest] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x); &#125;]; //发送信号 [subject1 sendNext:subject2]; [subject2 sendNext:@\"信号中信号\"]; //最终结果输出: \"信号中信号\"&#125; 4-8. skip跳过N个信号后, 再开始订阅信号123456789101112131415161718- (void)setSkipAction &#123; //创建信号 RACSubject *subject = [RACSubject subject]; //订阅信号 //要求跳过2个信号 [[subject skip:2] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x); &#125;]; //发送信号 [subject sendNext:@1]; [subject sendNext:@2]; [subject sendNext:@3]; [subject sendNext:@4]; //因为上面跳过了两个信号, 所以这里只会输出: 3, 4&#125; 5. 定时操作5-1. interval定时器, 每隔一段时间发出信号 1234//RAC定时器, 每隔一段时间执行一次[[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(NSDate * _Nullable x) &#123; NSLog(@\"定时器\");&#125;]; 其中RACScheduler是RAC中管理线程的类 5-2. delay延迟一段时间都发送信号 1234567//delay: 延迟执行[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@\"delay\"]; return nil;&#125;] delay:2] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x);&#125;]; 5-3. timeout超时, 可以让一个信号在一定时间后自动报错 1234567891011//timeout: 超时, 可以让一个信号在一定时间后自动报错RACSignal *single = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; return nil;&#125;] timeout:2 onScheduler:[RACScheduler currentScheduler]];[single subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x);&#125; error:^(NSError * _Nullable error) &#123; //2秒后自动调用 NSLog(@\"%@\", error);&#125;]; 6. 重复操作6-1. retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功. 1234567891011121314151617181920212223242526272829- (void)setResertAction &#123; //retry __block int i = 0; [[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; if (i == 5) &#123; [subscriber sendNext:@12]; &#125; else &#123; NSLog(@\"发生错误\"); [subscriber sendError:nil]; &#125; i++; return nil; &#125;] retry] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x); &#125; error:^(NSError * _Nullable error) &#123; NSLog(@\"%@\", error); &#125;]; /*输出结果 2018-03-30 15:44:08.412860+0800 ReactiveObjc[4125:341376] 发生错误 2018-03-30 15:44:08.461105+0800 ReactiveObjc[4125:341376] 发生错误 2018-03-30 15:44:08.461897+0800 ReactiveObjc[4125:341376] 发生错误 2018-03-30 15:44:08.462478+0800 ReactiveObjc[4125:341376] 发生错误 2018-03-30 15:44:08.462913+0800 ReactiveObjc[4125:341376] 发生错误 2018-03-30 15:44:08.463351+0800 ReactiveObjc[4125:341376] 12 */&#125; 6-2. replay重放：当一个信号被多次订阅,反复播放内容 12345678910111213141516171819202122//replayRACSignal *single = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@23]; [subscriber sendNext:@34]; return nil;&#125;] replay];[single subscribeNext:^(id _Nullable x) &#123; NSLog(@\"第一次订阅-%@\", x);&#125;];[single subscribeNext:^(id _Nullable x) &#123; NSLog(@\"第二次订阅-%@\", x);&#125;];/*输出结果: 2018-03-30 15:51:20.115052+0800 ReactiveObjc[4269:361568] 第一次订阅-23 2018-03-30 15:51:20.115195+0800 ReactiveObjc[4269:361568] 第一次订阅-34 2018-03-30 15:51:20.115278+0800 ReactiveObjc[4269:361568] 第二次订阅-23 2018-03-30 15:51:20.115352+0800 ReactiveObjc[4269:361568] 第二次订阅-34 */ 6-3. throttle节流:当某个信号发送比较频繁时，可以使用节流, 在一定时间（1秒）内，不接收任何信号内容，过了这个时间（1秒）获取最后发送的信号内容发出。 1234567891011121314151617RACSubject *subject = [RACSubject subject];[[subject throttle:0.001] subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x);&#125;];[subject sendNext:@10];[subject sendNext:@11];[subject sendNext:@12];[subject sendNext:@13];[subject sendNext:@14];[subject sendNext:@15];[subject sendNext:@16];[subject sendNext:@17];[subject sendNext:@18];//这里因为执行的速度非常快, 所以这里输出的结果只有最后一个: 18 以上就是RAC中的一些常用的高级用用法具体讲解和使用示例 如有不足之处, 还请多多指教, 后期会持续更新相关知识点 下面是RAC相关的两篇文章 ReactiveCocoa使用详解01 ReactiveCocoa之集合使用详解02","categories":[{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"https://titanjun.top/categories/ReactiveCocoa/"}],"tags":[{"name":"高级用法","slug":"高级用法","permalink":"https://titanjun.top/tags/高级用法/"}]},{"title":"ReactiveCocoa之集合使用详解02","slug":"ReactiveCocoa之集合使用详解02","date":"2018-03-21T14:48:29.000Z","updated":"2018-03-21T14:51:12.254Z","comments":true,"path":"2018/03/21/ReactiveCocoa之集合使用详解02/","link":"","permalink":"https://titanjun.top/2018/03/21/ReactiveCocoa之集合使用详解02/","excerpt":"上一篇ReactiveCocoa使用详解01提到了, RACStream中有两个子类——RACSignal 和 RACSequence 上一篇文章中只介绍了, 关于RACSignal的使用和底层实现原理 这里我们就主要学习一下RACSequence的使用和底层实现 GitHub上的Demo地址","text":"上一篇ReactiveCocoa使用详解01提到了, RACStream中有两个子类——RACSignal 和 RACSequence 上一篇文章中只介绍了, 关于RACSignal的使用和底层实现原理 这里我们就主要学习一下RACSequence的使用和底层实现 GitHub上的Demo地址 一. 关于RACTuple 这里在介绍RACSequence之前，我们先来看看RACTuple的介绍和实现吧! 在RAC中RACTuple是ReactiveCocoa的元组类 在Swift中, 元组类是一种很重要也很常用的类型, 是一种以下标访问成员变量的类型 123456789//swift中的元组let tuple = (3, 2, \"a\")print(tuple)//输出: (3, 2, \"a\")let tuple1 = tuple.0let tuple2 = tuple.2print(tuple1, tuple2)//输出: 3 a 1. RAC中的元组–RACTuple在RAC中RACTuple是继承自NSObject, 并遵循协议NSCoding, NSCopying, NSFastEnumeration的类, 如下 1234567891011@interface RACTuple : NSObject &lt;NSCoding, NSCopying, NSFastEnumeration&gt;//元组成员的个数@property (nonatomic, readonly) NSUInteger count;@property (nonatomic, readonly, nullable) id first;@property (nonatomic, readonly, nullable) id second;@property (nonatomic, readonly, nullable) id third;@property (nonatomic, readonly, nullable) id fourth;@property (nonatomic, readonly, nullable) id fifth;@property (nonatomic, readonly, nullable) id last; 使用参考12345678RACTuple *tuple = RACTuplePack(@1, @2, @\"32\", @23, @\"jun\", @2.3, @4.56, @100);NSLog(@\"%lu\", (unsigned long)tuple.count);NSLog(@\"%@--%@--%@\", tuple.first, tuple.last, tuple[6]);/*输出:2018-03-19 20:19:49.139932+0800 ReactiveObjc[23307:1441026] 82018-03-19 20:19:49.140112+0800 ReactiveObjc[23307:1441026] 1--100--4.56*/ RACTuple透过底层看上去, 其实就是一个NSArray在进行操作, 无非是针对该数组进行了一些不同的封装和处理 1234567@interface RACTuple ()- (instancetype)initWithBackingArray:(NSArray *)backingArray NS_DESIGNATED_INITIALIZER;@property (nonatomic, readonly) NSArray *backingArray;@end 下面我们看一下RACTuple提供的类方法和实例方法 一共3个实例方法, 3个类方法, 如下 123456789/// 类方法+ (instancetype)tupleWithObjectsFromArray:(NSArray *)array;+ (instancetype)tupleWithObjectsFromArray:(NSArray *)array convertNullsToNils:(BOOL)convert;+ (instancetype)tupleWithObjects:(id)object, ... NS_REQUIRES_NIL_TERMINATION;/// 实例方法- (nullable id)objectAtIndex:(NSUInteger)index;- (NSArray *)allObjects;- (__kindof RACTuple *)tupleByAddingObject:(nullable id)obj; 下面我们一个一个简单介绍下 12345678910111213141516+ (instancetype)tupleWithObjectsFromArray:(NSArray *)array &#123; return [self tupleWithObjectsFromArray:array convertNullsToNils:NO];&#125;+ (instancetype)tupleWithObjectsFromArray:(NSArray *)array convertNullsToNils:(BOOL)convert &#123; if (!convert) &#123; return [[self alloc] initWithBackingArray:array]; &#125; NSMutableArray *newArray = [NSMutableArray arrayWithCapacity:array.count]; for (id object in array) &#123; [newArray addObject:(object == NSNull.null ? RACTupleNil.tupleNil : object)]; &#125; return [[self alloc] initWithBackingArray:newArray];&#125; 这两个方法都是根据传入的array初始化为RACTuple内部的NSArray 然而这两个初始化方法唯一的不同点就在于convert参数, 区别在于是否把NSNull转换成RACTupleNil类型 这里还有一个需要注意的就是RACTupleNil, 是一个单例 123456789+ (RACTupleNil *)tupleNil &#123; static dispatch_once_t onceToken; static RACTupleNil *tupleNil = nil; dispatch_once(&amp;onceToken, ^&#123; tupleNil = [[self alloc] init]; &#125;); return tupleNil;&#125; 最后一个类方法, 与NSArray的类方法相同, 如下: 12+ (instancetype)arrayWithObjects:(ObjectType)firstObj, ... NS_REQUIRES_NIL_TERMINATION;+ (instancetype)tupleWithObjects:(id)object, ... NS_REQUIRES_NIL_TERMINATION; 简单使用:1234567891011121314 NSArray *arr = [NSArray arrayWithObjects:@1, NSNull.null, @2, @\"jun\", nil]; RACTuple *tuple1 = [RACTuple tupleWithObjectsFromArray:arr]; RACTuple *tuple2 = [RACTuple tupleWithObjectsFromArray:arr convertNullsToNils:YES]; NSLog(@\"%@\", tuple1.second); NSLog(@\"%@\", tuple2.second); RACTuple *tuple3 = [RACTuple tupleWithObjects:@1, @3.4, @\"jun\", nil]; NSLog(@\"%lu\", (unsigned long)tuple3.count);/*输出结果:2018-03-19 20:59:14.995245+0800 ReactiveObjc[24150:1545073] &lt;null&gt;2018-03-19 20:59:14.995557+0800 ReactiveObjc[24150:1545073] (null)2018-03-19 20:59:14.995866+0800 ReactiveObjc[24150:1545073] 3*/ 2. RACTuple的相关类–RACTupleUnpackingTrampoline关于RACTuple还有2个相关的类，RACTupleUnpackingTrampoline和RACTupleSequence 这里我们先看一下, 该类的属性和方法 123456@interface RACTupleUnpackingTrampoline : NSObject+ (instancetype)trampoline;- (void)setObject:(nullable RACTuple *)tuple forKeyedSubscript:(NSArray *)variables;@end 可以看到只有一个单例和一个示例方法, 下面看依稀阿底层的具体实现 123456789101112131415161718+ (instancetype)trampoline &#123; static dispatch_once_t onceToken; static id trampoline = nil; dispatch_once(&amp;onceToken, ^&#123; trampoline = [[self alloc] init]; &#125;); return trampoline;&#125;- (void)setObject:(RACTuple *)tuple forKeyedSubscript:(NSArray *)variables &#123; NSCParameterAssert(variables != nil); [variables enumerateObjectsUsingBlock:^(NSValue *value, NSUInteger index, BOOL *stop) &#123; __strong id *ptr = (__strong id *)value.pointerValue; *ptr = tuple[index]; &#125;];&#125; 该实例方法会遍历传入的NSArray数组, 然后依次取出每一个value的指针, 用这个指针又赋值给了tuple[index], 下面我们就看一下这个方法的具体使用方法 12345678910111213141516- (void)setUnpackingTrampoline &#123; RACTupleUnpackingTrampoline *line = [RACTupleUnpackingTrampoline trampoline]; NSString *str1; NSString *str2; NSString *str3; NSArray *arr = [NSArray arrayWithObjects:[NSValue valueWithPointer:&amp;str1], [NSValue valueWithPointer:&amp;str2], [NSValue valueWithPointer:&amp;str3], nil]; NSLog(@\"处理之前: str1 = %@, str2 = %@, str3 = %@\", str1, str2, str3); [line setObject:RACTuplePack(@\"tian\", @23, @3.45) forKeyedSubscript:arr]; NSLog(@\"处理之后: str1 = %@, str2 = %@, str3 = %@\", str1, str2, str3); /*输出结果: 2018-03-20 15:43:28.785571+0800 ReactiveObjc[7074:641560] 处理之前: str1 = (null), str2 = (null), str3 = (null) 2018-03-20 15:43:28.786078+0800 ReactiveObjc[7074:641560] 处理之后: str1 = tian, str2 = 23, str3 = 3.45 */&#125; 这个方法的作用类似于, 把封装好的RACTuple对象, 一个一个的把它的成员变量解析出来, 说到这里我们就不得不提及两个宏 3. RACTuple中的宏一般使用用两个宏，RACTupleUnpack( ) 用来解包，Rc( ) 用来装包 12345678910111213141516171819202122232425#define RACTuplePack(...) \\ RACTuplePack_(__VA_ARGS__)//下面RACTuplePack_底层的调用#define RACTuplePack_(...) \\ ([RACTuplePack_class_name(__VA_ARGS__) tupleWithObjectsFromArray:@[ metamacro_foreach(RACTuplePack_object_or_ractuplenil,, __VA_ARGS__) ]])//下面RACTupleUnpack_底层的调用#define RACTupleUnpack_(...) \\ metamacro_foreach(RACTupleUnpack_decl,, __VA_ARGS__) \\ \\ int RACTupleUnpack_state = 0; \\ \\ RACTupleUnpack_after: \\ ; \\ metamacro_foreach(RACTupleUnpack_assign,, __VA_ARGS__) \\ if (RACTupleUnpack_state != 0) RACTupleUnpack_state = 2; \\ \\ while (RACTupleUnpack_state != 2) \\ if (RACTupleUnpack_state == 1) &#123; \\ goto RACTupleUnpack_after; \\ &#125; else \\ for (; RACTupleUnpack_state != 1; RACTupleUnpack_state = 1) \\ [RACTupleUnpackingTrampoline trampoline][ @[ metamacro_foreach(RACTupleUnpack_value,, __VA_ARGS__) ] ] 这里的解包的宏的底层实现就是上面说到的RACTupleUnpackingTrampoline的实例方法 关于ACTuplePack的使用这里也不在多说了, 下面主要看一下用于解包的宏, 看一下主要用法, 上代码 12345678910111213141516//宏的使用RACTuple *tuple4 = RACTuplePack(@\"tian\", @23);RACTupleUnpack(NSString *str1, NSNumber *num1) = tuple4;NSLog(@\"%@--%d\", str1, num1.intValue);///输出: tian--23RACTuple *tuple3 = [RACTuple tupleWithObjects:@\"jun\", @3.4, nil];RACTupleUnpack(NSString *str2, NSNumber *num2) = tuple3;NSLog(@\"%@--%.2f\", str2, num2.floatValue);///输出: jun--3.40/// 上面的两种做法等同于下面这种做法NSString *str3 = tuple3[0];NSNumber *num3 = tuple3[1];NSLog(@\"%@--%.2f\", str3, num3.floatValue);///输出: jun--3.40 4. RACTupleSequence 上面提到了RACTuple还有2个相关的类，RACTupleUnpackingTrampoline和RACTupleSequence 而RACTupleUnpackingTrampoline上面我们已经介绍过了 这里我们来介绍一下RACTupleSequence 之所以说RACTupleSequence和RACTuple相关, 也只是因为两者的雷鸣里面都有一个Tuple 实际上RACTupleSequence是继承自RACSequence的, 下面看一下定义代码, 只有一个返回值为RACSequence的类方法 123456789101112131415161718#import \"RACSequence.h\"+ (RACSequence *)sequenceWithTupleBackingArray:(NSArray *)backingArray offset:(NSUInteger)offset;@end//方法的实现+ (RACSequence *)sequenceWithTupleBackingArray:(NSArray *)backingArray offset:(NSUInteger)offset &#123; NSCParameterAssert(offset &lt;= backingArray.count); if (offset == backingArray.count) return self.empty; RACTupleSequence *seq = [[self alloc] init]; seq-&gt;_tupleBackingArray = backingArray; seq-&gt;_offset = offset; return seq;&#125; 可见: RACTupleSequence这个类的目的就是把Tuple转换成Sequence Sequence里面的数组就是Tuple内部的backingArray。 offset从0开始 二. RACSequence底层实现RACSequence是RACStream的子类，主要是ReactiveCocoa里面的集合类, 先来看看关于RACSequence的属性 1. RACSequence的属性1234567891011@property (nonatomic, strong, readonly, nullable) ValueType head;@property (nonatomic, strong, readonly, nullable) RACSequence&lt;ValueType&gt; *tail;@property (nonatomic, copy, readonly) NSArray&lt;ValueType&gt; *array;@property (nonatomic, copy, readonly) NSEnumerator&lt;ValueType&gt; *objectEnumerator;@property (nonatomic, copy, readonly) RACSequence&lt;ValueType&gt; *eagerSequence;@property (nonatomic, copy, readonly) RACSequence&lt;ValueType&gt; *lazySequence; 1-1. 于head和tail RACSequence的所有属性中, 最重要的莫过于head和tail两个属性了, 而tail又是一个RACSequence 这两者就像一个人的头和身体两部分 测试代码如下 123456789101112RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^id _Nullable&#123; return @12;&#125; tailBlock:^RACSequence * _Nonnull&#123; return @[@23, @\"jun\"].rac_sequence;&#125;];NSLog(@\"sequence.head = %@ , sequence.tail = %@\", sequence.head, sequence.tail);/*输出结果:sequence.head = 12 , sequence.tail = &lt;RACArraySequence: 0x6000002325a0&gt;&#123; name = , array = ( 23, jun) &#125; 1-2. objectEnumeratorobjectEnumerator是一个快速枚举器, 看一下底层的get方法 12345- (NSEnumerator *)objectEnumerator &#123; RACSequenceEnumerator *enumerator = [[RACSequenceEnumerator alloc] init]; enumerator.sequence = self; return enumerator;&#125; 这里涉及到一个RACSequenceEnumerator, 底层只有一个属性 为了更加方便的RACSequence进行遍历, 重写了父类的方法 有了这个NSEnumerator，就可以从RACSequence的head一直遍历到tail 而RACSequence里面定义的objectEnumerator，就是为了取出内部的RACSequenceEnumerator 1234567891011121314151617@interface RACSequenceEnumerator : NSEnumerator@property (nonatomic, strong) RACSequence *sequence;@end//这里重写了父类的方法- (id)nextObject &#123; id object = nil; @synchronized (self) &#123; object = self.sequence.head; self.sequence = self.sequence.tail; &#125; return object;&#125; 1-3. array12345678- (NSArray *)array &#123; NSMutableArray *array = [NSMutableArray array]; for (id obj in self) &#123; [array addObject:obj]; &#125; return [array copy];&#125; RACSequence的定义里面还有一个array，这个数组就是返回一个NSArray 这个数组里面装满了RACSequence里面所有的对象。 这里之所以能用for-in，是因为实现了NSFastEnumeration协议。 至于for-in的效率，完全就看重写NSFastEnumeration协议里面countByEnumeratingWithState: objects: count: 方法里面的执行效率了 至于剩下的两个属性, 下文中会继续说到 三. RACSequence的方法1. RACSequence的初始化方法RACSequence的初始化方法有且只有一个 123+ (RACSequence *)sequenceWithHeadBlock:(id (^)(void))headBlock tailBlock:(RACSequence&lt;id&gt; *(^)(void))tailBlock &#123; return [[RACDynamicSequence sequenceWithHeadBlock:headBlock tailBlock:tailBlock] setNameWithFormat:@\"+sequenceWithHeadBlock:tailBlock:\"];&#125; 1-1. RACDynamicSequence属性上面初始化方法的底层是直接调用了RACDynamicSequence的一个类方法, 而这个类又是RACSequence的子类, 看看主要属性 1234567891011@interface RACDynamicSequence () &#123; id _head; RACSequence *_tail; id _dependency;&#125;@property (nonatomic, strong) id headBlock;@property (nonatomic, strong) id tailBlock;@property (nonatomic, assign) BOOL hasDependency;@property (nonatomic, strong) id (^dependencyBlock)(void);@end 相比大家应该知道, 正常情况下我们定义的block都是用copy修饰的 而这里, 作者定义了三个block: headBlock, tailBlock，dependencyBlock都是用strong修饰的 关于这个问题, 可以参考这里 1-2. 方法的实现123456789101112131415161718192021+ (RACSequence *)sequenceWithHeadBlock:(id (^)(void))headBlock tailBlock:(RACSequence&lt;id&gt; *(^)(void))tailBlock &#123; NSCParameterAssert(headBlock != nil); RACDynamicSequence *seq = [[RACDynamicSequence alloc] init]; seq.headBlock = [headBlock copy]; seq.tailBlock = [tailBlock copy]; seq.hasDependency = NO; return seq;&#125;+ (RACSequence *)sequenceWithLazyDependency:(id (^)(void))dependencyBlock headBlock:(id (^)(id dependency))headBlock tailBlock:(RACSequence *(^)(id dependency))tailBlock &#123; NSCParameterAssert(dependencyBlock != nil); NSCParameterAssert(headBlock != nil); RACDynamicSequence *seq = [[RACDynamicSequence alloc] init]; seq.headBlock = [headBlock copy]; seq.tailBlock = [tailBlock copy]; seq.dependencyBlock = [dependencyBlock copy]; seq.hasDependency = YES; return seq;&#125; hasDependency这个变量是代表是否有dependencyBlock。这个函数里面就只把headBlock和tailBlock保存起来了 上面第二个方法是带有dependencyBlock的, 也会把dependencyBlock保存起来 四. 积极运算和惰性求值 说到惰性求值, 就立马想到了懒加载, 就是在getter里动态返回属性, 也就是等到要用的时候才会计算 关于这两个概念, 推荐大家看这篇文章聊一聊iOS开发中的惰性计算 1. 积极运算在RACSequence中积极运算的代表是RACSequence的一个子类RACArraySequence的子类——RACEagerSequence。它的积极运算表现在其bind函数上 1234567891011121314151617181920- (RACSequence *)bind:(RACSequenceBindBlock (^)(void))block &#123; NSCParameterAssert(block != nil); RACStreamBindBlock bindBlock = block(); NSArray *currentArray = self.array; NSMutableArray *resultArray = [NSMutableArray arrayWithCapacity:currentArray.count]; for (id value in currentArray) &#123; BOOL stop = NO; RACSequence *boundValue = (id)bindBlock(value, &amp;stop); if (boundValue == nil) break; for (id x in boundValue) &#123; [resultArray addObject:x]; &#125; if (stop) break; &#125; return [[self.class sequenceWithArray:resultArray offset:0] setNameWithFormat:@\"[%@] -bind:\", self.name];&#125; 可以看到, 该方法内部执行了两层for-in循环 第一层循环遍历的自己RACSequence中的值，然后拿到这个值传入闭包bindBlock()中，返回一个RACSequence，最后用一个NSMutableArray依次把每个RACSequence里面的值都装起来 第二层循环是在遍历RACSequence，之所以可以用for-in的方式遍历就是因为实现了NSFastEnumeration协议，实现了countByEnumeratingWithState: objects: count:方法 这里就是一个积极运算的例子,在每次循环中都会把闭包block()的值计算出来。值得说明的是，最后返回的RACSequence的类型是self.class类型的，即还是RACEagerSequence类型的 2. 惰性计算等到需要用到的时候才会计算, 我们看一下在RACSequence中，bind函数的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243- (RACSequence *)bind:(RACSequenceBindBlock (^)(void))block &#123; RACSequenceBindBlock bindBlock = block(); return [[self bind:bindBlock passingThroughValuesFromSequence:nil] setNameWithFormat:@\"[%@] -bind:\", self.name];&#125;- (RACSequence *)bind:(RACSequenceBindBlock)bindBlock passingThroughValuesFromSequence:(RACSequence *)passthroughSequence &#123; __block RACSequence *valuesSeq = self; __block RACSequence *current = passthroughSequence; __block BOOL stop = NO; RACSequence *sequence = [RACDynamicSequence sequenceWithLazyDependency:^ id &#123; while (current.head == nil) &#123; if (stop) return nil; id value = valuesSeq.head; if (value == nil) &#123; stop = YES; return nil; &#125; current = (id)bindBlock(value, &amp;stop); if (current == nil) &#123; stop = YES; return nil; &#125; valuesSeq = valuesSeq.tail; &#125; NSCAssert([current isKindOfClass:RACSequence.class], @\"-bind: block returned an object that is not a sequence: %@\", current); return nil; &#125; headBlock:^(id _) &#123; return current.head; &#125; tailBlock:^ id (id _) &#123; if (stop) return nil; return [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail]; &#125;]; sequence.name = self.name; return sequence;&#125; 在上述方法实现中, 就是用sequenceWithLazyDependency: headBlock: tailBlock:方法生成了一个RACSequence，并返回 通过调用RACSequence里面的bind操作，并没有执行3个闭包里面的值，只是保存起来了。 这里就是惰性求值的表现——等到要用的时候才会计算 下面我们看一段代码示例 123456789101112131415161718192021222324 NSArray *arr = @[@1, @3, @4]; RACSequence *sequence1 = [arr.rac_sequence map:^id _Nullable(id _Nullable value) &#123; NSLog(@\"sequence\"); return @10; &#125;]; RACSequence *lazySequence = [arr.rac_sequence.lazySequence map:^id _Nullable(id _Nullable value) &#123; NSLog(@\"lazySequence\"); return @20; &#125;]; RACSequence *eagerSequence = [arr.rac_sequence.eagerSequence map:^id _Nullable(id _Nullable value) &#123; NSLog(@\"eagerSequence\"); return @30; &#125;];// [sequence1 array];// [lazySequence array]; /*输出: 2018-03-21 15:53:24.562184+0800 ReactiveObjc[9109:771797] eagerSequence 2018-03-21 15:53:24.562674+0800 ReactiveObjc[9109:771797] eagerSequence 2018-03-21 15:53:24.562799+0800 ReactiveObjc[9109:771797] eagerSequence */ 从打印结果可以看出,只有eagerSequence执行了三次, 而其他两个并没有输出 原因是因为bind闭包只在eagerSequence中真正被调用执行了，而在lazySequence中bind闭包仅仅只是被copy了 当吧最后两行注释打开之后 可见在RACSequence中，除去RACEagerSequence是积极运算，其他的Sequence都是惰性求值的。 1234567892018-03-21 15:53:24.562184+0800 ReactiveObjc[9109:771797] eagerSequence2018-03-21 15:53:24.562674+0800 ReactiveObjc[9109:771797] eagerSequence2018-03-21 15:53:24.562799+0800 ReactiveObjc[9109:771797] eagerSequence2018-03-21 15:53:24.562940+0800 ReactiveObjc[9109:771797] sequence2018-03-21 15:53:24.563403+0800 ReactiveObjc[9109:771797] sequence2018-03-21 15:53:24.563583+0800 ReactiveObjc[9109:771797] sequence2018-03-21 15:53:24.563742+0800 ReactiveObjc[9109:771797] lazySequence2018-03-21 15:53:24.563838+0800 ReactiveObjc[9109:771797] lazySequence2018-03-21 15:53:24.563937+0800 ReactiveObjc[9109:771797] lazySequence 五. RACSequence的方法123456789- (id)foldLeftWithStart:(nullable id)start reduce:(id _Nullable (^)(id _Nullable accumulator, ValueType _Nullable value))reduce;- (id)foldRightWithStart:(nullable id)start reduce:(id _Nullable (^)(id _Nullable first, RACSequence *rest))reduce;- (BOOL)any:(BOOL (^)(ValueType _Nullable value))block;- (BOOL)all:(BOOL (^)(ValueType _Nullable value))block;- (nullable ValueType)objectPassingTest:(BOOL (^)(ValueType _Nullable value))block; 1. 折叠函数我们先看一下他的底层实现, 函数传入了一个初始值start，然后依次循环执行reduce( )，循环之后，最终的值作为返回值返回。第一个函数就是折叠函数，从左边折叠到右边; 第二个方向是从右往左 123456789101112131415161718192021222324252627- (id)foldLeftWithStart:(id)start reduce:(id (^)(id, id))reduce &#123; NSCParameterAssert(reduce != NULL); if (self.head == nil) return start; for (id value in self) &#123; start = reduce(start, value); &#125; return start;&#125;- (id)foldRightWithStart:(id)start reduce:(id (^)(id, RACSequence *))reduce &#123; NSCParameterAssert(reduce != NULL); if (self.head == nil) return start; RACSequence *rest = [RACSequence sequenceWithHeadBlock:^&#123; if (self.tail) &#123; return [self.tail foldRightWithStart:start reduce:reduce]; &#125; else &#123; return start; &#125; &#125; tailBlock:nil]; return reduce(self.head, rest);&#125; 具体使用方法测试代码123456789101112131415- (void)setSequenceAction &#123; NSArray *array = @[@5, @3, @9, @4]; RACSequence *sequence = [array rac_sequence]; id leftData = [sequence foldLeftWithStart:@\"-\" reduce:^id _Nullable(id _Nullable accumulator, id _Nullable value) &#123; return [accumulator stringByAppendingString:[value stringValue]]; &#125;]; id rightData = [sequence foldRightWithStart:@\":\" reduce:^id _Nullable(id _Nullable first, RACSequence * _Nonnull rest) &#123; return [NSString stringWithFormat:@\"%@-%@\", rest.head, first]; &#125;]; NSLog(@\"leftData = %@, rightData = %@\", leftData, rightData); //输出: leftData = -5394, rightData = :-4-9-3-5&#125; 2. objectPassingTest函数里面会调用RACStream中的filter:函数, 如果block(value)为YES，就代表通过了Test，那么就会返回value的sequence, 取出head返回 12345- (id)objectPassingTest:(BOOL (^)(id))block &#123; NSCParameterAssert(block != NULL); return [self filter:block].head;&#125; 测试代码如下123456789NSArray *array = @[@5, @3, @9, @4];RACSequence *sequence = [array rac_sequence];id anyData = [sequence objectPassingTest:^BOOL(id _Nullable value) &#123; NSLog(@\"%@\", value); return false;&#125;];NSLog(@\"%@\", anyData);//输出: 5 3. any: 和 all:123456789101112131415- (BOOL)any:(BOOL (^)(id))block &#123; NSCParameterAssert(block != NULL); return [self objectPassingTest:block] != nil;&#125;- (BOOL)all:(BOOL (^)(id))block &#123; NSCParameterAssert(block != NULL); NSNumber *result = [self foldLeftWithStart:@YES reduce:^(NSNumber *accumulator, id value) &#123; return @(accumulator.boolValue &amp;&amp; block(value)); &#125;]; return result.boolValue;&#125; any: 会调用objectPassingTest:函数，如果不为nil就代表有value值通过了Test，有通过了value的就返回YES，反之返回NO all:会从左往右依次对每个值进行block( ) Test，然后每个值依次进行&amp;&amp;操作 测试代码如下: 12345678910111213NSArray *array = @[@5, @3, @9, @4];RACSequence *sequence = [array rac_sequence];//allBOOL anyBool = [sequence any:^BOOL(id _Nullable value) &#123; return true;&#125;];BOOL allBool = [sequence all:^BOOL(id _Nullable value) &#123; return true;&#125;];NSLog(@\"any = %d, all = %d\", anyBool, allBool);//输出: any = 1, all = 1 六. RACSequence的子类和扩展1. 子类 关于RACSequence有以下9个子类 其中RACEagerSequence是继承自RACArraySequence。 这些子类看名字就知道sequence里面装的是什么类型的数据。 RACUnarySequence里面装的是单元sequence, 它只有head值，没有tail值 下面列出了每一个子类里面的方法, 前面都已经介绍过这些方法, 这里也就不在赘述 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//RACArraySequence@interface RACArraySequence : RACSequence+ (RACSequence *)sequenceWithArray:(NSArray *)array offset:(NSUInteger)offset;@end//RACDynamicSequence@interface RACDynamicSequence : RACSequence+ (RACSequence *)sequenceWithLazyDependency:(id (^)(void))dependencyBlock headBlock:(id (^)(id dependency))headBlock tailBlock:(RACSequence *(^)(id dependency))tailBlock;@end//RACEmptySequence@interface RACEmptySequence : RACSequence//单例+ (RACEmptySequence *)empty;@end//RACIndexSetSequence@interface RACIndexSetSequence : RACSequence+ (RACSequence *)sequenceWithIndexSet:(NSIndexSet *)indexSet;@end//RACSignalSequence@interface RACSignalSequence : RACSequence+ (RACSequence *)sequenceWithSignal:(RACSignal *)signal;@end//RACStringSequence@interface RACStringSequence : RACSequence+ (RACSequence *)sequenceWithString:(NSString *)string offset:(NSUInteger)offset;@end//RACTupleSequence@interface RACTupleSequence : RACSequence+ (RACSequence *)sequenceWithTupleBackingArray:(NSArray *)backingArray offset:(NSUInteger)offset;@end//RACUnarySequence@interface RACUnarySequence : RACSequence+ (RACUnarySequence *)return:(id)value;@end 2. 扩展RACSequenceAdditions 总共有7个Category。这7个Category分别对iOS 里面的集合类进行了RACSequence的扩展，使我们能更加方便的使用RACSequence 2-1. NSArray+RACSequenceAdditions12345@interface NSArray&lt;__covariant ObjectType&gt; (RACSequenceAdditions)@property (nonatomic, copy, readonly) RACSequence&lt;ObjectType&gt; *rac_sequence;@end 把任意一个NSArray数组转换成RACSequence, 底层是RACArraySequence调用 sequenceWithArray方法, 将NSArray对象转成RACArraySequence对象 123- (RACSequence *)rac_sequence &#123; return [RACArraySequence sequenceWithArray:self offset:0];&#125; 2-2. NSDictionary+RACSequenceAdditions1234567@interface NSDictionary&lt;__covariant KeyType, __covariant ObjectType&gt; (RACSequenceAdditions)@property (nonatomic, copy, readonly) RACSequence&lt;RACTwoTuple&lt;KeyType, ObjectType&gt; *&gt; *rac_sequence;@property (nonatomic, copy, readonly) RACSequence&lt;KeyType&gt; *rac_keySequence;@property (nonatomic, copy, readonly) RACSequence&lt;ObjectType&gt; *rac_valueSequence;@end 把任意一个NSDictionary字典转换成RACSequence 1234567891011121314151617- (RACSequence *)rac_sequence &#123; NSDictionary *immutableDict = [self copy]; // TODO: First class support for dictionary sequences. return [immutableDict.allKeys.rac_sequence map:^(id key) &#123; id value = immutableDict[key]; return RACTuplePack(key, value); &#125;];&#125;- (RACSequence *)rac_keySequence &#123; return self.allKeys.rac_sequence;&#125;- (RACSequence *)rac_valueSequence &#123; return self.allValues.rac_sequence;&#125; rac_sequence: 通过map映射 先将每一个键值对转成RACTuple元组对象, key对应元组的第一个, value对应第二个 将每一个RACTuple元组放在一个数组里面 最后把数组转成RACSequence对象 rac_keySequence: 把所有的key值转成RACSequence对象 rac_valueSequence: 把所有的value值转成RACSequence对象 2-3. NSSet+RACSequenceAdditions把任意一个NSSet对象转换成RACSequence对象 123456789101112@interface NSSet&lt;__covariant ObjectType&gt; (RACSequenceAdditions)@property (nonatomic, copy, readonly) RACSequence&lt;ObjectType&gt; *rac_sequence;@end//属性的getter方法- (RACSequence *)rac_sequence &#123; // TODO: First class support for set sequences. return self.allObjects.rac_sequence;&#125; 2-4. NSString+RACSequenceAdditions把任意一个NSString转换成包含该字符串, 所有字符的数组对应的RACSequence 1234567891011@interface NSString (RACSequenceAdditions)@property (nonatomic, copy, readonly) RACSequence&lt;NSString *&gt; *rac_sequence;@end//属性的getter方法- (RACSequence *)rac_sequence &#123; return [RACStringSequence sequenceWithString:self offset:0];&#125; 2-5. NSEnumerator+RACSequenceAdditions 把任意一个NSEnumerator转换成RACSequence 返回的RACSequence的head是当前的sequence的head 返回的RACSequence的tail是当前的sequence本身 1234567891011121314@interface NSEnumerator&lt;ObjectType&gt; (RACSequenceAdditions)@property (nonatomic, copy, readonly) RACSequence&lt;ObjectType&gt; *rac_sequence;@end//底层实现- (RACSequence *)rac_sequence &#123; return [RACSequence sequenceWithHeadBlock:^&#123; return [self nextObject]; &#125; tailBlock:^&#123; return self.rac_sequence; &#125;];&#125; 2-6. NSIndexSet+RACSequenceAdditions把任意一个NSIndexSet转换成RACSequence 1234567891011@interface NSIndexSet (RACSequenceAdditions)@property (nonatomic, copy, readonly) RACSequence&lt;NSNumber *&gt; *rac_sequence;@end//底层实现- (RACSequence *)rac_sequence &#123; return [RACIndexSetSequence sequenceWithIndexSet:self];&#125; 2-7. NSOrderedSet+RACSequenceAdditions把任意一个NSOrderedSet中的数组转换成RACSequence对象 123456789101112@interface NSOrderedSet&lt;__covariant ObjectType&gt; (RACSequenceAdditions)@property (nonatomic, copy, readonly) RACSequence&lt;ObjectType&gt; *rac_sequence;@end//底层实现- (RACSequence *)rac_sequence &#123; // TODO: First class support for ordered set sequences. return self.array.rac_sequence;&#125; 3. 总结 这篇文章篇幅比较长, 都是对源码的解, 文中如有不足之处还望多多指教 下一篇将会着重介绍一下RAC中的一些高级用法, 敬请期待.. 参考文章: http://cocoadocs.org/docsets/ReactiveCocoa/2.1/Classes/RACSequence.html http://williamzang.com/blog/2016/11/07/liao-yi-liao-ioskai-fa-zhong-de-duo-xing-ji-suan/ http://blog.csdn.net/qq_30513483/article/details/53924990","categories":[{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"https://titanjun.top/categories/ReactiveCocoa/"}],"tags":[{"name":"函数式","slug":"函数式","permalink":"https://titanjun.top/tags/函数式/"},{"name":"响应式","slug":"响应式","permalink":"https://titanjun.top/tags/响应式/"},{"name":"RACTuple","slug":"RACTuple","permalink":"https://titanjun.top/tags/RACTuple/"},{"name":"RACSequence","slug":"RACSequence","permalink":"https://titanjun.top/tags/RACSequence/"}]},{"title":"ReactiveCocoa使用详解01","slug":"ReactiveCocoa使用详解01","date":"2018-03-19T13:58:09.000Z","updated":"2018-03-19T13:59:58.621Z","comments":true,"path":"2018/03/19/ReactiveCocoa使用详解01/","link":"","permalink":"https://titanjun.top/2018/03/19/ReactiveCocoa使用详解01/","excerpt":"ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的函数式响应式编程框架，它提供了一系列用来组合和转换值流的 API","text":"ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的函数式响应式编程框架，它提供了一系列用来组合和转换值流的 API 一. 什么是响应式变成思想?学习一个框架之前, 首先要了解这个框架的编程思想, 这里在介绍响应式编程思想之前, 先介绍一下之前接触过的编程思想 1.面向对象 万物皆对象 是一类以对象作为基本程序结构单位的程序设计语言 典型的面向对象的编程语言有C++, C#, Java等 2. 面向过程 一种以过程为中心的编程思想 C语言就是一门面向过程的语言 3. 链式编程思想 是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好 链式编程特点：方法的返回值是block, block必须有返回值（本身对象），block参数（需要操作的值） 典型框架：masonry框架。 4. 函数式编程思想 万物皆是流 不需要考虑调用顺序，只需要知道考虑结果 类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果 代表：KVO运用 5. 函数式编程思想 是把操作尽量写成一系列嵌套的函数或者方法调用 特点: 每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果） 代表：ReactiveCocoa 6. ReactiveCocoa编程思想 函数式编程 Functional Programming 响应式编程 Reactive Programming 所以, ReactiveCocoa被描述为函数响应式编程（FRP）框架, 下面具体介绍一下RAC的一些常见类 二. RACSiganl 信号类 ReactiveCocoa 中最核心的概念之一就是信号RACStream。RACStream中有两个子类——RACSignal 和 RACSequence; 这里我们就主要说一下RACSignal; 在ReactiveCocoa整个库中，RACSignal占据着比较重要的位置，而RACSignal的变换操作更是整个RACStream流操作核心之一 下面让我们俩看一下RACSignal被订阅的完整过程 1234567891011121314151617181920212223242526272829- (void)test2 &#123; //创建信号 RACSignal *single = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; //发送消息 [subscriber sendNext:@\"a\"]; [subscriber sendNext:@\"b\"]; //发送完成 [subscriber sendCompleted]; //清空数据 return [RACDisposable disposableWithBlock:^&#123; //当订阅者被消耗的时候就会执行 //当订阅者发送完成,或者error的时候也会执行 NSLog(@\"RACDisposable的block\"); &#125;]; &#125;]; //订阅信号 RACDisposable *disposable = [single subscribeNext:^(id _Nullable x) &#123; NSLog(@\"value = %@\", x); &#125; error:^(NSError * _Nullable error) &#123; NSLog(@\"error: %@\", error); &#125; completed:^&#123; NSLog(@\"completed\"); &#125;]; //释放 [disposable dispose];&#125; 在此之前先看一下RACSignal的一些子类 RACDynamicSignal: 动态信号，使用一个 block 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例 RACEmptySignal：空信号，用来实现 RACSignal 的 +empty 方法； RACReturnSignal：一元信号，用来实现 RACSignal 的 +return:方法； RACErrorSignal：错误信号，用来实现 RACSignal 的 +error: 方法； RACChannelTerminal：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定 RACSignal在创建信号的时候，底层会调用RACDynamicSignal的createSignal的方法, 如下: 123+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; return [RACDynamicSignal createSignal:didSubscribe];&#125; 这里的block是一个 id&lt;RACSubscriber&gt; 类型的subscriber, 而这个RACSubscriber, 我们可以点进去看一些底层实现, 协议方法如下: 1234567891011121314@protocol RACSubscriber &lt;NSObject&gt;@required/// Sends the next value to subscribers.- (void)sendNext:(nullable id)value;/// Sends the error to subscribers.- (void)sendError:(nullable NSError *)error;/// Sends completed to subscribers.- (void)sendCompleted;/// Sends the subscriber a disposable that represents one of its subscriptions.- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable; RACSignal底层实现： 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock 2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。 2.2 subscribeNext内部会调用siganl的didSubscribe 2.3 当信号订阅完成, 不在发送数据的时候, 最好调用完成发送的[subscriber sendCompleted]; 订阅完成的时候, 内部会自动调用[RACDisposable disposable]取消订阅信号 3.siganl的didSubscribe中调用[subscriber sendNext:@1]; 3.1 sendNext底层其实就是执行subscriber的nextBlock 三. 信号提供者: RACSubject 信号提供者，自己可以充当信号，又能发送信号 先订阅, 在发送信号 使用场景:通常用来代替代理/通知 1. RACSubject简单使用123456789101112131415161718192021222324- (void)setRacSubject1 &#123; //先订阅, 在发送信号 //1. 创建信号 RACSubject *subject = [RACSubject subject]; //2. 订阅 //内部创建RACSubscriber [subject subscribeNext:^(id _Nullable x) &#123; NSLog(@\"第一个订阅者--%@\", x); &#125;]; [subject subscribeNext:^(id _Nullable x) &#123; NSLog(@\"第二个订阅者---%@\", x); &#125;]; //3. 发送信号 //遍历所有的订阅者, 执行nextBlock [subject sendNext:@2]; /** 打印结果 2018-03-17 20:18:19.782119+0800 ReactiveObjc[23883:1420936] 第一个订阅者--2 2018-03-17 20:18:19.784715+0800 ReactiveObjc[23883:1420936] 第二个订阅者---2 */&#125; RACSubject:底层实现和RACSignal不一样 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock 2. RACReplaySubject简单使用 重复提供信号类，RACSubject的子类 先发送信号，再订阅信号； 使用场景 如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。 可以设置capacity数量来限制缓存的value的数量，即只缓充最新的几个值 1234567891011121314151617181920- (void)setReplaySubject &#123; //创建信号 RACReplaySubject *replySub = [RACReplaySubject subject]; //发送信号 [replySub sendNext:@23]; [replySub sendNext:@34]; //订阅信号 // 遍历值，让一个订阅者去发送多个值 // 只要订阅一次，之前所有发送的值都能获取到. [replySub subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\", x); &#125;]; /** 2018-03-19 12:01:14.112253+0800 ReactiveObjc[5130:446958] 23 2018-03-19 12:01:14.112511+0800 ReactiveObjc[5130:446958] 34 */&#125; RACReplaySubject的底层实现 订阅信号时，内部保存了订阅者，和订阅者响应block 当发送信号的，遍历订阅者，调用订阅者的nextBlock 发送的信号会保存起来，当订阅者订阅信号的时，会将之前保存的信号，一个一个作用于新的订阅者，保存信号的容量由capacity决定，这也是有别于RACSubject的 3. 替代代理/通知 这里我们设想一个反向传值的场景, vc里面有一个自定义的view, 当点击该View的时候, 更换vc的背景颜色 通常我们的做法是使用代理/通知/block 3-1. 下面看一下代理的简单使用 在自定义View中设置协议 12345678910111213141516#import &lt;UIKit/UIKit.h&gt;@class SubjectView;@protocol SubjectDelegate &lt;NSObject&gt;@optional- (void)viewWithTap:(SubjectView *)subView;@end@interface SubjectView : UIView@property (nonatomic, weak) id&lt;SubjectDelegate&gt; delegate;@end 在vc中, 遵循代理, 并实现代理方法 1234567/// 代理方法-(void)viewWithTap:(SubjectView *)subView&#123; NSLog(@\"完成代理, 点击了view\"); UIColor *color = [UIColor colorWithRed:(arc4random() % 255) / 255.0 green:(arc4random() % 255) / 255.0 blue:(arc4random() % 255) / 255.0 alpha:1.0]; self.view.backgroundColor = color;&#125; 3-1. RACSubject代替代理在自定义SubjectView.h文件中 12345678#import &lt;UIKit/UIKit.h&gt;#import &lt;ReactiveObjC.h&gt;@interface SubjectView : UIView@property (nonatomic, strong) RACSubject *subject;@end 在自定义SubjectView.m文件中 12345678910#import \"SubjectView.h\"@implementation SubjectView- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; //发送信号 [_subject sendNext:self];&#125;@end 下面看一下在vc中的操作 1234567891011121314- (void)setupSubjectView &#123; SubjectView *subV = [[SubjectView alloc]init]; subV.backgroundColor = [UIColor redColor]; subV.frame = CGRectMake(100, 100, 100, 100); RACSubject *subject = [RACSubject subject]; [subject subscribeNext:^(id _Nullable x) &#123; NSLog(@\"完成代理, 点击了view\"); UIColor *color = [UIColor colorWithRed:(arc4random() % 255) / 255.0 green:(arc4random() % 255) / 255.0 blue:(arc4random() % 255) / 255.0 alpha:1.0]; self.view.backgroundColor = color; &#125;]; subV.subject = subject; [self.view addSubview:subV];&#125; 相关ReactiveObjc的知识点, 后期会持续更新… 推荐文章: iOS ReactiveCocoa 最全常用API整理","categories":[{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"https://titanjun.top/categories/ReactiveCocoa/"}],"tags":[{"name":"函数式","slug":"函数式","permalink":"https://titanjun.top/tags/函数式/"},{"name":"响应式","slug":"响应式","permalink":"https://titanjun.top/tags/响应式/"},{"name":"RACSingle","slug":"RACSingle","permalink":"https://titanjun.top/tags/RACSingle/"},{"name":"RACSubject","slug":"RACSubject","permalink":"https://titanjun.top/tags/RACSubject/"}]},{"title":"iOS神技之动态更换APP的Icon图","slug":"iOS神技之动态更换APP的Icon图","date":"2018-03-16T12:18:00.000Z","updated":"2018-03-17T15:26:55.588Z","comments":true,"path":"2018/03/16/iOS神技之动态更换APP的Icon图/","link":"","permalink":"https://titanjun.top/2018/03/16/iOS神技之动态更换APP的Icon图/","excerpt":"在iOS10.3系统发布之前, 众所周知, 在App Store上架的APP如果要更换Icon图, 只能更新版本替换; 这次苹果却在iOS10.3系统中加入了了更换应用图标的新功能，当应用安装后，开发者可以为应用提供多个应用图标选择。 用户可以自由的在这些图标之间切换，并及时生效。 这是因为 10.3 里引入了一个新的 API，它允许在 App 运行的时候，通过代码为 app 更换 icon","text":"在iOS10.3系统发布之前, 众所周知, 在App Store上架的APP如果要更换Icon图, 只能更新版本替换; 这次苹果却在iOS10.3系统中加入了了更换应用图标的新功能，当应用安装后，开发者可以为应用提供多个应用图标选择。 用户可以自由的在这些图标之间切换，并及时生效。 这是因为 10.3 里引入了一个新的 API，它允许在 App 运行的时候，通过代码为 app 更换 icon 一. 项目配置 虽然提供了更换的功能，但更换的 icon 是有限制的 它只能更换项目中提前添加配置好的Icon图 具体可参考demo–github项目地址 这里先看个效果 1. 备选Icon 首先你需要将备选的Icon图添加到项目中, 注意: 图片不要放到Assets.xcassets, 而应该直接放到工程中, 不然可能导致更换Icon时, 找不到图片, 更换失败 在info.plist 的配置中，图片的文件名应该尽量不带 @2x/@3x 后缀扩展名，而让它自动选择 2. 配置info.plist文件 在info.plist文件中，添加对应的CFBundleAlternateIcons的信息 这里也可以查看官方的相关介绍 Source Code添加方式如下 123456789101112131415161718192021222324252627282930313233343536373839 &lt;key&gt;CFBundleAlternateIcons&lt;/key&gt;&lt;dict&gt; &lt;key&gt;天天特价&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;天天特价&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;小房子&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;小房子&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;小猫&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;小猫&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;邮件信息&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;邮件信息&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt;&lt;/dict&gt; 注意事项: 虽然文档中写着「You must declare your app&#39;s primary and alternate icons using the CFBundleIcons key of your app&#39;s Info.plist file. 」，但经测试，CFBundlePrimaryIcon 可以省略掉。在工程配置 App Icons and Launch Image - App Icons Source 中使用 asset catalog（默认配置），删除 CFBundlePrimaryIcon 的配置也是没有问题的。 省略这个配置的好处是，避免处理 App icon 的尺寸。现在的工程中，大家一般都使用 asset catalog 进行 icon 的配置，而一个 icon 对应有很多尺寸的文件。省略 CFBundlePrimaryIcon 就可以沿用 Asset 中的配置。 如果想设置回默认 icon，在 setAlternateIconName 中传入 nil 即可 二. API调用下面我们看一下系统提供的三个API, 这里产看官方文档 123456789101112var supportsAlternateIcons: Bool//一个布尔值，指示是否允许应用程序更改其图标var alternateIconName: String?//可选图标的名称，在app的Info.plist文件中声明的CFBundleAlternateIcons中设置。//如果要显示应用程序的主图标alternateIconName 传nil即可，主图标使用CFBundlePrimaryIcon声明，CFBundleAlternateIcons与CFBundlePrimaryIcon两个key都是CFBundleIcons的子条目func setAlternateIconName(_ alternateIconName: String?, completionHandler: ((Error?) -&gt; Void)? = nil)//更改应用程序的图标//completionHandler: 当有结果的时候的回调//成功改变图标的的时候，error为nil，如果发生错误，error描述发生什么了。并且alternateIconName的值保持不变 具体的实现代码: 12345678910111213if #available(iOS 10.3, *) &#123; //判断是否支持替换图标, false: 不支持 guard UIApplication.shared.supportsAlternateIcons else &#123; return &#125; //如果支持, 替换icon UIApplication.shared.setAlternateIconName(imageStr) &#123; (error) in if error != nil &#123; print(error ?? \"更换icon发生错误\") &#125; else &#123; print(\"更换成功\") &#125; &#125;&#125; 三. 消除alert弹窗 动态更换App图标会有弹框, 有时候这个弹框看上去可能会很别扭, 但是这个弹框是系统直接调用弹出的, 我们又如何消除呢 通过层级关系可以看到这个弹框就是一个UIAlertController, 并且是通过presentViewController:animated:completion:方法弹出的 所以可以考虑使用runtime, 拦截并替换该方法, 让更换icon的时候, 不弹 下面看一下具体代码: 123456789101112131415161718192021222324252627282930313233extension NoAlertChangeViewController &#123; fileprivate func runtimeReplaceAlert() &#123; DispatchQueue.once(token: \"UIAlertController\") &#123; let originalSelector = #selector(present(_:animated:completion:)) let swizzledSelector = #selector(noAlert_present(_:animated:completion:)) let originalMethod = class_getInstanceMethod(NoAlertChangeViewController.self, originalSelector) let swizzledMethod = class_getInstanceMethod(NoAlertChangeViewController.self, swizzledSelector) //交换实现的方法 method_exchangeImplementations(originalMethod!, swizzledMethod!) &#125; &#125; @objc fileprivate func noAlert_present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -&gt; Swift.Void)? = nil) &#123; //判断是否是alert弹窗 if viewControllerToPresent.isKind(of: UIAlertController.self) &#123; print(\"title: \\(String(describing: (viewControllerToPresent as? UIAlertController)?.title))\") print(\"message: \\(String(describing: (viewControllerToPresent as? UIAlertController)?.message))\") // 换图标时的提示框的title和message都是nil，由此可特殊处理 let alertController = viewControllerToPresent as? UIAlertController if alertController?.title == nil &amp;&amp; alertController?.message == nil &#123; //是更换icon的提示 return &#125; else &#123; //其他的弹框提示正常处理 noAlert_present(viewControllerToPresent, animated: flag, completion: completion) &#125; &#125; noAlert_present(viewControllerToPresent, animated: flag, completion: completion) &#125;&#125; 这里用到了DispatchQueue.once, 这个once是我对DispatchQueue加了一个扩展 在Swift4.0以后, static dispatch_once_t onceToken;这个已经不能用了 关于这方面的详细介绍, 大家可以看看我的这篇文章–升级Swift4.0遇到的坑 四. 支持不同尺寸的Icon 一个标准的Icon图集, 需要十几种尺寸, 比如: 20, 29, 40, 60等 对于 info.plist 中的每个 icon 配置，CFBundleIconFiles 的值是一个数组，我们可以在其中填入这十几种规格的图片名称。经测试: 文件的命名没有强制的规则，可以随意取， 数组中的文件名也不关心先后顺序。 总之把对应的文件名填进去即可，它会自动选择合适分辨率的文件（比如在 setting 中显示 icon 时，它会找到提供的数组中分辨率为 29pt 的那个文件）。 具体相关官方文档可参考, 官方介绍 首先, 针对不同的尺寸, 我们要有不同的命名, 具体参考下图 文件扩展名，如@2x,@3x，要么统一不写，那么系统会自动寻找合适的尺寸。 要写就需要把每张icon的扩展名写上，和上图的格式一样 代码中调用图片名, 更不需要加上尺寸: 1234567891011121314if #available(iOS 10.3, *) &#123; //判断是否支持替换图标, false: 不支持 guard UIApplication.shared.supportsAlternateIcons else &#123; return &#125; //如果支持, 替换icon UIApplication.shared.setAlternateIconName(\"Sunday\") &#123; (error) in //点击弹框的确认按钮后的回调 if error != nil &#123; print(error ?? \"更换icon发生错误\") &#125; else &#123; print(\"更换成功\") &#125; &#125;&#125; 具体可参考demo–github项目地址","categories":[{"name":"入坑指南","slug":"入坑指南","permalink":"https://titanjun.top/categories/入坑指南/"}],"tags":[{"name":"AppIcon","slug":"AppIcon","permalink":"https://titanjun.top/tags/AppIcon/"},{"name":"iOS 10.3","slug":"iOS-10-3","permalink":"https://titanjun.top/tags/iOS-10-3/"}]},{"title":"SwiftLint代码规范属性说明(三)","slug":"SwiftLint代码规范属性说明(三)","date":"2018-03-10T12:04:54.000Z","updated":"2018-04-10T08:58:55.686Z","comments":true,"path":"2018/03/10/SwiftLint代码规范属性说明(三)/","link":"","permalink":"https://titanjun.top/2018/03/10/SwiftLint代码规范属性说明(三)/","excerpt":"这篇文章是继前两篇文章的继续更新 Xcode代码规范之SwiftLint配置–这篇文章对SwiftLint进行了简单介绍和针对Xcode的相关配置 SwiftLint代码规范属性说明(一)/)–这里介绍了上半部分的相关属性的介绍 下面来具体介绍一下SwiftLint的其他的代码规则的相关说明","text":"这篇文章是继前两篇文章的继续更新 Xcode代码规范之SwiftLint配置–这篇文章对SwiftLint进行了简单介绍和针对Xcode的相关配置 SwiftLint代码规范属性说明(一)/)–这里介绍了上半部分的相关属性的介绍 下面来具体介绍一下SwiftLint的其他的代码规则的相关说明 规则101: switch_case_alignmentswitch-case语句中switch和case应该垂直对齐 识别码 默认是否启用 是否支持自动更正 类型 switch_case_alignment 启用 no style 代码示例: 1234567891011121314151617//应该是这样switch someBool &#123;case true: // case 1 print('red')case false: if case let .someEnum(val) = someFunc() &#123; print('blue') &#125;&#125;//而不是这样switch someBool &#123; ↓case true: print('red') ↓case false: print('blue')&#125; 规则102: switch_case_on_newline在switch语法里， case应该总是在一个新行上面 识别码 默认是否启用 是否支持自动更正 类型 switch_case_on_newline 启用 no idiomatic 代码示例: 12345678910111213141516/// swiftlint表示会触发warning switch type &#123; case .value1: print(\"1\")...................在同一行错 case .value2: print(\"2\")...................在同一行错 default: print(\"3\")...................在同一行错 &#125; /// 不会触发warning switch type &#123; case .value1: print(\"1\") case .value2: print(\"2\") default: print(\"3\") &#125; 规则103: syntactic_sugarswiftlint推荐使用速记语法糖， 例如 [Int] 代替 Array, 强烈建议推荐使用 识别码 默认是否启用 是否支持自动更正 类型 syntactic_sugar 启用 no idiomatic 代码示例: 1234567/// 触发warning let myArray: Array&lt;Int&gt; = [1, 2, 3] print(myArray) /// 正确写法，不会触发warning let myArray: [Int] = [1, 2, 3] print(myArray) 规则104: todoTODO 和 FIXME 应该避免使用， 使用“notaTODO 和 notaFIXME”代替。另外， 和 MARK 标记不同的是， “notaTODO 和 notaFIXME”没有空格要求 识别码 默认是否启用 是否支持自动更正 类型 todo 启用 no lint 规则105: trailing_closure关于闭包中{}的使用, 推荐使用尾随闭包的语法 识别码 默认是否启用 是否支持自动更正 类型 trailing_closure 未启用 no style 代码示例: 1234567//推荐使用foo.map &#123; $0 + 1 &#125;foo.reduce(0) &#123; $0 + 1 &#125;//不推荐使用foo.map(&#123; $0 + 1 &#125;)↓foo.reduce(0, combine: &#123; $0 + 1 &#125;) 规则106: trailing_comma…这个属性主要针对数组和字典最后一个元素, 不建议在最后一个元素会面加逗号 识别码 默认是否启用 是否支持自动更正 类型 trailing_comma 启用 yes style 代码示例: 1234567/// 数组这样写是没有任何问题的, 但是最后一个元素3后面加了一个逗号“,”尽管这样不会报错，但是这会让程序的可读性变差let ages = [1, 2, 3,]let person = [\"XingYun\": 98, \"JinGang\": 128, \"LangKe\": 18,]/// 使用swiftlint的trailing_comma规则后，就会报warning， 所以正确的写法不应该加上这个“,”let ages = [1, 2, 3]let person = [\"XingYun\": 98, \"JinGang\": 128, \"LangKe\": 18] 规则107: trailing_newline文件（属性、方法）结束的的时候（“}”之前）， 应该有一个空格新行，但这里要注意的是 识别码 默认是否启用 是否支持自动更正 类型 trailing_newline 启用 yes style 代码示例: 1234567891011121314151617/// 空一行，不会触发警告nonTriggeringExamples: [ \"let a = 0\\n\"],/// 下面会触发警告triggeringExamples: [ \"let a = 0\", /// 不空行，会触发警告（实际上，我试过，不会触发警告） \"let a = 0\\n\\n\" /// 空两行， 会触发警告（实际上，我试过，会触发警告，但是触发的是vertical_whitespace警告而不是trailing_newline）],/// 说说这里，它要求改正为都空一行，虽然这样code看起来很轻松，但如果定义变量或常量太多，就太分散了（值得说的是，就算不空行也不会触发trailing_newline, 应该刚才也已经说了，这个属性只是说“应该”，而不是必须）corrections: [ \"let a = 0\": \"let a = 0\\n\", \"let b = 0\\n\\n\": \"let b = 0\\n\", \"let c = 0\\n\\n\\n\\n\": \"let c = 0\\n\"] 规则108: trailing_semicolon尽管在变量或常量赋值之后加不加分号在swift中没有硬性的要求，但是为了使code style更swift化，所以尽量或者绝对不要加“;” 识别码 默认是否启用 是否支持自动更正 类型 trailing_semicolon 启用 yes idiomatic 规则109: trailing_whitespace函数方法结束后,不建议添加空格行, 和vertical_whitespace貌似有冲突 识别码 默认是否启用 是否支持自动更正 类型 trailing_whitespace 启用 yes style 代码示例: 12345678910111213/// 下面这个例子不会触发警告，但是一旦其中有一个空行就会触发警告trailing_whitespace, 这和vertical_whitespace实质上有些冲突，vertical_whitespace要求两行code之间不超过1行，要么没有空行，要么只有1行，而trailing_whitespace要求没有空行！！！class ViewController: UIViewController &#123;override func viewDidLoad() &#123; super.viewDidLoad() let a = 0 let b = 1 let c = 2&#125;func chenlong() -&gt; Void &#123; let a = 0 print(a)&#125;&#125; 规则110: type_body_length类型体长度。类型体长度不应该跨越太多行， 超过200行给warning，超过350行给error。一般是大括号或者括号内, 比如定义一个enum或struct 识别码 默认是否启用 是否支持自动更正 类型 type_body_length 启用 no metrics 规则111: type_name…类型名， 类型名应该只包含字母数字字符， 并且以大写字母开头，长度在3-40个字符 识别码 默认是否启用 是否支持自动更正 类型 type_name 启用 no idiomatic 规则112: unneeded_break_in_switch在switch-case语句中, 有方法调用或操作时,避免使用break语句 识别码 默认是否启用 是否支持自动更正 类型 unneeded_break_in_switch 启用 no idiomatic 代码示例: 123456789101112131415161718192021//不会触发warningswitch foo &#123;case .bar: break&#125;switch foo &#123;default: break&#125;switch foo &#123;case .bar: something()&#125;//会触发warningswitch foo &#123;case .bar://这里已经有方法调用了 something() ↓break&#125; 规则113: unneeded_parentheses_in_closure_argument…在定义或使用闭包时,闭包参数不建议使用括号() 识别码 默认是否启用 是否支持自动更正 类型 unneeded_parentheses_in_closure_argument 未启用 yes style 代码示例: 12345678//建议let foo = &#123; (bar: Int) in &#125;let foo = &#123; bar, _ in &#125;let foo = &#123; bar in &#125;//不建议call(arg: &#123; ↓(bar) in &#125;)call(arg: &#123; ↓(bar, _) in &#125;) 规则114: unused_closure_parameterswiftlint建议最好把不使用的闭包参数使用 “_”代替 识别码 默认是否启用 是否支持自动更正 类型 unused_closure_parameter 启用 yes lint 代码示例: 123456789101112131415//不会触发warning[1, 2].map &#123; number in number + 1 &#125;[1, 2].map &#123; _ in 3 &#125;//会触发warning[1, 2].map &#123; ↓number in return 3&#125;[1, 2].map &#123; ↓number in return numberWithSuffix&#125; 规则115: unused_enumerated在for遍历数组时, 如有未使用的索引,不建议使用.enumerated() 识别码 默认是否启用 是否支持自动更正 类型 unused_enumerated 启用 no idiomatic 代码示例: 12345678910//不会触发warningfor (idx, foo) in bar.enumerated() &#123; &#125;for (_, foo) in bar.enumerated().something() &#123; &#125;for (_, foo) in bar.something() &#123; &#125;//会触发warningfor (↓_, foo) in bar.enumerated() &#123; &#125;for (↓_, foo) in abc.bar.enumerated() &#123; &#125;for (↓_, foo) in abc.something().enumerated() &#123; &#125;for (idx, ↓_) in bar.enumerated() &#123; &#125; 规则116: unused_optional_binding在使用if判断某变量是否为nil的时候, 不建议使用下划线(_) 识别码 默认是否启用 是否支持自动更正 类型 unused_optional_binding 启用 no style 代码示例: 123456789//不会触发warningif let bar = Foo.optionalValue &#123;&#125;//会触发warningif let ↓_ = Foo.optionalValue &#123;&#125;if let a = Foo.optionalValue, let ↓_ = Foo.optionalValue2 &#123;&#125; 规则117: valid_ibinspectable@IBInspectable在swiftlint中的使用需要注意， 第一必须是变量， 第二必须要有指定的类型，如果指定的类型是可选类型或者隐式类型，则目前官方只支持以下几种类型： String, NSString, UIColor, NSColor, UIImage, NSImage. 识别码 默认是否启用 是否支持自动更正 类型 valid_ibinspectable 启用 no lint 代码示例: 12345678910111213/// 指定为变量var， 类型为String？和String！@IBInspectable private var yyy: String?@IBInspectable private var zzz: String!/// 如果写成这样，编译能通过，但是会触发警告, 因为swiftlint暂不支持Int可选和隐式类型:@IBInspectable private var dddl: Int!@IBInspectable private var eeel: Int?/// 如果指定的类型不是可选类型， 就应该初始化，否则系统不允许，会报错所在的类没有初始化对：@IBInspectable private var counts: Int = 0系统报错：@IBInspectable private var counts: Int 规则118: vertical_parameter_alignment垂直方向上的参数对齐。当函数参数有多行的时候， 函数参数在垂直方向上应该对齐（参数换行的时候左边对齐） 识别码 默认是否启用 是否支持自动更正 类型 vertical_parameter_alignment 启用 no style 代码示例: 12345678910//不会触发warningfunc validateFunction(_ file: File, kind: SwiftDeclarationKind, dictionary: [String: SourceKitRepresentable]) &#123; &#125; func validateFunction(_ file: File, kind: SwiftDeclarationKind, dictionary: [String: SourceKitRepresentable]) -&gt; [StyleViolation]//会触发warningfunc validateFunction(_ file: File, kind: SwiftDeclarationKind, ↓dictionary: [String: SourceKitRepresentable]) &#123; &#125; 规则119: vertical_parameter_alignment_on_call当调用多个参数的函数时,如果参数多行显示,则应该垂直对齐 识别码 默认是否启用 是否支持自动更正 类型 vertical_parameter_alignment_on_call 未启用 no style 代码示例: 12345678910111213141516171819//不会触发warningfoo(param1: 1, param2: bar param3: false, param4: true)foo(param1: 1, param2: bar)foo(param1: 1, param2: bar param3: false, param4: true)//会触发warningfoo(param1: 1, param2: bar ↓param3: false, param4: true) foo(param1: 1, param2: bar ↓param3: false, param4: true) foo(param1: 1, param2: bar ↓param3: false, ↓param4: true) 规则120: vertical_whitespace垂直方向上的空格行，限制为一行（注释除外） 识别码 默认是否启用 是否支持自动更正 类型 vertical_whitespace 启用 yes style 代码示例: 1234567891011121314151617181920/// 没有空格， nonTriggerWarningoverride func viewDidLoad() &#123; super.viewDidLoad() let aaa = 0&#125; /// 有一行空格, nonTriggerWarningoverride func viewDidLoad() &#123; super.viewDidLoad() let aaa = 0 ............................1&#125;/// &gt;=2行，就会触发警告override func viewDidLoad() &#123; super.viewDidLoad() let aaa = 0 .............................1 .............................2&#125; 规则121: void_return多余的返回值为空， 在函数声明的时候，返回值为空是多余的。定义常量或者变量的时候可以 识别码 默认是否启用 是否支持自动更正 类型 void_return 启用 yes style 代码示例: 123456789/// 这个属性要求这样写， 返回值为空省略func XingYun() &#123; print(\"titan\")&#125;/// 这个属性要求别这样写，否则会有warning（但是我在swift 3.0上测试并没有触发warning）func XingYun() -&gt; Void &#123; print(\"titan\")&#125; 规则122: weak_delegate代理应该写成weak类型（弱代理）来避免循环引用 识别码 默认是否启用 是否支持自动更正 类型 weak_delegate 启用 no lint 代码示例: 123456789101112131415161718192021222324252627282930/// 1.1 编译通过class Langke &#123; var chenlong: NSObjectProtocol?&#125;/// 1.2 编译通过，但是触发swiftlint的 weak_delegate警告， 原因是变量名 myDelegate 中有 delegate 关键字，这属于名字滥用class Langke &#123; var myDelegate: NSObjectProtocol?&#125;/// 1.3 编译通过， 不会触发警告， 原因是在 var 关键字前面加了 weakclass Langke &#123; weak var myDelegate: NSObjectProtocol?&#125;/// 2.1 编译通过，但是触发 weak_delegate 警告，原因是 scrollDelegate 中 Delegate 放在了最后， 被理解成了代理class Langke &#123; var scrollDelegate: UIScrollViewDelegate?&#125;/// 2.2 编译通过， 既然变量名被理解成了代理， 那为了类似防止循环引用， 应该加关键字 weakclass Langke &#123; weak var scrollDelegate: UIScrollViewDelegate?&#125;/// 编译通过， 不会触发警告， 因为delegate放在了前面， 没有被理解成代理class Langke &#123; var delegateScroll: UIScrollViewDelegate?&#125; 规则123: xctfail_message单元测试中,XCTFail调用应该包括声明描述 识别码 默认是否启用 是否支持自动更正 类型 xctfail_message 启用 no idiomatic 规则124: yoda_condition执行判断语句时, 变量名应该放在运算符的左边 识别码 默认是否启用 是否支持自动更正 类型 yoda_condition 未启用 no lint 代码示例: 123456789101112//不会触发warningif foo == 42 &#123;&#125;if foo &lt;= 42.42 &#123;&#125;guard foo &gt;= 42 else &#123; return &#125;guard foo != \"str str\" else &#123; return &#125;//会触发warning↓if 42 == foo &#123;&#125;↓if 42.42 &gt;= foo &#123;&#125;↓guard 42 &lt;= foo else &#123; return &#125;↓guard \"str str\" != foo else &#123; return &#125;↓while 10 &gt; foo &#123; &#125; 文中如有不足之处请多指教 持续更新中…..","categories":[{"name":"SwiftLint","slug":"SwiftLint","permalink":"https://titanjun.top/categories/SwiftLint/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"SwiftLint","slug":"SwiftLint","permalink":"https://titanjun.top/tags/SwiftLint/"},{"name":"规则","slug":"规则","permalink":"https://titanjun.top/tags/规则/"}]},{"title":"SwiftLint代码规范属性说明(二)","slug":"SwiftLint代码规范属性说明(二)","date":"2018-03-10T09:04:54.000Z","updated":"2018-04-10T08:59:09.294Z","comments":true,"path":"2018/03/10/SwiftLint代码规范属性说明(二)/","link":"","permalink":"https://titanjun.top/2018/03/10/SwiftLint代码规范属性说明(二)/","excerpt":"这篇文章是继前两篇文章的继续更新 Xcode代码规范之SwiftLint配置–这篇文章对SwiftLint进行了简单介绍和针对Xcode的相关配置 SwiftLint代码规范属性说明(一)/)–这里介绍了上半部分的相关属性的介绍 下面来具体介绍一下SwiftLint的其他的代码规则的相关说明","text":"这篇文章是继前两篇文章的继续更新 Xcode代码规范之SwiftLint配置–这篇文章对SwiftLint进行了简单介绍和针对Xcode的相关配置 SwiftLint代码规范属性说明(一)/)–这里介绍了上半部分的相关属性的介绍 下面来具体介绍一下SwiftLint的其他的代码规则的相关说明 规则51: legacy_cggeometry_functions当获取某个视图的宽、高、最小X、最大X值等等， swiftlint推荐使用swift的标准语法， 尽量不要使用从Objective-C中的遗留版本， 尽量语法swift化 识别码 默认是否启用 是否支持自动更正 类型 legacy_cggeometry_functions 启用 yes idiomatic 代码示例: 123456789/// 这样不推荐使用CGRectGetWidth(someView.frame)/// 推荐使用下面的形式rect.widthrect.heightrect.minXrect.midXrect................... 规则52: legacy_constant和属性legacy_cggeometry_functions一样， 结构范围常数尽量分开、明确、具体， 不要使用OC的遗留整体常数 识别码 默认是否启用 是否支持自动更正 类型 legacy_constant 启用 yes idiomatic 代码示例: 123456/// 规范的写法，不会触发warningCGPoint.zero/// 不规范的写法， 会触发warningCGPointZeroCGRectZero 规则53: legacy_constructorswiftlint要求系统自带构造器， 使用swift语法化， 不要使用OC版本的构造器 识别码 默认是否启用 是否支持自动更正 类型 legacy_constructor 启用 yes idiomatic 代码示例: 12345/// swift语法，相信之后系统也会强制规定使用CGPoint（x: 10， y: 20）/// 错误的构造器语法CGPointMake(10, 20) 规则54: legacy_nsgeometry_functionsns类几何函数， 和前面的几个属性一样， 使用swift点语法函数， 不使用以前的版本。 识别码 默认是否启用 是否支持自动更正 类型 legacy_nsgeometry_functions 启用 yes idiomatic 代码示例: 12345/// 正确view.width/height/minX/// 错误NSWidth(view.frame) 规则55: let_var_whitespacelet和var语句应该用空白行与其他语句分开 识别码 默认是否启用 是否支持自动更正 类型 let_var_whitespace 未启用 no style 代码示例: 12345678910//推荐这样写let a = 0var x = 1x = 2//不建议写法var x = 1x = 2 规则56: line_length行的字符长度属性。这个强烈不推荐使用。官方的规定是超过120字符就给warning， 超过200个字符就直接报error！！！我们又不是写底层脚本的，所以建议这种方式禁用！！ 识别码 默认是否启用 是否支持自动更正 类型 line_length 启用 no metrics 规则57: literal_expression_end_indentation字典和数组的开头和结尾要有相同的缩进格式 识别码 默认是否启用 是否支持自动更正 类型 literal_expression_end_indentation 未启用 no style 规则58: mark标记方法或者属性。这个推荐使用， 可以统一方法标记的格式， 有利于review查找某个方法或者属性的时候更清晰。使用也非常简单： “MARK”前空一格，”MARK:”后空一格。 识别码 默认是否启用 是否支持自动更正 类型 mark 启用 yes lint 代码示例: 123456789101112//推荐写法// MARK: good// MARK: - good// MARK: -//不建议写法//MARK: bad// MARK:bad//MARK:bad// MARK: bad// MARK: bad// MARK: -bad 规则59: multiline_arguments调用函数和方法时, 其参数应该在同一行上，或者每行一个 识别码 默认是否启用 是否支持自动更正 类型 multiline_arguments 未启用 no style 代码示例: 12345678//不建议以下写法foo(0, param1: 1, param2: true, param3: [3]) foo( 0, param1: 1, param2: true, param3: [3]) 规则60: multiline_parameters声明函数和方法时, 其参数应该在同一行上，或者每行一个 识别码 默认是否启用 是否支持自动更正 类型 multiline_parameters 未启用 no style 代码示例: 12345678910//不建议以下写法protocol Foo &#123; func foo(param1: Int, param2: Bool, param3: [String]) &#123; &#125;&#125;protocol Foo &#123; func foo(param1: Int, param2: Bool, param3: [String]) &#123; &#125;&#125; 规则61: multiple_closures_with_trailing_closure当函数有多个闭包时, 不建议使用尾随闭包语法 识别码 默认是否启用 是否支持自动更正 类型 multiple_closures_with_trailing_closure 启用 no style 代码示例: 12345678//不建议写法foo.something(param1: &#123; $0 &#125;) &#123; $0 + 1 &#125;UIView.animate(withDuration: 1.0, animations: &#123; someView.alpha = 0.0&#125;) &#123; _ in someView.removeFromSuperview()&#125; 规则62: nesting嵌套。类型嵌套至多一级结构， 函数语句嵌套至多五级结构。 识别码 默认是否启用 是否支持自动更正 类型 nesting 启用 no metrics 规则63: nimble_operator快捷操作符。和自由匹配函数相比， 更喜欢快捷操作符， 比如：&gt;=、 ==、 &lt;=、 &lt;等等。 识别码 默认是否启用 是否支持自动更正 类型 nimble_operator 未启用 yes idiomatic 代码示例: 123456789/// 会触发warning(person.voice).toNot(equal(\"Hello world\")) // 判断字符串相同10.to(beGreaterThan(5)) // 10比5大99.to(beLessThan(100)) // 99比100小// 改为以下(person.voice) != \"Hello world\" // 判断字符串相同10 &gt; 5 // 10比5大99 &lt; 100 // 99比100小 规则64: no_extension_access_modifier在extension扩展前面,不建议使用(fileprivate, public)等修饰符 识别码 默认是否启用 是否支持自动更正 类型 no_extension_access_modifier 未启用 no idiomatic 代码示例: 123456//不推荐写法private extension String &#123;&#125;public extension String &#123;&#125;open extension String &#123;&#125;internal extension String &#123;&#125;fileprivate extension String &#123;&#125; 规则65: no_grouping_extension只有class和protocol可以使用extension,其他类型不可使用 识别码 默认是否启用 是否支持自动更正 类型 no_grouping_extension 未启用 no idiomatic 代码示例: 123456789101112//不推荐写法enum Fruit &#123;&#125;extension Fruit &#123;&#125;extension Tea: Error &#123;&#125;struct Tea &#123;&#125;class Ham &#123; class Spam &#123;&#125;&#125;extension Ham.Spam &#123;&#125;extension External &#123; struct Gotcha &#123;&#125;&#125;extension External.Gotcha &#123;&#125; 规则66: notification_center_detachment对象移除通知只能在deinit移除self,函数中不能removeObserver(self) 识别码 默认是否启用 是否支持自动更正 类型 notification_center_detachment 启用 no lint 代码示例: 1234567891011121314151617181920//不会触发warningclass Foo &#123; deinit &#123; NotificationCenter.default.removeObserver(self) &#125;&#125;class Foo &#123; func bar() &#123; NotificationCenter.default.removeObserver(otherObject) &#125;&#125;//会触发warningclass Foo &#123; func bar() &#123; NotificationCenter.default.removeObserver(self) &#125;&#125; 规则67: number_separator数字分割线。当在大量的小数中， 应该使用下划线来作为千分位分割线 识别码 默认是否启用 是否支持自动更正 类型 number_separator 未启用 yes style 代码示例: 1234567/// 推荐使用这种形式let xxx = 1_000_000_000.000_1print(xxx)/// 不推荐使用这种形式（在swift let xxx = 1000000000.0001print(xxx) 规则68: object_literalswiftlint表示比起图片和颜色初始化，更喜欢对象初始化。因为swift初始化可以用表情，图片，颜色等，这不符合项目中的一些习惯用法 识别码 默认是否启用 是否支持自动更正 类型 object_literal 未启用 no idiomatic 代码示例: 123456789101112131415//不会触发warninglet image = #imageLiteral(resourceName: \"image.jpg\")let color = #colorLiteral(red: 0.9607843161, green: 0.7058823705, blue: 0.200000003, alpha: 1)let image = UIImage(named: aVariable)let image = UIImage(named: \"interpolated \\(variable)\")let color = UIColor(red: value, green: value, blue: value, alpha: 1)let image = NSImage(named: aVariable)let image = NSImage(named: \"interpolated \\(variable)\")let color = NSColor(red: value, green: value, blue: value, alpha: 1)//会触发warninglet image = ↓UIImage(named: \"foo\")let color = ↓UIColor(red: 0.3, green: 0.3, blue: 0.3, alpha: 1)let color = ↓UIColor(red: 100 / 255.0, green: 50 / 255.0, blue: 0, alpha: 1)let color = ↓UIColor(white: 0.5, alpha: 1) 规则69: opening_brace花括号之前应该有一个空格,且与声明在同一行 识别码 默认是否启用 是否支持自动更正 类型 opening_brace 启用 yes style 代码示例: 12345678//建议写法func abc() &#123;&#125;[].map() &#123; $0 &#125;[].map(&#123; &#125;)if let a = b &#123; &#125;while a == b &#123; &#125;guard let a = b else &#123; &#125; 规则70: operator_usage_whitespace操作符使用规则， 操作符两边应该有空格。比如 “+” “-” “？？” 识别码 默认是否启用 是否支持自动更正 类型 operator_usage_whitespace 未启用 yes style 代码示例: 1234567891011//建议写法let foo = 1 + 2let foo = 1 &gt; 2let foo = !false//不推荐写法let foo = 1+2let foo = 1 + 2let foo = 1 + 2let foo = 1 + 2let foo=1+2 规则71: operator_whitespace空格/空白操作符。当定义空格操作符的时候，被定义的名字或类型两边应该各有一个单行空格操作符 识别码 默认是否启用 是否支持自动更正 类型 operator_whitespace 启用 no style 代码示例: 12345678910// 触发警告class Something: Equatable &#123; var text: String? // \"==\"和“(lhs: Something, rhs: Something)”之间应该有一个空格 static func ==(lhs: Something, rhs: Something) -&gt; Bool &#123; return lhs.text == rhs.text &#125;&#125; 规则72: overridden_super_call一些重写的方法应该调用super.(父类的)方法 识别码 默认是否启用 是否支持自动更正 类型 overridden_super_call 未启用 no lint 代码示例: 123456789101112131415/// 这样会触发警告 class VCd: UIViewController &#123; override func viewWillAppear(_ animated: Bool) &#123; //没有调用父类 &#125; &#125; /// 不会触发警告 class VCd: UIViewController &#123; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) &#125; &#125; 规则73: override_in_extension在extension中,不能重写未声明的属性和未定义的方法 识别码 默认是否启用 是否支持自动更正 类型 override_in_extension 未启用 no lint 代码示例: 12345678910//错误写法extension Person &#123; //该属性之前未定义, 不能重写 override var age: Int &#123; return 42 &#125;&#125;extension Person &#123; //该方法之前也为定义不能重写 override func celebrateBirthday() &#123;&#125;&#125; 规则74: pattern_matching_keywords…在switch-case语句中, 建议不要将case中的let和var等关键字放到元祖内 识别码 默认是否启用 是否支持自动更正 类型 pattern_matching_keywords 未启用 no idiomatic 代码示例: 123456789101112131415161718192021222324//正确写法switch foo &#123; case let .foo(x, y): break&#125;switch foo &#123; case .foo(let x), .bar(let x): break&#125;//错误写法switch foo &#123; case (↓let x, ↓let y): break&#125;switch foo &#123; case .foo(↓let x, ↓let y): break&#125;switch foo &#123; case (.yamlParsing(↓let x), .yamlParsing(↓let y)): break&#125;switch foo &#123; case (↓var x, ↓var y): break&#125;switch foo &#123; case .foo(↓var x, ↓var y): break&#125; 规则76: prefixed_toplevel_constant类似全局常量,建议前缀以k开头 识别码 默认是否启用 是否支持自动更正 类型 prefixed_toplevel_constant 未启用 no style 代码示例: 12345//推荐写法private let kFoo = 20.0public let kFoo = falseinternal let kFoo = \"Foo\"let kFoo = true 规则77: private_actionIBActions修饰的方法,应该都是私有的 识别码 默认是否启用 是否支持自动更正 类型 private_action 未启用 no lint 代码示例: 12345678910111213141516171819//推荐写法class Foo &#123; @IBAction private func barButtonTapped(_ sender: UIButton) &#123;&#125;&#125;struct Foo &#123; @IBAction private func barButtonTapped(_ sender: UIButton) &#123;&#125;&#125;class Foo &#123; @IBAction fileprivate func barButtonTapped(_ sender: UIButton) &#123;&#125;&#125;struct Foo &#123; @IBAction fileprivate func barButtonTapped(_ sender: UIButton) &#123;&#125;&#125;private extension Foo &#123; @IBAction func barButtonTapped(_ sender: UIButton) &#123;&#125;&#125;fileprivate extension Foo &#123; @IBAction func barButtonTapped(_ sender: UIButton) &#123;&#125;&#125; 规则78: private_outletIBOutlets修饰的属性应该都是私有的 识别码 默认是否启用 是否支持自动更正 类型 private_outlet 未启用 no lint 代码示例: 123456789101112131415//推荐写法class Foo &#123; @IBOutlet private var label: UILabel?&#125;class Foo &#123; @IBOutlet private var label: UILabel!&#125;//不推荐写法class Foo &#123; @IBOutlet var label: UILabel?&#125;class Foo &#123; @IBOutlet var label: UILabel!&#125; 规则79: private_over_fileprivateprivate比fileprivate的私有程度更高 识别码 默认是否启用 是否支持自动更正 类型 private_over_fileprivate 启用 yes idiomatic 规则80: private_unit_test私有的单元测试。被标记为private的单元测试不会被测试工具XCTest运行， 也就是说，被标记为private的单元测试会被静态跳过 识别码 默认是否启用 是否支持自动更正 类型 private_unit_test 启用 no lint 代码示例: 123456789101112131415161718192021222324252627private ↓class FooTest: XCTestCase &#123; ...............继承于测试用例类XCTestCase, 被标记为private，所以触发warning func test1() &#123;&#125; internal func test2() &#123;&#125; public func test3() &#123;&#125; private func test4() &#123;&#125;.......另外注意这里，上面既然不会通过，那显然这里也不会通过，根本不会走这个func &#125; internal class FooTest: XCTestCase &#123; ......开始通过测试，因为没有被标记为private func test1() &#123;&#125; internal func test2() &#123;&#125; public func test3() &#123;&#125; private ↓func test4() &#123;&#125;................不通过，因为被标记为private &#125; public class FooTest: XCTestCase &#123; ..........通过 func test1() &#123;&#125; internal func test2() &#123;&#125; public func test3() &#123;&#125; private ↓func test4() &#123;&#125;.................不通过，因为被标记成private &#125; class FooTest: XCTestCase &#123; ..........通过 func test1() &#123;&#125; internal func test2() &#123;&#125; public func test3() &#123;&#125; private ↓func test4() &#123;&#125;.................不通过，因为被标记成private &#125; 规则81: prohibited_super_call一些方法不应该调用父类的方法 识别码 默认是否启用 是否支持自动更正 类型 prohibited_super_call 未启用 no lint 代码示例: 1234567891011121314151617181920212223242526//以下方法不建议调用父类的方法class VC: UIViewController &#123; override func loadView() &#123;↓ super.loadView() &#125;&#125;class VC: NSFileProviderExtension &#123; override func providePlaceholder(at url: URL,completionHandler: @escaping (Error?) -&gt; Void) &#123;↓ self.method1() super.providePlaceholder(at:url, completionHandler: completionHandler) &#125;&#125;class VC: NSView &#123; override func updateLayer() &#123;↓ self.method1() super.updateLayer() self.method2() &#125;&#125;class VC: NSView &#123; override func updateLayer() &#123;↓ defer &#123; super.updateLayer() &#125; &#125;&#125; 规则82: protocol_property_accessors_order在协议中声明属性时，访问者的顺序应该是get set 识别码 默认是否启用 是否支持自动更正 类型 protocol_property_accessors_order 启用 yes style 代码示例: 123456789//建议protocol Foo &#123; var bar: String &#123; get set &#125;&#125; //不建议protocol Foo &#123; var bar: String &#123; set get &#125;&#125; 规则83: quick_discouraged_call在单元测试中,不建议在describe和content比保重直接调用方法和类 识别码 默认是否启用 是否支持自动更正 类型 quick_discouraged_call 未启用 no lint 规则84: quick_discouraged_focused_test在单元测试中,不建议集中测试,否则可能不能运行成功 识别码 默认是否启用 是否支持自动更正 类型 quick_discouraged_focused_test 未启用 no lint 代码示例: 123456//官方示例, 不建议class TotoTests: QuickSpec &#123; override func spec() &#123; ↓fdescribe(\"foo\") &#123; &#125; &#125;&#125; 规则85: quick_discouraged_pending_test单元测试中阻止未进行的测试单元 识别码 默认是否启用 是否支持自动更正 类型 quick_discouraged_pending_test 未启用 no lint 规则86: redundant_discardable_let不需要初始化方法返回结果时,建议使用: _ = Person(), 而不是:let _ = Person() 识别码 默认是否启用 是否支持自动更正 类型 redundant_discardable_let 启用 yes style 代码示例: 12345678//推荐_ = foo()if let _ = foo() &#123; &#125;guard let _ = foo() else &#123; return &#125;//不建议let _ = foo()if _ = foo() &#123; let _ = bar() &#125; 规则87: redundant_nil_coalescing使用可能为为nil的可选值时,建议使用: str ?? “”, ??左右两侧要有一个空格 识别码 默认是否启用 是否支持自动更正 类型 redundant_nil_coalescing 未启用 yes idiomatic 代码示例: 123456//建议写法var myVar: Int?; myVar ?? 0//不建议写法var myVar: Int? = nil; myVar ?? nilvar myVar: Int? = nil; myVar??nil 规则88: redundant_optional_initialization初始化nil变量是,不建议赋值nil 识别码 默认是否启用 是否支持自动更正 类型 redundant_optional_initialization 启用 yes idiomatic 代码示例: 1234567891011//不会触发warningvar myVar: Int?let myVar: Int? = nilvar myVar: Optional&lt;Int&gt;let myVar: Optional&lt;Int&gt; = nil//会触发warningvar myVar: Int?↓ = nilvar myVar: Optional&lt;Int&gt;↓ = nilvar myVar: Int?↓=nilvar myVar: Optional&lt;Int&gt;↓=nil 规则89: redundant_string_enum_value在定义字符串枚举的时候, 当字符串枚举值等于枚举名称时，可以不用赋值 识别码 默认是否启用 是否支持自动更正 类型 redundant_string_enum_value 启用 no idiomatic 代码示例: 123456789101112131415161718//不会触发warningenum Numbers: String &#123; case one case two&#125;enum Numbers: Int &#123; case one = 1 case two = 2&#125;//会触发warningenum Numbers: String &#123; case one = ↓\"one\" case two = ↓\"two\"&#125;enum Numbers: String &#123; case one = ↓\"one\", two = ↓\"two\"&#125; 规则90: redundant_void_return当函数返回值为Void时,建议不谢返回值, 定义常量或者变量的时候可以 识别码 默认是否启用 是否支持自动更正 类型 redundant_void_return 启用 yes idiomatic 代码示例: 12345678910111213141516//不会触发warningfunc foo() &#123;&#125;func foo() -&gt; Int &#123;&#125;func foo() -&gt; Int -&gt; Void &#123;&#125;func foo() -&gt; VoidResponselet foo: Int -&gt; Void//会触发warningfunc foo()↓ -&gt; Void &#123;&#125;protocol Foo &#123; func foo()↓ -&gt; Void&#125;func foo()↓ -&gt; () &#123;&#125;protocol Foo &#123; func foo()↓ -&gt; ()&#125; 规则91: required_enum_case定义的枚举,必须有与其对应的操作实现 识别码 默认是否启用 是否支持自动更正 类型 required_enum_case 未启用 no lint 规则92: return_arrow_whitespaceswiftlint推荐返回箭头和返回类型应该被空格分开 识别码 默认是否启用 是否支持自动更正 类型 return_arrow_whitespace 启用 yes style 代码示例: 12345678910//推荐写法func abc() -&gt; Int &#123;&#125;func abc() -&gt; [Int] &#123;&#125;//不建议写法func abc()↓-&gt;Int &#123;&#125;func abc()↓-&gt;[Int] &#123;&#125;func abc()↓-&gt;(Int, Int) &#123;&#125;func abc()↓-&gt; Int &#123;&#125;func abc()↓ -&gt;Int &#123;&#125; 规则93: shorthand_operator在swiftlint中， 就是我们常用的简洁操作运算符，比如：+= ， -=， *=， /= 等等。在swiftlint中，在做一些赋值操作的时候，推荐使用简短操作符 识别码 默认是否启用 是否支持自动更正 类型 shorthand_operator 启用 no style 代码示例: 123456789/// 不推荐使用var value = 4value = value / 2print(value)/// 推荐使用var value = 4value /= 2print(value) 规则94: single_test_class单元测试中,测试文件应该包含一个QuickSpec或XCTestCase类 识别码 默认是否启用 是否支持自动更正 类型 single_test_class 未启用 no style 规则95: sorted_first_last在获取某数组中最大最小值时,建议使用min和max函数,而不是sorted().first和sorted().lase 识别码 默认是否启用 是否支持自动更正 类型 sorted_first_last 未启用 no style 代码示例: 12 规则96: aaa… 识别码 默认是否启用 是否支持自动更正 类型 aaa 未启用 no style 代码示例: 12345678910111213//建议let min = myList.min()let min = myList.min(by: &#123; $0 &lt; $1 &#125;)let min = myList.min(by: &gt;)let min = myList.max()let min = myList.max(by: &#123; $0 &lt; $1 &#125;)//不建议myList.sorted().firstmyList.sorted(by: &#123; $0.description &lt; $1.description &#125;).firstmyList.sorted(by: &gt;).firstmyList.map &#123; $0 + 1 &#125;.sorted().firstmyList.sorted(by: someFunction).first 规则97: sorted_imports分类/有序导入。 这个属性有些奇怪， 要求导入的时候导入的类要按顺序导入 识别码 默认是否启用 是否支持自动更正 类型 sorted_imports 未启用 yes style 代码示例: 123456789//建议写法import AAAimport BBBimport CCCimport DDDimport Alamofireimport API 规则98: statement_position陈述句位置， 这里主要指的是 else 和 catch 前面要加一个空格， 也不能大于1个空格， 否则就会触发警告 识别码 默认是否启用 是否支持自动更正 类型 statement_position 启用 yes style 代码示例: 1234567891011121314151617181920212223242526/// 没有空格，触发warninglet number = \"long\"if number.isEmpty &#123; print(\"为空\")&#125;else &#123;.............................注意这里 print(\"不为空\")&#125;/// 这里也会触发warning， 因为else if换行了let number = \"long\"if number.isEmpty &#123; print(\"为空\")&#125;else if number.contains(\"long\") &#123;............................注意这里 print(\"不为空\")&#125; else &#123; print(\"s\")&#125;/// 正确的写法let number = \"long\"if number.isEmpty &#123; print(\"为空\")&#125; else &#123; print(\"不为空\")&#125; 规则99: strict_fileprivateextension中不建议使用fileprivate 修饰方法和属性 识别码 默认是否启用 是否支持自动更正 类型 strict_fileprivate 未启用 no idiomatic 规则100: superfluous_disable_command被禁用的规则不会在禁用区域触发警告 识别码 默认是否启用 是否支持自动更正 类型 superfluous_disable_command 启用 no lint 文中如有不足之处请多指教 持续更新中…..","categories":[{"name":"SwiftLint","slug":"SwiftLint","permalink":"https://titanjun.top/categories/SwiftLint/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"SwiftLint","slug":"SwiftLint","permalink":"https://titanjun.top/tags/SwiftLint/"},{"name":"规则","slug":"规则","permalink":"https://titanjun.top/tags/规则/"}]},{"title":"基于GitHub和Hexo搭建个人博客","slug":"基于GitHub和Hexo搭建个人博客","date":"2018-03-08T12:13:00.000Z","updated":"2018-04-10T09:00:29.540Z","comments":true,"path":"2018/03/08/基于GitHub和Hexo搭建个人博客/","link":"","permalink":"https://titanjun.top/2018/03/08/基于GitHub和Hexo搭建个人博客/","excerpt":"本文是使用Mac电脑, 基于GitHub和Hexo搭建个人博客, 搞了两三天, 反复尝试了无数次, 踩了无数坑搭建起来的, 主要跟大家分享一点小经验, 希望对大家能有帮助!","text":"本文是使用Mac电脑, 基于GitHub和Hexo搭建个人博客, 搞了两三天, 反复尝试了无数次, 踩了无数坑搭建起来的, 主要跟大家分享一点小经验, 希望对大家能有帮助! 一. github博客简介github 是全球最大的社交编程及代码托管网站，GitHub可以托管各种git库，并提供一个web界面，但与其它像SourceForge或Google Code这样的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。这里着重写如何使用Github的page功能搭建个人博客! 使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 二. 准备工作 有一个github账号，没有的话去GitHub注册一个 安装了node.js、npm，并了解相关基础知识 安装了git 三. 环境搭建1. 安装Node.js 用来生成静态页面, 到Node.js官网，下载最新版本, 根据提示一路安装即可 Node.js默认会安装 npm 也可以使用Homebrew进行命令安装, 详情参考React Native中文网安装方法 2. 安装Git 用来将本地Hexo内容提交到Github上。下载的Xcode自带Git，这里不再赘述。 如果没有Xcode可以参考Hexo官网上的安装方法 通用版的Git安装, 无法下载的童鞋，可以去网上搜索下载 3. 安装Hexo当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令： 1sudo npm install -g hexo 此时, 会提示你输入管理员密码(电脑密码), 开始安装 四. 本地搭建 hexo 静态博客 在电脑中新建一个文件夹, 文件夹名字随意, 如MyBlog 在终端, cd 进入该文件夹 终端运行 git, 生成hexo模板，可能要翻墙 1hexo init 安装完模板, 安装npm 1npm install 最后, 开启hexo服务器 1hexo s 此时，浏览器中打开网址http://localhost:4000，能看到如下页面： 五. 将博客与Github关联1. 在GitHub上配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1.1首先检查本机是否存在的ssh密钥 如果存在, 直接进行步骤1.3, 否则执行步骤1.2生成新的密钥 打开终端输入, 注意~/.ssh之间没有空格 1cd ~/.ssh 如果提示：No such file or directory 说明你是第一次使用git, 或者之前没有安装过SSh密钥 1.2. 生成新的ssh key注意后面添加自己注册GitHub的邮箱地址, 打开终端输入 1ssh-keygen -t rsa -C \"邮件地址\" 输入命令后, 然后连续回车, 默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件 打开’访达’, 选择进入文件夹(快捷键Command+Shift+G), 输入~/.ssh, 进入该文件夹 1.3. 将ssh key添加到Github中打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存 1.4. 测试SSH配置是否成功1ssh -T git@github.com 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： 1Hi XXXX! You've successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 1.5. 更改GitHub用户名和邮箱12$ git config --global user.name XXXX// 你的github用户名，非昵称$ git config --global user.email \"xxx@qq.com\"// 填写你的github注册邮箱 2. 关联Github2.1 新建XXX.github.io 的项目 在 Github 上创建名字为 XXX.github.io 的项目，XXX为必须和自己的 github 用户名一模一样 2.2 修改_config.yml文件配置 打开本地的 MyBlog 文件夹项目内的_config.yml 配置文件 将其中的 type 设置为git，repository 是你 github.io 仓库的 git 地址, 如下所示 此处切记, 每一个毛好的后面都要加一个空格, 垂直方向一定要对齐, 否则可能会报错 1234deploy: type: git repository: https://github.com/CoderTitan/CoderTitan.github.io.git branch: master 2.3 将配置文件上传GitHub 打开终端, cd到MyBlog文件夹下, 以下命令均在MyBlog文件夹下执行 在blog文件夹目录下执行生成静态页面命令： 1hexo generate 或者：hexo g 此时若出现如下报错： 12ERROR Local hexo not found in ~/blogERROR Try runing: 'npm install hexo --save' 则执行命令： 1npm install hexo --save 再执行配置命令： 1hexo deploy 或者：hexo d 报错一: 若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git： 1npm install hexo-deployer-git --save 报错二: 若执行命令hexo d报以下错误: 123ERROR Plugin load failed: hexo-server//或者类似的错误ERROR Plugin load failed: hexo-renderer-sass 则执行响应的命令: 123sudo npm install hexo-server//或者sudo npm install hexo-renderer-sass 解决玩错误之后, 最后在执行1hexo d 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； hexo d命令执行成功后，浏览器中打开网址http://XXX.github.io（将XXX换成你的用户名）能看到和打开http://localhost:4000时一样的页面 六. 安装theme主题 搭建好的默认的主题真的是很丑, 所以这里我们先替换一个好看的主题, 大家更可以到官方主题去选择自己喜欢的主题样式 示例主题: Random 终端cd到 MyBlog 目录下执行如下命令： 1git clone https://github.com/stiekel/hexo-theme-random.git themes/random 修改_config.yml中的theme: landscape改为theme: random，然后重新执行hexo g来重新生成 终端cd到MyBlog目录下执行如下命令(每次部署文章的步骤)： 12345hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g //生成缓存和静态文件 hexo d //重新部署到服务器 七. 域名绑定 现在使用的域名是Github提供的二级域名XXX.github.io，也可以绑定为自己的个性域名。 购买域名，可以到GoDaddy官网，现在 GoDaddy已经有中文版了，虽然国家显示是新加坡，但不影响使用, 还可使用支付宝支付 也可以到阿里万网购买, 我是在万网买的，可直接在其网站做域名解析 1. 域名解析如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析, 如下图 进入解析页面后点击添加解析, 向你的 DNS 配置中添加 3 条记录, 如下图注意CNAME记录添加的是username.github.io.(不要忘记后面的.), 可能最后一个点不显示(我的就不显示) 2. 设置GitHub配置信息 打开你的XXX.github.io项目地址, 找到设置页面 滚动到下方找到GitHub Pages模块, 在Custom domain, 输入你购买的域名, 点击Save保存 3. 创建CNAME文件 在/MyBlog/themes/landscape/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名写入 CNAME一定要大写 12//在终端cd到该目录下, 然后输入命令, 即可创建该文件touch CNAME 完成上述步骤后, 终端cd到MyBlog目录下执行如下命令重新部署： 最后, 等十分钟左右，刷新浏览器，用你自己域名访问下试试 12345$ hexo clean$ hexo g$ hexo d 至此也算终于大功告成了, 感受一下: https://www.titanjun.top","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://titanjun.top/categories/Hexo博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://titanjun.top/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://titanjun.top/tags/Github/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://titanjun.top/tags/HTTPS/"}]},{"title":"SwiftLint代码规范属性说明(一)","slug":"SwiftLint代码规范属性说明(一)","date":"2018-03-03T12:53:54.000Z","updated":"2018-04-10T08:58:41.918Z","comments":true,"path":"2018/03/03/SwiftLint代码规范属性说明(一)/","link":"","permalink":"https://titanjun.top/2018/03/03/SwiftLint代码规范属性说明(一)/","excerpt":"下面来具体介绍一下SwiftLint的具体的代码规则的相关说明 Github 公布的 Swift 代码规范–原文 Github 公布的 Swift 代码规范–中文 官方的SwiftLint规则说明","text":"下面来具体介绍一下SwiftLint的具体的代码规则的相关说明 Github 公布的 Swift 代码规范–原文 Github 公布的 Swift 代码规范–中文 官方的SwiftLint规则说明 以下个属性均按照字母顺序排列规则1: closing_brace在使用Swift 3.2或更高版本时，首选系统的KVO 的API和keypath 识别码 默认是否启用 是否支持自动更正 类型 block_based_kvo 启用 no idiomatic 官方示例: 1234567891011//编译通过let observer = foo.observe(\\.value, options: [.new]) &#123; (foo, change) in print(change.newValue)&#125;//会触发警告class Foo: NSObject &#123; override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123;&#125;&#125; 规则2: class_delegate_protocol委托协议应该只是class类，可以被弱引用(官方解释,先放出官方示例吧) 识别码 默认是否启用 是否支持自动更正 类型 class_delegate_protocol 启用 no lint 示例: 123456789101112131415//不会触发warningprotocol FooDelegate: class &#123;&#125;protocol FooDelegate: class, BarDelegate &#123;&#125;protocol Foo &#123;&#125;class FooDelegate &#123;&#125;@objc protocol FooDelegate &#123;&#125;@objc(MyFooDelegate)protocol FooDelegate &#123;&#125;protocol FooDelegate: BarDelegate &#123;&#125;protocol FooDelegate: AnyObject &#123;&#125;protocol FooDelegate: NSObjectProtocol &#123;&#125;//会触发warningprotocol FooDelegate &#123;&#125;protocol FooDelegate: Bar &#123;&#125; 规则3: closing_brace类似小括号包含大括号的不能用空格 识别码 默认是否启用 是否支持自动更正 类型 closing_brace 启用 yes style 具体示例: 1234567891011//不会触发warning[1, 2].map(&#123; $0 &#125;)[1, 2].map( &#123; $0 &#125;)//会触发warning[1, 2].map(&#123; $0 &#125; )[1, 2].map(&#123; $0 &#125; )[1, 2].map( &#123; $0 &#125;) 规则4: closure_end_indentation闭包的封闭端和开始端有相同的缩进, 意思就是 大括号（一般是方法）上下对齐的问题，这样使code看起来更加整洁 识别码 默认是否启用 是否支持自动更正 类型 closure_end_indentation 未启用 no style 具体示例: 123456789101112131415161718192021//不会触发closure_end_indentation[1, 2].map &#123; $0 + 1 &#125;//不会触发closure_end_indentationSignalProducer(values: [1, 2, 3]) .startWithNext &#123; number in print(number) &#125;//不会触发closure_end_indentationfunction &#123; ..........&#125;//会触发closure_end_indentationSignalProducer(values: [1, 2, 3]) .startWithNext &#123; number in print(number)&#125;//不会触发closure_end_indentationfunction &#123; .......... &#125; 规则5: closure_parameter_position闭包参数位置， 闭包参数应该和大括号左边在同一行, 推荐使用 识别码 默认是否启用 是否支持自动更正 类型 closure_parameter_position 启用 no style 具体示例: 12345678910111213141516171819202122232425/// number 和 &#123; 在同一行, 不会触发warninglet names = [1, 2, 3]names.forEach &#123; (number) in print(number)&#125;let names = [1, 2, 3]names.map &#123; number in number + 1&#125;/// 这样不行，违背 closure_parameter_position规则, 触发warninglet names = [1, 2, 3]names.forEach &#123; (number) in print(number)&#125; let names = [1, 2, 3] names.map &#123; number in number + 1 &#125; 规则6: closure_spacing在闭包的{}中间要有一个空格,如map({ $0 }) 识别码 默认是否启用 是否支持自动更正 类型 closure_spacing 未启用 yes style 以下示例: 123456789不会触发警告map(&#123; $0 &#125;)[].map (&#123; $0.description &#125;)//会触发警告map(&#123;$0 &#125;)map(&#123; $0&#125;)map(&#123;$0&#125;)[].map (&#123;$0.description &#125;) 规则7: colon冒号的使用， swiftlint的这个colon属性规则很简单，要求“ ：”紧靠所定义的常量或变量等，必须没有空格，与所指定的类型之间必须只有一个空格，多一个或少一个都不行，如果是用在Dictionary中，则要求紧靠Key，与Value之间必须有且仅有一个空格。这个规则我觉得应该强制推荐使用 识别码 默认是否启用 是否支持自动更正 类型 colon 启用 yes style 具体示例: 12345678910//不会触发警告let abc: String = \"jun\"let abc = [1: [3: 2], 3: 4]let abc = [1: [3: 2], 3: 4]//会触发警告let jun:Voidlet jun : Voidlet jun :Voidlet jun: Void 规则8: comma逗号使用只要遵循“前不离身后退一步”就行了，这个也强制推荐使用 识别码 默认是否启用 是否支持自动更正 类型 comma 启用 yes style 具体示例: 12345//不触发警告[a, b, c, d]//触发警告[a ,b] 规则9: compiler_protocol_init编译器协议初始化, 不建议.init等初始化方式, 建议使用简单的初始化形式 识别码 默认是否启用 是否支持自动更正 类型 compiler_protocol_init 启用 no lint 官方示例: 123456789101112131415public static let description = RuleDescription( identifier: \"compiler_protocol_init\", name: \"Compiler Protocol Init\", description: \"The initializers declared in compiler protocols such as `ExpressibleByArrayLiteral` \" + \"shouldn't be called directly.\", kind: .lint, nonTriggeringExamples: [ \"let set: Set&lt;Int&gt; = [1, 2]\\n\", \"let set = Set(array)\\n\" ], triggeringExamples: [ \"let set = ↓Set(arrayLiteral: 1, 2)\\n\", \"let set = ↓Set.init(arrayLiteral: 1, 2)\\n\" ]) 规则10: conditional_returns_on_newline条件语句不能写在同一行, 条件返回语句应该在新的一行。 当有条件返回的时候应该换行返回，而不是在同一行 识别码 默认是否启用 是否支持自动更正 类型 conditional_returns_on_newline 未启用 no style 具体示例: 123456789101112/// swiftlint 不推荐的写法, 否则会触发warningif true &#123; return &#125;guard true else &#123; return &#125;/// swiftlint 推荐的写法if true &#123; return&#125;guard true else &#123; return &#125; 规则11: contains_over_first_not_nil类似first函数不能判断是否为nil 识别码 默认是否启用 是否支持自动更正 类型 contains_over_first_not_nil 未启用 no performance 具体示例: 1234567//推荐写法let first = myList.first(where: &#123; $0 % 2 == 0 &#125;)let first = myList.first &#123; $0 % 2 == 0 &#125;//不推荐写法myList.first &#123; $0 % 2 == 0 &#125; != nilmyList.first(where: &#123; $0 % 2 == 0 &#125;) != nil 规则12: control_statement控制语句, for，while，do，catch语句中的条件不能包含在()中 识别码 默认是否启用 是否支持自动更正 类型 control_statement 启用 no style 具体示例: 12345678//建议写法if condition &#123;if (a, b) == (0, 1) &#123;//不建议写法if (condition) &#123;if(condition) &#123;if ((a || b) &amp;&amp; (c || d)) &#123; 规则13: custom_rules自定义规则。 这个属性可以通过提供正则表达式来创建自定义规则， 可选指定语法类型搭配， 安全、级别和要陈列的什么信息。 这个属性只要熟悉使用正则表达式的人使用，目前可以不适用 识别码 默认是否启用 是否支持自动更正 类型 custom_rules 启用 no style 规则14: cyclomatic_complexity循环复杂度。函数体的复杂度应该要限制，这个属性主要约束条件句、循环句中的循环嵌套问题， 当嵌套太多的循环时，则会触发swiftlint中的warning和error，当达到10个循环嵌套时就会报warning，达到20个循环嵌套时就会报error 识别码 默认是否启用 是否支持自动更正 类型 cyclomatic_complexity 启用 no metrics 规则15: discarded_notification_center_observer当使用注册的通知时, 应该存储返回的观察者, 便于用完之后移除通知 识别码 默认是否启用 是否支持自动更正 类型 discarded_notification_center_observer 启用 no lint 代码示例: 123456789101112131415161718//推荐写法let foo = nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil) &#123; &#125;let foo = nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: &#123; &#125;)func foo() -&gt; Any &#123; return nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: &#123; &#125;)&#125;//不推荐写法nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil) &#123; &#125;nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: &#123; &#125;)@discardableResult func foo() -&gt; Any &#123; return nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: &#123; &#125;)&#125; 规则16: discouraged_direct_init阻止直接初始化导致的错误类型, 有类方法的,用类方法初始化(不建议直接init初始化) 识别码 默认是否启用 是否支持自动更正 类型 discouraged_direct_init 启用 no lint 代码示例: 12345678910//建议写法let foo = UIDevice.currentlet foo = Bundle.mainlet foo = Bundle(path: \"bar\")let foo = Bundle(identifier: \"bar\")//不建议写法let foo = UIDevice()let foo = Bundle()let foo = bar(bundle: Bundle(), device: UIDevice()) 规则17: discouraged_optional_boolean不建议使用可选布尔值 识别码 默认是否启用 是否支持自动更正 类型 discouraged_optional_boolean 未启用 no idiomatic 代码示例: 1234567891011//建议写法var foo: Boolvar foo: [String: Bool]var foo: [Bool]let foo: Bool = true//不建议写法var foo: Bool?var foo: [String: Bool?]var foo: [Bool?]let foo: Bool? = nil 规则18: discouraged_object_literal优先使用对象初始化方法, 不建议使用代码块初始化 识别码 默认是否启用 是否支持自动更正 类型 discouraged_object_literal 未启用 no idiomatic 代码示例: 123//不建议写法let white = #colorLiteral(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)let image = ↓#imageLiteral(resourceName: \"image.jpg\") 规则19: dynamic_inline避免一起使用 dynamic 和 @inline(_ _always)， 否则报 error 识别码 默认是否启用 是否支持自动更正 类型 dynamic_inline 启用 no lint 代码示例: 12345678910111213141516171819202122232425/// 正确的做法class LangKe &#123; dynamic func myFunction() &#123; &#125;&#125;class LangKe &#123; @inline(__always) func myFunction() &#123; &#125;&#125;class LangKe &#123; @inline(never) dynamic func myFunction() &#123; &#125;&#125;/// 只要同时使用 dynamic 和 @inline(_ _always)都报错 error！！！class LangKe &#123; @inline(__always) public dynamic func myFunction() &#123; &#125;&#125; 规则20: array_init序列转化成数组时, 优先使用数组转化, 而不是seq.map {$ 0}将序列转换为数组 识别码 默认是否启用 是否支持自动更正 类型 array_init 未启用 no lint 官方示例: 1234567891011121314151617181920212223242526272829303132333435363738public static let description = RuleDescription( identifier: \"array_init\", name: \"Array Init\", description: \"Prefer using Array(seq) than seq.map &#123; $0 &#125; to convert a sequence into an Array.\", kind: .lint, //以下示例不会触发警告 nonTriggeringExamples: [ \"Array(foo)\\n\", \"foo.map &#123; $0.0 &#125;\\n\", \"foo.map &#123; $1 &#125;\\n\", \"foo.map &#123; $0() &#125;\\n\", \"foo.map &#123; ((), $0) &#125;\\n\", \"foo.map &#123; $0! &#125;\\n\", \"foo.map &#123; $0! /* force unwrap */ &#125;\\n\", \"foo.something &#123; RouteMapper.map($0) &#125;\\n\" ], //以下示例会触发警告 triggeringExamples: [ \"↓foo.map(&#123; $0 &#125;)\\n\", \"↓foo.map &#123; $0 &#125;\\n\", \"↓foo.map &#123; return $0 &#125;\\n\", \"↓foo.map &#123; elem in\\n\" + \" elem\\n\" + \"&#125;\\n\", \"↓foo.map &#123; elem in\\n\" + \" return elem\\n\" + \"&#125;\\n\", \"↓foo.map &#123; (elem: String) in\\n\" + \" elem\\n\" + \"&#125;\\n\", \"↓foo.map &#123; elem -&gt; String in\\n\" + \" elem\\n\" + \"&#125;\\n\", \"↓foo.map &#123; $0 /* a comment */ &#125;\\n\" ]) 规则21: empty_count建议使用isEmpty判断,而不是使用count==0判断 识别码 默认是否启用 是否支持自动更正 类型 empty_count 未启用 no performance 代码示例: 1234567891011121314/// swiftlint不建议这样使用let number = \"long\"if number.characters.count == 0 &#123; print(\"为空\")&#125; else &#123; print(\"不为空\")&#125;/// swiftlint建议这种正式风格if number.isEmpty &#123; print(\"为空\")&#125; else &#123; print(\"不为空\")&#125; 规则22: empty_enum_arguments当枚举与关联类型匹配时，如果不使用它们，参数可以省略 识别码 默认是否启用 是否支持自动更正 类型 empty_enum_arguments 启用 yes style 代码示例: 123456789101112131415161718192021222324252627//SwiftLint建议写法switch foo &#123; case .bar: break&#125;switch foo &#123; case .bar(let x): break&#125;switch foo &#123; case let .bar(x): break&#125;switch (foo, bar) &#123; case (_, _): break&#125;switch foo &#123; case \"bar\".uppercased(): break&#125;//SwiftLint不建议写法switch foo &#123; case .bar(_): break&#125;switch foo &#123; case .bar(): break&#125;switch foo &#123; case .bar(_), .bar2(_): break&#125; 规则23: empty_parameters闭包参数为空时,建议使用() -&gt;Void, 而不是Void -&gt;Void 识别码 默认是否启用 是否支持自动更正 类型 empty_parameters 启用 yes style 代码示例: 12345678910111213/// 01 不会触发warninglet abc: () -&gt; Voidfunc foo(completion: () -&gt; Void) &#123;&#125;/// 02 直接报错let bcd: Void -&gt; Voidfunc foo(completion: Void -&gt; Void) &#123;&#125; 规则24: empty_parentheses_with_trailing_closure在使用尾随闭包的时候， 应该尽量避免使用空的圆括号 识别码 默认是否启用 是否支持自动更正 类型 empty_parentheses_with_trailing_closure 启用 yes style 1234567891011121314151617//不会触发warning[1, 2].map &#123; $0 + 1 &#125;[1, 2].map(&#123; $0 + 1 &#125;)[1, 2].reduce(0) &#123; $0 + $1 &#125;[1, 2].map &#123; number in number + 1 &#125;//会触发warning[1, 2].map() &#123; $0 + 1 &#125;[1, 2].map( ) &#123; $0 + 1 &#125;[1, 2].map() &#123; number in number + 1 &#125;[1, 2].map( ) &#123; number in number + 1 &#125; 规则26: explicit_acl…所有属性和方法的声明, 都应该明确指定修饰关键字 识别码 默认是否启用 是否支持自动更正 类型 explicit_acl 未启用 no idiomatic 官方代码示例: 123456789101112131415161718192021//非触发示例internal enum A &#123;&#125;public final class B &#123;&#125;private struct C &#123;&#125;internal func a() &#123; let a = &#125;private struct C &#123; let d = 5 &#125;internal class A &#123; deinit &#123;&#125; &#125;internal protocol A &#123; func b() var c: Int&#125;//触发示例enum A &#123;&#125;final class B &#123;&#125;internal struct C &#123; let d = 5 &#125;public struct C &#123; let d = 5 &#125;func a() &#123;&#125;internal let a = 0func b() &#123;&#125; 规则27: explicit_type_interface声明的属性应该明确其类型, 如: var myVar: Int = 0 识别码 默认是否启用 是否支持自动更正 类型 explicit_type_interface 未启用 no idomatic 代码示例: 1234567891011//推荐写法class Foo &#123; var myVar: Int? = 0 let myLet: Int? = 0&#125;//不建议写法class Foo &#123; var myVar = 0 let myLet = 0&#125; 规则28: extension_access_modifier在自定义类中,推荐使用extension扩展 识别码 默认是否启用 是否支持自动更正 类型 extension_access_modifier 未启用 no idiomatic 规则29: no_extension_access_modifier在extension扩展前面,不建议使用(fileprivate, public)等修饰符 识别码 默认是否启用 是否支持自动更正 类型 no_extension_access_modifier 未启用 no idiomatic 代码示例: 123456//不建议以下写法private extension String &#123;&#125;public extension String &#123;&#125;open extension String &#123;&#125;internal extension String &#123;&#125;fileprivate extension String &#123;&#125; 规则30: fallthroughswitch语句中不建议使用fallthrough 识别码 默认是否启用 是否支持自动更正 类型 fallthrough 启用 no idiomatic 代码示例: 12345678910111213//推荐写法switch foo &#123;case .bar, .bar2, .bar3: something()&#125;//不建议写法switch foo &#123;case .bar: fallthroughcase .bar2: something()&#125; 规则31: fatal_error_message执行fatalError错误时,建议有一个提示信息; 如:fatalError(“Foo”) 识别码 默认是否启用 是否支持自动更正 类型 fatal_error_message 未启用 no idiomatic 代码示例: 123456789//推荐写法required init?(coder aDecoder: NSCoder) &#123; fatalError(\"init(coder:) has not been implemented\")&#125;//不建议required init?(coder aDecoder: NSCoder) &#123; fatalError(\"\")&#125; 规则32: file_header文件头。新建的文件开始的注释应该一样 识别码 默认是否启用 是否支持自动更正 类型 aaa 未启用 no style 代码示例: 123456789101112131415161718/// 不会触发warning/// 如果我新建一个工程，在ViewController.swift文件中， 开始的注释应该是：// ViewController.swift// SwiftLint//// Created by langke on 17/1/17.// Copyright © 2017年 langke. All rights reserved.//改变一下变为：//// MyViewController.swift...................由于这里和外面的文件名不一样，所以触发warning（实际上在swift 3.0上测试这个属性暂时没有任何作用！！）// SwiftLint//// Created by langke on 17/1/17.// Copyright © 2017年 langke. All rights reserved................官方terminal表示，Copyright和Created没有对齐，也会触发warning！！！// 规则33: file_length文件内容行数, 超过400行warning, 超过1000行给error 识别码 默认是否启用 是否支持自动更正 类型 file_length 启用 no metrics 规则34: first_where不建议在使用filter和map函数后直接使用.first 识别码 默认是否启用 是否支持自动更正 类型 first_where 未启用 no performance 官方代码示例: 123456789101112131415161718192021222324public static let description = RuleDescription( identifier: \"first_where\", name: \"First Where\", description: \"Prefer using `.first(where:)` over `.filter &#123; &#125;.first` in collections.\", kind: .performance, //不会触发警告 nonTriggeringExamples: [ \"kinds.filter(excludingKinds.contains).isEmpty &amp;&amp; kinds.first == .identifier\\n\", \"myList.first(where: &#123; $0 % 2 == 0 &#125;)\\n\", \"match(pattern: pattern).filter &#123; $0.first == .identifier &#125;\\n\", \"(myList.filter &#123; $0 == 1 &#125;.suffix(2)).first\\n\" ], //以下写法会触发警告 triggeringExamples: [ \"↓myList.filter &#123; $0 % 2 == 0 &#125;.first\\n\", \"↓myList.filter(&#123; $0 % 2 == 0 &#125;).first\\n\", \"↓myList.map &#123; $0 + 1 &#125;.filter(&#123; $0 % 2 == 0 &#125;).first\\n\", \"↓myList.map &#123; $0 + 1 &#125;.filter(&#123; $0 % 2 == 0 &#125;).first?.something()\\n\", \"↓myList.filter(someFunction).first\\n\", \"↓myList.filter(&#123; $0 % 2 == 0 &#125;)\\n.first\\n\", \"(↓myList.filter &#123; $0 == 1 &#125;).first\\n\" ]) 规则35: for_where在for循环中,不建议使用单个if语句或者只使用一次循环变量,可使用where或者if{}else{}语句 识别码 默认是否启用 是否支持自动更正 类型 for_where 启用 no idiomatic 代码示例: 123456789101112131415161718192021222324252627//推荐写法for user in users where user.id == 1 &#123; &#125;for user in users &#123; if let id = user.id &#123; &#125;&#125;for user in users &#123; if var id = user.id &#123; &#125;&#125;for user in users &#123; if user.id == 1 &#123; &#125; else &#123; &#125;&#125;for user in users &#123; if user.id == 1 &#123; &#125; print(user)&#125;for user in users &#123; let id = user.id if id == 1 &#123; &#125;&#125;for user in users &#123; if user.id == 1 &amp;&amp; user.age &gt; 18 &#123; &#125;&#125;//不建议写法for user in users &#123; if user.id == 1 &#123; return true &#125;&#125; 规则36: force_cast不建议直接强解类型 识别码 默认是否启用 是否支持自动更正 类型 force_cast 启用 no idiomatic 代码示例: 12345//建议写法NSNumber() as? Int//不推荐NSNumber() ↓as! Int 规则37: force_try对会抛出异常(throws)的方法,不建议try!强解 识别码 默认是否启用 是否支持自动更正 类型 force_try 启用 no idiomatic 代码示例: 1234567891011func myFunction() throws &#123; &#125;/// 这样写是可以的，不会触发 errordo &#123; try myFunction()&#125; catch &#123;&#125;/// 这样直接触发 errortry! myFunction() 规则38: force_unwrapping强制解包/拆包。我们知道，当一个类型是可选类型的时候，当我们获取值时，需要强制解包（也叫隐式解包）, 通常我们是在一个变量或者所需要的常量、类型等后面加一个“ ！”， 然而，swiftlint建议强制解包应该要避免， 否则将给予warning 识别码 默认是否启用 是否支持自动更正 类型 force_unwrapping 未启用 no idiomatic 代码示例: 12345678910/// 将触发warningnavigationController!.pushViewController(myViewController, animated: true)let url = NSURL(string: \"http://www.baidu.com\")!print(url)return cell!/// 不会触发warningnavigationController?.pushViewController(myViewController, animated: true) 规则39: function_body_length函数体长度， 函数体不应该跨越太多行， 超过40行给warning， 超过100行直接报错 识别码 默认是否启用 是否支持自动更正 类型 function_body_length 启用 no metrics 规则40: function_parameter_count 函数参数个数， 函数参数数量(init方法除外)应该少点， 不要太多，swiftlint规定函数参数数量超过5个给warning， 超过8个直接报error 注：function_parameter_count: error 这样并不能改变它的警告或错误，该属性不允许修改，但是可以禁用 识别码 默认是否启用 是否支持自动更正 类型 function_parameter_count 启用 no metrics 规则41: generic_type_name泛型类型名称只能包含字母数字字符，以大写字母开头，长度介于1到20个字符之间 识别码 默认是否启用 是否支持自动更正 类型 generic_type_name 未启用 no idiomatic 代码示例: 1234567891011//推荐写法func foo&lt;T&gt;() &#123;&#125;func foo&lt;T&gt;() -&gt; T &#123;&#125;func foo&lt;T, U&gt;(param: U) -&gt; T &#123;&#125;func foo&lt;T: Hashable, U: Rule&gt;(param: U) -&gt; T &#123;&#125;//不推荐写法func foo&lt;T_Foo&gt;() &#123;&#125;func foo&lt;T, U_Foo&gt;(param: U_Foo) -&gt; T &#123;&#125;func foo&lt;TTTTTTTTTTTTTTTTTTTTT&gt;() &#123;&#125;func foo&lt;type&gt;() &#123;&#125; 规则42: identifier_name变量标识符名称应该只包含字母数字字符，并以小写字母开头或只应包含大写字母。在上述例外情况下，当变量名称被声明为静态且不可变时，变量名称可能以大写字母开头。变量名称不应该太长或太短 识别码 默认是否启用 是否支持自动更正 类型 identifier_name 启用 no style 官方给出的示例: 1234567891011121314151617181920212223242526272829303132internal struct IdentifierNameRuleExamples &#123; //不会触发error static let nonTriggeringExamples = [ \"let myLet = 0\", \"var myVar = 0\", \"private let _myLet = 0\", \"class Abc &#123; static let MyLet = 0 &#125;\", \"let URL: NSURL? = nil\", \"let XMLString: String? = nil\", \"override var i = 0\", \"enum Foo &#123; case myEnum &#125;\", \"func isOperator(name: String) -&gt; Bool\", \"func typeForKind(_ kind: SwiftDeclarationKind) -&gt; String\", \"func == (lhs: SyntaxToken, rhs: SyntaxToken) -&gt; Bool\", \"override func IsOperator(name: String) -&gt; Bool\" ] //会触发error static let triggeringExamples = [ \"↓let MyLet = 0\", \"↓let _myLet = 0\", \"private ↓let myLet_ = 0\", \"↓let myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0\", \"↓var myExtremelyVeryVeryVeryVeryVeryVeryLongVar = 0\", \"private ↓let _myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0\", \"↓let i = 0\", \"↓var id = 0\", \"private ↓let _i = 0\", \"↓func IsOperator(name: String) -&gt; Bool\", \"enum Foo &#123; case ↓MyEnum &#125;\" ]&#125; 规则44: implicit_getter对于只有只读属性不建议重写get方法 识别码 默认是否启用 是否支持自动更正 类型 implicit_getter 启用 no style 代码示例: 123456789101112131415161718192021222324252627282930313233343536373839404142//不会触发error//重写get和set方法class Foo &#123; var foo: Int &#123; get &#123; return 3 &#125; set &#123; _abc = newValue &#125; &#125;&#125;//只读class Foo &#123; var foo: Int &#123; return 20 &#125; &#125;class Foo &#123; static var foo: Int &#123; return 20 &#125; &#125;//会触发errorclass Foo &#123; var foo: Int &#123; get &#123; return 20 &#125; &#125; &#125;class Foo &#123; var foo: Int &#123; get&#123; return 20 &#125; &#125; &#125; 规则45: implicit_return 建议使用隐式返回闭包; 如: foo.map({ $0 + 1 }) 识别码 默认是否启用 是否支持自动更正 类型 implicit_return 未启用 no style 代码示例: 123456789101112//推荐写法foo.map &#123; $0 + 1 &#125;foo.map(&#123; $0 + 1 &#125;)foo.map &#123; value in value + 1 &#125;//不建议写法foo.map &#123; value in return value + 1&#125;foo.map &#123; return $0 + 1&#125; 规则46: implicitly_unwrapped_optional尽量避免隐式解析可选类型的使用 识别码 默认是否启用 是否支持自动更正 类型 implicitly_unwrapped_optional 未启用 no idiomatic 下面吗给出官方示例: 12345678910111213141516171819202122232425262728293031public static let description = RuleDescription( identifier: \"implicitly_unwrapped_optional\", name: \"Implicitly Unwrapped Optional\", description: \"Implicitly unwrapped optionals should be avoided when possible.\", kind: .idiomatic, //不会触发warning nonTriggeringExamples: [ \"@IBOutlet private var label: UILabel!\", \"@IBOutlet var label: UILabel!\", \"@IBOutlet var label: [UILabel!]\", \"if !boolean &#123;&#125;\", \"let int: Int? = 42\", \"let int: Int? = nil\" ], //会触发warning triggeringExamples: [ \"let label: UILabel!\", \"let IBOutlet: UILabel!\", \"let labels: [UILabel!]\", \"var ints: [Int!] = [42, nil, 42]\", \"let label: IBOutlet!\", \"let int: Int! = 42\", \"let int: Int! = nil\", \"var int: Int! = 42\", \"let int: ImplicitlyUnwrappedOptional&lt;Int&gt;\", \"let collection: AnyCollection&lt;Int!&gt;\", \"func foo(int: Int!) &#123;&#125;\" ]) 规则47: is_disjoint初始化集合Set时,推荐使用Set.isDisjoint(), 不建议:Set.intersection 识别码 默认是否启用 是否支持自动更正 类型 is_disjoint 启用 no idiomatic 代码示例: 123//推荐写法_ = Set(syntaxKinds).isDisjoint(with: commentAndStringKindsSet)let isObjc = !objcAttributes.isDisjoint(with: dictionary.enclosedSwiftAttributes) 规则48: joined_default_parameterjoined方法使用默认分隔符时, 建议使用joined()方法, 而不是joined(separator: “”)方法 识别码 默认是否启用 是否支持自动更正 类型 joined_default_parameter 未启用 yes idiomatic 代码示例: 12345678//建议写法let foo = bar.joined()let foo = bar.joined(separator: \",\")let foo = bar.joined(separator: toto)//不建议写法let foo = bar.joined(separator: \"\")let foo = bar.filter(toto).joined(separator: \"\") 规则49: large_tuple定义的元组成员个数,超过两个warning 识别码 默认是否启用 是否支持自动更正 类型 large_tuple 启用 no metrics 代码示例: 123456789//不会触发warninglet foo: (Int, Int)let foo: (start: Int, end: Int)let foo: (Int, (Int, String))//会触发warninglet foo: (Int, Int, Int)let foo: (start: Int, end: Int, value: String)let foo: (Int, (Int, Int, Int)) 规则50: leading_whitespace文件开始不应该有空格或者换行, 否则就会触发warning 识别码 默认是否启用 是否支持自动更正 类型 leading_whitespace 启用 yes style 代码示例: 123456789101112131415161718192021222324252627/// 不会触发warning//// ViewController.swift// SwiftLint//// Created by langke on 17/1/12.// Copyright © 2017年 langke. All rights reserved.///// 会触发warning //..................................这里有一个空格// ViewController.swift// SwiftLint//// Created by langke on 17/1/12.// Copyright © 2017年 langke. All rights reserved.///// 会触发warning......................................这里是一个空行//// ViewController.swift// SwiftLint//// Created by langke on 17/1/12.// Copyright © 2017年 langke. All rights reserved.// 参考文档SwiftLint规则官方文档SwiftLint个规则详细介绍 有些地方的解释和示例可能不是很完善, 希望各位大神多多指导,后续会持续更新中…….","categories":[{"name":"SwiftLint","slug":"SwiftLint","permalink":"https://titanjun.top/categories/SwiftLint/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"SwiftLint","slug":"SwiftLint","permalink":"https://titanjun.top/tags/SwiftLint/"},{"name":"规则","slug":"规则","permalink":"https://titanjun.top/tags/规则/"}]},{"title":"Xcode代码规范之SwiftLint配置","slug":"Xcode代码规范之SwiftLint配置","date":"2018-02-07T07:34:34.000Z","updated":"2018-04-10T08:57:32.869Z","comments":true,"path":"2018/02/07/Xcode代码规范之SwiftLint配置/","link":"","permalink":"https://titanjun.top/2018/02/07/Xcode代码规范之SwiftLint配置/","excerpt":"前言 最近公司大佬考虑将项目代码规范化, 然而自Xcode9之后,Xcode的插件基本处于废弃的状态大部分插件都是在一年前就停止更新了; 于是在谷歌找到了一款强大的代码规范工具SwiftLint SwiftLint是 Realm 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 Github 公布的 Swift 代码规范进行代码检查，并且能够很好的和 Xcode 整合 Github 公布的 Swift 代码规范–原文 Github 公布的 Swift 代码规范–中文 配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 红色错误 的形式指示出来 支持自定义规则,可禁用或者开启某一些规则","text":"前言 最近公司大佬考虑将项目代码规范化, 然而自Xcode9之后,Xcode的插件基本处于废弃的状态大部分插件都是在一年前就停止更新了; 于是在谷歌找到了一款强大的代码规范工具SwiftLint SwiftLint是 Realm 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 Github 公布的 Swift 代码规范进行代码检查，并且能够很好的和 Xcode 整合 Github 公布的 Swift 代码规范–原文 Github 公布的 Swift 代码规范–中文 配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 红色错误 的形式指示出来 支持自定义规则,可禁用或者开启某一些规则 一. 安装SwiftLint SwiftLint目前有三种安装方式可供选择,可以根据自己的项目需要自行选择 1. 安装全局配置(Homebrew 安装)Homebrew Homebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件, 输入以下代码安装: 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 译注：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复： 1sudo chown -R `whoami` /usr/local Homebrew 会自动安装最新版本 打开终端输入以下代码: 1brew install swiftlint 安装成功,如下图所示: 2. 使用 CocoaPods 安装 这种方式只能针对单个项目有效,如果你想要针对不同的项目使用不同的SwiftLint 版本，这是一种很好的解决方案 需要注意的是使用这种方案会将整个SwiftLint以及他的依赖包的完整资源文件都安装到 Pods/ 目录中去，所以在使用版本管理工具比如 git/svn 时要注意设置忽略相关目录 CocosPods安装和安装第三方框架一样 在根目录创建Podfile 1pod &apos;SwiftLint&apos; 3. 使用安装包SwiftLint 还支持使用 pkg 安装包进行安装，在官方的 Github 页面可以找到最新发布的安装包 二. 查看SwiftLint的全部命令 等待安装完成，在终端输入 swiftlint help 可以查看所有可用的命令： 各个命令注释1234567891011121314//查看所有命令swiftlint help//忽略空格导致的警告和错误swiftlint autocorrect//输出所有的警告和错误swiftlint lint//查看所有可获得的规则以及对应的 IDswiftlint rules//产看当前版本号swiftlint version 我们将目录切换到工程的根目录之下，然后敲击如下命令: 1swiftlint autocorrect 然后我们就会发现，所有的空格符Warning都消失了。这都得益于我们刚刚所进行的命令行操作，它会将已知的能够自动修复的Error和Warning都自动修复，大大的减轻了我们的工作量。 三. SwiftLint的使用 安装完成后,需要在Xcode中配置相关设置,才能使 SwiftLint 在 Xcode 中自动检测代码规范。配置也很简单，只需要在 Xcode 的 Build Phases 中新建一个 Run Script Phase 配置项，在里面添加相关代码后,编译即可! 配置代码添加步骤 需要将相关脚本添加到红色框内 1. 全局安装脚本添加方式12345if which swiftlint &gt;/dev/null; then swiftlintelse echo &quot;warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint&quot;fi 2. CocoaPods安装脚本添加1&quot;$&#123;PODS_ROOT&#125;/SwiftLint/swiftlint&quot; 这里其实是设置了一个自动编译脚本，每次运行编译都会自动执行这个脚本 如果正确安装了 SwiftLint，就会执行 SwiftLint 中的代码规范检查，如果没有安装，脚本会抛出一个没有安装 SwiftLint 并提示下载的警告，方便提醒团队团队中没有安装的成员。 当然，你也可以设置为强制要求安装，这时如果没有安装则无法通过编译。只需要在脚本中1echo &quot;warning: ...&quot; 之后添加一行代码：1exit 1 这样一来，如果没有安装 SwiftLint，编译时会直接抛出一个编译错误而非警告，提示需要安装 SwiftLint。 3. 配置完成后,command+B编译 如果你的是正在开发中的项目, 你可能会发现你的项目提示999+的黄色警告和999+的红色错误 甚至你会发现甚至一些空格和一些系统的方法和注释也会报错或者警告 SwiftLint默认方法名或者注释不得超过120个字符 Swift Lint 在完成上述操作之后，便已经生效。但是，如果觉得默认的风格过于严格，或者项目组有另外的要求，Swift Lint 也可以定制相应的风格，或者禁用某些规则。 SwiftLint 的全部规则可以在：Source/SwiftLintFramework/Rules 目录内找到 四. 自定义配置 当你编译过项目后,看到999+的警告和错误,是不是第一反应就是要放弃了,其实不然 仔细看一下具体的错误，会发现好多都是第三方库的代码规范问题，而且好多问题的级别被设置成为了 error 第三方库的代码规范问题,这个锅我们可不能背 这里我们可以做一些配置，让 SwiftLint 在做代码规范检查的时候自动忽略 CocoaPods、Carthage 等包管理器引入的第三方库（当然，手动导入的第三方库也能设置忽略） 1. 创建配置文件 首先需要在项目的根目录下新建一个名为 .swiftlint.yml 的配置文件 打开终端, cd 到项目根目录下 输入: touch .swiftlint.yml 执行完该命令后, 在文件夹中你可能找不到该yml格式文件,那是因为文件被隐藏了 关于隐藏/显示隐藏文件(命令一样): command + shift + . 下面我们来认识一下主要的几个配置选项 12345678910111213141516disabled_rules: # 禁用指定的规则 - colon - comma - control_statementopt_in_rules: # 启用指定的规则 - empty_count - missing_docs # 可以通过执行如下指令来查找所有可用的规则: # swiftlint rulesincluded: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。 - Sourceexcluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。 - Carthage - Pods - Source/ExcludedFolder - Source/ExcludedFile.swift 2. 在代码中关闭某个规则可以通过在一个源文件中定义一个如下格式的注释来关闭某个规则：1// swiftlint:disable &lt;rule&gt; 在该文件结束之前或者在定义如下格式的匹配注释之前，这条规则都会被禁用：1// swiftlint:enable &lt;rule&gt; 例如:12345678// swiftlint:disable opening_bracefunc initTakeScreenshot(launchOptions: [AnyHashable: Any]?)&#123; // swiftlint:enable opening_brace if let options = launchOptions &#123; let userInfo = options[UIApplicationLaunchOptionsKey.remoteNotification] NotificationCenter.default.post(name: Notification.Name.UIApplicationUserDidTakeScreenshot, object: userInfo) &#125;&#125; 规则关闭之前 规则关闭之后 也可以通过添加 :previous, :this 或者 :next 来使关闭或者打开某条规则的命令分别应用于前一行，当前或者后一行代码。 例如:123456// swiftlint:disable:next force_castlet noWarning = NSNumber() as! Intlet hasWarning = NSNumber() as! Intlet noWarning2 = NSNumber() as! Int // swiftlint:disable:this force_castlet noWarning3 = NSNumber() as! Int// swiftlint:disable:previous force_cast 3. 忽略引入的第三方库 1). 忽略CocoaPods导入的第三方库 12excluded: - Pods 2). excluded 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹 比如如果你的项目使用 Carthage 管理第三方库的话，可以将 Carthage 目录添加到忽略列表： 123excluded: - Pods - Carthage 3). 指定精确路径下的文件，通过 - xxxx 的形式列在下面就可以了 123excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。 - Source/ExcludedFolder - Source/ExcludedFile.swift 4. 嵌套配置SwiftLint 支持通过嵌套配置文件的方式来对代码分析过程进行更加细致的控制。 在你的根 .swiftlint.yml 文件里设置 use_nested_configs: true 值。 在目录结构必要的地方引入额外的 .swiftlint.yml 文件。 每个文件被检查时会使用在文件所在目录下的或者父目录的更深层目录下的配置文件。否则根配置文件将会生效。 excluded，included，和 use_nested_configs 在嵌套结构中会被忽略。 5. 自动更正 SwiftLint 可以自动修正某些错误，磁盘上的文件会被一个修正后的版本覆盖。 请确保在对文件执行 swiftlint autocorrect 之前有对它们做过备份，否则的话有可能导致重要数据的丢失。 因为在执行自动更正修改某个文件后很有可能导致之前生成的代码检查信息无效或者不正确，所以当在执行代码更正时标准的检查是无法使用的。 五. 最后贴上官方示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849disabled_rules: # 执行时排除掉的规则 - colon - comma - control_statementopt_in_rules: # 一些规则仅仅是可选的 - empty_count - missing_docs # 可以通过执行如下指令来查找所有可用的规则: # swiftlint rulesincluded: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。 - Sourceexcluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。 - Carthage - Pods - Source/ExcludedFolder - Source/ExcludedFile.swift# 可配置的规则可以通过这个配置文件来自定义# 二进制规则可以设置他们的严格程度force_cast: warning # 隐式force_try: severity: warning # 显式# 同时有警告和错误等级的规则，可以只设置它的警告等级# 隐式line_length: 110# 可以通过一个数组同时进行隐式设置type_body_length: - 300 # warning - 400 # error# 或者也可以同时进行显式设置file_length: warning: 500 error: 1200# 命名规则可以设置最小长度和最大程度的警告/错误# 此外它们也可以设置排除在外的名字type_name: min_length: 4 # 只是警告 max_length: # 警告和错误 warning: 40 error: 50 excluded: iPhone # 排除某个名字variable_name: min_length: # 只有最小长度 error: 4 # 只有错误 excluded: # 排除某些名字 - id - URL - GlobalAPIKeyreporter: &quot;xcode&quot; # 报告类型 (xcode, json, csv, checkstyle) 附录: 原文链接：https://github.com/realm/SwiftLint/blob/master/README.md译文链接：https://github.com/realm/SwiftLint/blob/master/README_CN.md","categories":[{"name":"SwiftLint","slug":"SwiftLint","permalink":"https://titanjun.top/categories/SwiftLint/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"SwiftLint","slug":"SwiftLint","permalink":"https://titanjun.top/tags/SwiftLint/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://titanjun.top/tags/Homebrew/"}]},{"title":"ReactNative之AsyncStorage本地存储","slug":"ReactNative之AsyncStorage本地存储","date":"2018-01-24T03:13:00.000Z","updated":"2018-03-08T05:47:37.000Z","comments":true,"path":"2018/01/24/ReactNative之AsyncStorage本地存储/","link":"","permalink":"https://titanjun.top/2018/01/24/ReactNative之AsyncStorage本地存储/","excerpt":"在RN开发中，持久化存储数据，可以使用AsyncStorage，对原生的API进行了一层封装 AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的","text":"在RN开发中，持久化存储数据，可以使用AsyncStorage，对原生的API进行了一层封装 AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的 AsyncStorage原理和使用 AsyncStorage存储数据，在iOS中，底层会把数据保存到沙盒中的Documents中,并生成manifest.json文件。保存的数据都在manifest.json中。 AsyncStorage删除数据，也仅仅是删除manifest.json文件中的数据，并不是删除manifest.json文件 唯有clear方法是将文件删除 一. 存储12static setItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; void) //将key字段的值设置成value，并在完成后调用callback函数。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象 注意：AsyncStorage只能存储字符串，需要把对象转换为字符串才行 具体使用 123456789101112131415161718//key值var key = 'per'var person = &#123; name:'jun', age:20&#125;//json转成字符串var jsonStr = JSON.stringify(person)//存储AsyncStorage.setItem('person', jsonStr, function (error) &#123; if (error) &#123; alert('存储失败') &#125;else &#123; alert('存储完成') &#125;&#125;) 二. 读取12static getItem(key: string, callback?: ?(error: ?Error, result: ?string) =&gt; void) //读取key字段并将结果作为第二个参数传递给callback。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。 使用方法 123456789101112//读取_readData()&#123; console.log('读取') AsyncStorage.getItem('per', function (error, result) &#123; if (error) &#123; alert('读取失败') &#125;else &#123; console.log(result) alert('读取完成') &#125; &#125;)&#125; 三. 删除12345static removeItem(key: string, callback?: ?(error: ?Error) =&gt; void) //删除一个字段。返回一个Promise对象。static clear(callback?: ?(error: ?Error) =&gt; void) //删除全部的AsyncStorage数据，即直接删除该缓存文件 函数用法 12345678910111213141516171819202122//删除_deleteData()&#123; console.log('删除') //删除一条数据 AsyncStorage.removeItem('per', function (error) &#123; if (error) &#123; alert('删除失败') &#125;else &#123; alert('删除完成') &#125; &#125;) //删除json文件 AsyncStorage.clear(function (error) &#123; if (error) &#123; alert('文件删除失败') &#125;else &#123; alert('文件删除完成') &#125; &#125;)&#125; 四. 其他用法12345678static mergeItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; void) //假设已有的值和新的值都是字符串化的JSON，则将两个值合并。返回一个Promise对象。还没有被所有原生实现都支持static getAllKeys(callback?: ?(error: ?Error, keys: ?Array&lt;string&gt;) =&gt; void) //获取所有本应用可以访问到的数据，不论来自什么库或调用者。返回一个Promise对象。static flushGetRequests() //清除所有进行中的查询操作。","categories":[{"name":"ReactNaive","slug":"ReactNaive","permalink":"https://titanjun.top/categories/ReactNaive/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://titanjun.top/tags/JavaScript/"},{"name":"AsyncStorage","slug":"AsyncStorage","permalink":"https://titanjun.top/tags/AsyncStorage/"}]},{"title":"Node.js搭建Web服务器","slug":"Node.js搭建Web服务器","date":"2018-01-20T03:13:00.000Z","updated":"2018-03-08T06:23:59.000Z","comments":true,"path":"2018/01/20/Node.js搭建Web服务器/","link":"","permalink":"https://titanjun.top/2018/01/20/Node.js搭建Web服务器/","excerpt":"服务器种类 Web服务器: 处理HTTP请求的服务器 Socket服务器(即时通讯): 通过socket传输 即时通讯(IM): 允许两人或多人使用网路即时的传递文字讯息、档案、语音与视频交流 流媒体服务器: 音视频处理程序, 接受流媒体格式文件,flv/ts等","text":"服务器种类 Web服务器: 处理HTTP请求的服务器 Socket服务器(即时通讯): 通过socket传输 即时通讯(IM): 允许两人或多人使用网路即时的传递文字讯息、档案、语音与视频交流 流媒体服务器: 音视频处理程序, 接受流媒体格式文件,flv/ts等 简单效果图 一. Node.js介绍 Node.js发布于2009年5月，由Ryan Dahl(瑞恩·达尔)在GitHub上发布了最初版本的部分Node.js包，随后几个月里，有人开始使用Node.js开发应用 Node.js是一个基于Chrome JavaScript运行时建立的平台， 是一个Javascript运行环境 Node 是一个服务器程序, 用Javascript这个语言开发服务器 Node.js的实质是对Chrome V8引擎进行了封装 V8 JavaScript 引擎是 Google 用于其 Chrome 浏览器的底层 JavaScript 引擎 传统意义上的 JavaScript 运行在浏览器上，这是因为浏览器内核实际上分为两个部分:渲染引擎和 JavaScript 引擎。前者负责渲染 HTML + CSS，后者则负责运行 JavaScript。Chrome 使用的 JavaScript 引擎是 V8，它的速度非常快 参考Node.js 究竟是什么？和Node.js的SDK文档 1. Node.js的优缺点 Node.js优点： 采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。 Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。 Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。 Node.js缺点： 可靠性低 单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。 一旦这个进程崩掉，那么整个web服务就崩掉了。 2. Node.js使用介绍 Node.js使用Module模块去划分不同的功能，以简化App开发，Module就是库，跟组件化差不多，一个功能一个库。 NodeJS内建了一个HTTP服务器，可以轻而易举的实现一个网站和服务器的组合，不像PHP那样，在使用PHP的时候，必须先搭建一个Apache之类的HTTP服务器，然后通过HTTP服务器的模块加载CGI调用，才能将PHP脚本的执行结果呈现给用户 require() 函数，用于在当前模块中加载和使用其他模块； 二. Express模块(框架) Express是Node.JS第三方库 Express可以处理各种HTTP请求 Express是目前最流行的基于Node.js的Web开发框架， Express框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器 1. 安装Node.js 打开终端，输入node -v，先查看是否已经安装 如果没有安装，就需要安装node软件 参考Node.js 安装配置 2. 安装npm npm是随同NodeJS一起安装的包管理工具，用于下载NodeJS第三方库。 类似iOS开发中cocoapods，用于安装第三方框架 新版的NodeJS已经集成了npm，所以只要安装好Node.JS就好3. 下载第三方模块Express 首先先创建项目 新建一个文件夹, 打开终端 cd到当前文件夹, 创建一个js文件, 如: touch app.js 安装package.json文件, 类似于CocoaPods中的Podfile - cd到当前文件夹 终端输入: npm init 最后安装express库 终端输入: npm install express --save 三. 搭建简单的Http服务器1. 开始搭建Http服务器 require加载模块 监听端口号和网址, 端口号不能使用已经占用的端口比如（80），每个服务器相当于一个app，都需要端口，才能找到入口 1234567891011121314151617181920//创建HTTP服务器//1. 加载http模块var http = require('http');//2. 创建http服务器// 参数: 请求的回调, 当有人访问服务器的时候,就会自动调用回调函数var server = http.createServer(function (request, response) &#123; console.log('有人访问了服务器') //回调数据 response.write('Hello, My Love') response.end()&#125;)//3. 绑定端口server.listen(3030, '192.168.2.11')//4. 执行console.log('执行了3030') 2. 开始运行服务器 那么还是要打开终端 输入: node app.js app.ja为文件名 四. express搭建服务器1. express框架的使用 引入express模块 创建express服务器 get, post请求中: 参数一: 请求根路径,若传&#39;/&#39;, 则url为: http://192.168.0.0:3030 若传&#39;/home&#39;, 则url为: http://192.168.0.0:3030/home 参数二: 请求数据的回调函数 监听端口: 默认url为当前电脑的IP地址 123456789101112131415161718192021222324/* express的服务器 *///1. 导入expressvar express = require('express')//2. 创建express服务器var server = express()//3. 访问服务器(get或者post)//参数一: 请求根路径//3.1 get请求server.get('/', function (request, response) &#123; // console.log(request) response.send('get请求成功')&#125;)//3.2 post请求server.post('/', function (request, response) &#123; response.send('post请求成功')&#125;)//4. 绑定端口server.listen(4040)console.log('启动4040') 2. 路由 路由:针对不同的URL有不同的处理方式，比如以后会有首页，发现模块，每个模块处理不一样。 添加url路径,根据不同路径，显示不同内容 路由句柄(索引):执行完一个函数，在执行下一个 ,因为有时候处理一个请求，需要做很多其他事情，写在一起业务逻辑不好分开,所以多弄几个行数 函数一定要添加next参数，一定要调用next(),才会进行下面操作，代码使一行一行执行，解释性语言 12345678910111213141516171819202122/* express的路由 *///1. 导入expressvar express = require('express')//2. 创建express服务器var server = express()//3. 访问服务器(get或者post)//参数一: 请求根路径//3.1 get请求server.get('/', function (request, response, next) &#123; // console.log(request) console.log('从据库获取数据') next()&#125;, function (request, response) &#123; response.send('get请求成功')&#125;)//3. 绑定端口server.listen(4040)console.log('启动4040') 3. 中间件 优化代码，使代码清晰可读 原理，发送一个请求给服务器的时候，会被中间件拦截，先由中间件处理，每个中间件都有一个回调函数作为参数,拦截到参数，就会自动执行回调函数。 注意：有中间件use，会先执行中间件的回调函数，然后才会调用get或者post的回调函数，也就是当监听到请求，先执行中间件，才会到get,post请求。 use是express注册中间件的方法 1234567891011121314151617181920212223242526272829/* express的中间件 *///1. 导入expressvar express = require('express')//2. 创建express服务器var server = express()//3. 创建中间件:use//截取请求, 拦截回调server.use('/', function (request, response, next) &#123; console.log('执行中间件') // console.log('获取数据库数据') console.log(request.query.page) next()&#125;)//4. 访问服务器(get或者post)//参数一: 请求根路径//4.1 get请求server.get('/home', function (request, response) &#123; // console.log(request) response.send('get参数请求成功')&#125;)//5. 绑定端口server.listen(4040)console.log('启动4040') 4. get请求参数 request.query会把请求参数包装成字典对象，直接通过点就能获取参数 这里的请求地址为: http://192.168.2.11:4040/home?page=12 1234567891011121314151617181920/* express的中间件 *///1. 导入expressvar express = require('express')//2. 创建express服务器var server = express()//4. 访问服务器(get或者post)//参数一: 请求根路径//4.1 get请求server.get('/home', function (request, response) &#123; // console.log(request) console.log(request.query.page) response.send('get参数请求成功')&#125;)//5. 绑定端口server.listen(4040)console.log('启动4040') 输出结果-12启动404012 5. post请求参数 这里先让我们看一下request的部分参数 123456789101112131415headers: &#123; //请求头 host: '192.168.2.11:4040/home', //保持长连接 connection: 'keep-alive', 'cache-control': 'max-age=0', 'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36', 'upgrade-insecure-requests': '1', //可接受的数据解析方式 accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'accept-encoding': 'gzip, deflate', 'accept-language': 'zh-CN,zh;q=0.9', 'if-none-match': 'W/\"15-H7HlVCzzVfmRL56LAnLfNUaMM+8\"' &#125; 使用http发送请求，需要设置content-type字段 content-type字段 application/x-www-form-urlencoded(普通请求，默认一般使用这种) application/json(带有json格式的参数，需要使用这个，比如参数是字典或者数组) multipart/form-data(传输文件，文件上传使用这个) AFN框架中AFHTTPRequestSerializer使用的是application/x-www-form-urlencoded，AFJSONRequestSerializer使用的是application/json Node.JS需要使用body-parser模块,解析post请求参数 可以采用中间件的方式解析post请求参数 注意bodyParser.urlencoded参数是一个字典，需要添加{}`包装 extends必传参数，是否展开 完整代码示例 123456789101112131415161718192021222324252627282930313233/** * 创建Post请求 * *///1. 导入expressvar express = require('express')//2. 加载模块var bodyParse = require('body-parser')//3. 创建服务器var server = express()//4. 生成解析器// application/x-www-form-urlencodedvar urlencoded = bodyParse.urlencoded(&#123; extends:true &#125;)// application/jsonvar jsonParser = bodyParse.json()//5. 中间件: 把请求体参数 存放到request.bodyserver.use('./home', jsonParser)//6. 请求数据// request:request请求头,请求体server.post('./home', function (request, response) &#123; //解析post请求参数 console.log(request.body) response.send(request.body)&#125;)//7. 绑定端口server.listen(5050) Demo地址 参考文章: Node.js优缺点 Node.js 究竟是什么？ Express 4.x API 中文手册 [JavaScript 语言参考]: https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94).aspx","categories":[{"name":"ReactNaive","slug":"ReactNaive","permalink":"https://titanjun.top/categories/ReactNaive/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://titanjun.top/tags/Node-js/"},{"name":"Web服务器","slug":"Web服务器","permalink":"https://titanjun.top/tags/Web服务器/"},{"name":"Express","slug":"Express","permalink":"https://titanjun.top/tags/Express/"}]},{"title":"ReactNative之TabBariOS和TabNavigator","slug":"ReactNative之TabBariOS和TabNavigator","date":"2018-01-06T07:23:00.000Z","updated":"2018-03-13T01:28:31.000Z","comments":true,"path":"2018/01/06/ReactNative之TabBariOS和TabNavigator/","link":"","permalink":"https://titanjun.top/2018/01/06/ReactNative之TabBariOS和TabNavigator/","excerpt":"目前React Native提供的官方的Tab Bar主要是TabBarIOS, 但是该控件目前只支持IOS端","text":"目前React Native提供的官方的Tab Bar主要是TabBarIOS, 但是该控件目前只支持IOS端 效果图 一. TabBarIOS 底部选项条, 不能跨平台,只能iOS端使用 添加如下代码, 就会出现底部选项条 123return ( &lt;TabBarIOS&gt;&lt;/TabBarIOS&gt;) 1. 相关属性123456789101112barTintColor='yellow'//标签栏的背景颜色tintColor='#ed7f30'//当前被选中的标签图标的颜色unselectedItemTintColor='#a19a9a'//当前没有被选中的标签图标的颜色。仅在iOS 10及以上版本有效translucent=&#123;false&#125; //一个布尔值，决定标签栏是否需要半透明化//默认为true, 有透明效果 二. 选项卡: TabBarIOS.Item TabBarIOS: 只是表示底部的一个选项条 TabBarIOS.Item: 才代表每一个选项卡 TabBarIOS.Item必须包装一个View,作为点击tabBar按钮，切换的View 123456789101112&lt;TabBarIOS.Item title='首页' icon=&#123;&#123;uri:'btn_home_normal'&#125;&#125; selectedIcon=&#123;&#123;uri:'btn_home_selected'&#125;&#125; onPress=&#123;()=&gt;&#123; this.setState(&#123; selectedIndex:0 &#125;) &#125;&#125; selected=&#123;this.state.selectedIndex == 0&#125;&gt; &lt;View style=&#123;&#123;backgroundColor:'red', flex:1&#125;&#125;/&gt;&lt;/TabBarIOS.Item&gt; 1. 常用属性12345678910111213141516171819202122badge string, number badge='我'badge=&#123;12&#125;//在图标右上角显示一个红色的气泡, 可接受string和number类型title string //在图标下面显示的标题文字。如果定义了systemIcon属性，这个属性会被忽略。icon Image.propTypes.source //给当前标签指定一个自定义的图标。如果定义了systemIcon属性， 这个属性会被忽略。selectedIcon Image.propTypes.source //当标签被选中的时候显示的自定义图标。如果定义了systemIcon属性，这个属性会被忽略。如果定义了icon而没定义这个属性，在选中的时候图标会染上蓝色。onPress function //当此标签被选中时调用。你应该修改组件的状态来使得selected属性为trueselected bool //这个属性决定了子视图是否可见。如果你看到一个空白的页面，很可能是没有选中任何一个标签systemIcon enum('bookmarks', 'contacts', 'downloads', 'favorites', 'featured', 'history', 'more', 'most-recent', 'most-viewed', 'recents', 'search', 'top-rated') //一些预定义的系统图标。注意如果你使用了此属性，标题和自定义图标都会被覆盖为系统定义的值。 只要设置对应的tabBarItem的selected为true,就会自动跳转到对应界面 注意：tabBarItem的selected属性不能写死，可以搞个角标记录当前选中那个角标 监听tabBarItem的点击，修改selected属性 相关示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243export default class App extends Component&lt;&#123;&#125;&gt; &#123; constructor(props)&#123; super(props) this.state = &#123; selectedIndex:0 &#125; &#125; // 当一个组件要显示的时候,就会自动调用render,渲染组件 render() &#123; return ( &lt;TabBarIOS tintColor='#ed7f30'&gt; &lt;TabBarIOS.Item title='首页' icon=&#123;&#123;uri:'btn_home_normal'&#125;&#125; selectedIcon=&#123;&#123;uri:'btn_home_selected'&#125;&#125; badge='我' onPress=&#123;()=&gt;&#123; this.setState(&#123; selectedIndex:0 &#125;) &#125;&#125; selected=&#123;this.state.selectedIndex == 0&#125; &gt; &lt;View style=&#123;&#123;backgroundColor:'red', flex:1&#125;&#125;/&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title='直播' icon=&#123;&#123;uri:'btn_column_normal'&#125;&#125; selectedIcon=&#123;&#123;uri:'btn_column_selected'&#125;&#125; badge=&#123;12&#125; onPress=&#123;()=&gt;&#123; this.setState(&#123; selectedIndex:1 &#125;) &#125;&#125; selected=&#123;this.state.selectedIndex == 1&#125; &gt; &lt;View style=&#123;&#123;backgroundColor:'yellow', flex:1&#125;&#125;/&gt; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ) &#125;&#125; 三. TabNavigator TabBarIOS只能用于iOS平台，如果在安卓上也需要有TabBar,就不能使用TabBarIOS。 TabNavigator:一个跨平台的TabBar第三方框架组件，可以用于iOS和安卓平台 TabNavigator地址 1. 安装和导入1-1. 安装第三方框架1yarn add react-native-tab-navigator 1-2. 导入框架1import TabNavigator from 'react-native-tab-navigator'; 2. TabNavigator常用属性 属性 默认值 类型 描述 sceneStyle inherited object (style) 定义渲染的场景 tabBarStyle inherited object (style) 为TabBar定义样式 tabBarShadowStyle inherited object (style) 为TabBar定义阴影样式 hidesTabTouch false boolean 禁用选项卡的onPress 3. TabNavigator.Item常用属性 属性 默认值 类型 描述 renderIcon none function 选项卡图标 renderSelectedIcon none function 选项卡选中状态图标 badgeText none string or number 图标右上角显示 title none string tabbar标题 titleStyle inherited style 标题样式 selectedTitleStyle inherited style 选中状态标题样式 tabStyle inherited style 选项卡样式 hidesTabTouch false boolean 是否选中该tabbar onPress none function 选项卡的点击方法 allowFontScaling false boolean 允许标题的字体缩放 使用示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152render() &#123; return ( &lt;TabNavigator&gt; &lt;TabNavigator.Item title='首页' selected=&#123;this.state.selectedIndex == 0&#125; titleStyle=&#123;&#123;color:'#9d9d9d'&#125;&#125; selectedTitleStyle=&#123;&#123;color:'#ed7f30'&#125;&#125; badgeText='首页' allowFontScaling=&#123;false&#125; renderIcon=&#123;()=&gt; &lt;Image source=&#123;&#123;uri:'btn_home_normal'&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt; &#125; renderSelectedIcon=&#123;()=&gt; &lt;Image source=&#123;&#123;uri:'btn_home_selected'&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt; &#125; onPress=&#123;()=&gt; this.setState(&#123; selectedIndex:0 &#125;) &#125; &gt; &lt;View style=&#123;[styles.viewStyle, &#123;backgroundColor:'red'&#125;]&#125;&gt; &lt;Text&gt;首页&lt;/Text&gt; &lt;/View&gt; &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item title='我的' selected=&#123;this.state.selectedIndex == 1&#125; titleStyle=&#123;&#123;color:'#9d9d9d'&#125;&#125; selectedTitleStyle=&#123;&#123;color:'#ed7f30'&#125;&#125; badgeText=&#123;10&#125; renderIcon=&#123;()=&gt; &lt;Image source=&#123;&#123;uri:'btn_user_normal'&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt; &#125; renderSelectedIcon=&#123;()=&gt; &lt;Image source=&#123;&#123;uri:'btn_user_selected'&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt; &#125; onPress=&#123;()=&gt; this.setState(&#123; selectedIndex:1 &#125;) &#125; &gt; &lt;View style=&#123;[styles.viewStyle, &#123;backgroundColor:'green'&#125;]&#125;&gt; &lt;Text&gt;我的&lt;/Text&gt; &lt;/View&gt; &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt; ) &#125;&#125;","categories":[{"name":"ReactNaive","slug":"ReactNaive","permalink":"https://titanjun.top/categories/ReactNaive/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://titanjun.top/tags/CSS/"},{"name":"TabBariOS","slug":"TabBariOS","permalink":"https://titanjun.top/tags/TabBariOS/"},{"name":"TabNavigator","slug":"TabNavigator","permalink":"https://titanjun.top/tags/TabNavigator/"}]},{"title":"React Native之导航组件NavigatorIOS和Navigator","slug":"React Native之导航组件NavigatorIOS和Navigator","date":"2018-01-05T09:04:00.000Z","updated":"2018-03-13T01:26:01.000Z","comments":true,"path":"2018/01/05/React Native之导航组件NavigatorIOS和Navigator/","link":"","permalink":"https://titanjun.top/2018/01/05/React Native之导航组件NavigatorIOS和Navigator/","excerpt":"一. NavigatorIOS NavigatorIOS是一个包装UINavigationController，能够实现一个导航堆栈, 且只能在iOS上使用的组件 它的工作原理与使用本地应用程序UINavigationController的效果完全相同，从UIKIt提供相同的动画和行为","text":"一. NavigatorIOS NavigatorIOS是一个包装UINavigationController，能够实现一个导航堆栈, 且只能在iOS上使用的组件 它的工作原理与使用本地应用程序UINavigationController的效果完全相同，从UIKIt提供相同的动画和行为 1. 常用属性1234567891011121314151617181920//样式, 必须设置&#123;flex:1&#125;, 否则看不到子控件style=&#123;&#123;flex:1&#125;&#125;//导航条的背景颜色barTintColor='yellow'//为true , 隐藏导航栏navigationBarHidden=&#123;false&#125;//是否隐藏阴影，true／false。shadowHidden=&#123;false&#125;//导航栏上按钮的颜色设置tintColor='black'//导航栏上标题的颜色设置titleTextColor='blue'//导航栏是否是半透明的，true／false。translucent=&#123;true&#125; 2. NavigatorIOS的使用 必须初始化路由: initialRoute{} 注意:component，需要传入组件，自定义组件 123456789101112131415//用于初始化路由。其参数对象中的各个属性如下：initialRoute： &#123; component: function, //加载的视图组件 title: string, //当前视图的标题 passPros: object, //传递的数据 backButtonIcon: Image.propTypes.source, // 后退按钮图标 backButtonTitle: string, //后退按钮标题 leftButtonIcon: Image.propTypes.soruce, // 左侧按钮图标 leftButtonTitle: string, //左侧按钮标题 onLeftButtonPress: function, //左侧按钮点击事件 rightButtonIcon: Image.propTypes.soruce, // 右侧按钮图标 rightButtonTitle: string, //右侧按钮标题 onRightButtonPress: function, //右侧按钮点击事件&#125; 使用示例 12345678910&lt;NavigatorIOS initialRoute=&#123; &#123; //JunNavigatorView: 为自定义的组件 component:JunNavigatorView, title: '首页', leftButtonTitle:'左按钮', rightButtonTitle:'跳转' &#125; &#125;/&gt; 3. 页面间的跳转 获取Navigator，只有它才能跳转 只要是导航控制器下的组件，都可以通过props获取 this.props.navigator 界面跳转方法 1234567pust(route)：//加载一个新的页面（视图或者路由）并且路由到该页面。pop()：//返回到上一个页面。popN(n)：//一次性返回N个页面。当 N=1 时，相当于 pop() 方法的效果。replace(route)：//替换当前的路由。replacePrevious（route）：//替换前一个页面的视图并且回退过去。resetTo(route)：//取代最顶层的路由并且回退过去。popToTop()：//回到最上层视图。 使用示例 12345678&lt;Text onPress=&#123;()=&gt;&#123; this.props.navigator.push(&#123; component:JunTwoView, title:'第二页面' &#125;)&#125;&#125;&gt;点击跳转到第二个页面&lt;/Text&gt; 二. Navigator Navigator很好解决了NavigatorIOS不能跨平台和自定义的问题 RN开发中通常使用Navigator Navigator作用：只提供跳转功能，支持iOS,安卓 导航条需要自定义，需要导航条的界面，自己添加只要一个控件，包装成Navigator就能获取跳转功能 1. Navigator导入问题 在0,43版本之前(包括0.43), Navigator在react-native库中 从0.44版本开始Navigator就被移入了react-native-deprecated-custom-components库中 使用前,先进入当前项目文件，安装Navigator所在的库 12345//终端输入yarn add react-native-deprecated-custom-components//下面方法可能已经失效(亲测失败)npm install react-native-deprecated-custom-components --save 下载完成后，导入1import &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos; 2. Navigator的使用2-1. initialRoute： 初始化路由 定义启动时加载的路由 路由是导航栏用来识别渲染场景的一个对象 1&lt;Navigator initialRoute=&#123;&#123;component: JunOneView&#125;&#125;/&gt; 2-2. 配置场景动画和手势 可选的函数, 设置跳转方向 会带有两个参数调用，一个是当前的路由，一个是当前的路由栈 返回一个场景配置对象 123_configureScene(route, routeStack) &#123; return Navigator.SceneConfigs.PushFromLeft;&#125; 其他跳转方向参数 12345678910Navigator.SceneConfigs.PushFromRight (默认)Navigator.SceneConfigs.FloatFromRightNavigator.SceneConfigs.FloatFromLeftNavigator.SceneConfigs.FloatFromBottomNavigator.SceneConfigs.FloatFromBottomAndroidNavigator.SceneConfigs.FadeAndroidNavigator.SceneConfigs.HorizontalSwipeJumpNavigator.SceneConfigs.HorizontalSwipeJumpFromRightNavigator.SceneConfigs.VerticalUpSwipeJumpNavigator.SceneConfigs.VerticalDownSwipeJump 2-3. 渲染指定路由的场景 必要参数, 调用的参数是路由和导航器 1234_renderScene(route, navigator) &#123; // ...扩展符, 作用:如果是对象,就获取对象中所有值,如果是数组,就获取数组中所有值 return (&lt;route.component navigator=&#123;navigator&#125; &#123;... route.props&#125;/&gt;)&#125; 2-4. 设置导航尺寸1style=&#123;&#123;flex:1&#125;&#125; 3. 其他属性或方法12345onDidFocus function //每当导航切换完成或初始化之后，调用此回调，参数为新场景的路由。onWillFocus function //会在导航切换之前调用，参数为目标路由。 三. 延展符 文中用到了一个操作符: ...即为延展符 延展符的作用 遍历数组 遍历对象的属性,一个一个传值给下一个控件 123456var arr1 = [1, 2, 3, 4, 5]var arr2 = [0] arr2.push(...arr1)console.log(arr2)//输出结果: [0, 1, 2, 3, 4, 5] 作用等同于JavaScript数组中的concat方法 区别在于concat只能作用于数组 1234567var arr1 = [1, 2, 3, 4, 5]var arr2 = [0]// arr2.push(...arr1)arr2 = arr2.concat(arr1)console.log(arr2)//输出结果: [0, 1, 2, 3, 4, 5] 关于JavaScript的数组语法, 请查看我的另一篇文章JavaScript基本语法01","categories":[{"name":"ReactNaive","slug":"ReactNaive","permalink":"https://titanjun.top/categories/ReactNaive/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://titanjun.top/tags/CSS/"},{"name":"NavigatorIOS","slug":"NavigatorIOS","permalink":"https://titanjun.top/tags/NavigatorIOS/"},{"name":"Navigator","slug":"Navigator","permalink":"https://titanjun.top/tags/Navigator/"}]},{"title":"ReactNaive之ScrollView和ListView","slug":"ReactNaive之ScrollView和ListView","date":"2018-01-03T08:54:00.000Z","updated":"2018-03-13T01:27:41.000Z","comments":true,"path":"2018/01/03/ReactNaive之ScrollView和ListView/","link":"","permalink":"https://titanjun.top/2018/01/03/ReactNaive之ScrollView和ListView/","excerpt":"一. ScrollView 记住ScrollView必须有一个确定的高度才能正常工作，因为它实际上所做的就是将一系列不确定高度的子组件装进一个确定高度的容器（通过滚动操作） 要给一个ScrollView确定一个高度的话，要么直接给它设置高度（不建议），要么确定所有的父容器都有确定的高度","text":"一. ScrollView 记住ScrollView必须有一个确定的高度才能正常工作，因为它实际上所做的就是将一系列不确定高度的子组件装进一个确定高度的容器（通过滚动操作） 要给一个ScrollView确定一个高度的话，要么直接给它设置高度（不建议），要么确定所有的父容器都有确定的高度 1. ScrollView常用的属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758horizontal bool //当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。showsHorizontalScrollIndicator bool//当此属性为true的时候，显示一个水平方向的滚动条。showsVerticalScrollIndicator bool//当此属性为true的时候，显示一个垂直方向的滚动条。alwaysBounceHorizontal bool //当此属性为true时，水平方向即使内容比滚动视图本身还要小，也可以弹性地拉动一截。当horizontal=&#123;true&#125;时默认值为true，否则为false。refreshControl element //指定RefreshControl组件，用于为ScrollView提供下拉刷新功能(ios) alwaysBounceVertical bool//当此属性为true时，垂直方向即使内容比滚动视图本身还要小，也可以弹性地拉动一截。//当horizontal=&#123;true&#125;时默认值为false，否则为true。(ios) automaticallyAdjustContentInsets bool//当滚动视图放在一个导航条或者工具条后面的时候，iOS系统是否要自动调整内容的范围。默认值为true。（译注：如果你的ScrollView或ListView的头部出现莫名其妙的空白，尝试将此属性置为false）(ios) bounces bool//当值为true时，如果内容范围比滚动视图本身大，在到达内容末尾的时候，可以弹性地拉动一截。如果为false，尾部的所有弹性都会被禁用，即使alwaysBounce*属性为true。默认值为true。(ios) bouncesZoom bool //当值为true时，使用手势缩放内容可以超过min/max的限制，然后在手指抬起之后弹回min/max的缩放比例。否则的话，缩放不能超过限制。(ios) contentInset &#123;top: number, left: number, bottom: number, right: number&#125; //内容范围相对滚动视图边缘的坐标。默认为&#123;0, 0, 0, 0&#125;(ios) contentOffset PointPropType//用来手动设置初始的滚动坐标。默认值为&#123;x: 0, y: 0&#125;pagingEnabled bool//当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。scrollEnabled bool//当值为false的时候，内容不能滚动，默认值为true。(ios) scrollEventThrottle number//这个属性控制在滚动过程中，scroll事件被调用的频率（单位是每秒事件数量）。更大的数值能够更及时的跟踪滚动位置，不过可能会带来性能问题，因为更多的信息会通过bridge传递。默认值为0，意味着每次视图被滚动，scroll事件只会被调用一次。(ios)scrollIndicatorInsets &#123;top: number, left: number, bottom: number, right: number&#125; //决定滚动条距离视图边缘的坐标。这个值应该和contentInset一样。默认值为&#123;0, 0, 0, 0&#125;。(ios) scrollsToTop bool //当此值为true时，点击状态栏的时候视图会滚动到顶部。默认值为true。stickyHeaderIndices [number]//一个子视图下标的数组，用于决定哪些成员会在滚动之后固定在屏幕顶端。//举个例子，传递stickyHeaderIndices=&#123;[0]&#125;会让第一个成员固定在滚动视图顶端。//这个属性不能和horizontal=&#123;true&#125;一起使用。(ios) maximumZoomScale number //允许的最大缩放比例。默认值为1.0。(ios) minimumZoomScale number //允许的最小缩放比例。默认值为1.0。 2. ScrollView常用的方法 开发中，常需要在滚动的时候做事情，那怎么监听ScrollView滚动 123456789101112131415161718192021222324252627282930313233343536// 监听滚动开始onMomentumScrollBegin=&#123;this._onMomentumScrollBegin.bind(this)&#125;// 监听滚动结束onMomentumScrollEnd=&#123;this._onMomentumScrollEnd.bind(this)&#125;// 监听开始拖拽onScrollBeginDrag=&#123;this._onScrollBeginDrag.bind(this)&#125;// 监听结束拖拽onScrollEndDrag=&#123;this._onScrollEndDrag.bind(this)&#125;// 监听滚动动画完成onScrollAnimationEnd=&#123;this._onScrollAnimationEnd.bind(this)&#125;onMomentumScrollStart?: function //滚动动画开始时调用此函数。onMomentumScrollEnd?: function //滚动动画结束时调用此函数。// 监听滚动的时候onScroll=&#123;this._onScroll.bind(this)&#125;// 设置滚动频率,一滚动就监听,需要和onScroll配套使用scrollEventThrottle=&#123;1&#125;scrollTo(y: number | &#123; x?: number, y?: number, animated?: boolean &#125;, x: number, animated: boolean) //滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画。//使用示例:scrollTo(&#123;x: 0, y: 0, animated: true&#125;)scrollToEnd(options?) //滚动到视图底部（水平方向的视图则滚动到最右边）。//加上动画参数 scrollToEnd(&#123;animated: true&#125;)则启用平滑滚动动画，或是调用 scrollToEnd(&#123;animated: false&#125;)来立即跳转。如果不使用参数，则animated选项默认启用。 3. 获取原生事件 滚动的时候,会传入一个合成事件作为监听滚动方法的参数，每个方法都会有这个合成事件 通过合成事件能获取原生事件nativeEvent,原生事件nativeEvent会有我们想要的信息. 什么是合成事件：在RN中，事件的处理由其内部自己实现的事件系统完成，触发的事件都叫做 合成事件（SyntheticEvent） 12345678910111213// 滚动完成的时候调用_onMomentumScrollEnd(e)&#123; // 获取原生事件 var nativeEvent = e.nativeEvent //获取当前偏移量 var contentX = nativeEvent.contentOffset.x //当前页 var page = contentX / kScreenWidth this.setState(&#123; currentPage:page &#125;)&#125; 二. ListView 官方文档提示: 在0.46版本开始此组件已过期, 并推荐使用FlatList或SectionList替代, 但是在0.51版本依然可以使用 ListView: 一个核心组件，用于高效地显示一个可以垂直滚动的变化的数据列表 ListView内部是通过ListViewDataSource这个对象，显示数据，因此使用ListView必须先创建ListViewDataSource对象。 ListViewDataSource构造方法(创建对象):可选择性传入4个参数,描述怎么提取数据，怎么刷新cell 这些参数：都是函数，当产生对应的事件的时候，会自动执行这些函数. 1. ListView常用的属性和方法 ListView可以使用所有ScrollView的属性。 12345initialListSize number //指定在组件刚挂载的时候渲染多少行数据。用这个属性来确保首屏显示合适数量的数据，而不是花费太多帧逐步显示出来dataSource ListViewDataSource //ListView.DataSource实例（列表依赖的数据源） ListViewDataSource构造函数可以接受下列四种参数（都是可选）： 12345678getRowData(dataBlob, sectionID, rowID);//怎么获取行数据getSectionHeaderData(dataBlob, sectionID);//怎么获取每一组头部数据rowHasChanged(prevRowData, nextRowData);//决定什么情况行数据才发生改变，当行数据发生改变，就会绘制下一行cellsectionHeaderHasChanged(prevSectionData, nextSectionData);//决定什么情况头部数据才发生改变，当行数据发生改变，就会绘制下一行cell ListViewDataSource为ListView组件提供高性能的数据处理和访问。我们需要调用clone方法从原始输入数据中抽取数据来创建ListViewDataSource对象。 要更新datasource中的数据，请（每次都重新）调用cloneWithRows方法（如果用到了section，则对应cloneWithRowsAndSections方法）clone方法会自动提取新数据并进行逐行对比（使用rowHasChanged方法中的策略），这样ListView就知道哪些行需要重新渲染了 注意：初始化ListViewDataSource的时候，如果不需要修改提取数据的方式，只需要实现rowHasChanged，告诉什么时候刷新下一行数据. 注意：默认ListViewDataSource有提取数据方式，可以使用默认的提取方式. 2. ListView使用步骤 1). 创建数据源 12345678910111213141516//1. 创建数据源对象var datas = new ListView.DataSource(&#123; //设置数据改变的时候刷新下一行数据 rowHasChanged: (r1, r2)=&gt;&#123;r1 != r2&#125;,&#125;)//2. 请求数据'var foodArr = require('./Resource/food.json')//3. 设置数据datas = datas.cloneWithRows(foodArr)//5. 保存数据源this.state = &#123; dataArr: datas&#125; 2). ListView实现 1234567891011121314&lt;ListView style=&#123;&#123;backgroundColor:'white', marginTop:20&#125;&#125; //设置数据源 dataSource=&#123;this.state.dataArr&#125; //渲染哪一行(设置cell样式) renderRow=&#123;this._renderRow.bind(this)&#125; //设置头部样式 renderHeader=&#123;this._renderHeader.bind(this)&#125; //设置section的头部样式 renderSectionHeader=&#123;this._renderSectionHeader.bind(this)&#125; //设置尾部样式 renderFooter=&#123;this._renderFooter.bind(this)&#125; //设置分割线样式 renderSeparator=&#123;this._renderSeparator.bind(this)&#125;/&gt; 3). 相关属性方法介绍 renderRow: 设置每行cell样式 1234567891011121314// 实现数据源方法,设置每行cell样式/*这个方法会自动传入四个参数(rowData,sectionID,rowID,highlightRow)rowData:当前行数据sectionID:当前行所在组IDrowID：哪一行的角标highlightRow:高亮函数*/ _renderRow(rowData, sectionID, rowID, highlightRow) &#123; return ( &lt;View&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125; ListView头部和尾部视图 12345678910111213141516//头部视图 _renderHeader() &#123; return ( &lt;View&gt; &lt;Text&gt;头部视图&lt;/Text&gt; &lt;/View&gt; ) &#125;//尾部视图 _renderFooter() &#123; return ( &lt;View&gt; &lt;Text&gt;尾部视图&lt;/Text&gt; &lt;/View&gt; ) &#125; renderSectionHeader: 设置每一个section的头部样式 12345//sectionData: 每一组的头部数据//sectionID: 组ID_renderSectionHeader(sectionData, sectionID)&#123; &#125; ListView分割线 1234567// 哪一组,哪一行,相邻行是否高亮 _renderSeparator(sectionID, rowID, adjacentRowHighlighted) &#123; console.log(sectionID,rowID,adjacentRowHighlighted); return ( &lt;View style=&#123;&#123;height:1,backgroundColor:'black'&#125;&#125;&gt;&lt;/View&gt; ) &#125;","categories":[{"name":"ReactNaive","slug":"ReactNaive","permalink":"https://titanjun.top/categories/ReactNaive/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://titanjun.top/tags/CSS/"},{"name":"ScrollView","slug":"ScrollView","permalink":"https://titanjun.top/tags/ScrollView/"},{"name":"ListView","slug":"ListView","permalink":"https://titanjun.top/tags/ListView/"}]},{"title":"Swift语音和文本的转换","slug":"Swift语音和文本的转换","date":"2017-12-10T05:40:00.000Z","updated":"2018-03-13T01:30:07.000Z","comments":true,"path":"2017/12/10/Swift语音和文本的转换/","link":"","permalink":"https://titanjun.top/2017/12/10/Swift语音和文本的转换/","excerpt":"谈到语音和文本的转换, 就要说到语音转文本和文本转语音两大技术 文本转语音是iOS7以后的技术, 用到的是AVFoundation框架 语音转文本是iOS10以后, 苹果发布的一个Speech框架","text":"谈到语音和文本的转换, 就要说到语音转文本和文本转语音两大技术 文本转语音是iOS7以后的技术, 用到的是AVFoundation框架 语音转文本是iOS10以后, 苹果发布的一个Speech框架 下面先介绍一下简单的文本转语音 GitHub上Demo地址 项目包括 文本转语音 实时语音转文本 本地语音转文本 录音保存本地,转文本 一. 文本转语音 文本转语音技术, 简称TTS (是Text To Speech的缩写), 语音合成苹果官方文档 是苹果iOS7以后新增的功能, 使用AVFoundation 库 下面介绍一下需要用到的类 1. AVSpeechSynthesizer: 语音合成器1-1. 属性12345//是否正在语音播放open var isSpeaking: Bool &#123; get &#125;//是否停止语音播放open var isPaused: Bool &#123; get &#125; 1-2. 方法1234567891011121314//播放语音open func speak(_ utterance: AVSpeechUtterance)//停止语音播放open func stopSpeaking(at boundary: AVSpeechBoundary) -&gt; Bool//暂停语音播放open func pauseSpeaking(at boundary: AVSpeechBoundary) -&gt; Bool//继续语音播放open func continueSpeaking() -&gt; Bool//(iOS10以上, 输出通道)open var outputChannels: [AVAudioSessionChannelDescription]? 2. AVSpeechBoundary 描述语音可能被暂停或停止的枚举值 12345case immediate//表示发言应该暂停或立即停止。case word//说完整个词语之后再暂停或者停止 3. AVSpeechUtterance 可以将文本和成一段语音的类, 或者说就是一段要播放的语音3-1. 属性 12345678910111213141516171819202122232425//使用的声音open var voice: AVSpeechSynthesisVoice?//文本属性 open var speechString: String &#123; get &#125;//富文本属性@available(iOS 10.0, *)open var attributedSpeechString: NSAttributedString &#123; get &#125;//说话的速度 open var rate: Float //提供了两个语速 AVSpeechUtteranceMinimumSpeechRate和 AVSpeechUtteranceMaximumSpeechRate和AVSpeechUtteranceDefaultSpeechRate//说话的基线音高, [0.5 - 2] Default = 1 open var pitchMultiplier: Float //说话音量, [0-1] Default = 1open var volume: Float //开始一段语音之前等待的时间open var preUtteranceDelay: TimeInterval //语音合成器在当前语音结束之后处理下一个排队的语音之前需要等待的时间, 默认0.0 open var postUtteranceDelay: TimeInterval 3-2. 初始化方法1234public init(string: String)@available(iOS 10.0, *)public init(attributedString string: NSAttributedString) 4. AVSpeechSynthesisVoice 用于语音合成的独特声音, 主要是不同的语言和地区 所支持的所有语言种类详见最底部附录 4-1. 相关属性123456789101112//获得当前的语言open var language: String &#123; get &#125;//返回用户当前语言环境的代码@available(iOS 9.0, *)open var identifier: String &#123; get &#125;@available(iOS 9.0, *)open var name: String &#123; get &#125;@available(iOS 9.0, *)open var quality: AVSpeechSynthesisVoiceQuality &#123; get &#125; 4-2. 相关方法123456789init?(language: String?)//返回指定语言和语言环境的语音对象。class func speechVoices()//返回所有可用的语音。class func currentLanguageCode()//返回用户当前语言环境的代码。 5. AVSpeechSynthesizerDelegate代理 所有代理方法都是支持iOS7.0以上的系统 1234567891011121314151617//开始播放optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didStart utterance: AVSpeechUtterance)//播放完成optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance)//暂停播放optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didPause utterance: AVSpeechUtterance)//继续播放optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didContinue utterance: AVSpeechUtterance)//取消播放optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didCancel utterance: AVSpeechUtterance)//将要播放某一段话 optional public func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, willSpeakRangeOfSpeechString characterRange: NSRange, utterance: AVSpeechUtterance) 6. 具体功能的核心代码123456789101112131415161718192021222324252627282930313233//MARK: 开始/停止转换extension TextToVoiceController&#123; //开始转换 fileprivate func startTranslattion()&#123; //1. 创建需要合成的声音类型 let voice = AVSpeechSynthesisVoice(language: \"zh-CN\") //2. 创建合成的语音类 let utterance = AVSpeechUtterance(string: textView.text) utterance.rate = AVSpeechUtteranceDefaultSpeechRate utterance.voice = voice utterance.volume = 1 utterance.postUtteranceDelay = 0.1 utterance.pitchMultiplier = 1 //开始播放 avSpeech.speak(utterance) &#125; //暂停播放 fileprivate func pauseTranslation()&#123; avSpeech.pauseSpeaking(at: .immediate) &#125; //继续播放 fileprivate func continueSpeek()&#123; avSpeech.continueSpeaking() &#125; //取消播放 fileprivate func cancleSpeek()&#123; avSpeech.stopSpeaking(at: .immediate) &#125;&#125; 二. 语音转文本 在2016 WWDC大会上，Apple公司介绍了一个很好的语音识别的API,那就是Speech框架 Speech框架支持iOS10以上系统 Speech框架官方文档 下面简单介绍一下主要的操作类 1. SFSpeechRecognizer: 语音识别器 这个类是语音识别的操作类 用于语音识别用户权限的申请，语言环境的设置，语音模式的设置以及向Apple服务发送语音识别的请求 初始化方法 1234567//这个初始化方法将默认以设备当前的语言环境作为语音识别的语言环境public convenience init?() //根据支持的语言初始化public init?(locale: Locale) //示例let recognize = SFSpeechRecognizer(locale: Locale(identifier: \"zh-CN\")) 类方法 12345678//获取所有支持的语言open class func supportedLocales() -&gt; Set&lt;Locale&gt;//获取当前用户权限状态open class func authorizationStatus() -&gt; SFSpeechRecognizerAuthorizationStatus//申请语音识别用户权限open class func requestAuthorization(_ handler: @escaping (SFSpeechRecognizerAuthorizationStatus) -&gt; Swift.Void) 其他属性 1234567891011var isAvailable: Bool//指示语音识别器是否可用var locale: Locale//当前语音识别器的语言环境class func supportedLocales()//获取语音识别所有支持的语言var queue: OperationQueue//语音识别器用于识别任务处理程序和委托消息的队列 相关方法 12345//识别与指定请求关联的音频来源的语音，使用指定的协议返回结果open func recognitionTask(with request: SFSpeechRecognitionRequest, resultHandler: @escaping (SFSpeechRecognitionResult?, Error?) -&gt; Swift.Void) -&gt; SFSpeechRecognitionTask//识别与指定请求关联的音频源的语音, 使用闭包结果open func recognitionTask(with request: SFSpeechRecognitionRequest, delegate: SFSpeechRecognitionTaskDelegate) -&gt; SFSpeechRecognitionTask 代理 1234weak var delegate: SFSpeechRecognizerDelegate? &#123; get set &#125;//代理方法: 监视语音识别器的可用性func speechRecognizer(SFSpeechRecognizer, availabilityDidChange: Bool) 2. SFSpeechRecognitionRequest 语音识别请求类，需要通过其子类来进行实例化 相关属性 123456789101112var contextualStrings: [String]//一系列应该被识别的语言种类var shouldReportPartialResults: Bool//是否获取每个语句的最终结果。var taskHint: SFSpeechRecognitionTaskHint//正在执行的语音识别的类型var interactionIdentifier: String?//标识与请求关联的识别请求对象的字符串 子类 SFSpeechURLRecognitionRequest SFSpeechAudioBufferRecognitionRequest 2-1. SFSpeechURLRecognitionRequest 通过制定的URL路径识别本地的语音 方法和属性 12345//创建一个语音识别请求，使用指定的URL进行初始化public init(url URL: URL)//获取当前的usl路径 open var url: URL &#123; get &#125; 2-2. SFSpeechAudioBufferRecognitionRequest 识别音频缓冲区中提供的语音的请求 识别即时语音, 类似于iPhone 中的Siri 官方文档 音频缓冲区相关方法属性 12345678func append(AVAudioPCMBuffer)//将PCM格式的音频追加到识别请求的末尾。func appendAudioSampleBuffer(CMSampleBuffer)//将音频附加到识别请求的末尾。func endAudio()//完成输入 获取音频格式 12var nativeAudioFormat: AVAudioFormat//用于最佳语音识别的首选音频格式。 3. SFSpeechRecognitionTask 语音识别请求结果类 语音识别任务，监视识别进度 相关方法属性 1234567891011121314151617func cancel()//取消当前的语音识别任务。var isCancelled: Bool//语音识别任务是否已被取消。func finish()//停止接受新的音频，并完成已接受的音频输入处理var isFinishing: Bool//音频输入是否已停止。var state: SFSpeechRecognitionTaskState//获取语音识别任务的当前状态。var error: Error?//在语音识别任务期间发生的错误的错误对象。 3-1. SFSpeechRecognitionTaskDelegate协议123456789101112131415161718//当开始检测音频源中的语音时首先调用此方法optional public func speechRecognitionDidDetectSpeech(_ task: SFSpeechRecognitionTask)//当识别出一条可用的信息后 会调用//apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didHypothesizeTranscription transcription: SFTranscription)//当识别完成所有可用的结果后调用optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishRecognition recognitionResult: SFSpeechRecognitionResult)//当不再接受音频输入时调用 即开始处理语音识别任务时调用 optional public func speechRecognitionTaskFinishedReadingAudio(_ task: SFSpeechRecognitionTask)//当语音识别任务被取消时调用 optional public func speechRecognitionTaskWasCancelled(_ task: SFSpeechRecognitionTask)//语音识别任务完成时被调用 optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishSuccessfully successfully: Bool) 4. SFTranscription 语音转换后的信息类, 包含改短语音信息的类 你所说的一句话，可能是有好几个词语拼成的，formattedString就是你所说的那句话，segments就是你所说的你那句话的组成每个单词的集合 12345//返回了一条表达语音译文的字符数据open var formattedString: String &#123; get &#125;//所有的可能的识别数据open var segments: [SFTranscriptionSegment] &#123; get &#125; 5. SFTranscriptionSegment 语音转换中的音频节点类 相关属性 1234567891011121314151617//当前节点识别后的文本信息open var substring: String &#123; get &#125;//当前节点识别后的文本信息在整体识别语句中的位置open var substringRange: NSRange &#123; get &#125;//当前节点的音频时间戳open var timestamp: TimeInterval &#123; get &#125;//当前节点音频的持续时间open var duration: TimeInterval &#123; get &#125;//可信度/准确度 0-1之间open var confidence: Float &#123; get &#125;//关于此节点的其他可能的识别结果 open var alternativeSubstrings: [String] &#123; get &#125; 6. SFSpeechRecognitionResult: 语音识别结果类 是语音识别结果的封装，其中包含了许多套平行的识别信息，其每一份识别信息都有可信度属性来描述其准确程度 该类只是语音识别结果的一个封装，真正的识别信息定义在SFTranscription类中 12345678//准确性最高的识别实例@NSCopying open var bestTranscription: SFTranscription &#123; get &#125;//识别到的多套语音转换信息数组 其会按照准确度进行排序open var transcriptions: [SFTranscription] &#123; get &#125;//是否已经完成 如果YES 则所有所有识别信息都已经获取完成open var isFinal: Bool &#123; get &#125; 三. 语音识别转文本 添加Speech框架 import Speech info.plist必须添加相关权限 12345Privacy - Speech Recognition Usage Description//语音识别权限Privacy - Microphone Usage Description//麦克风使用权限 判断用户授权 在使用speech framework做语音识别之前，你必须首先得到用户的允许 因为不仅仅只有本地的ios设备会进行识别，苹果的服务器也会识别 所有的语音数据都会被传递到苹果的后台进行处理 因此，获取用户授权是强制必须的 123456789101112131415161718192021222324///语音识别权限认证fileprivate func addSpeechRecordLimit()&#123; SFSpeechRecognizer.requestAuthorization &#123; (state) in var isEnable = false switch state &#123; case .authorized: isEnable = true print(\"已授权语音识别\") case .notDetermined: isEnable = false print(\"没有授权语音识别\") case .denied: isEnable = false print(\"用户已拒绝访问语音识别\") case .restricted: isEnable = false print(\"不能在该设备上进行语音识别\") &#125; DispatchQueue.main.async &#123; self.recordBtn.isEnabled = isEnable self.recordBtn.backgroundColor = isEnable ? UIColor(red: 255/255.0, green: 64/255.0, blue: 64/255.0, alpha: 1) : UIColor.lightGray &#125; &#125;&#125; 再然后就是初始化相关请求和识别类处理相关语音 详细代码参考GitHub的Demo地址 附录:AVSpeechSynthesisVoice支持的语言种类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273ar-SA 沙特阿拉伯（阿拉伯文）en-ZA, 南非（英文）nl-BE, 比利时（荷兰文）en-AU, 澳大利亚（英文）th-TH, 泰国（泰文）de-DE, 德国（德文）en-US, 美国（英文）pt-BR, 巴西（葡萄牙文）pl-PL, 波兰（波兰文）en-IE, 爱尔兰（英文）el-GR, 希腊（希腊文）id-ID, 印度尼西亚（印度尼西亚文）sv-SE, 瑞典（瑞典文）tr-TR, 土耳其（土耳其文）pt-PT, 葡萄牙（葡萄牙文）ja-JP, 日本（日文）ko-KR, 南朝鲜（朝鲜文）hu-HU, 匈牙利（匈牙利文）cs-CZ, 捷克共和国（捷克文）da-DK, 丹麦（丹麦文）es-MX, 墨西哥（西班牙文）fr-CA, 加拿大（法文）nl-NL, 荷兰（荷兰文）fi-FI, 芬兰（芬兰文）es-ES, 西班牙（西班牙文）it-IT, 意大利（意大利文）he-IL, 以色列（希伯莱文，阿拉伯文）no-NO, 挪威（挪威文）ro-RO, 罗马尼亚（罗马尼亚文）zh-HK, 香港（中文）zh-TW, 台湾（中文）sk-SK, 斯洛伐克（斯洛伐克文）zh-CN, 中国（中文）ru-RU, 俄罗斯（俄文）en-GB, 英国（英文）fr-FR, 法国（法文）hi-IN 印度（印度文）","categories":[{"name":"Swift黑科技","slug":"Swift黑科技","permalink":"https://titanjun.top/categories/Swift黑科技/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"Speech","slug":"Speech","permalink":"https://titanjun.top/tags/Speech/"}]},{"title":"Swift之Vision 图像识别框架","slug":"Swift之Vision 图像识别框架","date":"2017-11-29T06:58:00.000Z","updated":"2018-03-13T01:36:45.000Z","comments":true,"path":"2017/11/29/Swift之Vision 图像识别框架/","link":"","permalink":"https://titanjun.top/2017/11/29/Swift之Vision 图像识别框架/","excerpt":"2017年苹果大大又推出了新机型iPhone 8和iPhone 8Plus, 这还不是重点, 重点是那一款价值9000RMB的iPhone X, 虽说网上吐槽声从未停止过, 但是我觉得还是不错的哈! 软件方面, 苹果大大也推出了iOS 11, 经本人iPhone 7手机亲测, 耗电快外加通知栏改不完的bug 当然了随着iOS 11的推出, 也随之推出了一些新的API，如：ARKit 、Core ML、FileProvider、IdentityLookup 、Core NFC、Vison 等。 这里我们还要说的就是Apple 在 WWDC 2017 推出的图像识别框架–Vison官方文档 Demo地址","text":"2017年苹果大大又推出了新机型iPhone 8和iPhone 8Plus, 这还不是重点, 重点是那一款价值9000RMB的iPhone X, 虽说网上吐槽声从未停止过, 但是我觉得还是不错的哈! 软件方面, 苹果大大也推出了iOS 11, 经本人iPhone 7手机亲测, 耗电快外加通知栏改不完的bug 当然了随着iOS 11的推出, 也随之推出了一些新的API，如：ARKit 、Core ML、FileProvider、IdentityLookup 、Core NFC、Vison 等。 这里我们还要说的就是Apple 在 WWDC 2017 推出的图像识别框架–Vison官方文档 Demo地址 一. Vision应用场景 Face Detection and Recognition : 人脸检测 支持检测笑脸、侧脸、局部遮挡脸部、戴眼镜和帽子等场景，可以标记出人脸的矩形区域 可以标记出人脸和眼睛、眉毛、鼻子、嘴、牙齿的轮廓，以及人脸的中轴线 Image Alignment Analysis: 图像对比分析 Barcode Detection: 二维码/条形码检测 用于查找和识别图像中的条码 检测条形码信息 Text Detection: 文字检测 查找图像中可见文本的区域 检测文本区域的信息 Object Detection and Tracking: 目标跟踪 脸部，矩形和通用模板 二. Vision支持的图片类型1. Objective-C中 CVPixelBufferRef CGImageRef CIImage NSURL NSData 2. Swift中 CVPixelBuffer CGImage CIImage URL Data 具体详情可在Vision.framework的VNImageRequestHandler.h文件中查看 三. Vision之API介绍 使用在vision的时候，我们首先需要明确自己需要什么效果，然后根据想要的效果来选择不同的类 给各种功能的 Request 提供给一个 RequestHandler Handler 持有需要识别的图片信息，并将处理结果分发给每个 Request 的 completion Block 中 可以从 results 属性中得到 Observation 数组 observations数组中的内容根据不同的request请求返回了不同的observation 每种Observation有boundingBox，landmarks等属性，存储的是识别后物体的坐标，点位等 我们拿到坐标后，就可以进行一些UI绘制。 1. RequestHandler处理请求对象 VNImageRequestHandler: 处理与单个图像有关的一个或多个图像分析请求的对象 一般情况下都是用该类处理识别请求 初始化方法支持CVPixelBuffer, CGImage, CIImage, URL, Data VNSequenceRequestHandler: 处理与多个图像序列有关的图像分析请求的对象 目前我在处理物体跟踪的时候使用该类 初始化方法同上 2. VNRequest介绍 VNRequest: 图像分析请求的抽象类, 继承于NSObject VNBaseImageRequest: 专注于图像的特定部分的分析请求 具体分析请求类如下: 3. VNObservation检测对象 VNObservation: 图像分析结果的抽象类, 继承与NSObject 图像检测结果的相关处理类如下: 四. 实战演练1. 文本检测 方式一: 识别出具体的每一个字体的位置信息 方式二: 识别一行字体的位置信息 如图效果: 1.1 现将图片转成初始化VNImageRequestHandler对象时, 可接受的的CIImage12//1. 转成ciimageguard let ciImage = CIImage(image: image) else &#123; return &#125; 1.2 创建处理请求的handle 参数一: 图片类型 参数二: 字典类型, 有默认值为[:] 1let requestHandle = VNImageRequestHandler(ciImage: ciImage, options: [:]) 1.3 创建回调闭包 两个参数, 无返回值 VNRequest: 是所有请求Request的父类 1public typealias VNRequestCompletionHandler = (VNRequest, Error?) -&gt; Swift.Void 具体代码如下: 12345//4. 设置回调let completionHandle: VNRequestCompletionHandler = &#123; request, error in let observations = request.results //识别出来的对象数组 &#125; 1.4 创建识别请求 两种初始化方式 12345//无参数public convenience init() //闭包参数public init(completionHandler: Vision.VNRequestCompletionHandler? = nil) 这里使用带闭包的初始化方式 1let baseRequest = VNDetectTextRectanglesRequest(completionHandler: completionHandle) 属性设置(是否识别具体的每一个文字) 12// 设置识别具体文字baseRequest.setValue(true, forKey: \"reportCharacterBoxes\") 不设置该属性, 识别出来的是一行文字 1.5 发送请求1open func perform(_ requests: [VNRequest]) throws 该方法会抛出一个异常错误 在连续不断(摄像头扫描)发送请求过程中, 必须在子线程执行该方法, 否则会造成线程堵塞 12345678//6. 发送请求DispatchQueue.global().async &#123; do&#123; try requestHandle.perform([baseRequest]) &#125;catch&#123; print(\"Throws：\\(error)\") &#125;&#125; 1.6 处理识别的Observations对象 识别出来的results是[Any]?类型 根据boundingBox属性可以获取到对应的文本区域的尺寸 需要注意的是: boundingBox得到的是相对iamge的比例尺寸, 都是小于1的 Y轴坐标于UIView坐标系是相反的 1234567891011121314151617181920//1. 获取识别到的VNTextObservationguard let boxArr = observations as? [VNTextObservation] else &#123; return &#125; //2. 创建rect数组var bigRects = [CGRect](), smallRects = [CGRect]() //3. 遍历识别结果for boxObj in boxArr &#123; // 3.1尺寸转换 //获取一行文本的区域位置 bigRects.append(convertRect(boxObj.boundingBox, image)) //2. 获取 guard let rectangleArr = boxObj.characterBoxes else &#123; continue &#125; for rectangle in rectangleArr&#123; //3. 得到每一个字体的的尺寸 let boundBox = rectangle.boundingBox smallRects.append(convertRect(boundBox, image)) &#125;&#125; 坐标转换 1234567891011/// image坐标转换fileprivate func convertRect(_ rectangleRect: CGRect, _ image: UIImage) -&gt; CGRect &#123;//此处是将Image的实际尺寸转化成imageView的尺寸 let imageSize = image.scaleImage() let w = rectangleRect.width * imageSize.width let h = rectangleRect.height * imageSize.height let x = rectangleRect.minX * imageSize.width //该Y坐标与UIView的Y坐标是相反的 let y = (1 - rectangleRect.minY) * imageSize.height - h return CGRect(x: x, y: y, width: w, height: h)&#125; 2. 矩形识别和静态人脸识别 识别图像中的矩形 静态人脸识别 主要核心代码 12345678910111213141516171819202122232425//1. 转成ciimageguard let ciImage = CIImage(image: image) else &#123; return &#125; //2. 创建处理requestlet requestHandle = VNImageRequestHandler(ciImage: ciImage, options: [:]) //3. 创建baseRequest//大多数识别请求request都继承自VNImageBasedRequestvar baseRequest = VNImageBasedRequest() //4. 设置回调let completionHandle: VNRequestCompletionHandler = &#123; request, error in let observations = request.results self.handleImageObservable(type: type, image: image, observations, completeBack)&#125; //5. 创建识别请求switch type &#123;case .rectangle: baseRequest = VNDetectRectanglesRequest(completionHandler: completionHandle)case .staticFace: baseRequest = VNDetectFaceRectanglesRequest(completionHandler: completionHandle)default: break&#125; 处理识别的observation 1234567891011121314/// 矩形检测fileprivate func rectangleDectect(_ observations: [Any]?, image: UIImage, _ complecHandle: JunDetectHandle)&#123; //1. 获取识别到的VNRectangleObservation guard let boxArr = observations as? [VNRectangleObservation] else &#123; return &#125; //2. 创建rect数组 var bigRects = [CGRect]() //3. 遍历识别结果 for boxObj in boxArr &#123; // 3.1 bigRects.append(convertRect(boxObj.boundingBox, image)) &#125; //4. 回调结果 complecHandle(bigRects, [])&#125; 静态人脸识别需要将observation转成VNFaceObservation 1guard let boxArr = observations as? [VNFaceObservation] else &#123; return &#125; 3. 条码识别 这里请求的步骤与矩形识别相同, 这里不再赘述 需要注意的是,在初始化request的时候需要设一个置可识别的条码类型参数 这里先看一下VNDetectBarcodesRequest的两个参数 12345//支持的可识别的条码类型(需要直接用class调用)open class var supportedSymbologies: [VNBarcodeSymbology] &#123; get &#125;//设置可识别的条码类型open var symbologies: [VNBarcodeSymbology] 此处设置可识别到的条码类型为, 该请求支持是别的所有类型, 如下 注意supportedSymbologies参数的调用方法 12let request = VNDetectBarcodesRequest(completionHandler: completionHandle)request.symbologies = VNDetectBarcodesRequest.supportedSymbologies 条码识别不但能识别条码的位置信息, 还可以识别出条码的相关信息, 这里以二维码为例 这里需要将识别的observations转成[VNBarcodeObservation] VNBarcodeObservation有三个属性 12345678//条码类型: qr, code128....等等open var symbology: VNBarcodeSymbology &#123; get &#125;//条码的相关信息open var barcodeDescriptor: CIBarcodeDescriptor? &#123; get &#125;//如果是二维码, 则是二维码的网址链接 open var payloadStringValue: String? &#123; get &#125; 如上述图片识别出来的payloadStringValue参数则是小编的简书地址 下面是以上述图片的二维码为例处理的CIBarcodeDescriptor对象 有兴趣的可以仔细研究研究 12345678910111213/// 二维码信息处理fileprivate func qrCodeHandle(barCode: CIBarcodeDescriptor?)&#123; //1. 转成对应的条码对象 guard let code = barCode as? CIQRCodeDescriptor else &#123; return &#125; //2. 解读条码信息 let level = code.errorCorrectionLevel.hashValue let version = code.symbolVersion let mask = code.maskPattern let data = code.errorCorrectedPayload let dataStr = String(data: data, encoding: .utf8) print(\"这是二维码信息--\", level, \"---\", version, \"----\", mask, \"---\", dataStr ?? \"\")&#125; 4. 人脸特征识别 可识别出人脸的轮廓, 眼睛, 鼻子, 嘴巴等具体位置 VNFaceLandmarks2D介绍 1234567891011121314151617181920212223/// 脸部轮廓var faceContour: VNFaceLandmarkRegion2D?/// 左眼, 右眼var leftEye: VNFaceLandmarkRegion2D?var rightEye: VNFaceLandmarkRegion2D?/// 左睫毛, 右睫毛var leftEyebrow: VNFaceLandmarkRegion2D?var rightEyebrow: VNFaceLandmarkRegion2D?/// 左眼瞳, 右眼瞳var leftPupil: VNFaceLandmarkRegion2D?var rightPupil: VNFaceLandmarkRegion2D?/// 鼻子, 鼻嵴, 正中线var nose: VNFaceLandmarkRegion2D?var noseCrest: VNFaceLandmarkRegion2D?var medianLine: VNFaceLandmarkRegion2D?/// 外唇, 内唇var outerLips: VNFaceLandmarkRegion2D?var innerLips: VNFaceLandmarkRegion2D? 12345//某一部位所有的像素点@nonobjc public var normalizedPoints: [CGPoint] &#123; get &#125;//某一部位的所有像素点的个数open var pointCount: Int &#123; get &#125; 将所有的像素点坐标转换成image对应的尺寸坐标 使用图像上下文, 对应部位画线 在UIView中重写func draw(_ rect: CGRect)方法 1234567891011121314151617181920212223//5.1 获取当前上下文let content = UIGraphicsGetCurrentContext() //5.2 设置填充颜色(setStroke设置描边颜色)UIColor.green.set() //5.3 设置宽度content?.setLineWidth(2) //5.4. 设置线的类型(连接处)content?.setLineJoin(.round)content?.setLineCap(.round) //5.5. 设置抗锯齿效果content?.setShouldAntialias(true)content?.setAllowsAntialiasing(true) //5.6 开始绘制content?.addLines(between: pointArr)content?.drawPath(using: .stroke) //5.7 结束绘制content?.strokePath() 5. 动态人脸识别和实时动态添加 由于真机不好录制gif图(尝试了一下, 效果不是很好, 放弃了), 想看效果的朋友下载源码真机运行吧 这里提供一张可供扫描的图片 request的初始化这里就不做介绍了, 说一下handle的初始化方法 CVPixelBuffer: 扫描实时输出的对象 12//1. 创建处理请求let faceHandle = VNImageRequestHandler(cvPixelBuffer: pixelBuffer, options: [:]) 主要强调一点, 相机扫描, 获取实时图像的过程, 必须在子线程执行, 否在会堵塞线程, 整个app失去响应, 亲自踩过的坑 1234567DispatchQueue.global().async &#123; do&#123; try faceHandle.perform([baseRequest]) &#125;catch&#123; print(\"Throws：\\(error)\") &#125;&#125; 扫描结果处理 动态人脸识别和静态人脸识别不同的地方就是, 动态实时刷新, 更新UI, 所以处理结果的方法相同 动态添加: 这里处理方式是添加一个眼镜效果 这里需要获取到两只眼睛的位置和宽度 先获取到左右眼的所有的像素点和像素点的个数 遍历所有的像素点, 转换成合适的坐标 将左右眼的所有的point, 分别获取X和Y坐标放到不同的数组 将数组有小到大排序, 得到X的最大和最小的差值, Y的最大和最小的差值 具体代码如下 123456789101112131415161718192021/// H偶去转换后的尺寸坐标fileprivate func getEyePoint(faceModel: FaceFeatureModel, position: AVCaptureDevice.Position) -&gt; CGRect&#123; //1. 获取左右眼 guard let leftEye = faceModel.leftEye else &#123; return CGRect.zero &#125; guard let rightEye = faceModel.rightEye else &#123; return CGRect.zero &#125; //2. 位置数组 let leftPoint = conventPoint(landmark: leftEye, faceRect: faceModel.faceObservation.boundingBox, position: position) let rightPoint = conventPoint(landmark: rightEye, faceRect: faceModel.faceObservation.boundingBox, position: position) //3. 排序 let pointXs = (leftPoint.0 + rightPoint.0).sorted() let pointYs = (leftPoint.1 + rightPoint.1).sorted() //4. 添加眼睛 let image = UIImage(named: \"eyes\")! let imageWidth = (pointXs.last ?? 0.0) - (pointXs.first ?? 0) + 40 let imageHeight = image.size.height / image.size.width * imageWidth return CGRect(x: (pointXs.first ?? 0) - 20, y: (pointYs.first ?? 0) - 5, width: imageWidth, height: imageHeight)&#125; 每一只眼睛的坐标处理 1234567891011121314151617181920212223/// 坐标转换fileprivate func conventPoint(landmark: VNFaceLandmarkRegion2D, faceRect: CGRect, position: AVCaptureDevice.Position) -&gt; ([CGFloat], [CGFloat])&#123; //1. 定义 var XArray = [CGFloat](), YArray = [CGFloat]() let viewRect = previewLayer.frame //2. 遍历 for i in 0..&lt;landmark.pointCount &#123; //2.1 获取当前位置并转化到合适尺寸 let point = landmark.normalizedPoints[i] let rectWidth = viewRect.width * faceRect.width let rectHeight = viewRect.height * faceRect.height let rectY = viewRect.height - (point.y * rectHeight + faceRect.minY * viewRect.height) var rectX = point.x * rectWidth + faceRect.minX * viewRect.width if position == .front&#123; rectX = viewRect.width + (point.x - 1) * rectWidth &#125; XArray.append(rectX) YArray.append(rectY) &#125; return (XArray, YArray)&#125; 最后获取到该CGRect, 添加眼镜效果即可 6. 物体跟踪 简介 我们在屏幕上点击某物体, 然后Vision就会根据点击的物体, 实时跟踪该物体 当你移动手机或者物体时, 识别的对象和红框的位置是统一的 这里我们出的的对象是VNDetectedObjectObservation 定义一个观察属性 1fileprivate var lastObservation: VNDetectedObjectObservation? 创建一个处理多个图像序列的请求 12//处理与多个图像序列的请求handlelet sequenceHandle = VNSequenceRequestHandler() 创建跟踪识别请求 1234//4. 创建跟踪识别请求let trackRequest = VNTrackObjectRequest(detectedObjectObservation: lastObservation, completionHandler: completionHandle)//将精度设置为高trackRequest.trackingLevel = .accurate 当用户点击屏幕时，我们想要找出用户点击的位置, 根据点击的位置, 获取到一个新的物体对象 123456//2. 转换坐标let convertRect = visionTool.convertRect(viewRect: redView.frame, layerRect: previewLayer.frame) //3. 根据点击的位置获取新的对象let newObservation = VNDetectedObjectObservation(boundingBox: convertRect)lastObservation = newObservation 获取到扫描的结果, 如果是一个VNDetectedObjectObservation对象, 重新赋值 12345//1. 获取一个实际的结果guard let newObservation = observations?.first as? VNDetectedObjectObservation else &#123; return &#125; //2. 重新赋值self.lastObservation = newObservation 根据获取到的新值, 获取物体的坐标位置 转换坐标, 改变红色框的位置 1234//4. 坐标转换let newRect = newObservation.boundingBoxlet convertRect = visionTool.convertRect(newRect, self.previewLayer.frame)self.redView.frame = convertRect 以上就是iOS 11的新框架Vision在Swift中的所有使用的情况 文中所列的内容可能有点空洞, 也稍微有点乱 小编也是刚接触Vision, 文中如有解释不全, 或者错误的地方, 还请不吝赐教 GitHub–Demo地址 注意: 这里只是列出了主要的核心代码,具体的代码逻辑请参考demo 文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编 如果方便的话, 还望star一下","categories":[{"name":"Swift黑科技","slug":"Swift黑科技","permalink":"https://titanjun.top/categories/Swift黑科技/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"Vision","slug":"Vision","permalink":"https://titanjun.top/tags/Vision/"}]},{"title":"iOS黑科技之(AVFoundation)动态人脸识别(二)","slug":"iOS黑科技之(AVFoundation)动态人脸识别(二)","date":"2017-11-22T06:50:00.000Z","updated":"2018-03-07T06:23:03.000Z","comments":true,"path":"2017/11/22/iOS黑科技之(AVFoundation)动态人脸识别(二)/","link":"","permalink":"https://titanjun.top/2017/11/22/iOS黑科技之(AVFoundation)动态人脸识别(二)/","excerpt":"人脸识别原理简介：每一张图片都是由每一个像素点组成，而每一个像素点中又有对应的颜色值(如RGB)，人的面部特征中，不同的五官，颜色值肯定存在差异，而人脸识别技术就是通过对照片中每一个像素的识别进行大量的算法处理，最终得出五官的轮廓","text":"人脸识别原理简介：每一张图片都是由每一个像素点组成，而每一个像素点中又有对应的颜色值(如RGB)，人的面部特征中，不同的五官，颜色值肯定存在差异，而人脸识别技术就是通过对照片中每一个像素的识别进行大量的算法处理，最终得出五官的轮廓 一. 首先介绍一些人脸识别的方式1. CoreImage静态人脸识别, 可识别照片, 图像等 详情可查看上一篇博客介绍 2. Face++ 是北京旷视科技有限公司旗下的新型视觉服务平台, 旨在提供简单易用，功能强大，平台通用的视觉服务 Face++是新一代云端视觉服务平台，提供一整套世界领先的人脸检测，人脸识别，面部分析的视觉技术服务 Face++百度百科介绍 Face++官网 3. OpenCV 由一系列 C 函数和少量 C++ 类构成, 实现了图像处理和计算机视觉方面的很多通用算法, 其他的具体的不是很了解 这是百度百科的内容 4. Vision Vision 是 Apple 在 WWDC 2017 伴随iOS 11推出的基于CoreML的图像识别框架 根据Vision官方文档看，Vision 本身就有Face Detection and Recognition(人脸检测识别)、Machine Learning Image Analysis(机器学习图片分析)、Barcode Detection(条形码检测)、Text Detection(文本检测)。。。。。等等这些功能 感兴趣的同学可以查看相关文档学习一下, 这里小编就不过多作介绍了 5. AVFoundation 可以用来使用和创建基于时间的视听媒体的框架 这里我们使用的人脸识别方式也是使用AVFoundation框架 二. 对关键类的简单介绍1. AVCaptureDevice:代表硬件设备 我们可以从这个类中获取手机硬件的照相机、声音传感器等。 当我们在应用程序中需要改变一些硬件设备的属性（例如：切换摄像头、闪光模式改变、相机聚焦改变）的时候必须要先为设备加锁，修改完成后解锁。 示例: 切换摄像头 123456789//4. 移除旧输入，添加新输入//4.1 设备加锁session.beginConfiguration()//4.2. 移除旧设备session.removeInput(deviceIn)//4.3 添加新设备session.addInput(newVideoInput)//4.4 设备解锁session.commitConfiguration() 2. AVCaptureDeviceInput:设备输入数据管理对象 可以根据AVCaptureDevice创建对应的AVCaptureDeviceInput对象， 该对象将会被添加到AVCaptureSession中管理,代表输入设备，它配置抽象硬件设备的ports。通常的输入设备有（麦克风，相机等） 3. AVCaptureOutput: 代表输出数据 输出的可以是图片（AVCaptureStillImageOutput）或者视频（AVCaptureMovieFileOutput） 4. AVCaptureSession: 媒体（音、视频）捕捉会话 负责把捕捉的音频视频数据输出到输出设备中。 一个AVCaptureSession可以有多个输入或输出。 是连接AVCaptureInput和AVCaptureOutput的桥梁，它协调input到output之间传输数据。 它有startRunning和stopRunning两种方法来开启会话和结束会话。 每个session称之为一个会话，也就是在应用运行过程中如果你需要改变会话的一些配置（例如：切换摄像头）,此时需要先开启配置，配置完成之后再提交配置。 5. AVCaptureVideoPreviewLayer: 图片预览层 我们的照片以及视频是如何显示在手机上的呢？那就是通过把这个对象添加到UIView的layer上的 好了, 上面吧啦吧啦的说了那么多废话, 那么我们的人脸识别究竟是怎样实现的呢? 下面干货来了 三. 添加扫描设备 获取设备(摄像头) 创建输入设备 创建扫描输出 创建捕捉回话 1. 输出设备 这里使用AVCaptureMetadataOutput, 可以扫描人脸, 二维码, 条形码等信息 必须设置代理, 否则获取不到扫描结果 需要设置要输出什么样的数据: face(人脸), qr(二维码)等等 12345678//3.创建原数据的输出对象let metadataOutput = AVCaptureMetadataOutput() //4.设置代理监听输出对象输出的数据，在主线程中刷新metadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)//7.告诉输出对象要输出什么样的数据,识别人脸, 最多可识别10张人脸metadataOutput.metadataObjectTypes = [.face] 主要代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546fileprivate func addScaningVideo()&#123; //1.获取输入设备（摄像头） guard let device = AVCaptureDevice.default(for: .video) else &#123; return &#125; //2.根据输入设备创建输入对象 guard let deviceIn = try? AVCaptureDeviceInput(device: device) else &#123; return &#125; deviceInput = deviceIn //3.创建原数据的输出对象 let metadataOutput = AVCaptureMetadataOutput() //4.设置代理监听输出对象输出的数据，在主线程中刷新 metadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main) //4.2 设置输出代理 faceDelegate = previewView //5.设置输出质量(高像素输出) session.sessionPreset = .high //6.添加输入和输出到会话 if session.canAddInput(deviceInput!) &#123; session.addInput(deviceInput!) &#125; if session.canAddOutput(metadataOutput) &#123; session.addOutput(metadataOutput) &#125; //7.告诉输出对象要输出什么样的数据,识别人脸, 最多可识别10张人脸 metadataOutput.metadataObjectTypes = [.face] //8.创建预览图层 previewLayer = AVCaptureVideoPreviewLayer(session: session) previewLayer.videoGravity = .resizeAspectFill previewLayer.frame = view.bounds previewView.layer.insertSublayer(previewLayer, at: 0) //9.设置有效扫描区域(默认整个屏幕区域)（每个取值0~1, 以屏幕右上角为坐标原点） metadataOutput.rectOfInterest = previewView.bounds //10. 开始扫描 if !session.isRunning &#123; DispatchQueue.global().async &#123; self.session.startRunning() &#125; &#125;&#125; 2. 切换摄像头 获取当前摄像头方向 创建新的输入input 移除旧输入capture, 添加新的输入capture 具体代码如下: 123456789101112131415161718192021222324252627282930@IBAction func switchCameraAction(_ sender: Any) &#123; //1. 执行转场动画 let anima = CATransition() anima.type = \"oglFlip\" anima.subtype = \"fromLeft\" anima.duration = 0.5 view.layer.add(anima, forKey: nil) //2. 获取当前摄像头 guard let deviceIn = deviceInput else &#123; return &#125; let position: AVCaptureDevice.Position = deviceIn.device.position == .back ? .front : .back //3. 创建新的input let deviceSession = AVCaptureDevice.DiscoverySession(deviceTypes: [.builtInWideAngleCamera], mediaType: .video, position: position) guard let newDevice = deviceSession.devices.filter(&#123; $0.position == position &#125;).first else &#123; return &#125; guard let newVideoInput = try? AVCaptureDeviceInput(device: newDevice) else &#123; return &#125; //4. 移除旧输入，添加新输入 //4.1 设备加锁 session.beginConfiguration() //4.2. 移除旧设备 session.removeInput(deviceIn) //4.3 添加新设备 session.addInput(newVideoInput) //4.4 设备解锁 session.commitConfiguration() //5. 保存最新输入 deviceInput = newVideoInput&#125; 3. 处理扫描结果 实现AVCaptureMetadataOutputObjectsDelegate该协议的协议方法(只有一个方法) 12//`metadataObjects`就是返回的扫描结果optional public func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) 4. AVMetadataFaceObject介绍 faceID: 人脸的唯一标识 扫描出来的每一个人, 有不同的faceID 同一个人, 不同的状态下(摇头, 歪头, 抬头等), 都会有不同faceID hasRollAngle: 是否有倾斜角,侧倾角(左右歪头)(BOOL类型) rollAngle: 倾斜角,侧倾角的角度(CGFloat类型) hasYawAngle: 是否有偏转角(左右摇头) yawAngle: 偏转角角度 5. 处理扫描结果5.1 获取预览图层的人脸数组 遍历扫描的人脸数组, 转换成在预览图层的人脸数组 主要是人脸在图层的左边的转换 返回转换后的新的数组 12345678910fileprivate func transformedFaces(faceObjs: [AVMetadataObject]) -&gt; [AVMetadataObject] &#123; var faceArr = [AVMetadataObject]() for face in faceObjs &#123; //将扫描的人脸对象转成在预览图层的人脸对象(主要是坐标的转换) if let transFace = previewLayer.transformedMetadataObject(for: face)&#123; faceArr.append(transFace) &#125; &#125; return faceArr&#125; 5.2 根据人脸位置添加红框 设置红框的frame 1faceLayer?.frame = face.bounds 根据偏转角和倾斜角的角度获取CATransform3D 12345678910111213141516171819fileprivate func transformDegress(yawAngle: CGFloat) -&gt; CATransform3D &#123; let yaw = degreesToRadians(degress: yawAngle) //围绕Y轴旋转 let yawTran = CATransform3DMakeRotation(yaw, 0, -1, 0) //红框旋转问题 return CATransform3DConcat(yawTran, CATransform3DIdentity)&#125;//处理偏转角问题fileprivate func transformDegress(rollAngle: CGFloat) -&gt; CATransform3D &#123; let roll = degreesToRadians(degress: rollAngle) //围绕Z轴旋转 return CATransform3DMakeRotation(roll, 0, 0, 1)&#125;//角度转换fileprivate func degreesToRadians(degress: CGFloat) -&gt; CGFloat&#123; return degress * CGFloat(Double.pi) / 180&#125; 根据有无偏转角和倾斜角旋转红框 123456789101112131415//3.4 设置偏转角(左右摇头)if face.hasYawAngle&#123; let tranform3D = transformDegress(yawAngle: face.yawAngle) //矩阵处理 faceLayer?.transform = CATransform3DConcat(faceLayer!.transform, tranform3D)&#125;//3.5 设置倾斜角,侧倾角(左右歪头)if face.hasRollAngle&#123; let tranform3D = transformDegress(rollAngle: face.rollAngle) //矩阵处理 faceLayer?.transform = CATransform3DConcat(faceLayer!.transform, tranform3D)&#125; 至此, 动态的人脸识别就完成了, 会在人脸位置增加红框显示, 并且红框会根据人脸的位置动态的, 实时的调整 下面就快拿起你的相机测试吧 GitHub–Demo地址 注意: 这里只是列出了主要的核心代码,具体的代码逻辑请参考demo 文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编","categories":[{"name":"Swift黑科技","slug":"Swift黑科技","permalink":"https://titanjun.top/categories/Swift黑科技/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"AVFoundation","slug":"AVFoundation","permalink":"https://titanjun.top/tags/AVFoundation/"}]},{"title":"iOS黑科技之(CoreImage)静态人脸识别(一)","slug":"iOS黑科技之(CoreImage)静态人脸识别(一)","date":"2017-11-22T06:39:00.000Z","updated":"2018-03-13T01:37:57.000Z","comments":true,"path":"2017/11/22/iOS黑科技之(CoreImage)静态人脸识别(一)/","link":"","permalink":"https://titanjun.top/2017/11/22/iOS黑科技之(CoreImage)静态人脸识别(一)/","excerpt":"人脸识别原理简介：每一张图片都是由每一个像素点组成，而每一个像素点中又有对应的颜色值(如RGB)，人的面部特征中，不同的五官，颜色值肯定存在差异，而人脸识别技术就是通过对照片中每一个像素的识别进行大量的算法处理，最终得出五官的轮廓","text":"人脸识别原理简介：每一张图片都是由每一个像素点组成，而每一个像素点中又有对应的颜色值(如RGB)，人的面部特征中，不同的五官，颜色值肯定存在差异，而人脸识别技术就是通过对照片中每一个像素的识别进行大量的算法处理，最终得出五官的轮廓 这里我们将使用CoreImage框架,进行静态的人脸识别(类似照片, 图像等) 苹果原生的人脸识别并不是一个独立的框架，而是放在CoreImage框架中 Apple 已经帮我们把image的分类处理好了 CoreImage是iOS5新增的强大类库之一，它可以处理图片的各种效果，什么饱和度啊，旋转变形啊，色彩啊等等。 在使用CoreImage之前要导入CoreImage.framework框架 一. 主要类介绍 CIImage Core Image中的图像类，类似于UIKit中的UIImage类。 CIContext: 上下文对象 所有图像处理都在CIContext对象中实现，通过Quartz 2D、OpenGL渲染CIImage对象; 如滤镜、颜色等渲染处理 CIColor：颜色 图片的关联与画布、图片像素颜色的处理。 CIVector：向量 图片的坐标向量等几何方法处理。 CIDetector特征识别类 该类集成了苹果有关特征识别的一些功能。 可检测图片中人脸的眼睛、嘴巴、等等 CIFilter 滤镜类，包含一个字典结构，对各种滤镜定义了属于自己的属性 CIFilter 产生一个CIImage 接受一到多的图片作为输入，经过一些过滤操作，产生指定输出的图片 CIFeature: 代表由 detector处理后产生的特征 二. 项目代码介绍1. 创建1.1 这里要先介绍一下检测器的类别123456789101112131415161718192021222324252627282930313233343536373839404142434445//人脸检测器public let CIDetectorTypeFace: String//矩形识别public let CIDetectorTypeRectangle: String//二维码识别public let CIDetectorTypeQRCode: String//文本识别public let CIDetectorTypeText: String//指定检测精度public let CIDetectorAccuracy: String//指定使用特征跟踪，这个功能就像相机中的人脸跟踪功能public let CIDetectorTracking: String//设置将要识别的特征的最小尺寸public let CIDetectorMinFeatureSize: String//针对矩形探测器的，用于设置返回矩形特征的最多个数。//这个关键字的值是一个1~...的NSNumber值。有效范围1 &lt; = CIDetectorMaxFeatureCount &lt; = 256。默认值为1public let CIDetectorMaxFeatureCount: String//脸部透视数, 值为包含1、3、5、7、9、11的NSNumber对象public let CIDetectorNumberOfAngles: String//设置识别方向，值是一个从1 ~ 8的整型的NSNumberpublic let CIDetectorImageOrientation: String//设置这个参数为true(bool类型的NSNumber)，识别器将提取眨眼特征public let CIDetectorEyeBlink: String//如果设置这个参数为ture(bool类型的NSNumber)，识别器将提取微笑特征public let CIDetectorSmile: String//用于设置每帧焦距，值得类型为floot类型的NSNumberpublic let CIDetectorFocalLength: String//用于设置矩形的长宽比，值得类型为floot类型的NSNumberpublic let CIDetectorAspectRatio: String//控制文本检测器是否应该检测子特征。默认值是否，值的类型为bool类型的NSNumberpublic let CIDetectorReturnSubFeatures: String 这里需要的是人脸识别的CIDetectorTypeFace 123456789101112//1. 创建上下文对象let context = CIContext()//2. UIImage转成CIImageguard let image = imageView.image else &#123; return &#125;guard let ciImage = CIImage(image: image) else &#123; return &#125;//3. 参数设置(精度设置)let parmes = [CIDetectorAccuracy: CIDetectorAccuracyHigh]//4. 创建识别类let detector = CIDetector(ofType: CIDetectorTypeFace, context: context, options: parmes) 2. 参数设置 这里设置了一个识别精度CIDetectorAccuracy，识别精度的值有： 12345//识别精度低，但识别速度快、性能高public let CIDetectorAccuracyLow: String // 识别精度高，但识别速度慢、性能低public let CIDetectorAccuracyHigh: String 除了精度的设置，还有CIDetectorMinFeatureSize用于设置将要识别的特征的最小尺寸，也就是说小于这个尺寸的特征将不识别。 对于人脸检测器，这个关键字的值是从0.0 ~ 1.0的NSNumber值，这个值表示：基于输入图像短边长度的百分比。有效值范围:0.01 &lt;= CIDetectorMinFeatureSize &lt;= 0.5。为这个参数设定更高值仅用于提高性能。默认值是0.15。 对于矩形探测器，这个关键字的值是从0.0 ~ 1.0的NSNumber值，这个值表示：基于输入图像短边长度的百分比。有效值范围:0.2 &lt;= CIDetectorMinFeatureSize &lt;= 1.0的默认值是0.2。 对于文本探测器，这个关键字的值是一个范围从0.0 ~ 1.0的NSNumber值，这个值表示：基于输入图像高度的百分比。有效值范围:0.0 &lt;= CIDetectorMinFeatureSize &lt;= 1.0。默认值是10/(输入图像的高度) 3. CIFaceFeature概述 CIFaceFeature是保存脸部所有信息的类 CIFaceFeature是CIFeature的子类 CIFeature类只保存基本信息， 所有的附加信息由子类(CIFaceFeature)保存 各属性简介: 1234567891011121314151617181920212223242526272829303132333435//检测到的脸部在图片中的frameopen var bounds: CGRect &#123; get &#125;//是否检测到左眼的位置open var hasLeftEyePosition: Bool &#123; get &#125;//左眼的位置open var leftEyePosition: CGPoint &#123; get &#125;//是否检测到右眼的位置open var hasRightEyePosition: Bool &#123; get &#125;//右眼的位置open var rightEyePosition: CGPoint &#123; get &#125;//是否检测到嘴巴的位置open var hasMouthPosition: Bool &#123; get &#125;//嘴巴的位置open var mouthPosition: CGPoint &#123; get &#125;//脸部是否倾斜 open var hasFaceAngle: Bool &#123; get &#125;//脸部倾斜角度open var faceAngle: Float &#123; get &#125;//是否微笑 open var hasSmile: Bool &#123; get &#125;//左眼是否闭上open var leftEyeClosed: Bool &#123; get &#125;//右眼是否闭上open var rightEyeClosed: Bool &#123; get &#125; 4. Core Image坐标系问题 如图: UIView坐标系 图中上半部分坐标系 Y轴自上而下依次增大 Core Image坐标系 图中下半部分显示坐标系 X轴与UIView坐标系相同, Y轴坐标系最底部为0, 自下而上依次增大, 与UIView坐标系相反 所以需要对以次坐标设置frame的控件, 做一次针对Y轴的翻转, 如下: 1resultView.transform = CGAffineTransform(scaleX: 1, y: -1) 5. 人脸检测(核心代码)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/// 通过人脸识别提取有效的人脸图片static func faceImagesByFaceRecognition(imageView: UIImageView, resultCallback: @escaping ((_ count: Int) -&gt; ())) &#123; //0. 删除子控件 let subViews = imageView.subviews for subview in subViews &#123; if subview.isKind(of: UIView.self) &#123; subview.removeFromSuperview() &#125; &#125; //1. 创建上下文对象 let context = CIContext() //2. UIImage转成CIImage guard let image = imageView.image else &#123; return &#125; guard let ciImage = CIImage(image: image) else &#123; return &#125; //3. 参数设置(精度设置) let parmes = [CIDetectorAccuracy: CIDetectorAccuracyHigh] //4. 创建识别类 let detector = CIDetector(ofType: CIDetectorTypeFace, context: context, options: parmes) //5. 找到识别其中的人连对象 guard let faceArr = detector?.features(in: ciImage) else &#123; return &#125; //6. 添加识别的红框 let resultView = UIView(frame: CGRect(x: 0, y: 0, width: imageView.frame.width, height: imageView.frame.height)) imageView.addSubview(resultView) //7. 遍历扫描结果 for faceFeature in faceArr &#123; resultView.addSubview(addRedrectangleView(rect: faceFeature.bounds)) //7.1 如果识别到眼睛 guard let feature = faceFeature as? CIFaceFeature else &#123; return &#125; //左眼 if feature.hasLeftEyePosition &#123; let leftView = addRedrectangleView(rect: CGRect(x: 0, y: 0, width: 5, height: 5)) leftView.center = feature.leftEyePosition resultView.addSubview(leftView) &#125; //右眼 if feature.hasRightEyePosition &#123; let rightView = addRedrectangleView(rect: CGRect(x: 0, y: 0, width: 5, height: 5)) rightView.setValue(feature.rightEyePosition, forKey: \"center\") resultView.addSubview(rightView) &#125; //7.2 识别嘴巴 if feature.hasMouthPosition &#123; let mouthView = addRedrectangleView(rect: CGRect(x: 0, y: 0, width: 10, height: 5)) mouthView.setValue(feature.mouthPosition, forKey: \"center\") resultView.addSubview(mouthView) &#125; &#125; //8. 将resultView沿x轴翻转 resultView.transform = CGAffineTransform(scaleX: 1, y: -1) //9. 结果回调 resultCallback(faceArr.count)&#125; 6. 检测结果展示 检测到的人脸部位展示红色矩形框 眼镜和嘴巴部位显示红色矩形框 照片随机选取的, 不喜勿喷 7. 注意事项: image的实际尺寸需要和imageView的尺寸完全一样,获取的脸部各个部位的尺寸才能完全吻合 这里我只做了简单的尺寸比例转换 代码如下: 123456789static func getScale(imageView: UIImageView, image: UIImage) -&gt; CGFloat&#123; let viewSize = imageView.frame.size let imageSize = image.size let widthScale = imageSize.width / viewSize.width let heightScale = imageSize.height / viewSize.height return widthScale &gt; heightScale ? widthScale : heightScale&#125; GitHub–Demo地址 注意: 这里只是列出了主要的核心代码,具体的代码逻辑请参考demo 文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编","categories":[{"name":"Swift黑科技","slug":"Swift黑科技","permalink":"https://titanjun.top/categories/Swift黑科技/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"CIDetector","slug":"CIDetector","permalink":"https://titanjun.top/tags/CIDetector/"},{"name":"AVFoundation","slug":"AVFoundation","permalink":"https://titanjun.top/tags/AVFoundation/"},{"name":"CoreImage","slug":"CoreImage","permalink":"https://titanjun.top/tags/CoreImage/"}]},{"title":"Swift之二维码的生成、识别和扫描","slug":"Swift之二维码的生成、识别和扫描","date":"2017-11-16T08:00:00.000Z","updated":"2018-03-13T01:32:06.000Z","comments":true,"path":"2017/11/16/Swift之二维码的生成、识别和扫描/","link":"","permalink":"https://titanjun.top/2017/11/16/Swift之二维码的生成、识别和扫描/","excerpt":"最近在项目中遇到了涉及二维码相关的问题, 这里想记录总结一下二维码相关技术","text":"最近在项目中遇到了涉及二维码相关的问题, 这里想记录总结一下二维码相关技术 一. 二维码的介绍 二维条码/二维码是用某种特定的几何图形按一定规律在平面分布的黑白相间的图形记录数据符号信息的 总结: 用图形记录标记一些信息,方便通过图形识别来获取信息 应用场景 信息获取（名片、地图、WIFI密码、资料） 手机电商（用户扫码、手机直接购物下单） 手机支付（扫描商品二维码，通过银行或第三方支付提供的手机端通道完成支付) 微信添加好友 二. 二维码的生成 生成二维码的方式 采用第三方框架(放弃) ZXing/ZBar 框架不支持64位(2015年2月1号起, - 不允许不支持64位处理器的APP 上架) 系统自带API 生成二维码的步骤 创建二维码滤镜–CIFilter 恢复滤镜的默认属性 设置滤镜的输入数据 将传入的字符串转换成Data(OC为NSData)数据 通过KVC来设置输入的内容inputMessage1. 二维码容错率 1filter?.setValue(\"H\", forKey: \"inputCorrectionLevel\") inputCorrectionLevel 是一个单字母（@”L”, @”M”, @”Q”, @”H” 中的一个），表示不同级别的容错率，默认为 @”M”. QR码有容错能力，QR码图形如果有破损，仍然可以被机器读取内容，最高可以到7%~30%面积破损仍可被读取,相对而言，容错率愈高，QR码图形面积愈大。所以一般折衷使用15%容错能力。 L水平 7%的字码可被修正. M水平 15%的字码可被修正 Q水平 25%的字码可被修正 H水平 30%的字码可被修正 代码: 123456789101112131415161718192021222324252627282930313233/* * @param inputMsg 二维码保存的信息 * @param fgImage 前景图片 */func generateCode(inputMsg: String, fgImage: UIImage?) -&gt; UIImage &#123; //1. 将内容生成二维码 //1.1 创建滤镜 let filter = CIFilter(name: \"CIQRCodeGenerator\") //1.2 恢复默认设置 filter?.setDefaults() //1.3 设置生成的二维码的容错率 //value = @\"L/M/Q/H\" filter?.setValue(\"H\", forKey: \"inputCorrectionLevel\") // 2.设置输入的内容(KVC) // 注意:key = inputMessage, value必须是NSData类型 let inputData = inputMsg.data(using: .utf8) filter?.setValue(inputData, forKey: \"inputMessage\") //3. 获取输出的图片 guard let outImage = filter?.outputImage else &#123; return UIImage() &#125; //4. 获取高清图片 let hdImage = getHDImage(outImage) //5. 判断是否有前景图片 if fgImage == nil&#123; return hdImage &#125; //6. 获取有前景图片的二维码 return getResultImage(hdImage: hdImage, fgImage: fgImage!)&#125; 2. 获取高清图片12345678//4. 获取高清图片fileprivate func getHDImage(_ outImage: CIImage) -&gt; UIImage &#123; let transform = CGAffineTransform(scaleX: 10, y: 10) //放大图片 let ciImage = outImage.transformed(by: transform) return UIImage(ciImage: ciImage)&#125; 3. 将图片合成到二维码中 需要用到图形上下文 将二维码画到图形上下文 将图片合成到图行上下文 123456789101112131415161718192021//获取前景图片fileprivate func getResultImage(hdImage: UIImage, fgImage: UIImage) -&gt; UIImage &#123; let hdSize = hdImage.size //1. 开启图形上下文 UIGraphicsBeginImageContext(hdSize) //2. 将高清图片画到上下文 hdImage.draw(in: CGRect(x: 0, y: 0, width: hdSize.width, height: hdSize.height)) //3. 将前景图片画到上下文 let fgWidth: CGFloat = 80 fgImage.draw(in: CGRect(x: (hdSize.width - fgWidth) / 2, y: (hdSize.height - fgWidth) / 2, width: fgWidth, height: fgWidth)) //4. 获取上下文 guard let resultImage = UIGraphicsGetImageFromCurrentImageContext() else &#123; return UIImage() &#125; //5. 关闭上下文 UIGraphicsEndImageContext() return resultImage&#125; 后续会研究彩色二维码的黑科技, 敬请期待… 识别二维码 识别图片中二维码步骤 创建探测器 属于CoreImage框架(CIDetector) 获取CIImage类型的图片 获取图片中所有符合特征的内容(CIQRCodeFeature) 遍历所有的特性(CIQRCodeFeature) 获取特征中代表的信息(messageString) 识别二维码的代码实现 1234567891011121314151617181920/* * @param qrCodeImage 二维码的图片 * @return 结果的数组 */func recognitionQRCode(qrCodeImage: UIImage) -&gt; [String]? &#123; //1. 创建过滤器 let detector = CIDetector(ofType: CIDetectorTypeQRCode, context: nil, options: nil) //2. 获取CIImage guard let ciImage = CIImage(image: qrCodeImage) else &#123; return nil &#125; //3. 识别二维码 guard let features = detector?.features(in: ciImage) else &#123; return nil &#125; //4. 遍历数组, 获取信息 var resultArr = [String]() for feature in features &#123; resultArr.append(feature.type) &#125; return resultArr&#125; 三. 二维码的扫描 创建输入设备(摄像头) 获取摄像头设备 创建输入对象 创建输出设置(元数据) 创建输出对象 设置输出对象的代理(在代理中获取扫描到的数据) 设置输出数据的类型 创建捕捉会话 将输入添加到会话中 将输出添加到会话中 添加预览图片(方便用于查看) 创建图层,将图片添加到View图层中 开始扫描 1. 懒加载输入输出中间会话12//输入输出中间桥梁(会话)fileprivate lazy var session : AVCaptureSession = AVCaptureSession() 2. 初始化扫描设备2.1. 注意: AVCaptureMetadataOutputObjectsDelegate的代理设置, 该协议中的方法会将扫描的结果返回12345678910111213141516171819202122232425262728293031323334353637383940fileprivate func addScaningVideo()&#123; //1.获取输入设备（摄像头） guard let device = AVCaptureDevice.default(for: .video) else &#123; return &#125; //2.根据输入设备创建输入对象 guard let deviceInput = try? AVCaptureDeviceInput(device: device) else &#123; return &#125; //3.创建原数据的输出对象 let metadataOutput = AVCaptureMetadataOutput() //4.设置代理监听输出对象输出的数据，在主线程中刷新 metadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main) //5.创建会话（桥梁） // let session = AVCaptureSession() //6.添加输入和输出到会话 if session.canAddInput(deviceInput) &#123; session.addInput(deviceInput) &#125; if session.canAddOutput(metadataOutput) &#123; session.addOutput(metadataOutput) &#125; //7.告诉输出对象要输出什么样的数据(二维码还是条形码),要先创建会话才能设置 metadataOutput.metadataObjectTypes = [.qr, .code128, .code39, .code93, .code39Mod43, .ean8, .ean13, .upce, .pdf417, .aztec] //8.创建预览图层 let previewLayer: AVCaptureVideoPreviewLayer = AVCaptureVideoPreviewLayer(session: session) previewLayer.videoGravity = .resizeAspectFill previewLayer.frame = view.bounds view.layer.insertSublayer(previewLayer, at: 0) //9.设置有效扫描区域(默认整个屏幕区域)（每个取值0~1, 以屏幕右上角为坐标原点） let rect = CGRect(x: scanImageView.frame.minY / kScreenHeight, y: scanImageView.frame.minX / kScreenWidth, width: scanImageView.frame.height / kScreenHeight, height: scanImageView.frame.width / kScreenWidth) metadataOutput.rectOfInterest = rect //10. 开始扫描 session.startRunning()&#125; 2.2 代理方法的实现 需要将扫描的结果转化成机器可读的编码数据,才能获取二维码的相关信息 1234567891011121314151617181920212223242526extension ScaningViewController: AVCaptureMetadataOutputObjectsDelegate &#123; func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) &#123; //1. 取出扫描到的数据: metadataObjects //2. 以震动的形式告知用户扫描成功 AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate)) //3. 关闭session session.stopRunning() //4. 遍历结果 var resultArr = [String]() for result in metadataObjects &#123; //转换成机器可读的编码数据 if let code = result as? AVMetadataMachineReadableCodeObject &#123; resultArr.append(code.stringValue ?? \"\") &#125;else &#123; resultArr.append(result.type.rawValue) &#125; &#125; //5. 将结果 let vc = ShowViewController() vc.scanDataArr = resultArr navigationController?.pushViewController(vc, animated: true) &#125;&#125; 项目地址: Github 感谢大家的支持","categories":[{"name":"Swift黑科技","slug":"Swift黑科技","permalink":"https://titanjun.top/categories/Swift黑科技/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"CIFilter","slug":"CIFilter","permalink":"https://titanjun.top/tags/CIFilter/"},{"name":"CIDetector","slug":"CIDetector","permalink":"https://titanjun.top/tags/CIDetector/"},{"name":"AVFoundation","slug":"AVFoundation","permalink":"https://titanjun.top/tags/AVFoundation/"}]},{"title":"Swift之删除HTML5页面的广告","slug":"Swift之删除HTML5页面的广告","date":"2017-11-11T07:19:34.000Z","updated":"2018-03-13T01:39:00.000Z","comments":true,"path":"2017/11/11/Swift之删除HTML5页面的广告/","link":"","permalink":"https://titanjun.top/2017/11/11/Swift之删除HTML5页面的广告/","excerpt":"好久没来博客了,最近工作中任务(Bug)比较多!除了改Bug之外发现最近新出的一部电视剧不错, 给大家推荐一下&lt;&lt;&lt;&lt;猎场&gt;&gt;&gt;&gt;","text":"好久没来博客了,最近工作中任务(Bug)比较多!除了改Bug之外发现最近新出的一部电视剧不错, 给大家推荐一下&lt;&lt;&lt;&lt;猎场&gt;&gt;&gt;&gt; 一. UIWebViewDelegate 好了,言归正传,今天遇到了一个关于UIWebView问题的问题,如何删除H5页面的广告问题(一般出现在第三方的H5页面的情况) APP中嵌入一个H5的网页，但出现的广告条或是无关头尾，相当大煞风景, 那该如何去掉呢? 嵌入webview 一段JavaScript代码来隐藏，目前Android和iOS都支持此方法(这就是iOS中常说的js和OC交互) UIWebVIew的基本使用这里就不多做介绍了 下面介绍一下UIWebViewDelegate的一些代理方法 12345678910111213//当网页视图被指示载入内容而得到通知。应当返回YES，这样会进行加载。通过导航类型参数可以得到请求发起的原因optional public func webView(_ webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool//UIWebView的控件加载网页的监听函数方法：//1. 当网页视图已经开始加载一个请求后，得到通知。optional public func webViewDidStartLoad(_ webView: UIWebView)//2. 当网页视图结束加载一个请求之后，得到通知。optional public func webViewDidFinishLoad(_ webView: UIWebView)//3. 当前请求加载中发生错误时，得到通知。optional public func webView(_ webView: UIWebView, didFailLoadWithError error: Error) 二. 基于JavaScript的H5代码 首先,我们先看一下HTML5在浏览器中的现实情况, 参考地址 下面我们就要找到广告或者其他你想删除的部分对应的HTML代码 用浏览器打开参考地址, 建议使用谷歌浏览器 找到浏览器的开发者工具, 按照如下操作 控制网页和js源码的显示方式 调节手机/电脑显示: 你要选择在那种情境下显示网页,通俗来说,就是模拟器 放大镜:你可以通过放大镜对网页上的控件进行选取,然后找到html代码 手机:转化为手机模式,但是前提必须要转换Device的模式,要不然,光是视图上的转变,没有实际的转变(注意:我现在拿手机的网页做示例,所有我需要转化,当你做的电脑的就不需要转换这些了) 下面这就是要找到广告对应的js源码了(这里以订阅按钮为例) 将右侧按钮为选中状态 用鼠标选中你要删除的控件(这里以订阅按钮为例), 这时你会发现右侧代码会有一行背景颜色被加深 我们要做的就是调用js语法删除这行js代码, 从而删除订阅按钮 找到该控件的class标签或者id标签 通过以下代码控制删除 1234//class类型document.getElementsByClassName('gg-item news-gg-img3').style.display = 'none'//id类型document.getElementsById('gg-item news-gg-img3').style.display = 'none' 如果找到的该控件所在的js代码没有class或者id标志, 可以继续找到其父控件,通过以下方式删除 1document.getElementsByClassName('gg-item news-gg-img3')[0].style.display='none' 三. 具体核心代码如下 删除广告后的效果如图 核心代码 123456789101112131415161718extension NoneADViewController: UIWebViewDelegate&#123; func webViewDidFinishLoad(_ webView: UIWebView) &#123; //最顶部的广告 webView.stringByEvaluatingJavaScript(from: \"document.getElementsByClassName('gg-item news-gg-img3')[0].style.display='none'\") //删除页面浮框广告 webView.stringByEvaluatingJavaScript(from: \"document.getElementsByClassName('dbleleven-wrap')[0].style.display='none'\") //第一张图片下面的广告 webView.stringByEvaluatingJavaScript(from: \"document.getElementsByClassName('baiduimageplusm-title-img-only')[0].style.display = 'none'\") &#125; func webView(_ webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool &#123; guard let urlStr = request.url?.absoluteString else &#123; return true &#125; print(urlStr) return true &#125;&#125;","categories":[{"name":"入坑指南","slug":"入坑指南","permalink":"https://titanjun.top/categories/入坑指南/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"HTML5","slug":"HTML5","permalink":"https://titanjun.top/tags/HTML5/"},{"name":"WebView","slug":"WebView","permalink":"https://titanjun.top/tags/WebView/"}]},{"title":"Swift之微信朋友圈图片浏览器","slug":"Swift之微信朋友圈图片浏览器","date":"2017-10-28T11:19:19.000Z","updated":"2018-03-13T01:39:40.000Z","comments":true,"path":"2017/10/28/Swift之微信朋友圈图片浏览器/","link":"","permalink":"https://titanjun.top/2017/10/28/Swift之微信朋友圈图片浏览器/","excerpt":"最近闲来无事,突然对微信, 微博, QQ等社交APP的九宫格的图片浏览功能非常感兴趣, 最近就尝试着研究了一下: 这里先附上Demo地址","text":"最近闲来无事,突然对微信, 微博, QQ等社交APP的九宫格的图片浏览功能非常感兴趣, 最近就尝试着研究了一下: 这里先附上Demo地址 在介绍项目之前, 先介绍三个基础知识 CATransition转场动画 ViewController自定义转场 UIBesization贝塞尔曲线 一. CATransition转场动画 示例代码 1234567//4. 转场动画let transition = CATransition()transition.type = transitionTypetransition.subtype = isNext ? kCATransitionFromRight : kCATransitionFromLefttransition.duration = 1downloadImage(url: imageURL)baseImage.layer.add(transition, forKey: \"transition\") 更多关于该动画的详细介绍, 可参考iOS出门必备之CoreAnimation(核心动画)中第七种CA动画, 故这里不多做介绍 二. ViewController自定义转场 从iOS7开始，苹果更新了自定义ViewController转场的API,会用到的几个协议protocol: 描述ViewController转场的： UIViewControllerTransitioningDelegate UINavigationControllerDelegate UITabBarControllerDelegate 定义动画内容的 UIViewControllerAnimatedTransitioning UIViewControllerInteractiveTransitioning 表示动画上下文的 UIViewControllerContextTransitioning 1-1. 描述ViewController转场的 为什么苹果要引入这一套API？因为在iOS7之前，做转场动画很麻烦，要写一大堆代码在ViewController中。 引入这一套API之后，在丰富功能的同时极大程度地降低了代码耦合，实现方式就是将之前在ViewController里面的代码通过protocol分离了出来。 顺着这个思路往下想，实现自定义转场动画首先需要找到ViewController的delegate。 苹果告诉我们切换ViewController有三种形式： UITabBarController内部切换 UINavigationController切换 present ViewController 这三种方式是不是需要不同的protocol呢？ 1-2. 详解Protocol UIViewControllerTransitioningDelegate 自定义模态转场动画时使用。 设置UIViewController的属性transitioningDelegate 1weak open var transitioningDelegate: UIViewControllerTransitioningDelegate? UINavigationControllerDelegate 自定义navigation转场动画时使用 设置UINavigationController的属性delegate 1weak open var delegate: UINavigationControllerDelegate? UITabBarControllerDelegate自定义tab转场动画时使用 设置UITabBarController的属性delegate 1weak open var delegate: UITabBarControllerDelegate? 实际上这三个protocol干的事情是一样的只不过他们的应用场景不同罢了。我们下面以UINavigationControllerDelegate为例，其他的类似 UINavigationControllerDelegate主要的方法 123456@available(iOS 7.0, *)optional public func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning?@available(iOS 7.0, *)optional public func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationControllerOperation, from fromVC: UIViewController, to toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? 两个方法分别返回UIViewControllerInteractiveTransitioning和UIViewControllerAnimatedTransitioning，它们的任务是描述动画行为（转场动画如何执行，就看它俩的）。 从名字可以看出，这两个protocol的区别在于是否是interactive的。如何理解？ interactive动画可以根据输入信息的变化改变动画的进程。例如iOS系统为UINavigationController提供的默认右滑退出手势就是一个interactive 动画，整个动画的进程由用户手指的移动距离控制 1-3. UIViewControllerInteractiveTransitioning协议 定义了两个属性可以做到平滑过渡 completionCurve: 交互结束后剩余动画的速率曲线 completionSpeed: 交互结束后动画的开始速率由该参数与原来的速率相乘得到，实际上是个缩放参数，这里应该使用单位变化速率(即你要的速率/距离)。 注意： completionSpeed会影响剩余的动画时间，而不是之前设定的转场动画时间剩下的时间； 当completionSpeed很小时剩余的动画时间可能会被拉伸得很长，所以过滤下较低的速率比较好。 如果不设置两个参数，转场动画将以原来的速率曲线在当前进度的速率继续。 不过从实际使用效果来看，往往不到0.5s的动画时间，基本上看不出什么效果来 1-4. 定义动画内容的UIViewControllerAnimatedTransitioning 必须实现的方法 12345//返回动画的执行时间public func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval//处理具体的动画 public func animateTransition(using transitionContext: UIViewControllerContextTransitioning) 1-5. 表示动画上下文UIViewControllerContextTransitioning UIViewControllerContextTransitioning提供了一系列方法 是唯一一个我们不需要实现的Protocol 下面是一些我们常用的属性和方法: 123456789101112//转场动画发生在该View中 public var containerView: UIView &#123; get &#125;//上报动画执行完毕public func completeTransition(_ didComplete: Bool)//根据key返回一个ViewController。我们通过`FromViewControllerKey`找到将被替换掉的VC，通过`ToViewControllerKey`找到将要显示的VCpublic func viewController(forKey key: UITransitionContextViewControllerKey) -&gt; UIViewController?//根据key返回一个view, 我们通过from找到将要消失的view, 根据to找到将要弹出的view@available(iOS 8.0, *)public func view(forKey key: UITransitionContextViewKey) -&gt; UIView? 1-5. UIViewControllerTransitioningDelegate自定义模态转场时使用1234567891011// 该方法是告诉系统,弹出动画交给谁来处理func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; isPresent = true return self&#125;// 该方法是告诉系统,消失动画交给谁来处理func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; isPresent = false return self&#125; 三. 图片浏览器项目介绍1. 项目结构Alamofire + MVVM 2. 自定义ViewController的弹出和消失动画2-1. 自定义ViewController弹出和消失的Protocol12345678910111213141516171819//MARK: 自定义协议protocol JunBrowsePresentDelefate: NSObjectProtocol &#123; /// 1. 提供弹出的imageView func imageForPresent(indexPath: IndexPath) -&gt; UIImageView /// 2. 提供弹出的imageView的frame func startImageRectForpresent(indexPath: IndexPath) -&gt; CGRect /// 3.提供弹出后imageView的frame func endImageRectForpresent(indexPath: IndexPath) -&gt; CGRect&#125;protocol JunBrowserDismissDelegate &#123; /// 1.提供推出的imageView func imageViewForDismiss() -&gt; UIImageView /// 2. 提供推出的indexPath func indexPathForDismiss() -&gt; IndexPath&#125; 2-2. 遵循协议 UIViewControllerTransitioningDelegate告诉系统弹出/消失动画的处理页面 UIViewControllerAnimatedTransitioning 需要返回动画的执行时间 需要在弹出和消失页面的时候分别执行不同的动画 12345678910111213141516171819202122232425262728//MARK: UIViewControllerTransitioningDelegateextension PhotoBrowseAnimation: UIViewControllerTransitioningDelegate &#123; // 该方法是告诉系统,弹出动画交给谁来处理 func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; isPresent = true return self &#125; // 该方法是告诉系统,消失动画交给谁来处理 func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; isPresent = false return self &#125;&#125;//MARK: 继承AnimatedTransitioning协议extension PhotoBrowseAnimation: UIViewControllerAnimatedTransitioning &#123; //返回动画的执行时间 func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return 0.6 &#125; //处理具体的动画 func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; isPresent ? presentAnimation(transitionContext) : dismissAnimation(transitionContext) &#125;&#125; 2-3. 图片列表界面1. 在点击需要展示的imageView的时候,调用下面的方法123456789101112131415// MARK:- 弹出照片浏览器extension JunScrollViewController &#123; fileprivate func presentPhotoBrowse(indexPath: IndexPath) &#123; //1. 创建图片浏览器 let photoBrowseVC = BrowseViewController(images: imageVM.imageArray, currentIndexP: indexPath) //2. 设置弹出样式为自定义 photoBrowseVC.modalPresentationStyle = .custom //3. 设置转场动画代理 photoBrowseVC.transitioningDelegate = photoAnimation //4. 设置broseAnimation的属性 photoAnimation.setProperty(indexPath: indexPath, self, photoBrowseVC) //5. 弹出图片浏览器 present(photoBrowseVC, animated: true, completion: nil) &#125;&#125; 2. 遵循并实现自定义的协议方法1234567891011121314151617181920212223242526272829303132333435363738//MARK: JunBrowsePresentDelefateextension JunScrollViewController: JunBrowsePresentDelefate &#123; func imageForPresent(indexPath: IndexPath) -&gt; UIImageView &#123; let imageV = UIImageView() imageV.contentMode = .scaleAspectFill imageV.clipsToBounds = true //设置图片 imageV.kf.setImage(with: URL(string: imageVM.imageArray[indexPath.item].pic74), placeholder: UIImage(named: \"coderJun\")) return imageV &#125; func startImageRectForpresent(indexPath: IndexPath) -&gt; CGRect &#123; // 1.取出cell guard let cell = imageCollection.cellForItem(at: indexPath) else &#123; return CGRect(x: imageCollection.bounds.width * 0.5, y: kScreenHeight + 50, width: 0, height: 0) &#125; // 2.计算转化为UIWindow上时的frame return imageCollection.convert( cell.frame, to: UIApplication.shared.keyWindow) &#125; func endImageRectForpresent(indexPath: IndexPath) -&gt; CGRect &#123; //1. 取出对应的image的url let imageUrl = URL(string: imageVM.imageArray[indexPath.item].pic74)! //2.从缓存中取出image var image = KingfisherManager.shared.cache.retrieveImageInDiskCache(forKey: imageUrl.absoluteString) if image == nil &#123; image = UIImage(named: \"coderJun\") &#125; // 3.根据image计算位置 let imageH = kScreenWidth / image!.size.width * image!.size.height let y: CGFloat = imageH &lt; kScreenHeight ? (kScreenHeight - imageH) / 2 : 0 return CGRect(x: 0, y: y, width: kScreenWidth, height: imageH) &#125;&#125; 2-4. 在图片展示界面 遵循并实现相关dismiss协议方法 该协议主要实现viewController返回到该图片对应的IndexPath所在的位置 123456789101112131415161718//MARK: JunBrowserDismissDelegateextension JunTranstionPhotoController: JunBrowserDismissDelegate&#123; func imageViewForDismiss() -&gt; UIImageView &#123; let imageV = UIImageView() imageV.contentMode = .scaleAspectFill imageV.clipsToBounds = true //设置图片 imageV.image = baseImage.image imageV.frame = baseImage.convert(baseImage.frame, to: UIApplication.shared.keyWindow) return imageV &#125; func indexPathForDismiss() -&gt; IndexPath &#123; return IndexPath(item: currentIndex, section: 0) &#125;&#125; GitHubDemo地址 注意: 这里只是列出了主要的核心代码,具体的代码逻辑请参考demo 文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编","categories":[{"name":"Swiftk框架","slug":"Swiftk框架","permalink":"https://titanjun.top/categories/Swiftk框架/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"CATransition","slug":"CATransition","permalink":"https://titanjun.top/tags/CATransition/"},{"name":"UIBesizationv","slug":"UIBesizationv","permalink":"https://titanjun.top/tags/UIBesizationv/"}]},{"title":"Swift开发之3DTouch实用演练","slug":"Swift开发之3DTouch实用演练","date":"2017-10-22T23:54:58.000Z","updated":"2018-04-10T08:55:34.541Z","comments":true,"path":"2017/10/23/Swift开发之3DTouch实用演练/","link":"","permalink":"https://titanjun.top/2017/10/23/Swift开发之3DTouch实用演练/","excerpt":"2015年，苹果发布了iOS9以及iphone6s/iphone6s Plus，其中最具有创新的就是新的触控方式3D Touch,相对于多点触摸在平面二维空间的操作，3D Touch技术增加了对力度和手指面积的感知，可以通过长按快速预览、查看你想要的短信、图片或者超链接等内容，Peek和Pop手势的响应时间可迅捷到 10ms和15ms等。","text":"2015年，苹果发布了iOS9以及iphone6s/iphone6s Plus，其中最具有创新的就是新的触控方式3D Touch,相对于多点触摸在平面二维空间的操作，3D Touch技术增加了对力度和手指面积的感知，可以通过长按快速预览、查看你想要的短信、图片或者超链接等内容，Peek和Pop手势的响应时间可迅捷到 10ms和15ms等。 用户现在可以按主屏幕图标立即访问应用程序提供的功能。 在您的应用程序中，用户现在可以按视图来查看其他内容的预览，并获得对功能的加速访问 在日常开发中,我们经常需要使用3D Touch中的两个功能 在主屏幕上对应用图标使用3DTouch操作 在应用程序内对某一控件使用3DTouch操作 功能需要iOS9以上系统和iphone6s/iphone6s Plus及以上机型(模拟机现在也是可以的) demo地址 一. 效果演练1. 主屏幕快速操作 通过按下iPhone 6s或iPhone 6s Plus上的应用程序图标，用户可以获得一组快速操作。 当用户选择快速操作时，您的应用程序激活或启动，并跳转到相应界面 2. Peek and Pop 对界面内某一控件的3DTouch操作 Peek和Pop是应用内的一种全新交互模式,当用户不断增加力量在控件上按压,会依次进入四个阶段 轻按控件,除触发Peek的控件外,其他区域全部虚化 继续用力Peek被触发,展示Pop界面快照 向上滑动展示快捷选项 继续用力跳转进入Pop界面 3. 注意 3D Touch仅在3D Touch设备上可用，如果启用。在iOS 9以上，默认情况下启用3D Touch。 用户可以在设置&gt;常规&gt;辅助功能&gt; 3D触摸中关闭3D触摸。 当3D Touch可用时，利用其功能。当它不可用时，提供替代方法，例如通过使用触摸和保持。 3D Touch功能支持VoiceOver。 二. 主屏幕操作 ShortcutItem功能允许用户在主屏幕上对应用图标使用3DTouch操作,如果本次操作有效,则会给出几个快捷可选项允许用户进行操作 主屏幕icon上的快捷标签的实现方式有两种，一种是在工程文件info.plist里静态设置，另一种是代码的动态实现 优先显示静态添加，总数达到4个不再显示 1. 静态设置 在info.plist中添加UIApplicationShortcutItems关键字,以如下方式配置即可 其中各个关键字释义如下: UIApplicationShortcutItemType: 快捷可选项的特定字符串(必填) UIApplicationShortcutItemTitle: 快捷可选项的标题(必填) UIApplicationShortcutItemSubtitle: 快捷可选项的子标题(可选) UIApplicationShortcutItemIconType: 快捷可选项的图标(可选) UIApplicationShortcutItemIconFile: 快捷可选项的自定义图标(可选) UIApplicationShortcutItemUserInfo: 快捷可选项的附加信息(可选) 2. 动态添加UIApplicationShortcutItem2-1. UIApplicationShortcutItem初始化方法1UIApplicationShortcutItem(type: String, localizedTitle: String, localizedSubtitle: String?, icon: UIApplicationShortcutIcon?, userInfo: [AnyHashable : Any]?) 参数介绍 type: 快捷可选项的特定字符串(必填) localizedTitle: 快捷可选项的标题(必填) localizedSubtitle: 快捷可选项的子标题(可选) icon: 快捷可选项的图标(可选) userInfo: 快捷可选项的附加信息(可选) 2-1. 图标2-1-1. 初始化方式123456//方式一: 自定义图标//注: 自定义图标需要使用镂空图标,同时建议1倍图标大小为35*35UIApplicationShortcutIcon(templateImageName: String)//方式二: 使用系统图标UIApplicationShortcutIcon(type: UIApplicationShortcutIconType) 2-1-2. 系统图标样式如下 2-3. 具体实现代码如下1234567891011121314func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; //3D Touch let homeIcon = UIApplicationShortcutIcon(type: .compose) let homeItem = UIApplicationShortcutItem(type: \"homeAnchor\", localizedTitle: \"首页\", localizedSubtitle: \"点击进入首页\", icon: homeIcon, userInfo: nil) let playIcon = UIApplicationShortcutIcon(type: .play) let playItem = UIApplicationShortcutItem(type: \"play\", localizedTitle: \"播放\", localizedSubtitle: \"\", icon: playIcon, userInfo: nil) let userIcon = UIApplicationShortcutIcon(type: .search) let userItem = UIApplicationShortcutItem(type: \"username\", localizedTitle: \"用户名\", localizedSubtitle: \"\", icon: userIcon, userInfo: nil) UIApplication.shared.shortcutItems = [homeItem, playItem, userItem] return true&#125; 2-4. item点击跳转 可根据type标识判断 可根据localizedTitle标识判断 1234567891011121314151617181920//菜单跳转func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123; guard let tabBarVC = window?.rootViewController as? MainViewController else &#123; return &#125; //根据type唯一标识进行判断跳转, 或者根据localizedTitle判断 switch shortcutItem.type &#123; case \"homeAnchor\": tabBarVC.selectedIndex = 1 case \"play\": let username = ShowRoomViewController() username.hidesBottomBarWhenPushed = true tabBarVC.selectedViewController?.childViewControllers.first?.present(username, animated: true, completion: nil) case \"username\": let username = NameViewController() username.hidesBottomBarWhenPushed = true tabBarVC.selectedViewController?.childViewControllers.last?.navigationController?.pushViewController(username, animated: true) default: tabBarVC.selectedIndex = 0 &#125;&#125; 三. Peek and Pop Peek和Pop是应用内的一种全新交互模式,当用户不断增加力量在控件上按压,会依次进入四个阶段 这里小编将通过ViewController里面的UITableViewCell进行延时功能 注意: 在动态添加快捷可选项前,需要用判断是否支持3D Touch功能,以免在不支持的设备上运行程序导致闪退 1. 判断是否支持3D Touch功能123456789101112131415161718192021func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; var cell = tableView.dequeueReusableCell(withIdentifier: \"cell\") let model = happyVM.anchorGroups[indexPath.section].anchors[indexPath.row] if cell == nil &#123; cell = UITableViewCell(style: .default, reuseIdentifier: \"cell\") cell?.textLabel?.text = model.room_name cell?.accessoryType = .disclosureIndicator &#125; //这里是添加判断是否支持3D Touch的代码 if #available(iOS 9.0, *) &#123; if traitCollection.forceTouchCapability == .available &#123; //支持3D Touch //注册Peek &amp; Pop功能 registerForPreviewing(with: self, sourceView: cell!) &#125; &#125; return cell!&#125; 检测是否支持3D Touch：UIForceTouchCapability是一个枚举值,取值如下： 123case unknown //3D Touch检测失败case unavailable //3D Touch不可用case available //3D Touch可用 2. 给对应view注册3Dtouch事件 在判断支持3Dtouch里面注册 12//注册Peek &amp; Pop功能self.registerForPreviewing(with: self, sourceView: cell!) 3. 遵守UIViewControllerPreviewingDelegate协议 需要实现Peek &amp; Pop交互的控件所在的控制器遵循协议并实现两个代理方法 3-1. 当进入Peek状态时,系统会回调如下方法12345678910111213141516171819func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? &#123; //1. 获取按压的cell所在的行 guard let cell = previewingContext.sourceView as? UITableViewCell else &#123; return UIViewController() &#125; let indexPath = tableVIew.indexPath(for: cell) ?? IndexPath(row: 0, section: 0) //2. 设定预览界面 let vc = ShowRoomViewController() // 预览区域大小(可不设置), 0为默认尺寸 vc.preferredContentSize = CGSize(width: 0, height: 0) vc.showStr = \"我是第\\(indexPath.row)行用力按压进来的\" //调整不被虚化的范围，按压的那个cell不被虚化（轻轻按压时周边会被虚化，再少用力展示预览，再加力跳页至设定界面） let rect = CGRect(x: 0, y: 0, width: kScreenWidth, height: 44) //设置触发操作的视图的不被虚化的区域 previewingContext.sourceRect = rect //返回预览界面 return vc&#125; 3-2. 当进入Pop状态时,系统会回调如下方法 用力按压进入viewControllerToCommit 1234func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewController) &#123; viewControllerToCommit.hidesBottomBarWhenPushed = true show(viewControllerToCommit, sender: self)&#125; 来看看效果 3-4. 当弹出预览时，上滑预览视图，出现预览视图中快捷选项1var previewActionItems: [UIPreviewActionItem] &#123; get &#125; previewActionItems用户在3D Touch预览上向上滑动时显示的快速操作 在将要弹出的页面内重写previewActionItems的get属性 12345678910111213141516171819202122232425262728extension ShowRoomViewController &#123; //重写previewActionItems的get方法 override var previewActionItems: [UIPreviewActionItem] &#123; let action1 = UIPreviewAction(title: \"跳转\", style: .default) &#123; (action, previewViewController) in let showVC = ShowRoomViewController() showVC.hidesBottomBarWhenPushed = true previewViewController.navigationController?.pushViewController(showVC, animated: true) &#125; let action3 = UIPreviewAction(title: \"取消\", style: .destructive) &#123; (action, previewViewController) in print(\"我是取消按钮\") &#125; ////该按钮可以是一个组，点击该组时，跳到组里面的按钮。 let subAction1 = UIPreviewAction(title: \"测试1\", style: .selected) &#123; (action, previewViewController) in print(\"我是测试按钮1\") &#125; let subAction2 = UIPreviewAction(title: \"测试2\", style: .selected) &#123; (action, previewViewController) in print(\"我是测试按钮2\") &#125; let subAction3 = UIPreviewAction(title: \"测试3\", style: .selected) &#123; (action, previewViewController) in print(\"我是测试按钮3\") &#125; let groupAction = UIPreviewActionGroup(title: \"更多\", style: .default, actions: [subAction1, subAction2, subAction3]) return [action1, action3, groupAction] &#125;&#125; action的各种样式 123456789public enum UIPreviewActionStyle : Int &#123; //默认样式 case `default` //右侧有对勾的样式 case selected //红色字体的样式 case destructive&#125; 3-5. force 和 maximumPossibleForce 到此，3DTouch在APP中的集成就先介绍这些，3DTouch中还有个重要的属性–压力属性（force 和 maximumPossibleForce）这里简单介绍下 手指在屏幕上慢慢增加力度在减少力度，可以看到view背景色的变化 程序运行后找到我的 -&gt; 头像(用户名)查看效果 代码找到NameViewController.swift查看 12345678910override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let touch = touches.first ?? UITouch() //获取重按力度 print(\"平均触摸的力--\\(touch.force)\") print(\"触摸的最大可能力--\\(touch.maximumPossibleForce)\") let change = touch.force / touch.maximumPossibleForce view.backgroundColor = UIColor(red: 0.5, green: 0.5, blue: change, alpha: 1)&#125; 此外还有以下属性, 详细可参考3D Touch官方文档 1234567891011121314151617181920212223242526272829303132var tapCount: Int//手指触摸此次触摸的次数。var timestamp: TimeInterval//触摸发生的时间或最后一次突变的时间。var type: UITouchType//触摸的类型。enum UITouchType//接收的触摸类型。var phase: UITouchPhase//触摸的阶段。enum UITouchPhase//手指触摸的阶段。var maximumPossibleForce: CGFloat//触摸的最大可能力。var force: CGFloat//触摸力，其中值表示平均触摸的力（由系统预定，不是用户特定的）。1.0var altitudeAngle: CGFloat//手写笔的高度（弧度）。func azimuthAngle(in: UIView?)//返回触控笔的方位角（弧度）。func azimuthUnitVector(in: UIView?)//返回指向触控笔方位角方向的单位向量。 最后附上Demo地址 参考资料 iOS 3D touch开发 3D Touch官方文档","categories":[{"name":"高级用法","slug":"高级用法","permalink":"https://titanjun.top/categories/高级用法/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"3DTouch","slug":"3DTouch","permalink":"https://titanjun.top/tags/3DTouch/"}]},{"title":"ReactNaive之CSS和Flex布局","slug":"ReactNaive之CSS和Flex布局","date":"2017-10-22T23:54:34.000Z","updated":"2018-03-13T01:27:00.000Z","comments":true,"path":"2017/10/23/ReactNaive之CSS和Flex布局/","link":"","permalink":"https://titanjun.top/2017/10/23/ReactNaive之CSS和Flex布局/","excerpt":"ReactNaive之CSS和Flex布局","text":"ReactNaive之CSS和Flex布局 一. {}和()的使用1. {}的使用1-1. ReactNative中，使用表达式的时候需要用{}包住1style=&#123;styles.mainStyle&#125; 1-2. ReactNative中,在字符串中使用变量的时候，需要用{}包住12var str = 'hello'&lt;Text&gt;&#123;str&#125;&lt;/Text&gt; 1-3. ReactNative中，对象，字典需要用{}包住 style = {},最外层表达式，用{}包住 {flex:1},对象，用{}包住 1&lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;&lt;/View&gt; 2. ()的使用 创建组件&lt;View&gt;&lt;/View&gt;，必须要用()包住 因此只要返回组件，都需要用() 1234567render()&#123; return ( &lt;View style=&#123;styles.mainStyle&#125;&gt; &lt;/View&gt; )&#125; 二. ReactNative之CSS布局 ReactNative支持CSS中的布局属性，因此可以使用CSS布局属性 CSS颜色大全，下面会用到，点击这CSS颜色代码大全 1. 视图边框 什么时候使用？想设置自己周边有边框的时候 注意点：一定要设置边框宽度 1234567borderBottomWidth number //底部边框宽度borderLeftWidth number //左边框宽度borderRightWidth number //右边框宽度borderTopWidth number //顶部边框宽度borderWidth number //边框宽度border&lt;Bottom|Left|Right|Top&gt;Color //各方向边框的颜色,&lt;&gt;表示连着一起，例如borderBottomColorborderColor //边框颜色 2. 尺寸2-1. 设置宽高12width numberheight number 2-2. 外边距 设置组件与组件之间的间距 注意：第一个组件比较特殊，参照父组件，与父控件之间的间距。 其他组件间距，相对于上一个组件 什么时候使用？想设置自己在父控件的位置的时候使用 123456789margin number 外边距marginBottom number 下外边距marginHorizontal number 左右外边距marginLeft number 左外边距marginRight number 右外边距marginTop number 上外边距marginVertical number 上下外边距//注意marginRight和width冲突，如果设置了width，marginRight无效。 2-3. 内边距 设置子控件与当前控件的位置 什么时候使用？想设置自己的子控件相对自己的位置的时候使用 1234567padding number 内边距paddingBottom number 下内边距paddingHorizontal number 左右内边距paddingLeft number 做内边距paddingRight number 右内边距paddingTop number 上内边距paddingVertical number 上下内边距 2-4. 相对定位和绝对定位2-4-1. 边缘1234left number 左边缘。right number 右边缘。top number 顶部边缘。bottom number 底部边缘。 2-4-2. 定位(position): 通过 left, top, right 以及 bottom 边缘属性进行定位。 12absolute：绝对定位，参照父控件位置定位relative：相对定位，参照当前控件原始位置定位 什么时候使用绝对定位，当想把一个已经设置了宽度的控件快速的放在左下角，右下角的时候，可以使用绝对定位 什么时候使用相对定位，当想相对自己做出一些改变的时候，采用相对定位,比如相对自己，往下移动一点 ReactNative之Flex布局 一般使用ReactNative开发App,一般都采用Flex布局，使用这套布局就非常快。 1. Flex简介 Flex又叫弹性布局，会把当前组件看做一个容器，他的所有子组件都是他容器中的成员，通过Flex，就能迅速的布局容器中的成员。 使用场景：当想快速布局一个组件中所有子组件的时候，可以使用Flex布局 2. Flex主轴和侧轴 Flex中有两个主要的概念：主轴和侧轴 主轴与侧轴的关系：相互垂直的。 主轴：决定容器中子组件默认的布局方向：水平，垂直 侧轴：决定容器中子组件与主轴垂直的布局方向 比如主轴水平，那么子组件默认就是水平布局排布，侧轴就是控制子组件在垂直方向的布局 3. flexDirection属性 flexDirection:决定主轴的方向，水平或者垂直，这样子组件就会水平排布或者垂直排布 flexDirection共有四个值，在RN中默认为column。 1234row（默认值）：主轴为水平方向，从左向右。依次排列row-reverse：主轴为水平方向，从右向左依次排列column：主轴为垂直方向，默认的排列方式，从上向下排列column-reverse：主轴为垂直方向，从下向上排列 4. flexWrap属性 flexWrap:决定子控件在父视图内是否允许多行排列。 flexWrap共有两个值，默认为nowrap。 12nowrap 组件只排列在一行上，可能导致溢出。wrap 组件在一行排列不下时，就进行多行排列 5. justifyContent justifyContent:决定子组件在主轴中具体布局，是靠左，还是居中等 justifyContent共有五个值，默认为flex-start 12345flex-start: //子组件向主轴起点对齐，如果主轴水平，从左开始，主轴垂直，从上开始。flex-end: //子组件向主轴终点对齐，如果主轴水平，从右开始，主轴垂直，从下开始。center: //居中显示，注意：并不是让某一个子组件居中，而是整体有居中效果space-between: //均匀分配,相邻元素间距离相同。每行第一个组件与行首对齐，每行最后一个组件与行尾对齐。space-around: //均匀分配,相邻元素间距离相同。每行第一个组件到行首的距离和每行最后一个组件到行尾的距离将会是相邻元素之间距离的一半 6. alignItems alignItems:决定子组件在测轴中具体布局一直都没有管过侧轴，如果侧轴垂直，决定子组件在上，还是下，或者居中 alignItems共有四个值，默认为stretch。 1234flex-start 子组件向侧轴起点对齐。flex-end 子组件向侧轴终点对齐。center 子组件在侧轴居中。stretch 子组件在侧轴方向被拉伸到与容器相同的高度或宽度。 7. alignSelf alignSelf:自定义自己的侧轴布局，用于一个子组件设置。 注意：当某个子组件不想参照默认的alignItems时，可以设置alignSelf，自定义自己的侧轴布局。 alignSelf共有五个值，默认为auto。 12345auto 继承它的父容器的alignItems属性。如果没有父容器则为 \"stretch\"flex-start 子组件向侧轴起点对齐。flex-end 子组件向侧轴终点对齐。center 子组件在侧轴居中。stretch 子组件在侧轴方向被拉伸到与容器相同的高度或宽度。 8. flex flex: 决定子控件在主轴中占据几等分。 flex: 任意数字，所有子控件flex相加，自己flex占总共多少，就有多少宽度. 三. ReactNative之组件属性(Props、State) 在App开发中，少不了组件之间的传值，在RN中组件之间通信需要用到Props和State。 1. Props(属性) 什么是Props？一般用于自定义组件，大多数组件在创建时就可以使用各种参数来进行定制，用于定制的这些参数就称为props（属性）。 props不能在自己的组件中修改, 只能在父组件中修改 如果想在自己的组件中修改属性, 需要用state name:就是Props，通过this.props.name访问 1&lt;Room name=\"小码哥\" /&gt; 注意：props是在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。 2. State State：如果以后想修改某个属性，就修改界面，就需要用state。 注意:State属性一般在constructor中声明(ES6)，在setState中修改数据. 定义state属性 123this.state = &#123; num:1,&#125;; 修改state属性 123this.setState(&#123; num : number&#125;)","categories":[{"name":"ReactNaive","slug":"ReactNaive","permalink":"https://titanjun.top/categories/ReactNaive/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://titanjun.top/tags/CSS/"},{"name":"Flex","slug":"Flex","permalink":"https://titanjun.top/tags/Flex/"}]},{"title":"Swift之Facebook的POP动画使用和实战","slug":"Swift之Facebook的POP动画使用和实战","date":"2017-10-17T13:18:38.000Z","updated":"2018-03-13T01:35:36.000Z","comments":true,"path":"2017/10/17/Swift之Facebook的POP动画使用和实战/","link":"","permalink":"https://titanjun.top/2017/10/17/Swift之Facebook的POP动画使用和实战/","excerpt":"POP是一个来自于Facebook，在iOS与OSX上通用的极具扩展性的动画引擎。它在基本的静态动画的基础上增加的弹簧动画与衰减动画，使之能创造出更真实更具物理性的交互动画。 Pop Animation在使用上和Core Animation很相似，都涉及Animation对象以及Animation的载体的概念 关于Core Animation的相关详解, 可参考我的上一篇文章Core Animation(核心动画) 不同的是Core Animation的载体只能是CALayer，而Pop Animation可以是任意基于NSObject的对象 POP 使用 Objective-C++ 编写，Objective-C++ 是对 C++ 的扩展 GitHub项目地址","text":"POP是一个来自于Facebook，在iOS与OSX上通用的极具扩展性的动画引擎。它在基本的静态动画的基础上增加的弹簧动画与衰减动画，使之能创造出更真实更具物理性的交互动画。 Pop Animation在使用上和Core Animation很相似，都涉及Animation对象以及Animation的载体的概念 关于Core Animation的相关详解, 可参考我的上一篇文章Core Animation(核心动画) 不同的是Core Animation的载体只能是CALayer，而Pop Animation可以是任意基于NSObject的对象 POP 使用 Objective-C++ 编写，Objective-C++ 是对 C++ 的扩展 GitHub项目地址 一. POP自我介绍 POP 目前由四部分组成：1. Animations；2. Engine；3. Utility；4. WebCore。 POP 动画极为流畅，主要在于Enimator 里，POP 通过 CADisplayLink 高达 60 FPS 的特性，打造了一个游戏级的动画引擎。 CADisplayLink 是类似 NSTimer 的定时器，不同之处在于，NSTimer 用于我们定义任务的执行周期、资料的更新周期，他的执行受到 CPU 的阻塞影响，而 CADisplayLink 则用于定义画面的重绘、动画的演变，他的执行基于 frames 的间隔。 通过 CADisplayLink，Apple 允许你将 App 的重绘速度设定到和屏幕刷新频率一致，由此你可以获得非常流畅的交互动画，这项技术的应用在游戏中非常常见，著名的 Cocos-2D 也应用了这个重要的技术。 WebCore 里包含了一些从 Apple 的开源的网页渲染引擎里拿出的源文件，与 Utility 里的组件一并，提供了 POP 的各项复杂计算的基本支持 二. POP参数介绍 POP默认支持三种动画，但同时也支持自定义动画 POPBasicAnimation //基础动画 POPSpringAnimation //弹簧动画 POPDecayAnimation //衰减动画 POPCustomAnimation //自定义动画 1、相关属性介绍1-1、属性简单介绍 POP动画大部分属性和CoreAnimation(核心动画)的含义和用法一样 具体可参考Core Animation(核心动画) 每种动画的特殊属性会在下文中继续介绍 1-2、动画可配置属性 CALayer层各属性(比较简单,就不加注释了) 123456789101112131415161718192021222324252627282930313233/** Common CALayer property names. */extern NSString * const kPOPLayerBackgroundColor;extern NSString * const kPOPLayerBounds;extern NSString * const kPOPLayerCornerRadius;extern NSString * const kPOPLayerBorderWidth;extern NSString * const kPOPLayerBorderColor;extern NSString * const kPOPLayerOpacity;extern NSString * const kPOPLayerPosition;extern NSString * const kPOPLayerPositionX;extern NSString * const kPOPLayerPositionY;extern NSString * const kPOPLayerRotation;extern NSString * const kPOPLayerRotationX;extern NSString * const kPOPLayerRotationY;extern NSString * const kPOPLayerScaleX;extern NSString * const kPOPLayerScaleXY;extern NSString * const kPOPLayerScaleY;extern NSString * const kPOPLayerSize;extern NSString * const kPOPLayerSubscaleXY;extern NSString * const kPOPLayerSubtranslationX;extern NSString * const kPOPLayerSubtranslationXY;extern NSString * const kPOPLayerSubtranslationY;extern NSString * const kPOPLayerSubtranslationZ;extern NSString * const kPOPLayerTranslationX;extern NSString * const kPOPLayerTranslationXY;extern NSString * const kPOPLayerTranslationY;extern NSString * const kPOPLayerTranslationZ;extern NSString * const kPOPLayerZPosition;extern NSString * const kPOPLayerShadowColor;extern NSString * const kPOPLayerShadowOffset;extern NSString * const kPOPLayerShadowOpacity;extern NSString * const kPOPLayerShadowRadius; UIVIew层 12345678910111213/** Common UIView property names. */extern NSString * const kPOPViewAlpha;extern NSString * const kPOPViewBackgroundColor;extern NSString * const kPOPViewBounds;extern NSString * const kPOPViewCenter;extern NSString * const kPOPViewFrame;extern NSString * const kPOPViewScaleX;extern NSString * const kPOPViewScaleXY;extern NSString * const kPOPViewScaleY;extern NSString * const kPOPViewSize;extern NSString * const kPOPViewTintColor; 其他层视图层 12345678910111213141516171819/** Common UINavigationBar property names. */extern NSString * const kPOPNavigationBarBarTintColor;/** Common UIToolbar property names. */extern NSString * const kPOPToolbarBarTintColor;/** Common UITabBar property names. */extern NSString * const kPOPTabBarBarTintColor;/** Common UILabel property names. */extern NSString * const kPOPLabelTextColor; 以上仅仅列出了常用的一些属性,更多控件/更多参考框架里面类POPAnimatableProperty.h 1-3、POPBasicAnimation可配置的属性与默认值为1234POPBasicAnimation *basic = [POPBasicAnimation linearAnimation];basic.fromValue = @(0);//从0开始 basic.toValue = @(3*60);//180秒后结束basic.duration = 3*60;//持续3分钟[lab pop_addAnimation:basic forKey:nil]; 12345let basic1 = POPBasicAnimation(propertyNamed: kPOPLayerPositionX)basic1?.fromValue = redView.layer.position.xbasic1?.toValue = 300basic1?.beginTime = CFTimeInterval() + 1.0redView.pop_add(basic1, forKey: \"position.x\") 三. POPBasicAnimation基础动画1. 先看一下效果, 其动画效果如下 2. 示例代码12345let basic1 = POPBasicAnimation(propertyNamed: kPOPLayerPositionX)basic1?.toValue = 300//开始时间basic1?.beginTime = CFTimeInterval() + 1.0redView.pop_add(basic1, forKey: \"position.x\") 3. 可以看到，添加一个动画最少仅需三步 1）定义一个animation对象，并指定对应的动画属性（kPOPLayerPositionX） 2）设置初始值结束值(初始值可以不指定，会默认从当前值开始） 3）添加到想产生动画的对象上 4. Core Animation 和 POP 运行动画对比 由于 POP 是基于定时器定时刷新添加动画的原理，那么如果将动画库运行在主线程上，会由于线程阻塞的问题导致动画效果出现卡顿、不流畅的情况。 更为关键的是，你不能将动画效果放在子线程，因为你不能将对 view 和 layer 的操作放到主线程之外 POP 受主线程阻塞的影响很大，在使用过程中，应避免在有可能发生主线程阻塞的情况下使用 POP ，避免制作卡顿的动画效果，产生不好的用户体验 四. POPSpringAnimation弹性动画1. 属性介绍 velocity: 设置动画开始速度 springBounciness: 振幅, 可以设置的范围是0-20，默认为4。值越大振动的幅度越大 springSpeed: 速度, 可以设置的范围是0-20，默认为12.值越大速度越快，结束的越快 dynamicsMass: 质量, 质量越大，动画的速度越慢，振动的幅度越大，结束的越慢 dynamicsTension: 拉力 拉力越大，动画的速度越快，结束的越快 dynamicsFriction: 摩擦力, 摩擦力越大，动画的速度越慢，振动的幅度越小。 注意: 以上的六个属性中一般只会设置springBounciness和springSpeed, 如有特殊需求才会设置其他属性 2. 代码示例12345678let spring = POPSpringAnimation(propertyNamed: kPOPViewScaleXY)//注意: 这里改变的是x和y的比例,参数赋值也要传两个; 若只需要其中一个,则可设置//`spring?.fromValue = 0.4`即可spring?.fromValue = CGSize(width: 0.3, height: 0.3)spring?.toValue = CGSize(width: 2, height: 2)spring?.springSpeed = 5spring?.springBounciness = 15lightBlue.pop_add(spring, forKey: \"scale\") 五. POPDecayAnimation POPDecayAnimation提供一个过阻尼效果（其实Spring是一种欠阻尼效果）可以实现类似UIScrollView的滑动衰减效果（是的你可以靠它来自己实现一个UIScrollView） 属性介绍 deceleration （负加速度, 衰减系数(越小则衰减得越快)） 是一个你会很少用到的值，默认是就是我们地球的 0.998，如果你开发APP给火星人用，那么这个值你使用 0.376 会更合适 velocity 也是必须和你操作的属性有相同的结构，如果你操作的是 bounds, 传CGRect类型;如果 velocity 是负值，那么就会反向递减 代码示例 12345let decay = POPDecayAnimation(propertyNamed: kPOPViewSize)decay?.velocity = CGSize(width: 300, height: pictureBtn.frame.height)//延迟1秒后执行decay?.beginTime = CACurrentMediaTime() + 1.0pictureBtn.pop_add(decay, forKey: \"size\") 六. 自定义属性POP默认支持的三种动画都继承自POPPropertyAnimation, POPPropertyAnimation中定义了一个叫property的属性（之前没有用到它是因为POP根据不同的默认动画属性帮你生成了默认的property这个属性则是用来驱动POP的动画效果中的重要一环 1. 实力模块12345678910111213141516if let proper = POPAnimatableProperty.property(withName: \"prop\", initializer: &#123; (prop) in guard let prop = prop else &#123; return &#125; //read prop.readBlock = &#123; (obj, values) in &#125; //write prop.writeBlock = &#123;(obj, values) in &#125; prop.threshold = 0.01 &#125;) as? POPAnimatableProperty &#123; anim.property = proper&#125; 2. 属性介绍 其组成就是一个readBlock一个writeBlock和一个threashold readBlock告诉POP当前的属性值 writeBlock中修改变化后的属性值 threashold决定了动画变化间隔的阈值 值越大writeBlock的调用次数越少 POPAnimatableProperty其实是POP中一个比较重要的东西 像上面提到的POP自带的动画属性 查看源代码可以看到也只是POP自动帮你设置好了POPAnimatableProperty而已 其作用就是当动画的某个时间片被触发时 告诉系统如何根据当前时间片做出变化 还是以一个实际的例子来说明如何使用自定义属性 比如我们要实现一个像系统的时钟APP里秒表计时的一个效果 3. 完整代码示例123456789101112131415161718192021222324252627if let proper = POPAnimatableProperty.property(withName: \"prop\", initializer: &#123; (prop) in guard let prop = prop else &#123; return &#125; //read prop.readBlock = &#123; (obj, values) in guard let array = values else &#123; return &#125; print(array[0]) &#125; //write prop.writeBlock = &#123;(obj, values) in guard let button = obj as? UIButton, let array = values else &#123; return &#125; let value = array[0] button.setTitle(String(format: \"%02d:%02d:%02d\", Int(value / 60), Int(value.truncatingRemainder(dividingBy: 60)), Int((value * 100).truncatingRemainder(dividingBy: 100))), for: .normal) &#125; prop.threshold = 0.01 &#125;) as? POPAnimatableProperty &#123; if let popBasic = POPBasicAnimation.linear() &#123; //秒表用线性的时间函数初始化 popBasic.property = proper popBasic.fromValue = 0 //从0开始 popBasic.toValue = 18 //到18秒 popBasic.duration = 18 //持续18秒 popBasic.beginTime = CACurrentMediaTime() + 2 //延迟2秒开始 pictureBtn.pop_add(popBasic, forKey: \"linear\") &#125;&#125; 4. 注意: 在Swift4.0版本(4.0之前版本未知)中,初始化出来的对象都是可选类型 POP官方的建议是添加if条件判断,详情可到GitHub上查看示例 正如上段代码所示: 闭包中涉及的可选类型都添加了guard判断 七. 类似微博中间发布按钮弹出动画先看一下效果吧 动画分为两个部分 中间六个按钮依次执行动画弹出 上面标题图片最后动画落下 下面来看一下部分的核心代码1. 六个按钮的弹出和消失动画1234567891011121314151617181920212223for i in 0..&lt;titles.count &#123; let button = BaseButton() button.setTitle(titles[i], for: .normal) button.setImage(UIImage(named: images[i]), for: .normal) button.addTarget(self, action: #selector(buttonClick(button:)), for: .touchUpInside) addSubview(button) //计算X/Y let row = i / maxCols let col = i % maxCols let buttonX = btnStsrtX + CGFloat(col) * (xMargin + buttonW) let buttonEndY = btnStartY + CGFloat(row) * buttonH let buttonStartY = buttonEndY - kScreenHeight //按钮动画 let popSpring = POPSpringAnimation(propertyNamed: kPOPViewFrame) popSpring?.fromValue = CGRect(x: buttonX, y: buttonStartY, width: buttonW, height: buttonH) popSpring?.toValue = CGRect(x: buttonX, y: buttonEndY, width: buttonW, height: buttonH) popSpring?.springBounciness = kSpringFactor popSpring?.springSpeed = kSpringFactor popSpring?.beginTime = CACurrentMediaTime() + kAnimationDelay * Double(i) button.pop_add(popSpring, forKey: \"spring\")&#125; 2. 最上部分标语的弹出和消失12345678910111213//z执行动画let imagePOP = POPSpringAnimation(propertyNamed: kPOPViewCenter)imagePOP?.fromValue = CGPoint(x: kScreenWidth * 0.5, y: 0.2 * kScreenHeight - kScreenHeight)imagePOP?.toValue = CGPoint(x: kScreenWidth * 0.5, y: 0.2 * kScreenHeight)imagePOP?.springSpeed = kSpringFactorimagePOP?.springBounciness = kSpringFactorimagePOP?.beginTime = CACurrentMediaTime() + Double(btnCount) * kAnimationDelayimagePOP?.completionBlock = &#123; popAnim, finished in //所有动画执行完毕,回复View点击事件 kRootView?.isUserInteractionEnabled = true self.isUserInteractionEnabled = true&#125;topImage.pop_add(imagePOP, forKey: nil) 以上是类似微博动画的部分核心代码, 具体代码详见GitHub项目, 喜欢请star 折叠图片 音量震动条 活动指示器 微博动画 倒计时-计时器 类似QQ信息条数的粘性动画 类似雷达-水波纹动画 注: 项目持续更新中……","categories":[{"name":"iOS动画","slug":"iOS动画","permalink":"https://titanjun.top/categories/iOS动画/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"Facebook POP","slug":"Facebook-POP","permalink":"https://titanjun.top/tags/Facebook-POP/"}]},{"title":"iOS出门必备之CoreAnimation(核心动画)","slug":"iOS出门必备之CoreAnimation(核心动画)","date":"2017-10-12T11:48:28.000Z","updated":"2018-03-10T15:34:40.000Z","comments":true,"path":"2017/10/12/iOS出门必备之CoreAnimation(核心动画)/","link":"","permalink":"https://titanjun.top/2017/10/12/iOS出门必备之CoreAnimation(核心动画)/","excerpt":"CoreAnimation 前段时间接触到了一个牛逼的动画框架POP,本来想来装装逼,突然发现,苹果大大的CoreAnimation我还不会用呢! 依稀记得乔帮主在2007年的WWDC大会上亲自为你演示Core Animation的强大：点击查看视频(不好意思,又装逼了) 言归正传,我只是来温习一下CoreAnimation,还望路过的大神不要吐槽我太low GitHub项目地址","text":"CoreAnimation 前段时间接触到了一个牛逼的动画框架POP,本来想来装装逼,突然发现,苹果大大的CoreAnimation我还不会用呢! 依稀记得乔帮主在2007年的WWDC大会上亲自为你演示Core Animation的强大：点击查看视频(不好意思,又装逼了) 言归正传,我只是来温习一下CoreAnimation,还望路过的大神不要吐槽我太low GitHub项目地址 一、Core Animation简介 Core Animation，中文翻译为核心动画，它是一组非常强大的动画处理API，使用它能做出非常炫丽的动画效果，而且往往是事半功倍。也就是说，使用少量的代码就可以实现非常强大的功能。 Core Animation可以用在Mac OS X和iOS平台。 Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。 要注意的是，Core Animation是直接作用在CALayer上的，并非UIView 通过调用CALayer的addAnimation:forKey:方法增加CAAnimation对象到CALayer中，这样就能开始执行动画了 通过调用CALayer的removeAnimationForKey:方法可以停止CALayer中的动画 二. Core Animation及其相关属性 要想执行动画，就必须初始化一个CAAnimation对象。 一般情况下，我们使用的比较多的是CAAnimation的子类，因此，先大致看看CAAnimation的继承结构 黑线代表继承，黑色文字代表类名，白色文字代表属性。其中CAMediaTiming是一个协议(protocol) 需要注意的是 CAAnimation是所有动画类的父类，但是它不能直接使用，应该使用它的子类 CAPropertyAnimation也是不能直接使用的，也要使用它的子类 能用的动画类只剩下4个：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup 常用属性 1). removedOnCompletion：默认为true，代表动画执行完毕后就从图层上移除 图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为false，不过还要设置fillMode为kCAFillModeForwards 2). timingFunction：控制动画运行的节奏 1234567891011121314151617181920/** timingFunction可选的值 **/@available(iOS 2.0, *)public let kCAMediaTimingFunctionLinear: String//1.(匀速): 在整个动画时间内动画都是以一个相同的速度来改变@available(iOS 2.0, *)public let kCAMediaTimingFunctionEaseIn: String//2. (渐进): 缓慢进入, 加速离开@available(iOS 2.0, *)public let kCAMediaTimingFunctionEaseOut: String//3. (渐出): 快速进入, 减速离开@available(iOS 2.0, *)public let kCAMediaTimingFunctionEaseInEaseOut: String//4. (渐进渐出): 缓慢进入, 中间加速, 减速离开@available(iOS 3.0, *)public let kCAMediaTimingFunctionDefault: String//5. (默认): 效果基本等同于EaseOut(渐出) 3). fillMode决定当前对象在非active时间段的行为。 要想fillMode有效，需设置removedOnCompletion = false fillMode可选的值 12345678910111213141516/* `fillMode' options. */@available(iOS 2.0, *)public let kCAFillModeForwards: String//1. 当动画结束后，layer会一直保持着动画最后的状态@available(iOS 2.0, *)public let kCAFillModeBackwards: String//2. 设置为该值，将会立即执行动画的第一帧，不论是否设置了 beginTime属性。观察发现，设置该值，刚开始视图不见，还不知道应用在哪里@available(iOS 2.0, *)public let kCAFillModeBoth: String//3. 该值是 kCAFillModeForwards 和 kCAFillModeBackwards的组合状态; 动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态@available(iOS 2.0, *)public let kCAFillModeRemoved: String//4. 默认值，动画将在设置的 beginTime 开始执行（如没有设置beginTime属性，则动画立即执行），动画执行完成后会将layer的改变恢复原状 4). delegate：动画代理，用来监听动画的执行过程 12345678910public protocol CAAnimationDelegate : NSObjectProtocol &#123; // 动画开始执行的时候触发这个方法 @available(iOS 2.0, *) optional public func animationDidStart(_ anim: CAAnimation) // 动画执行完毕的时候触发这个方法 @available(iOS 2.0, *) optional public func animationDidStop(_ anim: CAAnimation, finished flag: Bool)&#125; 5). 其他相关属性 123456789duration 动画的时长repeatCount 重复的次数。不停重复设置为 HUGE_VALFrepeatDuration 设置动画的时间。在该时间内动画一直执行，不计次数。beginTime 指定动画开始的时间。从开始延迟几秒的话，设置为【CACurrentMediaTime() + 秒数】 的方式timingFunction 设置动画的速度变化autoreverses 动画结束时是否执行逆动画fromValue 所改变属性的起始值(Swift中为Any类型,OC中要包装成NSValue对象)toValue 所改变属性的结束时的值(类型与fromValue相同)byValue 所改变属性相同起始值的改变量(类型与fromValue相同) 三. CABasicAnimation CABasicAnimation是CAPropertyAnimation的子类，使用它可以实现一些基本的动画效果，它可以让CALayer的某个属性从某个值渐变到另一个值。下面就用CABasicAnimation实现几个简单的动画 1. 平移动画方法一: 改变label的position12345678let caBasic = CABasicAnimation(keyPath: \"position\")caBasic.duration = 2caBasic.fromValue = redLabel.layer.positioncaBasic.toValue = CGPoint(x: kScreenWidth - 50, y: 200)caBasic.delegate = selfcaBasic.isRemovedOnCompletion = falsecaBasic.fillMode = kCAFillModeForwardsredLabel.layer.add(caBasic, forKey: \"redLabel1\") 初始化方法中是@”position”，说明要修改的是CALayer的position属性，也就是会执行平移动画 默认情况下，动画执行完毕后，动画会自动从CALayer上移除，CALayer又会回到原来的状态。为了保持动画执行后的状态，可以加入第6、7行代码 第8行后面的@”redLabel1”是给动画对象起个名称，以后可以调用CALayer的removeAnimationForKey:方法根据动画名称停止相应的动画 遵循的代理方法 123456789101112131415extension ViewController: CAAnimationDelegate &#123; //开始执行 func animationDidStart(_ anim: CAAnimation) &#123; print(\"开始动画--layer:\", redLabel.layer.position) &#125; //结束之行 func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123; print(\"结束动画--layer:\", redLabel.layer.position) &#125;&#125;//打印结果为://开始动画--layer: (35.0, 213.0)//结束动画--layer: (35.0, 213.0) 从打印信息可以看出，实际上，动画执行完毕后，并没有真正改变CALayer的position属性的值！ 方法二.12345 let basic = CABasicAnimation(keyPath: \"transform\")basic.duration = 2let form = CATransform3DMakeTranslation(350, 400, 0)basic.toValue = formblueLabel.layer.add(basic, forKey: \"blueLabel\") 2. 旋转动画123456let basic1 = CABasicAnimation(keyPath: \"transform\")basic1.duration = 1basic1.toValue = CATransform3DMakeRotation(0.25, 0, 0, 1)basic1.isRemovedOnCompletion = falsebasic1.fillMode = kCAFillModeForwardsblueLabel.layer.add(basic1, forKey: \"basic1\") 可以不用设置fromValue，这里只设置了toValue 3. 缩放动画 CALayer的宽度从0.5倍变为2倍 CALayer的高度从0.5倍变为1.5倍 1234567let basic1 = CABasicAnimation(keyPath: \"transform\")basic1.duration = 1basic1.toValue = CATransform3DMakeScale(0.5, 0.5, 1)basic1.toValue = CATransform3DMakeScale(2, 1.5, 1)basic1.isRemovedOnCompletion = falsebasic1.fillMode = kCAFillModeForwardsblueLabel.layer.add(basic1, forKey: \"basic1\") CABasicAnimation虽然能够做很多基本的动画效果，但是有个局限性，只能让CALayer的属性从某个值渐变到另一个值，仅仅是在2个值之间渐变 总结一些常用的animationKeyPath值的 值 说明 使用形式 transform.scale 比例转化 0.5 transform.scale.x 宽的比例 0.5 transform.rotation.x 围绕x轴旋转 @(M_PI_4)(OC), 0.25(Swift) cornerRadius 圆角的设置 30 backgroundColor 背景颜色的变化 UIColor.purpleColor.cgColor bounds 大小，中心不变 CGRect position 位置(中心点的改变) CGPoint contents 内容，比如UIImageView的图片 imageAnima.toValue = UIImage(named: “toImage”)?.cgImage opacity 透明度 0.7 contentsRect.size.width 横向拉伸缩放 最好是0~1之间的 四. CAKeyframeAnimation——关键帧动画 关键帧动画，也是CAPropertyAnimation的子类，与CABasicAnimation的区别是： CABasicAnimation只能从一个数值（fromValue）变到另一个数值（toValue） 而CAKeyframeAnimation会使用一个Array保存这些数值 属性说明： values：上述的Array对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧 path：可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。path只对CALayer的anchorPoint和position起作用。如果设置了path，那么values将被忽略 keyTimes：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的 calculationMode: 该属性决定了物体在每个子路径下是跳着走还是匀速走，跟timeFunctions属性有点类似 kCAAnimationLinear默认值,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算; kCAAnimationDiscrete 离散的,就是不进行插值计算,所有关键帧直接逐个进行显示; kCAAnimationPaced 使得动画均匀进行,而不是按keyTimes设置的或者按关键帧平分时间,此时keyTimes和timingFunctions`无效; kCAAnimationCubic 对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义主要目的是使得运行的轨迹变得圆滑; kCAAnimationCubicPaced 看这个名字就知道和kCAAnimationCubic有一定联系,其实就是在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时keyTimes以及timingFunctions也是无效的. CABasicAnimation可看做是只有2个关键帧的CAKeyframeAnimation values方式 1234567let key = CAKeyframeAnimation(keyPath: \"position\")key.duration = 3key.repeatCount = HUGE //无线循环key.calculationMode = kCAAnimationPacedkey.values = [redLabel.frame.origin, CGPoint(x: 180, y: 70), CGPoint(x: 180, y: 200), redLabel.frame.origin]key.keyTimes = [NSNumber(value: 0.0), NSNumber(value: 0.6), NSNumber(value: 0.7), NSNumber(value: 0.8)]redLabel.layer.add(key, forKey: \"key\") 五. CASpringAnimation CASpringAnimation是iOS 9 新出的 CASpringAnimation 继承于CABaseAnimation CASpringAnimation是苹果专门解决开发者关于弹簧动画的这个需求而封装的类。 1. CASpringAnimation相关属性123456789101112131415//1. 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大, 默认值: 1open var mass: CGFloat//2. 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快(默认值: 100)open var stiffness: CGFloat//3. 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快(默认值: 10)open var damping: CGFloat//4. 初始速率，动画视图的初始速度大小, 默认0//速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反(默认值: 0)open var initialVelocity: CGFloat//5. 估算时间 返回弹簧动画到停止时的估算时间，根据当前的动画参数估算(只读)open var settlingDuration: CFTimeInterval &#123; get &#125; 2. 示例代码123456789let spring = CASpringAnimation(keyPath: \"position.y\")spring.mass = 5spring.stiffness = 100spring.damping = 5spring.initialVelocity = 2spring.fromValue = blueLabel.layer.position.yspring.toValue = kScreenHeight - 150spring.duration = spring.settlingDurationblueLabel.layer.add(spring, forKey: \"spring\") 六. CAAnimationGroup动画组 是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行 属性说明： animations：用来保存一组动画对象的Array 默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间 代码示例: 同时执行：平移、缩放、位移动画 -&gt; 使用动画组 12345678910111213141516171819202122232425262728//动画组fileprivate func getCAAnimationGroup()&#123; //0. 初始化动画组 let group = CAAnimationGroup() //1. 平移动画 let basic1 = CABasicAnimation(keyPath: \"position\") basic1.fromValue = blueLabel.layer.position basic1.toValue = CGPoint(x: CGFloat(arc4random_uniform(200)), y: CGFloat(arc4random_uniform(500))) //2. 缩放动画 let basic2 = CABasicAnimation(keyPath: \"transform.scale\") var scale: CGFloat = 0.1 scale = scale &lt; 1 ? 1.5 : 0.5 basic2.toValue = scale //3. 旋转动画 let basic3 = CABasicAnimation(keyPath: \"transform.rotation\") basic3.toValue = CGFloat(arc4random_uniform(360)) / 180.0 //4. 添加到动画组 group.animations = [basic1, basic2, basic3] //取消反弹 group.isRemovedOnCompletion = false group.fillMode = kCAFillModeForwards group.duration = 0.5 blueLabel.layer.add(group, forKey: \"group\")&#125; 七. 转场动画——CATransition CATransition是CAAnimation的子类，用于做转场动画，能够为layer层提供移出屏幕和移入屏幕的动画效果。 iOS比Mac OS X的转场动画效果少一点UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果 动画属性: type：动画过渡类型 subtype：动画过渡方向 startProgress：动画起点(在整体动画的百分比) endProgress：动画终点(在整体动画的百分比) 1. type和subtype属性说明12345678910111213141516171819202122232425262728293031323334/* type类型 */@available(iOS 2.0, *)public let kCATransitionFade: String//交叉淡化过渡@available(iOS 2.0, *)public let kCATransitionMoveIn: String//新视图移到旧视图上面@available(iOS 2.0, *)public let kCATransitionPush: String//新视图把旧视图推出去@available(iOS 2.0, *)public let kCATransitionReveal: String//将旧视图移开,显示下面的新视图/* subtypes类型 */@available(iOS 2.0, *)public let kCATransitionFromRight: String//从右侧转场@available(iOS 2.0, *)public let kCATransitionFromLeft: String//从左侧转场@available(iOS 2.0, *)public let kCATransitionFromTop: String//从上部转场@available(iOS 2.0, *)public let kCATransitionFromBottom: String//从底部转场 注意： 除了上述四种效果之外,还有很多私有API效果，使用的时候要小心，可能会导致app审核不被通过 使用的时候要以字符串的形式 12345678cube //立方体翻滚效果oglFlip //上下左右翻转效果suckEffect //收缩效果，如一块布被抽走(不支持过渡方向)rippleEffect //滴水效果(不支持过渡方向)pageCurl //向上翻页效果pageUnCurl //向下翻页效果cameraIrisHollowOpen //相机镜头打开效果(不支持过渡方向)cameraIrisHollowClose //相机镜头关上效果(不支持过渡方向) 效果参考 2. 代码示例: 展示立方体翻滚效果的图片浏览 1. 初始化变量123//初始化变量fileprivate var imageView = UIImageView(frame: UIScreen.main.bounds)fileprivate var currentIndex = 0 2. 需要在viewDidLoad中调用一下方法123456789101112131415//转场动画 fileprivate func imageCATransition()&#123; //0.初始化ImageView imageView.isUserInteractionEnabled = true imageView.image = UIImage(named: \"0.jpg\") view.addSubview(imageView) //1. 添加滑动手势 let left = UISwipeGestureRecognizer(target: self, action: #selector(leftSwipe(gesture:))) left.direction = .left imageView.addGestureRecognizer(left) let right = UISwipeGestureRecognizer(target: self, action: #selector(rightSwipe(gesture:))) right.direction = .right imageView.addGestureRecognizer(right) &#125; 3. 滑动后执行的方法1234567891011121314151617181920212223242526272829//MARK: 手势相关方法//左滑@objc fileprivate func leftSwipe(gesture: UIGestureRecognizer) &#123; print(\"左滑动\") transitionAnimation(isNext: true)&#125;//右滑@objc fileprivate func rightSwipe(gesture: UIGestureRecognizer) &#123; print(\"右滑动\") transitionAnimation(isNext: false)&#125;//设置转场动画fileprivate func transitionAnimation(isNext: Bool)&#123; let transition = CATransition() transition.type = kCATransitionFade transition.subtype = isNext ? kCATransitionFromRight : kCATransitionFromLeft transition.duration = 1 imageView.image = getImage(isNext) imageView.layer.add(transition, forKey: \"transition\")&#125;//获取下/上一张图片fileprivate func getImage(_ isNext: Bool) -&gt; UIImage &#123; currentIndex = isNext ? currentIndex + 1 : currentIndex - 1 currentIndex = currentIndex &lt; 0 ? 7 : currentIndex currentIndex = currentIndex &gt; 7 ? 0 : currentIndex return UIImage(named: \"\\(currentIndex)\" + \".jpg\")!&#125; 八. 总结 核心动画给我们展示的只是一个假象，layer的的frame、bounds、position并不会在动画完毕之后发生改变。 UIView封装的动画，会使会真实修改view的一些属性 以上就是小编总结的关于Core Animation核心动画的相关分类 总结的知识点比较简单, 个人感觉有点low 如有不足之处,还望路过的大神多多指教","categories":[{"name":"iOS动画","slug":"iOS动画","permalink":"https://titanjun.top/categories/iOS动画/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"CoreAnimation","slug":"CoreAnimation","permalink":"https://titanjun.top/tags/CoreAnimation/"}]},{"title":"RxSwift+Moya网络请求之项目实战","slug":"RxSwift+Moya网络请求之项目实战","date":"2017-10-08T09:58:28.000Z","updated":"2018-03-13T01:43:02.000Z","comments":true,"path":"2017/10/08/RxSwift+Moya网络请求之项目实战/","link":"","permalink":"https://titanjun.top/2017/10/08/RxSwift+Moya网络请求之项目实战/","excerpt":"RxSwift相关基本介绍和用法可参考: RxSwift的使用详解01 RxSwift的使用详解02","text":"RxSwift相关基本介绍和用法可参考: RxSwift的使用详解01 RxSwift的使用详解02 一. 下面将将进行实战项目 1.登录注册功能 输入用户名要大于6个字符，不然密码不能输入 密码必须大于6个字符，不然重复密码不能输入 重复密码输入必须和密码一样，不然注册按钮不能点击 根据输入的字符是否合法,按钮动态的改变颜色 2.UITableView和搜索SertchBar的应用 searchBar根据输入的字体展示包含该字体的cell列表 RxSwift实现tableView列表展示 3.Moya+RxSwift实现网络请求 应用RxSwift在UICollectionView中的应用 用Moya进行网络请求 ObjectMapper进行json到model的数据解析 整个Demo的架构使用MVVM 二. Demo地址下面简单看一下demo的界面1. 登录注册 2. UITableView和SearchBar 3. UICollectionView和Moya 三. 项目结构和框架1. 结构demo是使用的纯MVVM模式，因为RxSwift就是为MVVM而生。不懂MVVM的猿友可参考MVVM模式快速入门 2. 项目框架123456789101112131415161718192021// Swift三方库 // Rx pod 'RxSwift' //RxSwift的必备库 pod 'RxCocoa' //对 UIKit Foundation 进行 Rx 化 pod 'RxDataSources' // 帮助我们优雅的使用tableView的数据源方法 // 网络请求 pod 'Moya/RxSwift' // 为RxSwift专用提供，对Alamofire进行封装的一个网络请求库 // 图片处理 pod 'Kingfisher' //图片处理库 // 数据解析 pod 'ObjectMapper' //json转模型 // OC库 // MJRefresh pod 'MJRefresh' //MJ上拉下拉刷新 pod 'SVProgressHUD' //HUD 四. 注册界面 这里主要使用了Observable的相关知识,不了解的童鞋可参考RxSwift的使用详解01,了解Observable的操作 注册和登录并没有保存已注册的账号和密码, 故登录功能并不完善,后期会在完善,望知晓 下面将针对注册用户名做简单介绍: 1. 首先在model里处理输入字符串的语法法则和字符个数是否符合规范12345678910111213141516171819202122232425262728extension InputValidator &#123; //判断字符串是否符合语法法则 class func isValidEmail(_ email: String) -&gt; Bool &#123; let regular = try? NSRegularExpression(pattern: \"^\\\\S+@\\\\S+\\\\.\\\\S+$\", options: []) if let re = regular &#123; let range = NSRange(location: 0, length: email.lengthOfBytes(using: .utf8)) let result = re.matches(in: email, options: [], range: range) return result.count &gt; 0 &#125; return false &#125; //判断密码字符个数&gt;8 class func isValidPassword(_ password: String) -&gt; Bool &#123; return password.characters.count &gt;= 8 &#125; //判断用户名 class func validateUserName(_ username: String) -&gt; Result &#123; //判断字符个数是否正确 if username.characters.count &lt; 6 &#123; return Result.failure(message: \"输入的字符个数不能少于6个字符\") &#125; //账号可用 return Result.success(message: \"账号可用\") &#125;&#125; 其中Result是一个返回是否成功的枚举值,可传入字符串变量 1234enum Result &#123; case success(message: String) case failure(message: String)&#125; 2. 根据输入的用户名判断该用户名是否可用123456789101112var usernameObserable: Observable&lt;Result&gt;var passwordObserable: Observable&lt;Result&gt;var repeatPassObserable: Observable&lt;Result&gt;var registerBtnObserable: Observable&lt;Bool&gt;init()&#123; //检测账号 usernameObserable = username.asObservable().map(&#123; (username) -&gt; Result in return InputValidator.validateUserName(username) &#125;)&#125; 该返回参数Result,控制器将根据该Result是否成功来改变输入框是否是可编辑状态 初始化方法中，我们对传入的序列进行处理和转换成相对应的Result序列 3. controller逻辑,根据用户名输入改变各控件状态12345678910111213141516//1. 账号判断逻辑 //1-1. 检测账号 usernameTextField.rx.text .orEmpty // 将String? 类型转为String型 .bindTo(registerVM.username) .addDisposableTo(bag) //1-2. 根据账号监听提示字体的状态 registerVM.usernameObserable .bindTo(usernameHintLabel.rx.validationResult) .addDisposableTo(bag) //1-3. 根据账号监听密码输入框的状态 registerVM.usernameObserable .bindTo(passwordTextField.rx.enableResult) .addDisposableTo(bag) 检测输入用户名是否符合规范 根据账号监听提示字体的状态 根据账号监听密码输入框的状态 根据账号监听注册按钮的状态 五. UITableView和SearchBar 该UITableView展示界面并未涉及网络请求 数据来源plist文件 图片为本地图片,可下载demo,在demo中查找图片 选用自定义UITableViewCell,故cell不做介绍 model小编这里也不多做介绍,详情可下载demo看具体代码 1. viewModel中的代码逻辑1-1. 读取plist文件,获取模型数组12345678910fileprivate func getHeroData() -&gt; [HeroModel]&#123; // 1.获取路径 let path = Bundle.main.path(forResource: \"heros.plist\", ofType: nil)! // 2.读取文件内容 let dictArray = NSArray(contentsOfFile: path) as! [[String : Any]] // 3.遍历所有的字典并且转成模型对象 return dictArray.map(&#123; HeroModel(dict: $0) &#125;).reversed()&#125; 1-2. seachBar123456789101112131415161718lazy var heroVariable: Variable&lt;[HeroModel]&gt; = &#123; return Variable(self.getHeroData())&#125;()var searchText: Observable&lt;String&gt;init(searchText: Observable&lt;String&gt;) &#123; self.searchText = searchText self.searchText.subscribe(onNext: &#123; (str: String) in let heros = self.getHeroData().filter(&#123; (hero: HeroModel) -&gt; Bool in //过滤 if str.isEmpty &#123; return true &#125; //model是否包含搜索字符串 return hero.name.contains(str) &#125;) self.heroVariable.value = heros &#125;).addDisposableTo(bag)&#125; 其中heroVariable是一个数组模型的包装箱,在controller内调用使用前需要asObservable或者asDriver解包装;详细用法可参考:RxSwift的使用详解01 searchText搜索框输入的关键字,根据该关键字从数组中过滤出所有包含该关键字的model 对heroVariable重新赋值,发出事件 1-3. RxTableViewController.swift主要代码1-3-1. searchBar搜索框,输入字符后间隔0.5秒开始搜索1234var searchText: Observable&lt;String&gt; &#123; //输入后间隔0.5秒搜索,在主线程运行 return searchBar.rx.text.orEmpty.throttle(0.5, scheduler: MainScheduler.instance)&#125; 1-3-2. UITableView的设置12345678910//2.给tableView绑定数据//注意: 三个参数:row, model, cell三个顺序不可以搞错, 不需要的可省略 heroVM.heroVariable.asDriver().drive(rxTableView.rx.items(cellIdentifier: kCellID, cellType: RxTableViewCell.self)) &#123; (_, hero, cell) in cell.heroModel = hero&#125;.addDisposableTo(bag) // 3.监听UITableView的点击rxTableView.rx.modelSelected(HeroModel.self).subscribe &#123; (event: Event&lt;HeroModel&gt;) in print(event.element?.name ?? \"\")&#125;.addDisposableTo(bag) 将viewModel中的heroVariable进行解包装，如果是Driver序列，我们这里不使用bingTo，而是使用的Driver，用法和bingTo一模一样。 Deriver的监听一定发生在主线程，所以很适合我们更新UI的操作 如需设置delegate的代理 1rxTableView.rx.setDelegate(self).addDisposableTo(bag) 然后在实现相应的代理方法即可,如: 12345extension RxTableViewController: UITableViewDelegate&#123; func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; return 100 &#125;&#125; 六. UICollectionView+Moya+ObjectMapper网络请求和数据处理 与上述UITableView不同的是,这部分将以RxDataSources处理数据源 model数组以sections组集合处理 结合Moya进行网络请求 使用ObjectMapper进行json数据转模型 1. 配合ObjectMapper这里再介绍一下ObjectMapper 12345678910111213141516171819202122class AnchorModel: Mappable &#123; var name = \"\" //名字 var pic51 = \"\" //头像 var pic74 = \"\" //大图 var live = 0 var push = 0 var focus = 0 //关注量 required init?(map: Map) &#123; &#125; func mapping(map: Map) &#123; name &lt;- map[\"name\"] pic51 &lt;- map[\"pic51\"] pic74 &lt;- map[\"pic74\"] live &lt;- map[\"live\"] push &lt;- map[\"push\"] focus &lt;- map[\"focus\"] &#125;&#125; 使用 ObjectMapper ，需要让自己的 Model 类使用 Mappable 协议，这个协议包括两个方法： 123required init?(map: Map) &#123;&#125; func mapping(map: Map) &#123;&#125; 在 mapping 方法中，用 &lt;- 操作符来处理和映射你的 JSON数据 详细的 ObjectMapper 教程可以查看它的 Github 主页，我在这里只做简单的介绍。 2. Moya的使用 Moya是基于Alamofire的网络请求库，这里我使用了Moya/Swift，它在Moya的基础上添加了对RxSwift的接口支持。 Github上的官方介绍罗列了Moya的一些特点： 编译时检查正确的API端点访问. 使你定义不同端点枚举值对应相应的用途更加明晰. 提高测试地位从而使单元测试更加容易. 接下来我们来说下Moya的使用 2-1. 创建一个枚举API123456//请求枚举类型enum JunNetworkTool &#123; case getNewList case getHomeList(page: Int)&#125; 2-2. 为枚举添加扩展 需遵循协议 TargetType 这个协议的Moya这个库规定的协议，可以单击进入相应的文件进行查看 这个协议内的每一个参数(除了validate可不重写)都必须重写,否则会报错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//请求参数extension JunNetworkTool: TargetType &#123; //统一基本的url var baseURL: URL &#123; return (URL(string: \"http://qf.56.com/home/v4/moreAnchor.ios\"))! &#125; //path字段会追加至baseURL后面 var path: String &#123; return \"\" &#125; //请求的方式 var method: Moya.Method &#123; return .get &#125; //参数编码方式(这里使用URL的默认方式) var parameterEncoding: ParameterEncoding &#123; return URLEncoding.default &#125; //用于单元测试 var sampleData: Data &#123; return \"getList\".data(using: .utf8)! &#125; //将要被执行的任务(请求：request 下载：upload 上传：download) var task: Task &#123; return .request &#125; //请求参数(会在请求时进行编码) var parameters: [String: Any]? &#123; switch self &#123; case .getHomeList(let index): return [\"index\": index] default: return [\"index\": 1] &#125; &#125; //是否执行Alamofire验证，默认值为false var validate: Bool &#123; return false &#125;&#125; 2-3. 定义一个全局变量用于整个项目的网络请求1let junNetworkTool = RxMoyaProvider&lt;JunNetworkTool&gt;() 至此，我们就可以使用这个全局变量来请求数据了 3. RxDataSources RxDataSources是以section来做为数据结构来传输，这点很重要，比如:在传统的数据源实现的方法中有一个numberOfSection，我们在很多情况下只需要一个section，所以这个方法可实现，也可以不实现，默认返回的就是1，这给我们带来的一个迷惑点：【tableView是由row来组成的】，不知道在坐的各位中有没有是这么想的呢？？有的话那从今天开始就要认清楚这一点，【tableView其实是由section组成的】，所以在使用RxDataSources的过程中，即使你的setion只有一个，那你也得返回一个section的数组出去！！！ 传统方式适用于简单的数据集，但不处理需要将复杂数据集与多个部分进行绑定的情况，或者在添加/修改/删除项目时需要执行动画时。而使用RxDataSources时，它很容易写 想了解更多关于RxDataSources的用法,请参考其GitHub主页 3-1. Sections自定义 在我们自定义的Model中创建一个AnchorSection的结构体 并遵循SectionModelType协议，实现相应的协议方法 12345678910111213141516//MARK: SectionModelstruct AnchorSection &#123; // items就是rows var items: [Item] // 你也可以这里加你需要的东西，比如 headerView 的 title&#125;extension AnchorSection: SectionModelType &#123; // 重定义 Item 的类型为 typealias Item = AnchorModel init(original: AnchorSection, items: [AnchorSection.Item]) &#123; self = original self.items = items &#125;&#125; 4. ViewModel4-1. 自定义协议BaseViewModel我们知道MVVM思想就是将原本在ViewController的视图显示逻辑、验证逻辑、网络请求等代码存放于ViewModel中，让我们的ViewController瘦身。这些逻辑由ViewModel负责，外界不需要关心，外界只需要结果，ViewModel也只需要将结果给到外界，基于此，我们定义了一个协议 12345678protocol JunViewModelType &#123; //associatedtype: 关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定 associatedtype Input associatedtype Output //我们通过 transform 方法将input携带的数据进行处理，生成了一个Output func transform(input: Input) -&gt; Output&#125; 4-2. 自定义用于网络请求的刷新状态 根据枚举值的判断,改变collection的刷新状态 123456789//刷新的状态enum JunRefreshStatus &#123; case none case beingHeaderRefresh case endHeaderRefresh case beingFooterRefresh case endFooterRefresh case noMoreData&#125; 4-3. 自定义用于继承的BaseViewModel 定义请求数据的页数index 定义input和output的结构体 123456789101112131415161718192021222324252627class BaseViewModel: NSObject &#123; // 记录当前的索引值 var index: Int = 1 struct JunInput &#123; // 网络请求类型 let category: JunNetworkTool init(category: JunNetworkTool) &#123; self.category = category &#125; &#125; struct JunOutput &#123; // tableView的sections数据 let sections: Driver&lt;[AnchorSection]&gt; // 外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载） let requestCommond = PublishSubject&lt;Bool&gt;() // 告诉外界的tableView当前的刷新状态 let refreshStatus = Variable&lt;JunRefreshStatus&gt;(.none) //初始化时,section的数据 init(sections: Driver&lt;[AnchorSection]&gt;) &#123; self.sections = sections &#125; &#125;&#125; 4-4. 自定义AnchorViewModel 1) 继承BaseViewModel 12345class AnchorViewModel : BaseViewModel&#123; // 存放着解析完成的模型数组 let anchorArr = Variable&lt;[AnchorModel]&gt;([])&#125; 2) 遵循JunViewModelType协议 123456789101112131415161718192021222324252627282930313233extension AnchorViewModel: JunViewModelType &#123; typealias Input = JunInput typealias Output = JunOutput func transform(input: AnchorViewModel.JunInput) -&gt; AnchorViewModel.JunOutput &#123; let sectionArr = anchorArr.asDriver().map &#123; (models) -&gt; [AnchorSection] in // 当models的值被改变时会调用 return [AnchorSection(items: models)] &#125;.asDriver(onErrorJustReturn: []) let output = JunOutput(sections: sectionArr) output.requestCommond.subscribe(onNext: &#123; (isReloadData) in self.index = isReloadData ? 1 : self.index + 1 //开始请求数据 junNetworkTool.request(JunNetworkTool.getHomeList(page: self.index)) .mapObjectArray(AnchorModel.self) .subscribe(&#123; (event) in switch event &#123; case let .next(modelArr): self.anchorArr.value = isReloadData ? modelArr : (self.anchorArr.value) + modelArr SVProgressHUD.showSuccess(withStatus: \"加载成功\") case let .error(error): SVProgressHUD.showError(withStatus: error.localizedDescription) case .completed: output.refreshStatus.value = isReloadData ? .endHeaderRefresh : .endFooterRefresh &#125; &#125;).addDisposableTo(bag) &#125;).addDisposableTo(bag) return output &#125;&#125; sectionArr是将model数组按照section分别存储 当请求回来的anchorArr数据改变的时候, sectionArr随之会发生改变 isReloadData用于区分是下拉刷新(true时), 还是上拉加载更多(false时) 5. RxCollectionViewController控制器中 创建数据源RxDataSources 绑定cell 初始化input和output请求 绑定section数据 设置刷新 5-1. 创建数据源RxDataSources12// 创建一个数据源属性，类型为自定义的Section类型let dataSource = RxCollectionViewSectionedReloadDataSource&lt;AnchorSection&gt;() 5-2. 绑定cell(自定义的cell要提前注册)12345dataSource.configureCell = &#123; dataSource, collectionView, indexPath, item in let cell = collectionView.dequeueReusableCell(withReuseIdentifier: kCollecCellID, for: indexPath) as! RxCollectionViewCell cell.anchorModel = item return cell&#125; 以上四个参数的顺序分别为:dataSource, collectionView(或者tableView), indexPath, model, 其对应类型不言而喻,不多做介绍 5-3. 初始化input和output请求12let vmInput = AnchorViewModel.JunInput(category: .getNewList)let vmOutput = anchorVM.transform(input: vmInput) 5-4. 绑定section数据12345//4-1. 通过dataSource和section的model数组绑定数据(demo的用法, 推荐)vmOutput.sections .asDriver() .drive(collectionVIew.rx.items(dataSource: dataSource)) .addDisposableTo(bag) 5-5. 设置刷新5-5-0. 在controller中初始化刷新状态12345678collectionVIew.mj_header = MJRefreshNormalHeader(refreshingBlock: &#123; vmOutput.requestCommond.onNext(true)&#125;)collectionVIew.mj_header.beginRefreshing() collectionVIew.mj_footer = MJRefreshAutoNormalFooter(refreshingBlock: &#123; vmOutput.requestCommond.onNext(false)&#125;) 5-5-1. 添加刷新的序列 在JunOutput的结构体中添加刷新序列 我们在进行网络请求并得到结果之后，修改refreshStatus的value为相应的JunRefreshStatus项 MJRefre遍会根据该状态做出相应的刷新事件 默认状态为none 12// 告诉外界的tableView当前的刷新状态let refreshStatus = Variable&lt;JunRefreshStatus&gt;(.none) 5-5-2. 外界订阅output的refreshStatus 外界订阅output的refreshStatus，并且根据接收到的值进行相应的操作 refreshStatus每次改变都会触发刷新事件 1234567891011121314151617//5. 设置刷新状态vmOutput.refreshStatus.asObservable().subscribe(onNext: &#123; (status) in switch status &#123; case .beingHeaderRefresh: self.collectionVIew.mj_header.beginRefreshing() case .endHeaderRefresh: self.collectionVIew.mj_header.endRefreshing() case .beingFooterRefresh: self.collectionVIew.mj_footer.beginRefreshing() case .endFooterRefresh: self.collectionVIew.mj_footer.endRefreshing() case .noMoreData: self.collectionVIew.mj_footer.endRefreshingWithNoMoreData() default: break &#125;&#125;).addDisposableTo(bag) 5-5-3. output提供一个requestCommond用于控制是否请求数据 PublishSubject 的特点：即可以作为Observable，也可以作为Observer，说白了就是可以发送信号，也可以订阅信号 当你订阅PublishSubject的时候，你只能接收到订阅他之后发生的事件。subject.onNext()发出onNext事件，对应的还有onError()和onCompleted()事件 12// 外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载）let requestCommond = PublishSubject&lt;Bool&gt;() 七. 总结 为了研究RxSwift相关知识, 工作之余的时间,差不多一个月了 学习的瓶颈大部分在于网络请求和配合刷新这一模块 文中如出现self循环引用的问题,还望大神多多指正 小编目前也还在初学阶段,文中如出现小错误还望多多指正,如有更好的方法,也希望不吝分享 如果喜欢,可以收藏,也可以在Github上star一下 最后再一次附上Demo地址参考文献: Moya ObjectMapper RxDataSources Kingfisher RxSwift的使用详解01 RxSwift的使用详解02 moya + RxSwift 进行网络请求 扒一扒swift中的unowned和weak下 iOS - RxSwift -项目实战记录","categories":[{"name":"RxSwift框架","slug":"RxSwift框架","permalink":"https://titanjun.top/categories/RxSwift框架/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://titanjun.top/tags/RxSwift/"},{"name":"响应式编程","slug":"响应式编程","permalink":"https://titanjun.top/tags/响应式编程/"}]},{"title":"RxSwift的使用详解02","slug":"RxSwift的使用详解02","date":"2017-09-21T11:15:47.000Z","updated":"2018-03-14T09:54:19.000Z","comments":true,"path":"2017/09/21/RxSwift的使用详解02/","link":"","permalink":"https://titanjun.top/2017/09/21/RxSwift的使用详解02/","excerpt":"一. RxSwift简介 推荐: RxSwift官方文档 中文: RxSwift官方文档的中文翻译 上一篇: RxSwift的使用详解01","text":"一. RxSwift简介 推荐: RxSwift官方文档 中文: RxSwift官方文档的中文翻译 上一篇: RxSwift的使用详解01 上一篇主要讲了 RxSwift简介 RxSwift简单体验(在控件中的简单使用) RxSwift常见操作(never, just, of, empty, creat等10个sequence的使用) RxSwift中Subjects 变换操作(map, flatMap等)和资源释放DisposeBag UIBindingObserver创建自己的监听者 本文主要内容 联合操作: 把多个Observable流合成单个Observable流 elementAt, single, skip等过滤和约束操作 toArray, reduce, concat等数学操作 二. 联合操作 联合操作就是把多个Observable流合成单个Observable流 1. startWith 在发出事件消息之前，先发出某个特定的事件消息。 比如发出事件2 ，3然后我startWith(1)，那么就会先发出1，然后2 ，3. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//未添加startWithObservable.of(\"2\", \"3\").subscribe(&#123; print($0) &#125;).addDisposableTo(bag) /***输出顺序: next(2) next(3) completed ***///使用startWithObservable.of(\"2\", \"3\").startWith(\"1\").subscribe(&#123; print($0) &#125;).addDisposableTo(bag) /*输出顺序: next(1) next(2) next(3) completed */``` ## 2. merge- 合并两个Observable流合成单个Observable流，根据时间轴发出对应的事件```objclet subject1 = PublishSubject&lt;String&gt;()let subject2 = PublishSubject&lt;String&gt;()Observable.of(subject1, subject2) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) print(\"-------------------------\")Observable.of(subject1, subject2) .merge() .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) subject1.onNext(\"quan\")subject1.onNext(\"jun\")subject2.onNext(\"ya\")subject2.onNext(\"jie\")subject1.onNext(\"tian\")subject2.onNext(\"guo\") /*输出事件: next(quan) next(jun) next(ya) next(jie) next(tian) next(guo) */ 3. zip 绑定超过最多不超过8个的Observable流，结合在一起处理。 注意Zip是一个事件对应另一个流一个事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980let subject3 = PublishSubject&lt;String&gt;()let subject4 = PublishSubject&lt;String&gt;()Observable.zip(subject3, subject4) &#123; (sub3, sub4) -&gt; String in sub3 + \"+\" + sub4 &#125;.subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) subject3.onNext(\"quan\")subject3.onNext(\"jun\")subject4.onNext(\"ya\")subject4.onNext(\"jie\")subject3.onNext(\"tian\")subject4.onNext(\"guo\") /*输出事件: 将subject3和subject4压缩到一起共同处理 next(quan+ya) next(jun+jie) next(tian+guo) */``` ## 4. combineLatest- 绑定超过最多不超过8个的Observable流，结合在一起处理。- 和Zip不同的是combineLatest是一个流的事件对应另一个流的最新的事件，两个事件都会是最新的事件，可将下图与Zip的图进行对比```objclet subject5 = PublishSubject&lt;String&gt;()let subject6 = PublishSubject&lt;String&gt;()Observable.combineLatest(subject5, subject6) &#123; (sub5, sub6) -&gt; String in sub5 + \"+\" + sub6 &#125;.subscribe(&#123; print($0) &#125;).addDisposableTo(bag)subject5.onNext(\"quan\")subject5.onNext(\"1\")subject6.onNext(\"ya\")subject6.onNext(\"2\")subject5.onNext(\"--\") /*输出事件: 将subject3的最新事件和subject4的最新事件一起处理 next(1+ya) next(1+2) next(--+2) */``` ## 5. switchLatest- switchLatest可以对事件流进行转换，本来监听的subject1，我可以通过更改variable里面的value更换事件源。变成监听subject2了```objclet subject7 = BehaviorSubject(value: \"love\")//BehaviorSubject: 接受订阅之前的最后一个事件let subject8 = BehaviorSubject(value: \"love to\")let variable = Variable(subject7)variable.asObservable() .switchLatest() .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) subject7.onNext(\"ya\")subject7.onNext(\"jie\")variable.value = subject8subject7.onNext(\"quan\")subject8.onNext(\"jun\") variable.value = subject7subject8.onNext(\"jie\")subject7.onNext(\"guo\") /*输出事件: next(love) next(ya) next(jie) next(love to) next(jun) next(quan) next(guo) */ 二. 过滤和约束1. 1. distinctUntilChanged distinctUntilChanged就是当: 下一个事件与前一个事件是不同事件的事件才进行处理操作 12345678910111213Observable.of(1, 2, 1, 1, 1, 3, 3, 1) .distinctUntilChanged() .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(1) next(2) next(1) next(3) next(1) completed */ 2. elementAt 只处理在指定位置的事件 12345678Observable.of(1, 2, 3, 4, 5) .elementAt(3) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(4) completed */ 3. single 找出在sequence只发出一次的事件，如果超过一个就会发出error错误 &gt;1 多个信号输出的情况123456789Observable.of(1, 2, 3, 4) .single() .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(1) //单一信号超过了一个,只会输出第一个,然后输出error error(Sequence contains more than one element.) */ &gt;2 指定某唯一信号的情况12345678Observable.of(1, 2, 3, 4) .single(&#123; $0 == 2 &#125;) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(2) completed */ &gt;3 指定某不唯一信号的情况12345678910Observable.of(1, 4, 3, 4) .single(&#123; $0 == 4 &#125;) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(4) //单一信号超过了一个,只会输出第一个,然后输出error error(Sequence contains more than one element.) */ &gt;4 找不到该信号的情况12345678Observable.of(1, 4, 3, 4) .single(&#123; $0 == 2 &#125;) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: 没有对应的参数,然后输出error error(Sequence doesn't contain any elements.) */ 4. filter 过滤掉某些不符合要求的事件 123456789Observable.of(1, 2, 3, 4, 5) .filter(&#123; $0 &gt; 3 &#125;) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(4) next(5) completed */ 5. take 只处理前几个事件信号 12345678910Observable.of(1, 2, 3, 4, 5) .take(2) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(1) next(2) completed */ 6. takeLast 只处理后几个事件信号 123456789Observable.of(1, 2, 3, 4, 5) .takeLast(2) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(4) next(5) completed */ 7. takeWhile 当条件满足的时候进行处理 123456789Observable.of(1, 2, 3, 4, 5) .takeWhile(&#123; $0 &gt; 3 &#125;) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(4) next(5) completed */ 8. takeUntil 接收事件消息，直到另一个sequence发出事件消息的时候.停止接收消息,输出completed 123456789101112131415161718let subject1 = PublishSubject&lt;String&gt;()let subject2 = PublishSubject&lt;String&gt;()subject1.takeUntil(subject2) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag)subject1.onNext(\"quan\")subject1.onNext(\"jun\")subject2.onNext(\"ya\")//停止接收消息 subject1.onNext(\"tian\")subject2.onNext(\"guo\") /*输出顺序为: next(quan) next(jun) completed */ 9. skip 取消前几个事件 12345678910Observable.of(1, 2, 3, 4, 5) .skip(3) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(4) next(5) completed */ 10. skipWhile 满足条件的事件消息都取消 123456789Observable.of(1, 2, 3, 4, 5) .skipWhile(&#123; $0 &lt; 4 &#125;) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(4) next(5) completed */ 11. skipWhileWithIndex 满足条件的都被取消，传入的闭包同skipWhile有点区别而已 skipWhile的(&lt;4)和skipWhileWithIndex的(&lt;=3)的效果是一样的 123456789101112Observable.of(1, 2, 3, 4, 5) .skipWhileWithIndex(&#123; (element, index) -&gt; Bool in index &lt;= 3 &#125;) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(4) next(5) completed */ 12. skipUntil 直到某个sequence发出了事件消息，才开始接收当前sequence发出的事件消息 12345678910111213141516let subject3 = PublishSubject&lt;String&gt;()let subject4 = PublishSubject&lt;String&gt;()subject3.skipUntil(subject4) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag)subject3.onNext(\"quan\")subject4.onNext(\"jun\") subject4.onNext(\"ya\")//开始接收消息 subject3.onNext(\"tian\")subject4.onNext(\"guo\") /*输出顺序为: next(tian) */ 三. 数学操作1. toArray 将sequence转换成一个array，并转换成单一事件信号，然后结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Observable.range(start: 1, count: 5) .toArray() .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next([1, 2, 3, 4, 5]) completed */``` ## 2. reduce- 用一个初始值，对事件数据进行累计操作。reduce接受一个初始值，和一个操作符号```objcObservable.of(10, 12, 34) .reduce(0, accumulator: +) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) /*输出顺序为: next(56) completed */``` ## 3. concat- concat会把多个sequence和并为一个sequence，并且当前面一个sequence发出了completed事件，才会开始下一个sequence的事件。- 在第一sequence发出onCompleted完成之前，第二个sequence发出的事件都会被忽略```objclet subject1 = BehaviorSubject(value: \"quan\")let subject2 = BehaviorSubject(value: \"jun\")let variable = Variable(subject1)variable.asObservable() .concat() .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag)subject1.onNext(\"ya\")subject1.onNext(\"jie\")subject2.onNext(\"jun\") //subject2不被输出 variable.value = subject2 //subject1发出onCompleted()之前会继续输出subject1 subject1.onNext(\"guo\")subject2.onNext(\"tian\") subject1.onCompleted() //subject1结束,开始输出subject2,此时subject2的值接受最后一个(\"tian\") subject2.onNext(\"love\")subject1.onNext(\"to love\") //subject1将不再被输出 /*输出顺序为: next(quan) next(ya) next(jie) next(guo) next(tian) next(love) */ 四. RxSwift的优点 Composable 可组合，在设计模式中有一种模式叫做组合模式，你可以方便的用不同的组合实现不同的类 Reusable 代码可重用，原因很简单，对应RxSwift，就是一堆Obserable Declarative 响应式的，因为状态不可变，只有数据变化 Understandable and concise 简洁，容易理解。 Stable 稳定，因为RxSwift写出的代码，单元测试时分方便 Less stateful “无”状态性，因为对于响应式编程，你的应用程序就是一堆数据流 Without leaks 没有泄漏，因为资源管理非常简单","categories":[{"name":"RxSwift框架","slug":"RxSwift框架","permalink":"https://titanjun.top/categories/RxSwift框架/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://titanjun.top/tags/RxSwift/"},{"name":"响应式编程","slug":"响应式编程","permalink":"https://titanjun.top/tags/响应式编程/"}]},{"title":"RxSwift的使用详解01","slug":"RxSwift的使用详解01","date":"2017-09-15T12:15:47.000Z","updated":"2018-03-17T15:44:12.330Z","comments":true,"path":"2017/09/15/RxSwift的使用详解01/","link":"","permalink":"https://titanjun.top/2017/09/15/RxSwift的使用详解01/","excerpt":"一. RxSwift简介 推荐: RxSwift官方文档 中文: RxSwift官方文档的中文翻译","text":"一. RxSwift简介 推荐: RxSwift官方文档 中文: RxSwift官方文档的中文翻译 RxSwift是Swift函数响应式编程的一个开源库，由Github的ReactiveX组织开发、维护 其他语言像C#, Java 和 JS 也有，Rx.Net、RxJava、rxjs RxSwift的目的是让数据/事件流和异步任务能够更方便的序列化处理，能够使用Swift进行响应式编程 1. RxSwift做了什么 RxSwift把我们程序中每一个操作都看成一个事件 比如一个TextField中的文本改变，一个按钮被点击，或者一个网络请求结束等，每一个事件源就可以看成一个管道，也就是sequence 比如TextField，当我们改变里面的文本的时候，这个TextField就会不断的发出事件，从他的这个sequence中不断的流出，我们只需要监听这个sequence，每流出一个事件就做相应的处理。 同理，Button也是一个sequence，每点击一次就流出一个事件。 2 RxSwift的核心思想是 Observable sequence，Observable表示可监听或者可观察，也就是说RxSwift的核心思想是可监听的序列。 并且，Observable sequence可以接受异步信号，也就是说，信号是可以异步给监听者的 Observable(ObservableType) 和 SequenceType类似 ObservableType.subscribe 和 SequenceType.generate类似 由于RxSwift支持异步获得信号，所以用ObservableType.subscribe，这和indexGenerator.next()类似 其中SequenceType是Swift(2.3以前版本,之后的版本没有该协议)中的一个协议，比如Swift中的Array就遵循这个协议，通过这个协议，你可以这样的去操作一个Array 12345let array = [1,2,3,4,5]let array2 = array.filter(&#123;$0 &gt; 1&#125;).map(&#123;$0 * 2&#125;)//4 6 8 10var indexGenerator = array2.generate()let fisrt = indexGenerator.next() // 4let seoncd = indexGenerator.next() //6 3. RxSwift中，ObservableType.subscribe的回调（新的信号到来）一共有三12345678enum Event&lt;Element&gt; &#123; case Next(Element) // 新的信号到来 case Error(ErrorType) // 信号发生错误，序列不会再产生信号 case Completed // 序列发送信号完成，不会再产生新的信号&#125;protocol ObserverType &#123; func on(event: Event&lt;Element&gt;) //监听所有的信号&#125; 4. 取消监听 Observable分为两种 在有限的时间内会自动结束（Completed/Error）,比如一个网络请求当作一个序列，当网络请求完成的时候，Observable自动结束，资源会被释放 信号不会自己结束，最简单的比如一个Timer，每隔一段时间发送一个新的信号过来，这时候需要手动取消监听，来释放相应的资源 比如一个label.rx.text是一个Obserable，通常需要这样调用addDisposableTo(disposeBag)来让其在deinit，也就是所有者要释放的时候，自动取消监听1234class Observable&lt;Element&gt; &#123; func subscribe(observer: Observer&lt;Element&gt;) -&gt; Disposable //调用Disposable的方法来取消&#125; 当然，除了手动释放，RxSwift提供了一些操作符，比如 takeUntil来根据条件取消 12345sequence .takeUntil(self.rx_deallocated) //当对象要释放的时候，取消监听 .subscribe &#123; print($0) &#125; 二. RxSwift简单体验 首先创建deinit属性，也就是所有者要释放的时候，自动取消监听 1fileprivate lazy var bag = DisposeBag() 1. RxSwift监听按钮的点击 传统方式: 1button1.addTarget(self, action: #selector(btn1Click(_:)), for: .touchUpInside) RxSwift方式 12345678button1.rx.tap.subscribe &#123; (event) in self.button1.setTitle(\"按钮1\", for: .normal) print(\"button1\")&#125;.addDisposableTo(bag) button2.rx.tap.subscribe &#123; (event) in self.textField2.text = \"按钮2被点击了\"&#125;.addDisposableTo(bag) 2. RxSwift监听UITextField的文字改变 传统做法,设置textField2.delegate = self RxSwift方式 2-1. 用on方法实现 1subscribe(&lt;#T##on: (Event&lt;Int&gt;) -&gt; Void##(Event&lt;Int&gt;) -&gt; Void#&gt;) 12345678910textField1.rx.text.subscribe &#123; (event: Event&lt;String?&gt;) in //将UITextField文字改变的内容显示在Label中 self.label1.text = event.element! print(event.element!!)&#125;.addDisposableTo(bag) textField2.rx.text.subscribe &#123; (event: Event&lt;String?&gt;) in print(event.element)//报警告 //输出: Optional(Optional(\"jun\"))&#125;.addDisposableTo(bag) 2-2. 用onNext方法实现 1subscribe(on: (Event&lt;Int&gt;) -&gt; Void) 123456789101112131415textField1.rx.text.subscribe(onNext: &#123; (str: String?) in self.label1.text = str!&#125;).addDisposableTo(bag)``` ### 3. RxSwift改变Label中文字```objclabel1.rx.observe(String.self, \"text\").subscribe(onNext: &#123; (str: String?) in print(str!)&#125;).addDisposableTo(bag) label2.rx.observe(CGRect.self, \"frame\").subscribe(onNext: &#123; (rect: CGRect?) in print(rect!.width)&#125;).addDisposableTo(bag) 4. RxSwift监听UIScrollView的滚动12345scrollView.contentSize = CGSize(width: 1000, height: 0)scrollView.rx.contentOffset .subscribe(onNext: &#123; (point : CGPoint) in print(point) &#125;).addDisposableTo(bag) 三. RxSwift常见操作 addDisposableTo(disposeBag)方法是让其deinit，也就是所有者要释放的时候，自动取消监听 12//创建baglet bag = DisposeBag() 1. never never就是创建一个sequence,但是不发出任何事件信号 123456let neverSqu = Observable&lt;String&gt;.never()neverSqu.subscribe &#123; (_) in //该语句不会执行 print(\"This will never be printed\")&#125;.addDisposableTo(bag)//调用Disposable的方法来取消 2. empty empty就是创建一个空的sequence,只能发出一个complected事件 12345Observable&lt;Int&gt;.empty().subscribe &#123; (event) in //该语句只会执行一次 //输出: completed print(event)&#125;.addDisposableTo(bag) 3. just just是创建一个sequence只能发出一种特定的事件，能正常结束 123456789101112131415161718192021222324252627282930313233343536Observable&lt;Int&gt;.just(3).subscribe &#123; (event) in print(event) /*该语句只会执行两次,分别输出 1) next(3),语句结果 2) completed, 结束事件 */&#125;.addDisposableTo(bag) Observable.just(\"jun\").subscribe &#123; (event) in print(event) /*该语句只会执行两次,分别输出 1) next(jun),语句结果 2) completed, 结束事件 */&#125;.addDisposableTo(bag)``` ### 4.of- of是创建一个sequence能发出很多种事件信号```objcObservable.of(\"a\", \"b\", \"2\", \"5.3\") .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(bag) //会分别输出 \"a\", \"b\", \"2\", \"5.3\"Observable.of(\"a\", \"b\", \"2\", \"5.3\").subscribe(onNext: &#123; (event) in print(event) /*该语句只会执行4次,分别输出 1) next(a),语句结果 2) next(b),语句结果 3) next(2),语句结果 4) next(3.5),语句结果 */&#125;, onError: nil, onCompleted: nil, onDisposed: nil).addDisposableTo(bag) //每一个闭包都设置设置了 一个默认值,故可以省略 5. from from就是从数组中创建sequence 123456789101112131415161718192021222324252627Observable.from([\"a\", \"b\", \"2\", \"5.3\"]).subscribe &#123; (event) in print(event) /*该语句只会执行5次,分别输出 1) next(a),语句结果 2) next(b),语句结果 3) next(2),语句结果 4) next(3.5),语句结果 5) completed, 结束事件 */&#125;.addDisposableTo(bag)``` ### 6. create- 我们也可以自定义可观察的sequence，那就是使用create- create操作符传入一个观察者observer，然后调用observer的onNext，onCompleted和onError方法。返回一个可观察的obserable序列#### 1) 自定义方法创建observable的creat##### 6-1 无参创建creat```objcfileprivate func myobserable() -&gt; Observable&lt;Any&gt; &#123; return Observable.create(&#123; (observal: AnyObserver&lt;Any&gt;) -&gt; Disposable in observal.onNext(\"abc\") observal.onNext(\"12\") observal.onCompleted() return Disposables.create() &#125;)&#125; 6-2 添加参数创建creat1234567fileprivate func myJunst(element: String) -&gt; Observable&lt;String&gt; &#123; return Observable.create(&#123; (observal: AnyObserver&lt;String&gt;) -&gt; Disposable in observal.onNext(element) observal.onCompleted() return Disposables.create() &#125;)&#125; 2) 在函数内调用自定义方法123456myobserable().subscribe(onNext: &#123; print($0) &#125;).addDisposableTo(bag)//该语句只会执行2次,分别输出\"abc\", \"12\" myJunst(element: \"jun\").subscribe(onNext: &#123; print($0) &#125;).addDisposableTo(bag)//该语句只会执行2次,分别输出\"jun\" 7. range(给定范围, 依次显示) range就是创建一个sequence，他会发出这个范围中的从开始到结束的所有事件 Observable,必须指定数据类型 12345678910Observable&lt;Int&gt;.range(start: 1, count: 4).subscribe &#123; (event: Event&lt;Int&gt;) in print(event) /*该语句只会执行5次,分别输出 1) next(1),语句结果 2) next(2),语句结果 3) next(3),语句结果 4) next(4),语句结果 5) completed, 结束事件 */&#125;.addDisposableTo(bag) 8. repeatElement(重复执行)创建一个sequence，发出特定的事件n次 12345Observable.repeatElement(\"quanjun\") .take(3) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(bag) //该语句只会执行3次,每次都输出\"quanjun\" 9. generate(类似于for循环) generate是创建一个可观察sequence，当初始化的条件为true的时候，他就会发出所对应的事件 1234567891011121314let generate = Observable.generate(initialState: 0, condition: &#123; $0 &lt; 5 &#125;, iterate: &#123; $0 + 2 &#125;)generate.subscribe(&#123; print($0) &#125;).addDisposableTo(bag) /*1&gt; 输出顺序: next(0) next(2) next(4) completed 2&gt; 以上代码可以理解为for循环处理逻辑 for (Int i = 0; i &lt; 5; i++) &#123; print(i) &#125; */ 10. error(发出错误信号) 创建一个可观察序列，但不发出任何正常的事件，只发出error事件并结束 1234567891011121314151617181920212223242526272829303132333435363738 let error = NSError(domain: \"错误\", code: 10, userInfo: nil) as Error Observable&lt;Any&gt;.error(error) .subscribe(&#123; print($0) &#125;) .addDisposableTo(bag) //输出: error(Error Domain=错误 Code=10 \"(null)\")``` ## 四. RxSwift中Subjects- Subjects是什么? - Subjet是observable和Observer之间的桥梁，一个Subject既是一个Obserable也是一个Observer，他既可以发出事件，也可以监听事件 ## 1. PublishSubject- 当你订阅PublishSubject的时候，你只能接收到订阅他之后发生的事件。subject.onNext()发出onNext事件，对应的还有onError()和onCompleted()事件```objclet pSubject = PublishSubject&lt;String&gt;()pSubject.subscribe &#123; (event: Event&lt;String&gt;) in print(\"2--\", event) &#125;.addDisposableTo(bag)print(\"1--------------\") pSubject.onNext(\"T\")pSubject.onNext(\"Q\") pSubject.subscribe &#123; (event: Event&lt;String&gt;) in print(\"3--\", event) &#125;.addDisposableTo(bag)pSubject.onNext(\"J\") /*输出顺序为: 1-------------- 2-- next(T) 2-- next(Q) 2-- next(J) 3-- next(J) */ 2. ReplaySubject 当你订阅ReplaySubject的时候，你可以接收到订阅他之后的事件，但也可以接受订阅他之前发出的事件，接受几个事件取决与bufferSize的大小 createUnbounded()表示接受所有事件 create(bufferSize: 4) 表示可接受到的订阅他之前的事件的个数,但是订阅他之后的事件一定会触发 2-1. createUnbounded()表示接受所有事件1234567891011121314let rSubject = ReplaySubject&lt;String&gt;.createUnbounded()rSubject.onNext(\"T\")rSubject.onNext(\"Q\")rSubject.subscribe &#123; (event: Event&lt;String&gt;) in print(\"0--\", event) &#125;.addDisposableTo(bag) rSubject.onNext(\"J\")/*输出顺序为: 0-- next(T) 0-- next(Q) 0-- next(J) */ 2-2. create(bufferSize: 4) 表示可接受到的订阅他之前的事件的个数12345678910111213let rSubject1 = ReplaySubject&lt;String&gt;.create(bufferSize: 1)rSubject1.onNext(\"T\")rSubject1.onNext(\"Q\")rSubject1.subscribe &#123; (event: Event&lt;String&gt;) in print(\"4--\", event) &#125;.addDisposableTo(bag) rSubject1.onNext(\"J\")/*输出顺序为: 4-- next(Q) 4-- next(J) */ 3. BehaviorSubject 当你订阅了BehaviorSubject，你会接受到订阅之前的最后一个事件,订阅之后的事件一定会触发 12345678910111213141516171819202122let bSubject = BehaviorSubject(value: \"G\")bSubject.subscribe &#123; (event: Event&lt;String&gt;) in print(\"5--\", event) &#125;.addDisposableTo(bag) bSubject.onNext(\"Y\")bSubject.onNext(\"Q\") bSubject.subscribe &#123; (event: Event&lt;String&gt;) in print(\"6--\", event) &#125;.addDisposableTo(bag) bSubject.onNext(\"J\")/*输出顺序为: 5-- next(G) 5-- next(Y) 5-- next(Q) 6-- next(Q) 5-- next(J) 6-- next(J) */ 4. Variable Variable是BehaviorSubject一个包装箱，就像是一个箱子一样，使用的时候需要调用asObservable()拆箱，里面的value是一个BehaviorSubject，他不会发出error事件，但是会自动发出completed事件。 1&gt; 相当于对BehaviorSubject进行装箱 2&gt; 如果想将Variable当成Obserable, 让订阅者进行订阅时, 需要调用asObserable拆箱转成Obserable 3&gt; 如果Variable打算发出事件, 直接修改对象的value即可 4&gt; 当事件结束时,Variable会自动发出completed事件 123456789101112131415161718192021222324let variable = Variable(\"S\")variable.asObservable().subscribe &#123; (event) in print(\"7--\", event) &#125;.addDisposableTo(bag) variable.value = \"D\"variable.value = \"Q\" variable.asObservable().subscribe &#123; (event) in print(\"8--\", event) &#125;.addDisposableTo(bag) variable.value = \"j\"/*输出顺序为: 7-- next(S) 7-- next(D) 7-- next(Q) 8-- next(Q) 7-- next(j) 8-- next(j) 7-- completed 8-- completed */ 五. RxSwift细节理解1. 变换操作1-1. map 通过传入一个函数闭包把原来的sequence转变为一个新的sequence的操作 1234567891011Observable.of(1, 2, 3, 4) .map(&#123; $0 * $0 &#125;) .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(bag) /* 输出顺序为: 1 4 9 16 */ 1-2. flatMap 将一个sequence转换为一个sequences，当你接收一个sequence的事件，你还想接收其他sequence发出的事件的话可以使用flatMap，她会将每一个sequence事件进行处理以后，然后再以一个sequence形式发出事件 首先创建一个struct123struct Student &#123; var score: Variable&lt;Double&gt;&#125; flatMap执行代码123456789101112131415161718192021let stu1 = Student(score: Variable(80))let stu2 = Student(score: Variable(100)) let student = Variable(stu1)student.asObservable().flatMap &#123; (stu: Student) -&gt; Observable&lt;Double&gt; in return stu.score.asObservable()&#125;.subscribe &#123; (event) in print(event)&#125;.addDisposableTo(bag) student.value = stu2stu1.score.value = 10stu2.score.value = 20 /* 输出顺序为: next(80.0) next(100.0) next(10.0) next(20.0) completed */ 1-3. flatMapLatest flatMapLatest只会接收最新的value事件，将上例代码改为flatMapLatest 123456789101112131415161718let stu3 = Student(score: Variable(70))let stu4 = Student(score: Variable(60))let student1 = Variable(stu3)student1.asObservable().flatMapFirst &#123; (stu) -&gt; Observable&lt;Double&gt; in return stu.score.asObservable()&#125;.subscribe &#123; (event: Event&lt;Double&gt;) in print(event)&#125;.addDisposableTo(bag)student1.value = stu4stu3.score.value = 10stu4.score.value = 20 /* 输出顺序为: next(70.0) next(10.0) completed */ 2. 释放资源 当监听一个事件序列的时候，有消息事件来了，我们做某些事情。但是这个事件序列不再发出消息了，我们的监听也就没有什么存在价值了，所以我们需要释放我们这些监听资源，其实也就是每种编程语言中的内存资源释放。 OC和Swift中也一样，在你不需要用某些变量的时候，你需要把这些变量所占用的内存空间释放掉。 释放某一个监听的时候我们可以手动调用释放方法 2-1. dispose 相当于MRC中手动调用release操作 注意: 因为观察者已经销毁, 所有后面无法接受事件 1234567891011let testVariable = Variable(\"jun\")testVariable.asObservable().subscribe &#123; (event : Event&lt;String&gt;) in print(event)&#125;.dispose()testVariable.value = \"tian\" /* 输出顺序为: next(jun) completed */ 2-2. Dispose Bags 除了上面手动的方法，还有一种是自动的方式 推荐大家使用这种方式，这种方式就好像iOS中的ARC方式似得，会自动去释放资源。1fileprivate lazy var bag = DisposeBag() 在代码结尾调用.addDisposableTo(bag)方法 3. UIBindingObserver UIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa(RxSwiftz中对UIKit的一个扩展库)给的扩展不够我们使用 比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做： 1234567extension Reactive where Base: UITextField &#123; var inputEnabled: UIBindingObserver&lt;Base, Result&gt; &#123; return UIBindingObserver(UIElement: base) &#123; textFiled, result in textFiled.isEnabled = result.isValid &#125; &#125;&#125; 后续会继续更新相关方面知识,敬请期待","categories":[{"name":"RxSwift框架","slug":"RxSwift框架","permalink":"https://titanjun.top/categories/RxSwift框架/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://titanjun.top/tags/RxSwift/"},{"name":"响应式编程","slug":"响应式编程","permalink":"https://titanjun.top/tags/响应式编程/"}]},{"title":"iOS之Scanner字符串扫描类","slug":"iOS之Scanner字符串扫描类","date":"2017-09-09T14:14:40.000Z","updated":"2018-04-10T08:55:01.798Z","comments":true,"path":"2017/09/09/iOS之Scanner字符串扫描类/","link":"","permalink":"https://titanjun.top/2017/09/09/iOS之Scanner字符串扫描类/","excerpt":"注: 本文主要语法为Swift4.0 Scanner继承自NSObject，遵守NSCopying协议。是一个用于扫描指定字符串的抽象类 可以创建Scanner时制定他的String属性，然后scanner会按照你的要求从头到尾扫描这个字符串的每个字符 扫描操作从上次扫描的位置开始，并且继续往后扫描直到指定的内容出现为止（如果有的话）","text":"注: 本文主要语法为Swift4.0 Scanner继承自NSObject，遵守NSCopying协议。是一个用于扫描指定字符串的抽象类 可以创建Scanner时制定他的String属性，然后scanner会按照你的要求从头到尾扫描这个字符串的每个字符 扫描操作从上次扫描的位置开始，并且继续往后扫描直到指定的内容出现为止（如果有的话） 1. 部分属性的相关解释123456789101112131415 open var string: String &#123; get &#125; // (只读)返回当前被扫描的字符串open var scanLocation: Int// 当前扫描的位置，默认是从0开始的。通过设置这个属性值，可以自定义扫描的位置open var charactersToBeSkipped: CharacterSet?// 这个集合是用来设置我们需要跳过扫描的一个字符集合open var caseSensitive: Bool// 是否大小写敏感 public init(string: String)// 用给定扫描字符串初始化 2. 部分方法的相关解释2-1 以下方法的作用都是 扫描该类型的字符串,并将扫描结果赋值给result 判断该字符串的第一个字符(默认第一个,可根据scanLocation属性设置)是否为该类型 1234567891011121314open func scanInt32(_ result: UnsafeMutablePointer&lt;Int32&gt;?) -&gt; Bool@available(iOS 2.0, *)open func scanInt(_ result: UnsafeMutablePointer&lt;Int&gt;?) -&gt; Boolopen func scanInt64(_ result: UnsafeMutablePointer&lt;Int64&gt;?) -&gt; Bool@available(iOS 7.0, *)open func scanUnsignedLongLong(_ result: UnsafeMutablePointer&lt;UInt64&gt;?) -&gt; Boolopen func scanFloat(_ result: UnsafeMutablePointer&lt;Float&gt;?) -&gt; Boolopen func scanDouble(_ result: UnsafeMutablePointer&lt;Double&gt;?) -&gt; Bool 2-1-1 包含纯数字的字符串1234567891011121314151617var int1: Int = 0var int64: Int64 = 0var int32: Int32 = 0var float1: Float = 0.0var double1: Double = 0.0//判断字符串包含的类型(输出结果为true)print(Scanner(string: \"987\").scanInt(&amp;int1))print(Scanner(string: \"897\").scanInt64(&amp;int64))print(Scanner(string: \"99\").scanInt32(&amp;int32))print(Scanner(string: \"90.99\").scanFloat(&amp;float1))print(Scanner(string: \"98.09\").scanDouble(&amp;double1))//输出扫描后的结果int1 = 98int64 = 897int32 = 99float = 90.99double = 98.09 2-1-2 非纯数字的字符串1234567891011var int1: Int = 0let scanner = Scanner(string: \"m998k23l\")scanner.scanLocation = 1print(scanner.scanInt(&amp;int1)) // true//int1 = 998var double1: Double = 0.0let scanner = Scanner(string: \"ms9.98k45l\")scanner.scanLocation = 1print(scanner.scanDouble(&amp;double1)) false//double1 = 0.0 2-2 以下方法的作用都是 扫描字符串前缀是否是”0x”或者”0X”,返回true或false 将0x(0X)字符后面符合十六进制数的字符串转化成十进制数(可运用到UIColor关于十六进制数的转化) 12345678910open func scanHexInt32(_ result: UnsafeMutablePointer&lt;UInt32&gt;?) -&gt; Bool // Optionally prefixed with \"0x\" or \"0X\"@available(iOS 2.0, *)open func scanHexInt64(_ result: UnsafeMutablePointer&lt;UInt64&gt;?) -&gt; Bool // Optionally prefixed with \"0x\" or \"0X\"@available(iOS 2.0, *)open func scanHexFloat(_ result: UnsafeMutablePointer&lt;Float&gt;?) -&gt; Bool // Corresponding to %a or %A formatting. Requires \"0x\" or \"0X\" prefix.@available(iOS 2.0, *)open func scanHexDouble(_ result: UnsafeMutablePointer&lt;Double&gt;?) -&gt; Bool // Corresponding to %a or %A formatting. Requires \"0x\" or \"0X\" prefix. 2-2-1 代码示例123456789print(Scanner(string: \"xdd\").scanHexInt64(&amp;uint64)) //falseprint(Scanner(string: \"0xdd\").scanHexInt64(&amp;uint64)) //trueprint(uint64) //221print(Scanner(string: \"0xax\").scanHexInt32(&amp;uint32)) //trueprint(uint32) // 10print(Scanner(string: \"0X991\").scanHexFloat(&amp;float1)) //trueprint(float1) //2449.0print(Scanner(string: \"0X99\").scanHexDouble(&amp;double1)) //trueprint(double1) //153.0 2-3 从给定的字符串中找到相同的字符1open func scanString(_ string: String, into result: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?) -&gt; Bool 代码示例 12345678var sstring: NSString?let scan = Scanner(string: \"32jingki\")while !scan.isAtEnd&#123; // 判断是否扫描到最后 scan.scanLocation += 1 print(scan.scanLocation) scan.scanString(\"i\", into: &amp;sstring) print(sstring)&#125; 2-4 Scanner的其他方法12345678910open func scanCharacters(from set: CharacterSet, into result: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?) -&gt; Bool////从scan中扫描出string放入result中，如果不需要存储string，则result传NULLopen func scanUpTo(_ string: String, into result: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?) -&gt; Bool//从scan中扫描出string之外的数据放入result中，如果不需要存储string，则result传NULLopen func scanUpToCharacters(from set: CharacterSet, into result: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?) -&gt; Bool//从scan中扫描出set之外的数据放入result中，如果不需要存储string，则result传NULL 2-5 关于使用Scanner处理UIColor十六进制数值的问题 可在UIColor的extension中添加扩展方法 12345678910111213141516171819202122232425262728293031323334353637383940/** 十六进制颜色扩充 */convenience init?(hex : String, alpha : CGFloat = 1.0) &#123; //1.判断字符串长度是否符合 guard hex.characters.count &gt;= 6 else &#123; return nil &#125; //2.将字符串转成大写 var tempHex = hex.uppercased() //3.判断开头 if tempHex.hasPrefix(\"0x\") || tempHex.hasPrefix(\"##\") || tempHex.hasPrefix(\"0X\") &#123; //去掉开头 tempHex = tempHex.dropFirst(2) &#125; if tempHex.hasPrefix(\"#\") &#123; tempHex = tempHex.dropFirst() &#125; //4.分别截取RGB var range = NSRange(location: 0, length: 2) let rHex = (tempHex as NSString).substring(with: range) range.location = 2 let gHex = (tempHex as NSString).substring(with: range) range.location = 4 let bHex = (tempHex as NSString).substring(with: range) //5.将字符串转化成数字 emoji也是十六进制表示(此处也可用Float类型) var r : UInt32 = 0, g : UInt32 = 0, b : UInt32 = 0 //创建扫描器,将字符串的扫描结果赋值给:r,g,b Scanner(string: rHex).scanHexInt32(&amp;r) Scanner(string: gHex).scanHexInt32(&amp;g) Scanner(string: bHex).scanHexInt32(&amp;b) self.init(r : CGFloat(r), g : CGFloat(g), b : CGFloat(b))&#125;/**RGB三原色 */convenience init(r : CGFloat, g : CGFloat, b : CGFloat, alpha : CGFloat = 1.0) &#123; self.init(red: r / 255.0, green: g / 255.0, blue: b / 255.0, alpha: alpha)&#125;","categories":[{"name":"高级用法","slug":"高级用法","permalink":"https://titanjun.top/categories/高级用法/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"Scanner","slug":"Scanner","permalink":"https://titanjun.top/tags/Scanner/"},{"name":"iOS扫描器","slug":"iOS扫描器","permalink":"https://titanjun.top/tags/iOS扫描器/"}]},{"title":"升级Swift4.0遇到的坑","slug":"升级Swift4.0遇到的坑","date":"2017-08-25T07:06:40.000Z","updated":"2018-03-14T09:56:01.000Z","comments":true,"path":"2017/08/25/升级Swift4.0遇到的坑/","link":"","permalink":"https://titanjun.top/2017/08/25/升级Swift4.0遇到的坑/","excerpt":"并不是所有库都能做到及时支持Swift4.0，更何况是在现在连Xcode9也还是beta的状态 所以我们仅能做到将自己的业务代码（主工程代码）部分升级到Swift4.0，然后同时保留各种pod库在Swift3.2版本。 没办法，谁叫Swift4.0也还无法做到API兼容呢（但愿能在Swift5之前实现吧）。 至于我说的同时使用两个版本的Swift，这是没问题的，Xcode9支持在项目中同时使用Swift3.2和Swift4.0。","text":"并不是所有库都能做到及时支持Swift4.0，更何况是在现在连Xcode9也还是beta的状态 所以我们仅能做到将自己的业务代码（主工程代码）部分升级到Swift4.0，然后同时保留各种pod库在Swift3.2版本。 没办法，谁叫Swift4.0也还无法做到API兼容呢（但愿能在Swift5之前实现吧）。 至于我说的同时使用两个版本的Swift，这是没问题的，Xcode9支持在项目中同时使用Swift3.2和Swift4.0。 一. 修改Swift版本1. 如下图指定主工程的Swift版本为4.0 2. 修改pod库 在Podfile文件的最下方加入如下代码，指定pod库的Swift版本为3.2(这样会使得所有的第三方pod库的Swift版本都为3.2) 1234567post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['SWIFT_VERSION'] = '3.2' end endend 二. 主工程中的代码修改1. 列举一下Swift3.2到Swift4.0的改变(只是我项目中遇到的)： 1). Swift4.0中对于扩展的属性(包括实例属性、static属性、class属性)，都只能使用get方法，不可使用set方法 2). Swift4.0中不再允许复写扩展中的方法(包括实例方法、static方法、class方法) 比如:自定义的协议方法在extension中实现,若某个类遵循了该协议,其子类便不能重写该协议方法 解决的方法是: 在每个需要该协议的类里面都重新遵循该协议,实现协议方法 个人想到的办法,不知道有没有其他解决办法可以提供一下 3). swift3使用#selector指定的方法，只有当方法权限为private时需要加@objc修饰符，现在Swift4.0全都要加@objc修饰符 4). 自定义的protocol协议中,有optional修饰的非必须实现的方法,需要用@objc修饰 5). 字体方面的一些重命名 12345678910111213141516NSFontAttributeName --- .font //或者NSAttributedStringKey.fontNSForegroundColorAttributeName --- .foregroundColor//NSAttributedStringKey.foregroundColorNSStrikethroughStyleAttributeName --- .strikethroughStyle//NSAttributedStringKey.strikethroughStyle//字符串类型的,添加rawValueNSAttributedStringKey.font.rawValue//等等等等..........//大部分类似以下,涉及富文本的方法均已改为了NSAttributedStringKey类型addAttributes(_ attrs: [NSAttributedStringKey : Any] = [:], range: NSRange) 三. 项目中遇到的一些的报错问题3-1. “Closure cannot implicitly capture a mutating self parameter”错误 在struct中，如果我们在闭包中使用self，就会得到Closure cannot implicitly capture a mutating self parameter的错误提示。比如： 1234567891011struct RecordModel &#123; /// 定义一个闭包 var action: (() -&gt; ())? var height = 10 self.action = &#123; self.height = 20 //Closure cannot implicitly capture a mutating self parameter报错 &#125;&#125; 并且由于RecordModel的类型是struct，我们也没发在action闭包里添加截获列表。那么是不是就必须使用class了？答案是否定的。有两种方式可以解决这个问题。 方案一：为closure增加一个inout类型的参数12345678910struct RecordModel &#123; /// 定义一个闭包 var action: ((_ inSelf: inout RecordModel) -&gt; ())? var height = 10 self.action = &#123; (inSelf) in inSelf.height = 20 &#125;&#125; 根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure(闭包)中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。 方案二：使用UnsafeMutablePointer&lt;Pointee&gt; 这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。 123456789101112struct RecordModel &#123; /// 定义一个闭包 var action: (() -&gt; ())? var height = 10 let selfPointer = UnsafeMutablePointer(&amp;self) self.action = &#123; selfPointer.pointee.height = 20 &#125;&#125; 结论Closure cannot implicitly capture a mutating self parameter错误的原因是在进出closure(闭包)之后，self的一致性没办法得到保证，所以编译器默认不允许在struct的closure(闭包)中使用self。如果我们确定这么做是安全的，就可以通过上面的两种方式解决这个问题。其中，方法二的性能更好一些。 注意 这里可以记一下指针和swift变量之间的关系： UnsafePointer对应let UnsafeMutablePointer对应var AutoreleasingUnsafeMutablePointer对应unowned UnsafeMutablePointer，用于inout的参数类型 UnsafeRawPointer对应let Any，raw系列都是对应相应的Any类型 UnsafeBufferPointer是non-owning的类型（unowned），用于collection的elements, buffer系列均如此 3-2. Declarations from extensions cannot be overridden yet 错误这个错误大致是因为,协议方法是在extension里面的,不能被重写 解决办法:(仅供参考,如有更好的建议还望多多指教) 小编想到的解决办法就是在每一个需要此协议的类里面,重新遵循代理,实现该协议方法 3-3. &quot;Method &#39;initialize()&#39; defines Objective-C class method &#39;initialize&#39;, which is not permitted by Swift&quot;报错原因: 在于已经废弃的initialize方法,示例如下 方法交叉(Method Swizzling) 有时为了方便，也有可能是解决某些框架内的 bug，或者别无他法时，需要修改一个已经存在类的方法的行为。方法交叉可以让你交换两个方法的实现，相当于是用你写的方法来重载原有方法，并且还能够是原有方法的行为保持不变。 1234567extension UIViewController &#123; public override class func initialize() &#123;//此处报错 //此处省略100行代码 &#125;&#125; initialize该方法已经被Swift4.0废弃 在Swift3.0还勉强可以使用,但是会有警告;但是在4.0已经被完全废弃 替代方法: 在 app delegate 中实现方法交叉 像上面通过类扩展进行方法交叉，而是简单地在 app delegate 的 application(_:didFinishLaunchingWithOptions:) 方法调用时调用该方法 1234567891011121314extension UIViewController &#123; public override class func initializeOnceMethod() &#123; //此处省略100行代码 &#125;&#125;//在AppDelegate的方法中调用:func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool &#123; //此处省略100行代码 UIViewController.initializeOnceMethod()&#125; 3-4. &#39;dispatch_once&#39; is unavailable in Swift: Use lazily initialized globals instead 报错原因: dispatch_once在Swift4.0也已经被废弃 123456789extension UITableView &#123; struct once&#123; static var onceTaken:Int = 0 &#125; dispatch_once(&amp;once.onceTaken) &#123; () -&gt; Void in //在这里dispatch_once就会报错 //此处省略1000000行代码 &#125;&#125; 解决方法: 通过给DispatchQueue添加扩展实现 12345678910111213141516171819202122extension DispatchQueue &#123; private static var _onceTracker = [String]() public class func once(token: String, block: () -&gt; ()) &#123; objc_sync_enter(self) defer &#123; objc_sync_exit(self) &#125; if _onceTracker.contains(token) &#123; return &#125; _onceTracker.append(token) block() &#125; func async(block: @escaping ()-&gt;()) &#123; self.async(execute: block) &#125; func after(time: DispatchTime, block: @escaping ()-&gt;()) &#123; self.asyncAfter(deadline: time, execute: block) &#125;&#125; 使用字符串token作为once的ID，执行once的时候加了一个锁，避免多线程下的token判断不准确的问题。使用的时候可以传token 123DispatchQueue.once(token: \"tableViewOnce\") &#123; print( \"Do This Once!\" ) &#125; 或者使用UUID也可以： 12345private let _onceToken = NSUUID().uuidString DispatchQueue.once(token: _onceToken) &#123; print( \"Do This Once!\" ) &#125; 后续又遇到别的问题会继续更新 文章中如有解释不足之处,还望多多指教","categories":[{"name":"入坑指南","slug":"入坑指南","permalink":"https://titanjun.top/categories/入坑指南/"}],"tags":[{"name":"Swift4.0","slug":"Swift4-0","permalink":"https://titanjun.top/tags/Swift4-0/"},{"name":"Error","slug":"Error","permalink":"https://titanjun.top/tags/Error/"},{"name":"入坑","slug":"入坑","permalink":"https://titanjun.top/tags/入坑/"}]},{"title":"JavaScript基本语法01","slug":"JavaScript基本语法01","date":"2017-08-09T15:16:40.000Z","updated":"2018-03-13T01:46:20.000Z","comments":true,"path":"2017/08/09/JavaScript基本语法01/","link":"","permalink":"https://titanjun.top/2017/08/09/JavaScript基本语法01/","excerpt":"JavaScript 是一门高端的、动态的、弱类型的编程语言，适合面向对象和函数式的编程风格。 JavaScript 语法源自 Java，一等函数（first-class function）来自于Scheme，基于原型（prototype-based）的继承来自于Self。","text":"JavaScript 是一门高端的、动态的、弱类型的编程语言，适合面向对象和函数式的编程风格。 JavaScript 语法源自 Java，一等函数（first-class function）来自于Scheme，基于原型（prototype-based）的继承来自于Self。 一、类型、值和变量1、数字 JavaScript 中不区分整数值和浮点数值，所有数字均用浮点数值表示 JS采用IEEE754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是±1.7976031348623157×10308，最小值是±5×10-324 按照JS中的数字格式，能够表示的整数范围是-9007199254740992~9007199254740992（即 -253~253） 需要注意的是，JS中实际的操作（比如数组索引，位操作符）则是基于32位整数。 1.1、数字展示格式1234567021000003.1415.3333339.02e10 //9.02 * 10的10次方1.4E-8 //1.4 * 10的-8次方 1.2、JavaScript中的算术运算符 JavaScript用Math对象实现复杂的运算 1234567891011121314151617Math.pow(2,3) //8；2的3次幂Math.round(.6) //1.0；四舍五入Math.ceil(.6) //1.0；向上取整Math.floor(.6) //0.0；向下取整Math.abs(-5) //5；求绝对值Math.max(x,y,z) //返回最大值Math.min(x,y,z) //返回最小值Math.random() //生成一个大于等于0小于1.0的伪随机数Math.PI //π；圆周率Math.E //e；自然对数的底数Math.sqrt(3) //3的平方根Math.pow(3,1/3) //3的立方根Math.sin(0) //三角函数。Math.cos(),Math.tan(),Math.sin(30/180*Math.PI) Math.log(10) //10的自然对数Math.log(100)/Math.LN10 //以10为底100的对数Math.log(512)/Math.LN2 //以2为底512的对数Math.exp(3) //e的3次幂 1.3、日期和时间 Date()构造函数，用于创建表示日期和时间的对象 123456789101112var then=new Date(2017,0,1); //2017年1月1日var later=new Date(2017,0,1,17,10,30);//2017年1月1日 17:10:30var now=new Date(); //当前日期和时间var elapsed=now-then; //日期减法，计算时间间隔的毫秒数later.getFullYear(); //获取年份later.getMonth(); //获取月份，从0开始计数，一月份是0later.getDate(); //获取日期，从1开始计数，一号是1later.getDay(); //星期几，0是星期日，5是星期五later.getHours(); //获取小时later.getMinutes(); //获取分钟later.getSeconds(); //获取秒later.getUTCHours(); //获取使用UTC表示的小时的时间 二、文本字符串12345678910111213141516171819202122232425262728293031323334//字符串var jsString = \"Hello,JavaScript\";//字符串长度var s0 = jsString.length; //16,// 第一个字符var s1 = jsString.charAt(0) ; //\"H\",// 最后一个字符var s2 = jsString.charAt(s0 - 1) //\"t\",//第2~4个字符var s3 = jsString.substring(1, 4) //\"ell\",//第2~4个字符var s4 = jsString.slice(1, 4) //\"ell\"// 最后三个字符var s5 = jsString.slice(-3) //\"ipt\"// 字符\"a\"首次出现的位置var s6 = jsString.indexOf(\"a\") //7// 字符\"a\"最后一次出现的位置var s7 = jsString.lastIndexOf(\"a\") //9// 字符\"a\"第二次出现的位置var s8 = jsString.indexOf(\"a\", 2) //7// 字符串分割成数组var s9 = jsString.split(\",\") //[\"Hello\", \"JavaScript\"]// 全文字符替换var s10 = jsString.replace(\"e\", \"E\") //\"HEllo,JavaScript\"// 全文转换为大写var s11 = jsString.toUpperCase() //\"HELLO,JAVASCRIPT\"// 全文转换成小写var s12 = jsString.toLowerCase() //\"hello,javascript\"//测试输出结果var sArr = [s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]for (var i = 0; i &lt; sArr.length; i++) &#123; console.log(sArr[i])&#125; 三、JavaScript之数组 数组是值的有序集合 JavaScript数组事务类型的:数组元素可以使任何类型, 同一数组中的不同元素也可以是不同类型 数组的元素也可以是对象或者其他数组 JavaScript数组可能是稀疏的: 数组元素的索引不一定是连续的,之间可能有空缺 稀疏数组的length比任何元素的索引都要大 1.创建数组(直接量创建)1234567891011121314151617//1.1: 简单数组var empty = []; //空数组var pram = [2, 3, 2] //有三个数值的数组var misc = [1.1, true, \"a\"] //三个不同元素的数组// 1.2: 数组中的直接量不一定是常量,也可能是表达式var base = 1024var baseArr = [base, base + 1, base + 2, base + 3]// 1.3: 包含对象或数组var array3 = [[1, &#123;x: 1, y: 2&#125;], [2, &#123;x: 3, y: 4&#125;]]//1.4: 忽略中间量中的某个值,省略的元素将被赋予undefinedvar undef1 = [1, ,3] //三个元素,中间的为undefinedvar undef2 = [, ,] //2个元素都是undefined//注: 数组直接量的语法允许游客选的结尾的逗号,故[, ,]只有2个元素 2. Array()创建数组123456// 空数组var a = new Array()//指定数组长度var a1 = new Array(10)//显示创建var a2 = new Array(1, 2, 3, \"a\") 3. 数组操作123456789101112131415161718//3. 读写数组元素//注: 1.数组是对象的特殊形式,故JavaScript的数组不存在越界报错的情况,只会取到undefinedvar value = a2[3]//4. 数组的长度//length属性为可读可写var arr = [1, 2, 3, 4, 5, 6]var arrLength = arr.length //6arr.length = 4 //数组变为[1, 2, 3, 4]arr.length = 0 // 删除所有元素,为[]arr.length = 5 // 长度为5,但是没有元素,相当于new Array(5)//5. 数组元素的添加和删除//5.1: 索引值添加var a0 = []a0[0] = 3a0[1] = \"one\"//a0为[3, \"one\"] 6. 数组的方法 主要介绍ECMAScript中的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//6.1: join()/*注:0.不改变原数组1.将数组所有的元素都转化成字符串,并连接在一起,返回生成后的字符串(如不指定分隔符默认使用逗号)2.join是String.split()的逆向操作*/var arr0 = [1, 2, 3, 4]var join1 = arr0.join() // \"1,2,3,4\"var join2 = arr0.join(\"\") //\"1234\"var join3 = arr0.join(\"-\") //\"1-2-3-4\"console.log(join1,join2,join3)//6.2: reverse()/*0.改变原数组1.将数组中的元素颠倒顺序*/arr0.reverse() //现在arr0为[4, 3, 2, 1]console.log(arr0)//6.3: sort()排序/*注:0.改变原数组1.不带参数时,以字母表顺序排序2.如果数组包含undefined,则会被排到数组的末尾3.字母排序区分大小写,A &lt; a*/var arr1 = new Array(\"tian\", \"quan\", \"jun\")arr1.sort() //arr1 = [\"jun\", \"quan\", \"tian\"]console.log(arr1)//条件比较var arr2 = new Array(\"ant\", \"Bug\", \"cat\", \"Dog\")arr2.sort() //[\"Bug\", \"Dog\", \"ant\", \"cat\"]console.log(arr2)//不区分大小写排序arr2.sort(function (s, t) &#123; var a = s.toLowerCase() var b = t.toLowerCase() if (a &lt; b) return -1 if (a &gt; b) return 1 return 0&#125;)console.log(arr2)//[\"ant\", \"Bug\", \"cat\", \"Dog\"]//6.4: concat()创建并返回一个新数组//0.不改变原数组var arr4 = [0, 2, 3]var concat1 = arr4.concat() //[0, 2, 3]var concat2 = arr4.concat(1, 4) //[0, 2, 3, 1, 4]var concat3 = arr4.concat([1, 4]) //[0, 2, 3, 1, 4]var concat4 = arr4.concat([1, 4], [5, 6]) //[0, 2, 3, 1, 4, 5, 6]var concat5 = arr4.concat(1, [4, [5, 6]]) //[0, 2, 3, 1, 4, [5, 6]]var concatArr = [concat1, concat2, concat3, concat4, concat5]console.log(concatArr)//6.5: slice()/** 注意:* 1.返回数组的部分数组* 2.不改变原数组* 3.两个参数,分别表示始末位置,含左不含右* 4. 1表示第一个元素,-1表示倒数第一个元素* 5.只有一个参数,默认以此参数开始,到最后一个元素结束* */var arr3 = [1, 2, 3, 4, 5]var slice1 = arr3.slice(0,2) //[1, 2]var slice2 = arr3.slice(3) //[4, 5]var slice3 = arr3.slice(1,-2) //[2, 3]var slice4 = arr3.slice(-3,-2) //[3]var sliceArr = [slice1, slice2, slice3, slice4]console.log(sliceArr)//6.6: splice()/** 1.在数组中插入或删除元素的通用方法* 2.会修改原数组,会改变数组的索引值* 3.两个参数,参数一:起始位置;参数二:处理元素的个数(可省略)* 4.若省略第二个参数,默认从起始位置到最后* 5.如果没有元素就返回空数组* */var m = [1, 2, 3, 4, 5, 6, 7]var splice1 = m.splice(4) //返回[5, 6, 7], m 是[1, 2, 3, 4]console.log(m)var splice2 = m.splice(1, 2) //返回[2, 3], m 是[1, 4]console.log(m)var splice3 = m.splice(1, 1) //返回[4], m 是[1]console.log(m)var spliceArr = [splice1, splice2, splice3]console.log(spliceArr)//6.7: push()和pop()/** 方法将数组当成栈使用* 1.push方法在尾部添加一个或者多个元素,返回新的数组长度* 2.pop删除数组的最后一个元素,减小数组的长度,返回删除的值* 3.改变原数组的值和长度* */var m0 = []var pp1 = m0.push(1, 2) //[1, 2], 返回2var pp2 = m0.pop() //[1], 返回2var pp3 = m0.push(3, 4) //[1, 3, 4], 返回3var pp4 = m0.pop() //[1, 3], 返回4var pp5 = m0.push([9,0]) //[1, 3, [9, 0]], 返回3var pp6 = m0.pop() //[1, 3], 返回[9, 0]var pp7 = m0.pop() //[1], 返回3var ppArr = [pp1, pp2, pp3, pp4, pp5, pp6, pp7]console.log(ppArr)//6.8: unshift()和shift()/** 1.unshift在头部添加一个或者多个元素,返回长度* 2.shift删除数组的第一个元素,返回删除的元素* 3.改变原数组,改变原数组的索引* 4.unshift插入多个元素时,试一次性插入的* */var sh = []var sh1 = sh.unshift(1) //sh: [1], 返回: 1var sh2 = sh.unshift(22) //sh: [1, 22], 返回: 2var sh3 = sh.shift() //sh: [22], 返回: 22var sh4 = sh.unshift(3, [4, 5]) //sh: [3, [4, 5], 1], 返回: 3var sh5 = sh.shift() //sh: [[4, 5], 1], 返回: 3var sh6 = sh.shift() //sh: [1], 返回: [4, 5]var shiftArr = [sh1, sh2, sh3, sh4, sh5, sh6]console.log(shiftArr)//注: unshift插入多个元素时,试一次性插入的,例如:sh.unshift(3, 4)// 结果: [3, 4]sh.unshift(3)sh.unshift(4)//结果: [4, 3]//6.9: toString()和toLocalString()/** 1.toString()将数组元素转化成字符串后,用都好链接输出* 2.toString()和join()不加参数的返回的值是一样的* 3.toLocalString()是toString()的本地化版本* */var str0 = [1, 2, 3].toString() //返回: \"1,2,3\"var str1 = [\"a\", \"b\", \"c\"].toString() //返回: \"a,b,c\"var str2 = [1, [2, \"c\"]].toString() //返回: \"1,2,c\"var str3 = [1, 2, 3].toLocaleString() //返回: \"1,2,3\"var strArr = [str0, str1, str2, str3, str4]console.log(strArr) 7. ECMAScript5中数组的方法 1.ECMAScript5定义了九个新的数组方法 2.大多数ECMAScript5数组方法的第一个参数是一个函数 2.第二个参数是可选的,如果有,则调用的函数被看作是第二个参数的方法 3.也就是说在调用函数时,传递进去的第二个参数作为它的this关键字的值来使用 4.ECMAScript5中的数组方法不会修改他们调用的原始数组 5.传递给这些方法的函数是可以改变这些数组的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//7.1: forEach()/** 1.方法从头到尾遍历数组,为每个元素调用指定的函数* 2.forEach使用三个参数调用该函数:数组元素,元素索引, 数组本身* */var data1 = [1, 2, 3, 4, 5]//求和var sum = 0data1.forEach(function (value) &#123; sum += value&#125;)//15//每个元素本身自加1data1.forEach(function (value, i, arr) &#123; arr[i] = value + 1&#125;)//[2, 3, 4, 5, 6]//7.2: map()/** 1.返回一个新数组,不改变原数组* 2.原数组若是稀疏数组,返回也是稀疏数组* 3.具有相同的长度,相同的缺失元素* */var arr2 = data1.map(function (x) &#123; return x * x&#125;)// [4, 9, 16, 25, 36]//7.3: filter()逻辑判定,过滤数组/** 1.返回原数组的一个子集* 2.返回原数组符合条件的元素,组成新数组* 3.会将稀疏数组压缩,返回的是稠密数组* */var arr3 = data1.filter(function (x) &#123; return x &gt; 3&#125;)//[4, 5, 6]var data2 = [1, 2, 3, 4, 5]var arr4 = data2.filter(function (i) &#123; return i % 2 == 0&#125;)//[2, 4]var data3 = [1, 2, , , null, 5]var arr5 = data3.filter(function (x) &#123; return x !== undefined &amp;&amp; x != null&#125;)console.log(arr5)//[1, 2, 5]//7.4: every()和some()数组的逻辑判定/** 1.对数组元素应用指定的函数进行判定* 2.返回trur或者false* 2.every()都为true返回true,否则返回false* 3.some()都为false,返回false;有一个为true,返回true* 4.一旦该方法确定了返回值,就会停止遍历数组* 5.空数组,every()返回true,some()返回false* */var data4 = [1, 2, 3, 4, 5]var sum1 = data4.every(function (x) &#123; return x &lt; 10&#125;)//sum1 = truevar sum2 = data4.every(function (x) &#123; return x % 2 === 0&#125;)//sum2 = falsevar sum3 = data4.some(function (x) &#123; return x % 2 === 0&#125;)//sum3 = truevar sum4 = data4.some(isNaN)//sum4 = false, data4不包含非整数值元素//7.5: reduce()和reduceRigh()/** 作用: 将数组元素进行组合生成单个值* 1.reduce()需要两个参数;参数一:执行操作的函数;参数二:传递给函数的初始值* 2.reduceRight()是倒叙操作,功能与reduce相同* */var data5 = [1, 2, 3, 4, 5]var sn0 = data5.reduce(function (x, y) &#123; return x + y&#125;, 0)//15var sn1 = data5.reduce(function (x, y) &#123; return x * y&#125;, 1)//120var sn2 = data5.reduce(function (x, y) &#123; return x &gt; y ? x : y&#125;)//5//7.6: indexOf()和lastIndexOf()/** 1.搜索整个数组中具有给定值的元素,返回找到的第一个元素的索引,如果没有找到就返回-1* 2.indexOf(),从前向后搜索,lastIndexOf()从后向前搜索* 3.参数一:元素值; 参数二: 搜索的起始位置(可省略,默认从头开始)* */var data6 = [0, 1, 2, 1, 0]var index1 = data6.indexOf(1) //1, data6[1] = 1var index2 = data6.indexOf(3) //-1, 没有值为3的元素var index3 = data6.lastIndexOf(1) //3, data6[3] = 1var index4 = data6.indexOf(2, 1)//2, data6[2] = 2var index5 = data6.lastIndexOf(2, -1)//2, data6[2] = 2 8. 判定一个位置对象是否为数组123var data = [1, 2]// var isA = data.isArray()console.log(data.isArray())","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://titanjun.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://titanjun.top/tags/JavaScript/"},{"name":"语法","slug":"语法","permalink":"https://titanjun.top/tags/语法/"}]},{"title":"Swift4.0新特性之String、Array和Dictionary","slug":"Swift4.0新特性之String、Array和Dictionary","date":"2017-07-19T13:16:40.000Z","updated":"2018-03-13T01:49:22.000Z","comments":true,"path":"2017/07/19/Swift4.0新特性之String、Array和Dictionary/","link":"","permalink":"https://titanjun.top/2017/07/19/Swift4.0新特性之String、Array和Dictionary/","excerpt":"推荐: Swift 编程语言 原文链接: What’s New in Swift 4? Guards翻译组: 中文地址 Swift 4是苹果计划在2017年秋季推出的最新版本，值得关注的是其提供了与Swift 3代码很好的兼容性，并最大限度的保持了ABI稳定性.","text":"推荐: Swift 编程语言 原文链接: What’s New in Swift 4? Guards翻译组: 中文地址 Swift 4是苹果计划在2017年秋季推出的最新版本，值得关注的是其提供了与Swift 3代码很好的兼容性，并最大限度的保持了ABI稳定性. String 字符串已经像之前的2.0版一样, 改为了Collection类型 。此变化消除了字符串对字符数组的依赖 0.创建空字符串的两种方式,可用isEmpty判断是否为空123let SwiftString = \"Hello\"var emptyString = \"\" // empty string literalvar anotherEmptyString = String() 1.字符和字符串1.1 遍历字符串123for char in SwiftString &#123; print(char)&#125; 1.2通过 Character类型创建单个字符1let char : Character = \"H\" 1.3 String值可以通过传入 Character来构造：123let charArr : [Character] = [\"H\", \"e\", \"l\", \"l\", \"o\"]print(String(char)) // Hprint(String(charArr)) // Hello 1.4 拼接字符串12345//方式一:let addString = String(charArr) + String(char) //HelloH//方式二:var addString2 = \"Why\"addString2 += String(charArr) //\"WhyHello\" 2.字符串个数123let count1 = SwiftString.count //5(类型: String.CharacterView.IndexDistance)let count2 = SwiftString.characters.count // 5(Int型)count1: 3.是否为空1let isStr = SwiftString.isEmpty //false 4.去掉某一个或几个字符123456let text1 = SwiftString.dropFirst()//\"ello\"let text2 = SwiftString.dropLast()//\"Hell\"let text3 = SwiftString.dropFirst(2)//\"llo\"let text4 = SwiftString.dropLast(2)//\"Hel\"//注:以上皆为String.SubSequence类型let text5 = String(text1) //\"ello\"---text5为String类型 5.倒叙1let text6 = String(SwiftString.reversed()) //\"olleH\" 6.字符串分割数组123let swiftString2 = \"one two three\"let StrArr = swiftString2.split(separator: \" \") //[\"one\", \"two\", \"three\"]//let StrArr: [String.SubSequence] 7.删除不符合ASCII编码的字符12345let swiftString3 = \"quanjun 🐷,\"let qj = swiftString3.filter &#123; (char) -&gt; Bool in return char.unicodeScalars.reduce(true, &#123; $0 &amp;&amp; $1.isASCII &#125;)&#125;print(qj) //\"quanjun ,\" 8. 字符串索引 Swift 的字符串不能通过整数值索引 使用 index(before:) 和 index(after:) 方法来访问给定索引的前后。要访问给定索引更远的索引，你可以使用 index(_:offsetBy:) 方法而不是多次调用这两个方法。 Swift 4添加了Substring类型，用于引用String的子序列。 String和Substring都实现了StringProtocol，两者几乎具有相同的功能： 8.1 startIndex和endIndex1234567891011121314let greeting = &quot;Guten Tag!&quot;//startIndex属性来访问 String中第一个 Character的位置print(greeting[greeting.startIndex])print(greeting[greeting.index(after: greeting.startIndex)])//endIndex属性就是 String中最后一个字符后的位置。endIndex属性并不是字符串下标脚本的合法实际参数//greeting[greeting.endIndex] //会报错print(greeting[greeting.index(before: greeting.endIndex)])//注: 如果 String为空，则 startIndex与 endIndex相等let index = greeting.index(greeting.startIndex, offsetBy: 2)print(greeting[index])let indesString = greeting[greeting.startIndex...index] //&quot;Gut&quot;//注:indesString : Substring类型print(String(indesString)) //&quot;Gut&quot; 8.2使用 characters属性的 indices属性来创建所有能够用来访问字符串中独立字符的索引范围 Range。123for index in greeting.characters.indices &#123; print(\"\\(greeting[index]) \", terminator: \"\")//不换行输出&#125; 9.多行字符串 注:你可以在多行字面量中使用单个双引号 “ 。要在多行字符串中包含 “”” ，你必须用反斜杠（ \\ ）转义至少其中一个双引号 123456let rowsString = \"\"\" 我是一只小鸭子 咿呀咿呀哟 \\\"\"\" \"\"\"print(rowsString) Array Swift 的 Array类型被桥接到了基础框架的 NSArray类上。 Swift 数组的类型完整写法是 Array， Element是数组允许存入的值的类型。你同样可以简写数组的类型为 [Element]。 1. 创建确定大小且元素都设定为相同默认值的数组。1234/*Array*///默认值（叫做 repeating）和新数组元素的数量（叫做 count)var array1 = Array(repeating: 1, count: 2)var array2 = Array(repeating: 3, count: 2) 2. 连接两个数组来创建数组(类型必须一致)12var array3 = array1 + array2print(array3) //[1, 1, 3, 3] 3. 数组个数1print(array3.count) //5 4. 判断数组个数是否为012print(array3.isEmpty) //falseprint(array3.count == 0) //false 5. 添加123array3.append(4) //[1, 1, 3, 3, 4]array3 += [5] //[1, 1, 3, 3, 4, 5]array3 += [6, 5] //[1, 1, 3, 3, 4, 5, 6, 5] 6. 取值12345print(array3[0]) // 1array3[1] = 9 // [1, 9, 3, 3, 4, 5, 6, 5]//用下标改变一个范围的值，就算替换与范围长度不同的值的合集也行array3[2...4] = [0, 8] //[1, 9, 0, 8, 5, 6, 5] 7.遍历1234567891011121314151617for item in array3 &#123; print(item)&#125;//元组输出for (index, item) in array3.enumerated() &#123; print(\"\\(index)---\\(item)\")&#125;//倒叙输出for item in array3.reversed() &#123; print(item)&#125;//forEach遍历,如同for-inlet arr = [1, 9, 3, 3, 4, 5, 6, 5]arr.forEach &#123; (x) in print(x)&#125; 8. 删除和插入123456array3.remove(at: 1) //[1, 0, 8, 5, 6, 5]array3.removeFirst() //[0, 8, 5, 6, 5]array3.removeLast() //[0, 8, 5, 6]array3.removeFirst(2) //[5,6]array3.removeLast(1) //[5]array3.removeAll() //[] Dictionary and Set 至于Collection类型，Set和Dictionary并不那么最直观的 Swift 的 Dictionary桥接到了基础框架的 NSDictionary类。 1.首先列表可以是从一系列键值对（元组）创建一个字典:123456789//Dictionarylet keyNames = [\"a\", \"b\", \"c\", \"d\", \"e\"]let valueNames = [1, 2, 4, 5, 6]//public init&lt;S&gt;(uniqueKeysWithValues keysAndValues: S) where S : Sequence, S.Element == (Key, Value)//对于该方法的具体解释,可以点进去看一下官方的讲解let nameDic = Dictionary(uniqueKeysWithValues: zip(keyNames, valueNames))print(nameDic)//[\"b\": 2, \"e\": 6, \"a\": 1, \"d\": 5, \"c\": 4] 2.在初始化Dictionary时, 你现在可以使用你喜欢的方式来处理重复的键,同时避免覆盖键值对，且不会出现任何问题：1234567let keyNames2 = [\"a\", \"b\", \"c\", \"a\", \"b\"]//public init&lt;S&gt;(_ keysAndValues: S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value) rethrows where S : Sequence, S.Element == (Key, Value)//对于该方法的具体解释,可以点进去看一下官方的讲解let nameDic2 = Dictionary(zip(keyNames2, repeatElement(1, count: keyNames2.count)), uniquingKeysWith: +)print(nameDic2)//[\"b\": 2, \"a\": 2, \"c\": 1] 3.Dictionary 和 Set现在都可以将结果 通过filter函数 过滤到原始类型的新对象中：123let nameDic3 = nameDic.filter(&#123; $0.value &lt; 5 &#125;)print(nameDic3)//[\"b\": 2, \"a\": 1, \"c\": 4] 4.Dictionary为直接映射其值提供了一种非常有用的方法:：1234//将value值Int转化为字符串let nameDic4 = nameDic3.mapValues(&#123; \"\\($0)\" &#125;)print(nameDic4)//[\"b\": \"2\", \"a\": \"1\", \"c\": \"4\"] 5.在Dictionary上访问某个值时，常见的做法是使用nil-coalescing operator给出默认值1let nameDic5 = nameDic4[\"d\", default : \"unknown\"] 6.我们可以从Sequence”中初始化Dictionary，并将其分组为bucket:：12345//注: 当通过特定模式对数据进行分组时，这相当方便。let name2 = [\"Proxima\", \"Centauri A\", \"Centauri B\", \"Barnard\", \"Wolf\"]let nameDic6 = Dictionary(grouping: name2, by: &#123; $0.first! &#125;)print(nameDic6)//[\"B\": [\"Barnard\"], \"W\": [\"Wolf\"], \"P\": [\"Proxima\"], \"C\": [\"Centauri A\", \"Centauri B\"]] 涉及Zip的用法,详见Swift语法之Zip详解 7.预留空间 Sequence和Dictionary现在都具有明确保留容量的能力 在这些类型上，Reallocation可能是一项代价高昂的任务。 如果你知道需要存储的数据量时, 使用reserveCapacity(_:)可以提高性能且便捷 1234var name3 : [String : Int] = [ : ]print(name3.capacity) // 0name3.reserveCapacity(10) //储备 10元素的能力print(name3.capacity) // 12","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://titanjun.top/categories/学习笔记/"}],"tags":[{"name":"Swift4.0","slug":"Swift4-0","permalink":"https://titanjun.top/tags/Swift4-0/"},{"name":"String","slug":"String","permalink":"https://titanjun.top/tags/String/"},{"name":"Array","slug":"Array","permalink":"https://titanjun.top/tags/Array/"},{"name":"Dictionary","slug":"Dictionary","permalink":"https://titanjun.top/tags/Dictionary/"}]},{"title":"Swift版-H5页面实现长按保存图片","slug":"Swift版-H5页面实现长按保存图片","date":"2017-07-10T06:26:40.000Z","updated":"2018-04-10T09:03:27.639Z","comments":true,"path":"2017/07/10/Swift版-H5页面实现长按保存图片/","link":"","permalink":"https://titanjun.top/2017/07/10/Swift版-H5页面实现长按保存图片/","excerpt":"刚开始拿到需求的第一反应是:H5页面还可以保存图片?? 随即想了一下,好像微信里好多H5页面都有这样的功能 然后查阅了一下相关资料,有咨询了前端大神发现两行核心代码 123456//获取长按所在点let urlString = \"document.elementFromPoint(\\(touchPoint.x), \\(touchPoint.y)).src\"//根据该点的参数获取对应图片的链接let saveUrl = webView.stringByEvaluatingJavaScriptFromString(urlString)","text":"刚开始拿到需求的第一反应是:H5页面还可以保存图片?? 随即想了一下,好像微信里好多H5页面都有这样的功能 然后查阅了一下相关资料,有咨询了前端大神发现两行核心代码 123456//获取长按所在点let urlString = \"document.elementFromPoint(\\(touchPoint.x), \\(touchPoint.y)).src\"//根据该点的参数获取对应图片的链接let saveUrl = webView.stringByEvaluatingJavaScriptFromString(urlString) 下面来一起啊看一下完整的代码步骤 首先给UiWebView加一个长按手势 123456//添加长按手势let longPressGes = UILongPressGestureRecognizer(target: self, action: #selector(longPressedGesture(_:)))//一定要遵循代理longPressGes.delegate = selfwebView.addGestureRecognizer(longPressGes) 实现代理方法 12345//不实现该代理方法,长按无效func gestureRecognizer(gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWithGestureRecognizer otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123; return true&#125; 接着在手势响应方法里面实现相应的功能 注意: 一定要判断手势的state属性 判断saveUrl是否是一个nil值 12345678910111213@objc func longPressedGesture(recognizer: UILongPressGestureRecognizer)&#123; if recognizer.state != .Began &#123; return &#125; let touchPoint = recognizer.locationInView(webView) //核心代码 let urlString = &quot;document.elementFromPoint(\\(touchPoint.x), \\(touchPoint.y)).src&quot; if let saveUrl = webView.stringByEvaluatingJavaScriptFromString(urlString) &#123; //判断图片的链接是否为空,长度是否为o if saveUrl.characters.count == 0 &#123; return &#125; addAlertAction(saveUrl) &#125;&#125; 调用保存图片功能按钮 123456789101112fileprivate func addAlertAction(imageStr: String)&#123; let alertV = UIAlertController() let saveAction = UIAlertAction(title: \"保存图片\", style: .Default) &#123; (alertV) in self.saveImageToPhoto(imageStr) &#125; //取消保存不作处理 let cancelAction = UIAlertAction(title: \"取消\", style: .Cancel, handler: nil) alertV.addAction(saveAction) alertV.addAction(cancelAction) controller.presentViewController(alertV, animated: true, completion: nil)&#125; 使用SDWebImage保存图片 注意使用SDWebImage的缓存机制 1234567891011121314151617181920fileprivate func saveImageToPhoto(imageStr: String)&#123; guard let imageUrl = NSURL(string: imageStr) else &#123; return &#125; let sdManager = SDWebImageManager.sharedManager() var image : UIImage! if sdManager.diskImageExistsForURL(imageUrl) &#123; //先判断缓存中的图片 image = sdManager.imageCache.imageFromDiskCacheForKey(imageUrl.absoluteString) &#125;else&#123; //缓存没有在进行下载 let data = NSData(contentsOfURL: imageUrl) image = UIImage(data: data!) &#125; //保存图片到相册中 UIImageWriteToSavedPhotosAlbum(image, self, #selector(self.image(_:didFinishSavingWithError:contextInfo:)), nil)&#125; 最后是一个保存成功与否的回调方法 1234567func image(image: UIImage, didFinishSavingWithError: NSError?, contextInfo: AnyObject) &#123; if didFinishSavingWithError != nil &#123; MBProgressHUD.show(string: \"请开启访问相册权限后使用此功能\", inView: self.view) &#125; else &#123; MBProgressHUD.show(string: \"图片保存成功\", inView: self.view) &#125;&#125; 以上如有不妥之处还望多多指正","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://titanjun.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://titanjun.top/tags/JavaScript/"},{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"WebView","slug":"WebView","permalink":"https://titanjun.top/tags/WebView/"}]},{"title":"HTML5学习笔记之音视频标签","slug":"HTML5学习笔记之音视频标签","date":"2017-06-16T12:01:00.000Z","updated":"2018-03-10T15:31:12.000Z","comments":true,"path":"2017/06/16/HTML5学习笔记之音视频标签/","link":"","permalink":"https://titanjun.top/2017/06/16/HTML5学习笔记之音视频标签/","excerpt":"HTML5学习笔记之音视频标签","text":"HTML5学习笔记之音视频标签 一. video标签1. 作用: 播放视频2. video标签格式1:12&lt;video src=\"\"&gt;&lt;/video&gt; 3. video标签的属性 src: 告诉video标签需要播放的视频地址 autoplay: 告诉video标签是否需要自动播放视频 controls:告诉video标签是否需要显示控制条 poster: 告诉video标签视频没有播放之前显示的占位图片 loop: 告诉video标签循环播放视频. 一般用于做广告视频 preload: 告诉video标签预加载视频, 但是需要注意preload和autoplay相冲, 如果设置了autoplay属性, 那么preload属性就会失效 muted:告诉video标签视频静音 width/height: 和img标签中的一模一样 4. video标签格式21234&lt;video&gt; &lt;source src=\"\" type=\"\"&gt;&lt;/source&gt; &lt;source src=\"\" type=\"\"&gt;&lt;/source&gt;&lt;/video&gt; 第二种格式存在的意义 由于视频数据非常非常的重要, 所以五大浏览器厂商都不愿意支持别人的视频格式, 所以导致了没有一种视频格式是所有浏览器都支持的这个时候W3C为了解决这个问题, 所以推出了第二个video标签的格式 video标签的第二种格式存在的意义就是为了解决浏览器适配问题. video 元素支持三种视频格式, 我们可以把这三种格式都通过source标签指定给video标签, 那么以后当浏览器播放视频时它就会从这三种中选择一种自己支持的格式来播放 注意点: 当前通过video标签的第二种格式虽然能够指定所有浏览器都支持的视频格式, 但是想让所有浏览器都通过video标签播放视频还有一个前提条件, 就是浏览器必须支持HTML5标签, 否则同样无法播放 在过去的一些浏览器是不支持HTML5标签的, 所以为了让过去的一些浏览器也能够通过video标签来播放视频, 那么我们以后可以通过一个JS的框架叫做html5media来实现 代码示例12345&lt;video width=\"200\" height=\"100\" poster=\"http://www.youname.com/images/first.png\" autoplay=\"autoplay\" preload=\"none\" controls=\"controls\"&gt; &lt;!--楚乔传,好像是第4集--&gt; &lt;source src=\"https://v.qq.com/x/cover/dhzimk1qzznf301/t0024jjys1q.html?ptag=baidu.aladdin.tv\" &gt; &lt;source src=\"http://www.youname.com/images/first.ogg\" /&gt;&lt;/video&gt; 二.audio标签1. 作用: 播放音频2. 格式:123456&lt;audio src=\"\"&gt;&lt;/audio&gt;&lt;audio&gt;&lt;source src=\"\" type=\"\"&gt;&lt;/audio&gt; 3. 注意点: audio标签的使用和video标签的使用基本一样 video中能够使用的属性在audio标签中大部分都能够使用, 并且功能都一样 只不过有3个属性不能用,height/width/poster 三.详情和概要标签1. 作用: 利用summary标签来描述概要信息, 利用details标签来描述详情信息 默认情况下是折叠展示, 想看见详情必须点击 2. 格式:1234&lt;details&gt; &lt;summary&gt;概要信息&lt;/summary&gt; 详情信息&lt;/details&gt; 3. 示例代码12345&lt;!--详情和概要标签--&gt;&lt;details&gt; &lt;summary&gt;概要信息&lt;/summary&gt; 这里是详情: 是假的呢举案说法南石道街开发病那都是独守空房技能速度加快非农数据的看法山东矿机第三方看似简单妇女节看电视呢房间看电视开始的减肥纳斯达克今年初vdsfw的看法今年圣诞节开放男&lt;/details&gt; 四. marquee标签1. 作用: 跑马灯效果2. 格式:&lt;marquee&gt;内容&lt;/marquee&gt; 3. 属性: direction: 设置滚动方向 left/right/up/down scrollamount: 设置滚动速度, 值越大就越快 loop: 设置滚动次数, 默认是-1, 也就是无限滚动 behavior: 设置滚动类型 slide滚动到边界就停止, alternate滚动到边界就弹回 4. 注意点: marquee标签不是W3C推荐的标签, 在W3C官方文档中也无法查询这个标签, 但是各大浏览器对这个标签的支持非常好 5. 示例代码12345&lt;!--跑马灯-marquee标签--&gt;&lt;marquee direction=\"left\" scrollamount=\"5\"&gt;跑马灯&lt;/marquee&gt;&lt;marquee direction=\"right\" scrollamount=\"3\"&gt;marquee&lt;/marquee&gt;&lt;marquee direction=\"up\" scrollamount=\"1\"&gt;标签&lt;/marquee&gt;&lt;marquee direction=\"down\" scrollamount=\"1\"&gt;down&lt;/marquee&gt; 注: 实际的效果中,这三个是一直在滚动的,只是图片看不到效果,自己亲自实践感受下吧! 五. HTML中被废弃的标签 由于HTML现在只负责语义而不负责样式.但是HTML一开始有一部分标签连样式也包揽了, 所以这部分标签都被废弃了 123b、u、i、s - 以上标签自己带有样式, 有浓厚的样式作用, 今后一般都只作为CSS钩子使用- 原则: 不到万不得已,切记不要使用如上标签. 大家可以到BAT的网站查看源代码, 几乎看不到以上标签 b(Bold)作用: 将文本字体加粗 格式:&lt;b&gt;将文本字体加粗&lt;/b&gt; u(Underlined)作用: 为文本添加下划线 格式: &lt;u&gt;为文本添加下划线&lt;/u&gt; i(Italic)作用: 显示斜体文本效果 格式: &lt;i&gt;显示斜体文本效果&lt;/i&gt; s(Strikethrough)作用: 为文本添加删除线 格式: &lt;s&gt;为文本添加删除线&lt;/s&gt; 为了弥补 b、u、i、s标签的不足, W3C又推出了一组新的标签, 这些标签在显示上看似和buis没什么区别, 但是在语义上却有重大区别 strong作用: 着重内容 格式:&lt;strong&gt;着重内容&lt;/strong&gt; ins(Inserted)作用: 新插入的文本 格式:&lt;ins&gt;新插入的文本&lt;/ins&gt; em(Emphasized)作用:强调内容 格式:&lt;em&gt;强调内容&lt;/em&gt; del(Deleted)作用: 已删除的文本 格式:&lt;del&gt;已删除的文本&lt;/del&gt; 示例代码12345&lt;!--新增标签--&gt;&lt;strong&gt;着重内容&lt;/strong&gt;&lt;ins&gt;新插入的内容&lt;/ins&gt;&lt;em&gt;强调的内容&lt;/em&gt;&lt;del&gt;已经删除的内容&lt;/del&gt; 对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://titanjun.top/categories/HTML5/"}],"tags":[{"name":"HTML5标签","slug":"HTML5标签","permalink":"https://titanjun.top/tags/HTML5标签/"},{"name":"CSS","slug":"CSS","permalink":"https://titanjun.top/tags/CSS/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://titanjun.top/tags/WebStorm/"}]},{"title":"HTML5学习笔记之表格标签","slug":"HTML5学习笔记之表格标签","date":"2017-06-15T12:18:00.000Z","updated":"2018-03-10T15:29:39.000Z","comments":true,"path":"2017/06/15/HTML5学习笔记之表格标签/","link":"","permalink":"https://titanjun.top/2017/06/15/HTML5学习笔记之表格标签/","excerpt":"HTML5学习笔记之表格标签","text":"HTML5学习笔记之表格标签 一.表格标签 1.作用: 以表格形式将数据显示出来, 当数据量非常大的时候, 表格这种展现形式被认为是最为清晰的一种展现形式 2.格式: table定义表格 tr定义行 td定义单元格 3.表格中的属性 border: 默认情况下表格的边框宽度为0看不到, 通过border属性给表格指定边框宽度 width: 默认情况下表格的宽度是由内容自动计算出来的, 可以通过width属性指定表格的宽度 height:默认情况下表格的高度是由内容自动计算出来的, 可以通过height属性指定表格的高度 cellspacing: 外边距. 默认情况下单元格之间有2个像素的间隙, 可以通过cellpadding指定表格之间的间隙 cellpadding: 内边距. 默认情况下单元格边缘距离内容有1个像素的内边距, 可以通过cellpadding属性指定单元格边缘和内容之间的内边距 align: 规定表格相对周围元素的对齐方式, 它的取值有center、left、right 给table设置align属性, 是让表格在浏览器中居左/居右/居中 给tr设置align属性, 是让当前行中所有内容居左/居右/居中 给td设置align属性,是让当前单元格中所有内容居左/居右/居中 该属性仅仅作为了解, 企业开发中用css代替, 因为HTML仅仅用于说明语义 如果td中设置了align属性, tr中也设置了align属性, 那么单元格中的内容会按照td中设置的来对齐 valign: 规定表格相对周围元素的对齐方式, 它的取值有center、left、right 给table设置valign属性, 无效给tr设置valign属性, 是让当前行中所有内容居上/居中/居下 给td设置valign属性,是让当前单元格中所有内容居上/居中/居下 如果td中设置了valign属性, tr中也设置了valign属性, 那么单元格中的内容会按照td中设置的来对齐 bgcolor:规定表格的背景颜色 给table设置bgcolor属性, 是给整个表格设置背景颜色 给tr设置bgcolor属性, 是给当前行设置背景颜色 给td设置bgcolor属性, 是给当前单元格设置背景颜色 该属性仅仅作为了解, 企业开发中用css代替, 因为HTML仅仅用于说明语义 1) 示例代码1234567891011121314&lt;!--表格标签--&gt;&lt;!--先定义一个表格, 然后通过tr告诉浏览器这个表格中一共有多少行, 然后再通过td告诉浏览器这一行中一共有多少个元素(一共有多少列)--&gt;&lt;table border=\"1\" width=\"500\" cellpadding=\"5\" cellspacing=\"10\"&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 2) 展示样式 4.表格中的其它标签 表单中有两种类型的单元格, 一种是标准单元格td, 一种是表头单元格th th标签: 给每一列设置标题, 单元格中的内容会自动加粗，居中 caption标签:给整个表格设置标题 一定要嵌套在talbe标签内部才有效 1) 示例代码123456789101112131415161718192021222324252627282930313233343536&lt;table bgcolor=\"#5f9ea0\" cellspacing=\"1px\" width=\"1000\" align=\"center\"&gt; &lt;caption&gt; &lt;h2&gt;这周代码量排行榜&lt;/h2&gt; &lt;/caption&gt; &lt;tr bgcolor=\"#8a2be2\"&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;关键词&lt;/th&gt; &lt;th&gt;趋势&lt;/th&gt; &lt;th&gt;今日搜索&lt;/th&gt; &lt;th&gt;最近一天&lt;/th&gt; &lt;th&gt;最近一天相关链接&lt;/th&gt; &lt;/tr&gt; &lt;tr bgcolor=\"#f0ffff\" align=\"center\"&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;穷爸爸富爸爸&lt;/td&gt; &lt;td&gt;上涨&lt;/td&gt; &lt;td&gt;456&lt;/td&gt; &lt;td&gt;234214&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\"&gt;贴吧&lt;/a&gt; &lt;a href=\"#\"&gt;百度&lt;/a&gt; &lt;a href=\"#\"&gt;杭州&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=\"#f0ffff\" align=\"center\"&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;穷爸爸富爸爸&lt;/td&gt; &lt;td&gt;上涨&lt;/td&gt; &lt;td&gt;234&lt;/td&gt; &lt;td&gt;3423542&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\"&gt;贴吧&lt;/a&gt; &lt;a href=\"#\"&gt;百度&lt;/a&gt; &lt;a href=\"#\"&gt;杭州&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; 2) 展示样式 5.表格的结构 thead标签:用来存放当前列的表头, 如果没有加css页面默认将表头中的高度设置变小 tbody标签:一般用来存放页面中的主体数据, 如果不写会自动加上 tfoot标签:用来存放表格的页脚（脚注或表注), 如果没有加css页面默认将表头中的高度设置变小, 一般不会出现 1) 示例代码123456789101112131415161718192021222324252627282930&lt;table bgcolor=\"#7fffd4\" width=\"800\" cellspacing=\"2\" align=\"center\"&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt; &lt;thead&gt; &lt;tr align=\"center\"&gt; &lt;th&gt;每一列的标题&lt;/th&gt; &lt;th&gt;每一列的标题&lt;/th&gt; &lt;th&gt;每一列的标题&lt;/th&gt; &lt;th&gt;每一列的标题&lt;/th&gt; &lt;th&gt;每一列的标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr align=\"center\"&gt; &lt;td&gt;数据&lt;/td&gt; &lt;td&gt;数据&lt;/td&gt; &lt;td&gt;数据&lt;/td&gt; &lt;td&gt;数据&lt;/td&gt; &lt;td&gt;数据&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr align=\"center\"&gt; &lt;td&gt;数据&lt;/td&gt; &lt;td&gt;数据&lt;/td&gt; &lt;td&gt;数据&lt;/td&gt; &lt;td&gt;数据&lt;/td&gt; &lt;td&gt;数据&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 2) 展示样式 5.注意事项 表格结构的意义主要是用于SEO, 便于搜索引擎指定哪部分的内容是需要抓取的重要内容, 一般情况下搜索引擎会优先抓取tbody中的内容 由于有一部分浏览器对talbe的这种结构支持不是很好, 所以在企业开发中一般都不用严格的按照这种结构来编写 对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://titanjun.top/categories/HTML5/"}],"tags":[{"name":"HTML5标签","slug":"HTML5标签","permalink":"https://titanjun.top/tags/HTML5标签/"},{"name":"CSS","slug":"CSS","permalink":"https://titanjun.top/tags/CSS/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://titanjun.top/tags/WebStorm/"}]},{"title":"HTML5学习笔记之表单标签","slug":"HTML5学习笔记之表单标签","date":"2017-06-15T12:18:00.000Z","updated":"2018-03-10T15:29:10.000Z","comments":true,"path":"2017/06/15/HTML5学习笔记之表单标签/","link":"","permalink":"https://titanjun.top/2017/06/15/HTML5学习笔记之表单标签/","excerpt":"HTML5学习笔记之表单标签","text":"HTML5学习笔记之表单标签 1.作用: 用于收集用户信息, 让用户填写、选择相关信息 2.格式: 123&lt;form&gt; 所有的表单内容，都要写在form标签里面&lt;/form&gt; 3.注意事项: 所有的表单内容，都要写在form标签里面form标签中有两个比较重要的属性action和method input标签 如果说td是表格最核心的标签, 那么input就是表单最核心的标签. nput标签有一个type属性, 这个属性有很多类型的取值, 取值的不同就决定了input标签的功能和外观不同 1.输入框1.1 明文输入框 作用: 用户可以在输入框内输入内容 账号: &lt;input type=&quot;text&quot;/&gt;1.2 暗文输入框 作用: 用户可以在输入框内输入内容 密码: &lt;input type=&quot;password&quot;/&gt;1.3 给输入框设置默认值 账号: &lt;input type=&quot;text&quot; value=&quot;tqj&quot;/&gt; 密码: &lt;input type=&quot;password&quot; value=&quot;0929&quot;/&gt;1.4 规定输入字段中的字符的最大长度 账号: &lt;input type=&quot;text&quot; name=&quot;fullname&quot; maxlength=&quot;8&quot; /&gt; 1.5 代码12345678910111213&lt;form&gt; &lt;!--明文输入框--&gt; &lt;p&gt;账号: &lt;input type=\"text\" /&gt;&lt;/p&gt; &lt;!--暗文输入框--&gt; &lt;p&gt;密码: &lt;input type=\"password\" /&gt;&lt;/p&gt; &lt;!--p标签换行--&gt; &lt;p&gt;账号: &lt;input type=\"text\" value=\"tqj\" /&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" value=\"0929\" /&gt;&lt;/p&gt; &lt;p&gt;最大长度: &lt;input type=\"text\" maxlength=\"5\"/&gt;&lt;/p&gt;&lt;/form&gt; 2. 单选框(radio) 作用: 用户只能从众多选项中选择其中一个 单选按钮，天生是不互斥的，如果想互斥，必须要有相同的name属性 3. 多选框(checkbox) 作用: 用户只能从众多选项中选择多个 复选框，最好也是有相同的name（虽然他不需要互斥，但是也要有相同的name） 4. label标签 作用: label标签不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性 注意事项:表单元素要有一个id，然后label标签就有一个for属性，for属性和id相同就表示绑定了所有表单元素都可以通过label绑定 示例代码1234567891011121314&lt;!--单选框--&gt;&lt;!--checked属性,为默认值--&gt;&lt;label for=\"sex\"&gt;性别: &lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" checked /&gt; &lt;label for=\"sex\"&gt;男&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" /&gt; &lt;label for=\"sex\"&gt;女&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" /&gt; &lt;label for=\"sex\"&gt;妖&lt;/label&gt;&lt;p&gt;&lt;/p&gt;&lt;!--多选框--&gt;&lt;label for=\"课程\"&gt;课程: &lt;/label&gt;&lt;input type=\"checkbox\" name=\"课程\" checked /&gt; &lt;label for=\"课程\"&gt;HTML5 &lt;/label&gt;&lt;input type=\"checkbox\" name=\"课程\" checked /&gt; &lt;label for=\"课程\"&gt;Swift &lt;/label&gt;&lt;input type=\"checkbox\" name=\"课程\" /&gt; &lt;label for=\"课程\"&gt;OC &lt;/label&gt;&lt;input type=\"checkbox\" name=\"课程\" /&gt; &lt;label for=\"课程\"&gt;CSS &lt;/label&gt; 5. 按钮5.1 普通按钮 作用: 定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）&lt;input type=&quot;button&quot; value=&quot;点我丫&quot; /&gt; 5.2 图片按钮 作用:定义图像形式的提交按钮&lt;input type=&quot;image&quot; src=&quot;1.png&quot; /&gt; 5.3 还原按钮 作用: 定义还原按钮。还原按钮会清除表单中的所有数据&lt;input type=&quot;reset&quot; /&gt; 注意事项:这个按钮不需要写value自动就有“还原”文字reset只对form表单中表单项有效果 5.4 提交按钮 作用:定义提交按钮。提交按钮会把表单数据发送到action属性指定的页面&lt;input type=&quot;submit&quot; /&gt; 注意事项: 这个按钮不需要写value自动就有“提交”文字 要想通过submit提交数据到服务器, 被提交的表单项都必须设置name属性 默认明文传输(GET)不安全, 可以将method属性设置为POST改为非明文传输(学到Ajax再理解) 示例代码123456789&lt;!--按钮--&gt;&lt;!--普通按钮--&gt;&lt;input type=\"button\" value=\"点我有奖\"&gt;&lt;!--图片按钮--&gt;&lt;input type=\"image\" src=\"http://note.youdao.com/favicon.ico\"&gt;&lt;!--还原按钮--&gt;&lt;input type=\"reset\"&gt;&lt;!--提交按钮--&gt;&lt;input type=\"submit\"&gt; 6. 隐藏域 作用: 定义隐藏的输入字段 暂时不用掌握, 在Ajax中对数据的CRUD操作有非常大的作用 7.取色器和日期选择器 取色器: &lt;input type=&quot;color&quot;&gt; 日期选色器: &lt;input type=&quot;date&quot;&gt; HTML5中input类型增加了很多type类型, 例如color、date但是都不兼容, 后面讲到浏览器兼容时会重点讲解 亲自测试,在Mac电脑的Safari浏览器不兼容,只能用谷歌浏览器 1234567&lt;!--取色器--&gt;&lt;label&gt;颜色: &lt;/label&gt; &lt;input type=\"color\"&gt;&lt;!--换行--&gt;&lt;p&gt;&lt;/p&gt;&lt;!--日期选色器--&gt;&lt;label&gt;时间: &lt;/label&gt; &lt;input type=\"date\"&gt; 8. 数据列表 作用: 给输入框绑定待选项 格式: 123datalist&gt; &lt;option&gt;待选项内容&lt;/option&gt;&lt;/datalist&gt; 如何给输入框绑定待选列表 搞一个输入框 搞一个datalist列表 给datalist列表标签添加一个id 给输入框添加一个list属性,将datalist的id对应的值赋值给list属性即可 12345678910&lt;!--数据列表--&gt;请选择车型: &lt;input type=\"text\" list=\"cars\"&gt;&lt;datalist id=\"cars\"&gt; &lt;option&gt;奔驰&lt;/option&gt; &lt;option&gt;宝马&lt;/option&gt; &lt;option&gt;奥迪&lt;/option&gt; &lt;option&gt;别克&lt;/option&gt; &lt;option&gt;奔腾&lt;/option&gt; &lt;option&gt;奔跑&lt;/option&gt;&lt;/datalist&gt; 当输入某一个字符时,会自动根据datalist列表查询,并显示对应的列表,如图: 三. 多行文本框(文本域) 作用: textarea标签用于在表单中定义多行的文本输入控件 cols属性表示columns“列”, 规定文本区内的可见宽度 rows属性表示rows“行”, 规定文本区内的可见高度 格式:&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;默认&lt;/textarea&gt; 注意点: 可以通过cols和rows来指定输入框的宽度和高度 默认情况下输入框是可以手动拉伸的 123456&lt;!--禁止手动拉伸--&gt;&lt;style type=\"text/css\"&gt; textarea&#123; resize: none; &#125;&lt;/style&gt; 四. 下拉列表 作用: select标签和ul、ol、dl一样，都是组标签. 用于创建表单中的待选列表 和radio、checkbox一样select也可以设置默认值, 通过selected属性设置(本身默认是第一个选项) 给下拉列表添加分组 示例代码1234567891011121314&lt;!--给下拉表添加分组--&gt;&lt;select&gt; &lt;optgroup label=\"杭州市\"&gt; &lt;option&gt;江干区&lt;/option&gt; &lt;option&gt;西湖区&lt;/option&gt; &lt;option&gt;滨江区&lt;/option&gt; &lt;option&gt;下城区&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=\"烟台市\"&gt; &lt;option&gt;莱山区&lt;/option&gt; &lt;option&gt;芝罘区&lt;/option&gt; &lt;/optgroup&gt; &lt;option selected&gt;北京市&lt;/option&gt;&lt;/select&gt; 对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://titanjun.top/categories/HTML5/"}],"tags":[{"name":"HTML5标签","slug":"HTML5标签","permalink":"https://titanjun.top/tags/HTML5标签/"},{"name":"CSS","slug":"CSS","permalink":"https://titanjun.top/tags/CSS/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://titanjun.top/tags/WebStorm/"}]},{"title":"HTML5学习笔记之基础标签","slug":"HTML5学习笔记之基础标签","date":"2017-06-15T12:17:00.000Z","updated":"2018-03-13T01:16:54.000Z","comments":true,"path":"2017/06/15/HTML5学习笔记之基础标签/","link":"","permalink":"https://titanjun.top/2017/06/15/HTML5学习笔记之基础标签/","excerpt":"HTML5学习笔记之基础标签","text":"HTML5学习笔记之基础标签 一.列表标签1.无序列表(unordered list) 无序 : 没有先后之分 1) 作用: 给一堆内容添加无序列表语义(一个没有先后顺序整体), 列表中的条目是不分先后 2) 格式: li 英文是 list item, 翻译为列表项 1234567 &lt;h4&gt;中国城市列举(CN)&lt;/h4&gt;&lt;ul&gt; &lt;li&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;广州&lt;/li&gt; &lt;li&gt;杭州&lt;/li&gt;&lt;/ul&gt; 3) ul应用场景: 导航条 商品列表等 新闻列表 4) 注意: 其实ul还有一个type属性, 可以修改先导符号的样式, 取值有disc、square、circle几种 但是由于样式将来都是通过css来完成, 所以这里就不给大家介绍了 ul是一个组标签, 一定是一坨一坨的出现, 也就是说li标签不能单独存在, 必须包裹在ul里面 由于ul和li是一个整体, 所以ul里面不推荐包裹其它标签, 永远记住ul里面最好只写li标签 虽然ul中推荐只能写li标签, 但是li标签是一个容器标签, li标签中可以添加任意标签, 甚至可以添加ul标签 123456789101112131415161718&lt;h4&gt;课程安排&lt;/h4&gt;&lt;ul&gt; &lt;li&gt; 上午 &lt;ul&gt; &lt;li&gt;HTML5&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 下午 &lt;ul&gt; &lt;li&gt;OC&lt;/li&gt; &lt;li&gt;Swift&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 2.有序列表(ordered list)1) 作用: 给一堆内容添加有序列表语义(一个有顺序整体), 列表中的条目有先后之分12345678&lt;h4&gt;中国房价排行榜&lt;/h4&gt;&lt;ol&gt; &lt;li&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;杭州&lt;/li&gt; &lt;li&gt;广州&lt;/li&gt; &lt;li&gt;深圳&lt;/li&gt;&lt;/ol&gt; 2) ol应用场景: xxx排行榜 其实ol应用场景并不多, 因为能用ol做的用ul都能做 ul的常见属性start、type属性, 可以修改先导符号的样式和序号 二.定义列表(definition list)1) 作用: 给一堆内容添加列表语义, 通过dt罗列出列表的条目, 然后再通过dd给每个条目进行相应的描述 2) 格式: dt英文definition title, 翻译为定义标题 dd英文definition description, 翻译为定义描述信息 12345678&lt;dl&gt; &lt;dt&gt;北京&lt;/dt&gt; &lt;dd&gt;国家的首都&lt;/dd&gt; &lt;dt&gt;杭州&lt;/dt&gt; &lt;dd&gt;坑爹,房价上涨最快的地方&lt;/dd&gt;&lt;/dl&gt;![Snip20170614_7.png](http://upload-images.jianshu.io/upload_images/4122543-2d304b7b5f58b8c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 3) dl应用场景: 网站底部相关信息 但凡看到一堆内容都是用于描述某一个内容的时候就要想到dl 4) 注意事项: dl是一个组标签, 一定是一坨一坨的出现, 也就是说dt和dd标签不能单独存在, 必须包裹在dl里面 由于dl和dt、dd是一个整体, 所以dl里面不推荐包裹其它标签 dd和dt和li标签一样是容器标签, 里面可以添加任意标签 定义列表非常灵活, 可以给一个dt配置多个dd, 但是最好不要出现多个dt对应一个dd, dd的语义是描述离它最近的一个dt, 所以其它dt相当于没有描述, 而定义列表存在的意义就是既可以列出每一个条目又可以对每一个条目进行描述 定义列表非常灵活, 可以将多个dt+dd组合拆分为多个dl 三.H系列标签(Header 1~Header 6)1.作用: 用于给文本添加标题语义 格式: &lt;h1&gt;xxxxxx&lt;/h1&gt;2.注意点: H标签是用来给文本添加标题语义的, 而不是用来修改文本的样式的 H标签一共有6个, 从H1~H6, 最多就只能到6, 超过6则无效 被H系列标签包裹的内容会独占一行 在H系列的标签中, H1最大, H6最小 在企业开发中, 一定要慎用H系列的标签, 特别是H1标签. 在企业开发中一般情况下一个界面中只能出现一个H1标签(和SEO有关) 四.P标签(Paragraph)1.作用: 告诉浏览器哪些文字是一个段落 格式: xxxxxxxx2.注意点: 在浏览器中会单独占一行 五.Hr标签(Horizontal Rule)1.作用: 在浏览器上显示一条分割线 格式: &lt;hr /&gt;2.注意点: 在浏览器中会单独占一行 通过我的观察发现HR标签可以写/也可以不写 如果不写/那么就是按照HTML的规范来编写 如果写上/那么就是按照XHTML的规范来编写. 由于hr标签是用来修改样式的, 所以不推荐使用. 今后开发中添加水平线一般都使用CSS盒子来做 六.HTML注释(Annotation)1.什么是注释?1.注释格式&lt;!--被注释的内容--&gt; 2.注意点: 被注释的内容不会在浏览器中显示, 注释是写给我们自己看的 注释不能嵌套使用 &lt;!--&lt;!--被注释的内容--&gt;--&gt; 3.快捷键: ctrl + /示例代码123456789101112131415&lt;h1&gt;标题1&lt;/h1&gt;&lt;h2&gt;标题2&lt;/h2&gt;&lt;h3&gt;标题3&lt;/h3&gt;&lt;h4&gt;标题4&lt;/h4&gt;&lt;h5&gt;标题5&lt;/h5&gt;&lt;h6&gt;标题6&lt;/h6&gt;&lt;h7&gt;我是假的,标题7&lt;/h7&gt;&lt;!--我是注释--&gt;&lt;hr /&gt;&lt;p&gt;告诉浏览器哪些文字是一个段落&lt;/p&gt;&lt;!--下面是分割线--&gt;&lt;hr /&gt; 七.img标签(image)1) 作用: 在网页上插入一张图片 2) 格式: ![image](http://note.youdao.com/favicon.ico) 3) 标签的属性 写在标签中K=”V”这种格式的文本我们称之为标签属性 属性名称 作用 src(source) 告诉浏览器需要插入的图片路径, 以便于浏览器到该路径下找到需要插入的图片 alt(alternate) 规定图像的替代文本, 只有在src指定的路径下找不到图片,才会显示alt指定的文本 title 悬停文本(介绍这张图片, 只有在鼠标移动到图片上时才会显示) height 设置图片显示的高度 width 设置图片显示的宽度 4) 注意点: img标签添加的图片默认不是占一整行空间如果想让图片等比拉伸,只写高度或者宽度即可 5) 示例代码12345678&lt;!--图片标签--&gt;![](http://note.youdao.com/favicon.ico)![有道云笔记](http://note.youdao.com/favicon.ico)![有道云笔记](http://note.youdao.com/favicon.ico)![有道云笔记](http://note.youdao.com/favicon.ico)![有道云笔记](http://note.youdao.com/favicon.ico)![有道云笔记](http://note.youdao.com/favicon.ico)&lt;img src=\"\" alt=\"找不到图片\"&gt; 5) 运行结果 八.br标签(Break)1) 作用: 让内容换行2) 格式: &lt;br/&gt;3) 注意点: br的意思是不另起一个段落进行换行, 而网页中99.99%需要换行时都是因为另起了一个段落, 所以应该用p来做 九.a标签(anchor)1) 格式: &lt;a href=&quot;http://www.jianshu.com/u/5bd5e9ed569e&quot;&gt;我的简书&lt;/a&gt;2) 作用: 用于从一个页面链接到另一个页面3) 注意事项: 在a标签之间一定要写上文字, 如果没有, 那么在页面上找不到这个标签a标签也叫做超级链接或超链接4) a标签的属性 属性名称 作用 href(hypertext reference) 指定跳转的目标地址 target 告诉浏览器是否保留原始界面, _blank保留, _self不保留 title 悬停文本(介绍这个链接, 只有在鼠标移动到超链接上时才会显示) 4) 代码示例1234&lt;!--a标签--&gt;&lt;a href=\"http://www.jianshu.com/u/5bd5e9ed569e\"&gt;我的简书&lt;/a&gt;&lt;a href=\"http://www.jianshu.com/u/5bd5e9ed569e\" title=\"我的简书\"&gt;我的简书&lt;/a&gt;&lt;a href=\"http://www.jianshu.com/u/5bd5e9ed569e\" title=\"我的简书\" target=\"_blank\"&gt;我的简书&lt;/a&gt; 5) base标签和a标签结合使用 如果每个a标签都想在新页面中打开,那么逐个设置a标签的target属性比较麻烦, 这时我们可以使用base和a标签结合的方式,一次性设置有a标签都在新页面中打开 格式: &lt;base target=&quot;_blank&quot; /&gt; 注意事项: base必须嵌套在head标签里面 如果标签上指定了target,base中也指定了target,那么会按照标签上指定的来执行6) a标签其它用法 假链接(本质是跳转到当前页面) 格式&lt;a href=&quot;#&quot;&gt;我的简书&lt;/a&gt; 格式&lt;a href=&quot;javascript:&quot;&gt;我的简书&lt;/a&gt; 跳转到当前页面指定位置(锚点链接) 1.格式&lt;a href=&quot;#location&quot;&gt;跳转到指定位置&lt;/a&gt; 2.在页面的指定位置给任意标签添加一个id属性 例如 &lt;p id=&quot;location&quot;&gt;这个是目标&lt;/p&gt; 跳转到指定页面的指定位置 格式: &lt;a href=&quot;01-锚点链接.html#location&quot;&gt;跳转到指定位置&lt;/a&gt; 只需要在01-锚点链接.html页面添加一个id位置即可 下载(极力不推荐使用) 例如&lt;a href=&quot;girl.zip&quot;&gt;下载福利资源&lt;a/&gt; 对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://titanjun.top/categories/HTML5/"}],"tags":[{"name":"HTML5标签","slug":"HTML5标签","permalink":"https://titanjun.top/tags/HTML5标签/"},{"name":"CSS","slug":"CSS","permalink":"https://titanjun.top/tags/CSS/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://titanjun.top/tags/WebStorm/"}]},{"title":"HTML5基本介绍","slug":"HTML5基本介绍","date":"2017-06-15T12:16:00.000Z","updated":"2018-03-13T01:14:20.000Z","comments":true,"path":"2017/06/15/HTML5基本介绍/","link":"","permalink":"https://titanjun.top/2017/06/15/HTML5基本介绍/","excerpt":"一.网页固定格式1.编写网页的步骤: 新建一个文本文档 利用记事本打开 编写THML代码 保存并且修改纯文本文档的扩展名为.html 利用浏览器打开编写好的文件","text":"一.网页固定格式1.编写网页的步骤: 新建一个文本文档 利用记事本打开 编写THML代码 保存并且修改纯文本文档的扩展名为.html 利用浏览器打开编写好的文件 一.网页固定格式1.编写网页的步骤: 新建一个文本文档 利用记事本打开 编写THML代码 保存并且修改纯文本文档的扩展名为.html 利用浏览器打开编写好的文件 一款强大的编辑软件 Webstorm或者 WebStorm 1.1 WebStorm常见快捷键 如何在WebStorm中利用快捷键创建一个新的.html的文件 同时按下键盘上的Ctrl + Alt + Insert 如何在WebStorm中让光标移动到当前行的末尾 按下键盘上的End键即可 如何在WebStorm中让光标移动到当前行的最前面 按下键盘上的Home键即可 如何在WebStorm中让光标在多行中闪烁 按住键盘上的Alt键不放, 然后再按住鼠标的左键不放, 然后再拖动鼠标即可 如何在WebStorm中快速的复制光标所在的那一行 按下键盘上的Ctrl + D 如何在WebStorm中快速的删除光标所在的那一行 按下键盘上的Ctrl + X 如何在WebStorm中让标签包裹一段内容, 也就是自动在一段内容前后加上标签 按下键盘上的Ctrl + Alt + T, 然后按下回车, 然后输入对应的标签即可 2.网页基本结构12345678910&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;音视频测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 通过观察我们发现, HTML基本结构中所有的标签都是成对出现的, 这些成对出现的标签中有一个带/有一个不带/, 那么这些不带/的标签我们称之为开始标签, 这些带/的我们称之为结束标签 二.网页标签1.HTML标签 作用: 用于告诉浏览器这是一个网页, 也就是说告诉浏览器我是一个HTML文档 注意点: 其它所有的标签都必须写在html标签里面, 也就是写在html开始标签和结束标签中间 2.head标签 作用:用于给网站添加一些配置信息 例如: 指定网站的标题 / 指定网站的小图片 添加网站的SEO相关的信息(指定网站的关键字/指定网站的描述信息) 外挂一些外部的css/js文件 添加一些浏览器适配相关的内容 注意点:一般情况下, 写在head标签内部的内容都不会显示给用户查看, 也就是说一般情况下写在head标签内部的内容我们都看不到 3.title标签 作用:专门用于指定网站的标题, 并且这个指定的标题将来还会作为用户保存网站的默认标题 注意点:title标签必须写在head标签里面 4.body标签 作用:专门用于定义HTML文档中需要显示给用户查看的内容(文字/图片/音频/视频) 注意点:虽然说有时候你可能将内容写到了别的地方在网页中也能看到, 但是千万不要这么干, 一定要将需要显示的内容写在body中一对html标签中(一个html开始标签和一个html结束标签)只能有一对body标签 5.meta标签 作用 : 在编写网页的时候指定字符集,可避免出现乱码现象 1&lt;meta charset=\"UTF-8\"&gt; GBK(GB2312)和UTF-8区别 GBK(GB2312)里面存储的字符比较少, 仅仅存储了汉字和一些常用外文体积比较小 UTF-8里面存储的世界上所有的文字,提交比较大 个人推荐:所有一律都写UTF-8 3.HTML标签分类1.单标签 只有开始标签没有结束标签, 也就是由一个&lt;&gt;组成的 1&lt;meta charset=\"UTF-8\" /&gt; 2.双标签 有开始标签和结束标签, 也就是由一个&lt;&gt;和一个&lt;/&gt;组成的 12&lt;html&gt;&lt;/html&gt; 4.HTML标签关系分类1.并列关系(兄弟/平级)1234&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 2.嵌套关系(父子/上下级)1234&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;音视频测试&lt;/title&gt;&lt;/head&gt; 对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://titanjun.top/categories/HTML5/"}],"tags":[{"name":"HTML5标签","slug":"HTML5标签","permalink":"https://titanjun.top/tags/HTML5标签/"},{"name":"CSS","slug":"CSS","permalink":"https://titanjun.top/tags/CSS/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://titanjun.top/tags/WebStorm/"}]},{"title":"Swift项目创建桥接文件","slug":"Swift项目创建桥接文件","date":"2017-06-15T03:16:00.000Z","updated":"2018-04-10T09:04:43.706Z","comments":true,"path":"2017/06/15/Swift项目创建桥接文件/","link":"","permalink":"https://titanjun.top/2017/06/15/Swift项目创建桥接文件/","excerpt":"一.创建具体步骤参考Object-C 和 swift桥接文件","text":"一.创建具体步骤参考Object-C 和 swift桥接文件 二.报错 如出现 xxx file not found 的错误 参考解决(文中解释比较详细)Swift: 在Swift中桥接OC文件（自己创建的类文件、第三方库文件）","categories":[{"name":"入坑指南","slug":"入坑指南","permalink":"https://titanjun.top/categories/入坑指南/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"桥接","slug":"桥接","permalink":"https://titanjun.top/tags/桥接/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://titanjun.top/tags/Objective-C/"}]},{"title":"Swift仿网易新闻首页左右滑动切换页面","slug":"Swift仿网易新闻首页左右滑动切换页面","date":"2017-06-12T12:12:00.000Z","updated":"2018-03-13T01:52:07.000Z","comments":true,"path":"2017/06/12/Swift仿网易新闻首页左右滑动切换页面/","link":"","permalink":"https://titanjun.top/2017/06/12/Swift仿网易新闻首页左右滑动切换页面/","excerpt":"顶部标题左右滑动切换控制器是一种非常用的左右滚动切换效果,几乎每一个APP都有用到,在这里介绍一下我自己封装的一个Swift版本的简单框架;代码中注释相对详细,故文中没有做过多的解释;废话不多少,直接上效果图:","text":"顶部标题左右滑动切换控制器是一种非常用的左右滚动切换效果,几乎每一个APP都有用到,在这里介绍一下我自己封装的一个Swift版本的简单框架;代码中注释相对详细,故文中没有做过多的解释;废话不多少,直接上效果图: 一.框架介绍github地址 1234567TJTitleStyle.swift //控制框架所有显示样式的参数值TJTitleView.swift //顶部标题的处理viewTJContentView.swift //处理所有控制器的viewTJPageView.swift //控制整体框架的总试图View TJTitleStyle.swift1234567891011121314151617181920212223242526272829303132333435363738/// 是否是滚动的Titlevar isScrollEnable : Bool = false/// 普通Title颜色var normalColor : UIColor = UIColor(r: 0, g: 0, b: 0)/// 选中Title颜色var selectedColor : UIColor = UIColor(r: 255, g: 127, b: 0)/// Title字体大小var font : UIFont = UIFont.systemFont(ofSize: 14.0)/// 滚动Title的字体间距var titleMargin : CGFloat = 20/// title的高度var titleHeight : CGFloat = 44/// 是否显示底部滚动条var isShowBottomLine : Bool = false/// 底部滚动条的颜色var bottomLineColor : UIColor = UIColor.orange/// 底部滚动条的高度var bottomLineH : CGFloat = 2/// 是否进行缩放var isNeedScale : Bool = falsevar scaleRange : CGFloat = 1.2/// 是否显示遮盖var isShowCover : Bool = false/// 遮盖背景颜色var coverBgColor : UIColor = UIColor.lightGray/// 文字&amp;遮盖间隙var coverMargin : CGFloat = 5/// 遮盖的高度var coverH : CGFloat = 25/// 设置圆角大小var coverRadius : CGFloat = 12 TJPageCollectionLayout.swift自定义布局 代码如下,注释比较详尽,不做赘述 123456789101112131415161718192021222324252627282930313233343536// 在该方法中设定一些必要的layout的结构和初始需要的参数override func prepare() &#123; super.prepare() //0.计算item的宽度和高度 let itemW = ((collectionView?.bounds.width)! - sectionInset.left - sectionInset.right - minimumInteritemSpacing * CGFloat(cols - 1)) / CGFloat(cols) let itemH = ((collectionView?.bounds.height)! - sectionInset.top - sectionInset.bottom - minimumLineSpacing * CGFloat(rows - 1)) / CGFloat(rows) //1.获取一共多少个组 let sectionCount = collectionView!.numberOfSections //2.获取每个组中有多少个item var prePageCount : Int = 0 //页数 for i in 0..&lt;sectionCount &#123; let itemCount = collectionView!.numberOfItems(inSection: i) for j in 0..&lt;itemCount &#123; //2.1获取cell对应的indexPath let indexpath = IndexPath(item: j, section: i) //2.2根据indexPath创建UICollectionViewLayoutAttributes let attr = UICollectionViewLayoutAttributes(forCellWith: indexpath) // 2.3.计算j在该组中第几页 let page = j / (cols * rows) let index = j % (cols * rows) //2.4设置attrs的frame let itemY = sectionInset.top + (itemH + minimumLineSpacing) * CGFloat(index / cols) let itemX = CGFloat(prePageCount + page) * collectionView!.bounds.width + sectionInset.left + (itemW + minimumInteritemSpacing) * CGFloat(index % cols) attr.frame = CGRect(x: itemX, y: itemY, width: itemW, height: itemH) //2.5加入到数组中 cellAttrs.append(attr) &#125; prePageCount += (itemCount - 1) / (cols * rows) + 1 &#125; //计算最大宽度 maxWidth = CGFloat(prePageCount) * collectionView!.bounds.width&#125; TJPageCollectionView.swift 创建collectionView显示布局内容,设置代理方法和对外暴露的方法 代理方法123456789101112131415protocol TJPageCollectionViewDateSource : class &#123; //返回section的个数 func numberOfSections(in pageCollectionView : TJPageCollectionView) -&gt; Int //返回每个section中item的个数 func pageCollectionView(_ collectionView : TJPageCollectionView, numberOfItemsInSection section : Int) -&gt; Int //cell func pageCollectionView(_ pageCollectionView : TJPageCollectionView, _ collectionView : UICollectionView, cellForItemAt indexPath : IndexPath) -&gt; UICollectionViewCell&#125;protocol TJPageCollectionViewDelegate : class &#123; //cell点击事件处理 func pageCollectionView(_ pageCollectionView : TJPageCollectionView, didSelectorItemAt indexPath : IndexPath)&#125; 二.首页左右滑动调用方法1.设置显示样式1234567let style = TJTitleStyle()//是否可以滚动style.isScrollEnable = true//是否显示下划线style.isShowBottomLine = true//是否显示遮挡试图viewstyle.isShowCover = true 2.初始化方法123456789101112/**初始化方法* frame : 坐标* titles : 标题数组* style : 样式* childVcs : 自控制器数组* parentVc : 父控制器*/let pageView = TJPageView(frame: frame, titles: titles, style: style, childVcs: childVcs, parentVc: self)view.addSubview(pageView) 三.底部类似表情键盘布局调用方法1.初始化12345678910111213141516171819202122// 1.设置显示样式let style = TJTitleStyle()style.isShowBottomLine = true //2.设置cell布局Layoutlet layout = TJPageCollectionLayout()layout.cols = 7 // 列layout.rows = 3 // 行layout.minimumLineSpacing = 0layout.minimumInteritemSpacing = 0layout.sectionInset = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10) //3.创建collectionViewlet pageCollection = TJPageCollectionView(frame: CGRect(x: 0, y: UIScreen.main.bounds.height - 250, width: UIScreen.main.bounds.width, height: 250), style: style, titles: [\"普通\", \"粉丝\"], isTitleInTop: false, layout: layout)pageCollection.delegate = selfpageCollection.dataSource = self//4.注册cellpageCollection.register(nib: UINib(nibName: \"EmoticonViewCell\", bundle: nil), identifier: kEmoticonCellID)//5.添加到视图中view.addSubview(pageCollection) 2.遵循协议12345678910111213141516171819202122//MARK: TJCollectionViewDateSourceextension NextViewController : TJPageCollectionViewDateSource&#123; func numberOfSections(in pageCollectionView: TJPageCollectionView) -&gt; Int &#123; return 5 &#125; func pageCollectionView(_ collectionView: TJPageCollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return 40 &#125; func pageCollectionView(_ pageCollectionView: TJPageCollectionView, _ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: kEmoticonCellID, for: indexPath) as! EmoticonViewCell return cell &#125;&#125;//MARK: TJPageCollectionViewDelegateextension NextViewController : TJPageCollectionViewDelegate&#123; func pageCollectionView(_ pageCollectionView: TJPageCollectionView, didSelectorItemAt indexPath: IndexPath) &#123; print(indexPath) &#125;&#125; 框架代码中可能还有不足之处,还望大神多多指教. 菜鸟一枚,多多交流. github地址","categories":[{"name":"Swiftk框架","slug":"Swiftk框架","permalink":"https://titanjun.top/categories/Swiftk框架/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"框架","slug":"框架","permalink":"https://titanjun.top/tags/框架/"}]},{"title":"iOS9之UIStackView的使用","slug":"iOS9之UIStackView的使用","date":"2017-06-10T09:12:00.000Z","updated":"2018-03-10T15:31:50.000Z","comments":true,"path":"2017/06/10/iOS9之UIStackView的使用/","link":"","permalink":"https://titanjun.top/2017/06/10/iOS9之UIStackView的使用/","excerpt":"苹果在iOS9新增了一个简易的布局控件UIStackView,它是一个基于 Auto Layout 的抽象层从而使布局属性的创建简单化,它可以将一组 UIView 视图进行垂直或水平方向的排列。 UIStackView 既可以用代码编写也可以在 Interface Builder 中设计(简易xib更方便适用)。 你可以在一个主 UIStackView 中嵌套 UIStackView 从而让视图精确放置到相应的位置","text":"苹果在iOS9新增了一个简易的布局控件UIStackView,它是一个基于 Auto Layout 的抽象层从而使布局属性的创建简单化,它可以将一组 UIView 视图进行垂直或水平方向的排列。 UIStackView 既可以用代码编写也可以在 Interface Builder 中设计(简易xib更方便适用)。 你可以在一个主 UIStackView 中嵌套 UIStackView 从而让视图精确放置到相应的位置 下面就具体介绍一下UIStackView的一些方法和属性 一.方法1.初始化数组12345678//OC中- (instancetype)initWithArrangedSubviews:(NSArray&lt;__kindof UIView *&gt; *)views;//Swiftlet stackView1 = UIStackView(arrangedSubviews: subViews) 2.添加子视图12345678//OC- (void)addArrangedSubview:(UIView *)view;//SwiftstackView.addArrangedSubview(UIView) 3.移除子视图12345678//OC- (void)removeArrangedSubview:(UIView *)view;//SwiftstackView1.removeArrangedSubview(UIView) 4.根据下标插入子视图12345678//OC- (void)insertArrangedSubview:(UIView *)view atIndex:(NSUInteger)stackIndex;//SwiftstackView1.insertArrangedSubview(UIView, atIndex: Int) 二.属性1.布局方向123456789101112stackView.axis = .Horizontal/**************/Horizontal -&gt; UILayoutConstraintAxisHorizontal水平方向布局Vertical -&gt; UILayoutConstraintAxisVertical垂直方向布局 2.内容物填充样式123456789101112131415161718192021222324stackView.distribution = .FillEqually/****************/Fill -&gt; UIStackViewDistributionFill填充整个UIStackView，并且根据内部子视图尺寸对子视图尺寸进行动态调整。Fill Equally -&gt; UIStackViewDistributionFillEqually根据视图大小平均分配UIStackView尺寸，等比例填充UIStackView，过程中会根据分配的大小改变子视图尺寸。Fill Proportionally -&gt; UIStackViewDistributionFillProportionally根据之前的比例填充UIStackView。Equal Spacing -&gt; UIStackViewDistributionEqualSpacing填充整个UIStackView，子视图没有占满UIStackView将会用空白平均填充子视图中间的间距，超出UIStackView将会根据arrangedSubviews数组下标压缩子视图。Equal Centering -&gt; UIStackViewDistributionEqualCentering平均分配子视图得到每个视图的中心点，使用这个中心点来布局每个子视图，并且保持spacing距离，超出将会重新布局子视图，并压缩部分子视图。 3.视图填充样式123456789101112131415161718192021222324252627282930313233343536stackView.alignment = .Fill/****************/Fill -&gt; UIStackViewAlignmentFill视图纵向填充Top -&gt; UIStackViewAlignmentTop视图向上对其(适用于Horizontal模式)Center -&gt; UIStackViewAlignmentCenter视图居中对其Bottom -&gt; UIStackViewAlignmentBottom视图向下对其(适用于Horizontal模式)First Baseline -&gt; UIStackViewAlignmentFirstBaseline根据上方基线布局所有子视图的y值(适用于Horizontal模式)Last Baseline -&gt; UIStackViewAlignmentLastBaseline根据下方基线布局所有子视图的y值(适用于Horizontal模式)trailing -&gt; UIStackViewAlignmentTrailing视图向左对齐(适用于Vertical模式)leading -&gt; UIStackViewAlignmentLeading视图向右对齐(适用于Vertical模式) 4.子控件之间最小距离123456stackView.spacing = 0/****************/spacing -&gt; CGFloat spacing 5.基线相对布局12public var baselineRelativeArrangement: Bool 如果YES，则从顶视图的最后基线到底视图的顶部测量两个视图之间的垂直间距。 6.边界相对布局12public var layoutMarginsRelativeArrangement: Bool 决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距，选中 Layout Margins Relative 将相对于标准边界空白来调整subview位置 ##Xib创建 择UIStackView控件直接拖到XIB中。可以选择Horizontal和Vertical两个方向的UIStackView，也可以在拖到XIB中之后手动修改。 父视图可以将UIStackView作为子视图来进行多层UIStackView嵌套，这也是苹果推荐的做法。 打开右侧设置面板来设置UIStackView的一些对应属性，达到更好的布局效果。 除了上面的方法也可以在XIB中直接选择多个View，然后点击右下方的Stack按钮，系统会自动推断布局方式,平均分配空间布局，帮我们自动布局子视图，我们可以在系统布局之后在手动进行调整。 作为一枚小菜鸟,不足之处还望大家多多指正,互相学起,共同进步!","categories":[{"name":"iOS","slug":"iOS","permalink":"https://titanjun.top/categories/iOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://titanjun.top/tags/Objective-C/"},{"name":"UIStackView","slug":"UIStackView","permalink":"https://titanjun.top/tags/UIStackView/"}]},{"title":"NSMutableAttributedString富文本","slug":"NSMutableAttributedString富文本","date":"2017-05-19T08:57:23.000Z","updated":"2018-04-10T08:54:13.044Z","comments":true,"path":"2017/05/19/NSMutableAttributedString富文本/","link":"","permalink":"https://titanjun.top/2017/05/19/NSMutableAttributedString富文本/","excerpt":"在iOS开发中，常常会有一段文字显示不同的颜色和字体，或者给某几个文字加删除线或下划线的需求。以及一些直播界面中包含图片和字体的弹幕效果，大部分都是由NSMuttableAttstring（带属性的字符串）实现的。","text":"在iOS开发中，常常会有一段文字显示不同的颜色和字体，或者给某几个文字加删除线或下划线的需求。以及一些直播界面中包含图片和字体的弹幕效果，大部分都是由NSMuttableAttstring（带属性的字符串）实现的。 一、简易使用方法 1、示例代码 12345678910111213141516171819fileprivate func addAttributeString() -&gt; NSMutableAttributedString&#123; let time = \"还剩 19 时 30 分 40 秒 开售\" let timeAtt = NSMutableAttributedString(string: time) //字典中存放一些属性名和属性值 let timeDic = [NSFontAttributeName : UIFont.systemFont(ofSize: 18), NSForegroundColorAttributeName : UIColor.red, NSBackgroundColorAttributeName : UIColor.orange] //为某一范围内的文字设置多个属性 timeAtt.setAttributes(timeDic, range: NSMakeRange(2, 4)) //为某一范围内的文字添加单个属性 timeAtt.addAttribute(NSFontAttributeName, value: UIFont.systemFont(ofSize: 18), range: NSMakeRange(8, 4)) //为某一范围内的文字添加多个属性 timeAtt.addAttributes(timeDic, range: NSMakeRange(8, 4)) //为某一范围内的文字移除某个属性 timeAtt.removeAttribute(NSFontAttributeName, range: NSMakeRange(8, 4)) return timeAtt&#125; 字符串处理 123456789101112//拼接字符串timeAtt.append(NSAttributedString)//插入字符串timeAtt.insert(NSAttributedString, at: Int)//替换timeAtt.replaceCharacters(in: NSRange, with: NSAttributedString)timeAtt.replaceCharacters(in: NSRange, with: String)//删除timeAtt.removeAttribute(String, range: NSRange) 2、常见属性及说明 1234567891011121314151617181920212223242526272829303132333435363738394041NSFontAttributeName 设置字体属性，默认值：字体：Helvetica(Neue) 字号：12NSForegroundColorAttributeNam 设置字体颜色，取值为 UIColor对象，默认值为黑色NSBackgroundColorAttributeName 设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色NSLigatureAttributeName 设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符NSKernAttributeName 设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄NSStrikethroughStyleAttributeName 设置删除线，取值为 NSNumber 对象（整数）NSStrikethroughColorAttributeName 设置删除线颜色，取值为 UIColor 对象，默认值为黑色NSUnderlineStyleAttributeName 设置下划线，取值为NSNumber对象（整数），枚举常量NSUnderlineStyle中的值，与删除线类似NSUnderlineColorAttributeName 设置下划线颜色，取值为 UIColor 对象，默认值为黑色NSStrokeWidthAttributeName 设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果NSStrokeColorAttributeName 填充部分颜色，不是字体颜色，取值为 UIColor 对象NSShadowAttributeName 设置阴影属性，取值为 NSShadow 对象NSTextEffectAttributeName 设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：NSBaselineOffsetAttributeName 设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏NSObliquenessAttributeName 设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾NSExpansionAttributeName 设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本NSWritingDirectionAttributeName 设置文字书写方向，从左向右书写或者从右向左书写NSVerticalGlyphFormAttributeName 设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本NSLinkAttributeName 设置链接属性，点击后调用浏览器打开指定URL地址NSAttachmentAttributeName 设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排NSParagraphStyleAttributeName 设置文本段落排版格式，取值为 NSParagraphStyle 对象 更多方法和属性说明详见苹果官方说明文档 二实现图文混排 效果如图 实例代码 123456789101112131415161718//1,富文本字符串let attText = NSMutableAttributedString(string: \"你好不好\")attText.setAttributes([NSForegroundColorAttributeName : UIColor.orange], range: NSMakeRange(0, 4)) //2,图片处理let attachment = NSTextAttachment()attachment.image = UIImage(named: \"tt1\") //3,计算文字高度let lineHeight = label.font.lineHeight //4,设置图片的显示大小attachment.bounds = CGRect(x: 0, y: 0, width: lineHeight, height: lineHeight)//5,图片转成富文本let picAtt = NSAttributedString(attachment: attachment) //6,插入到原字符串中attText.insert(picAtt, at: 2) 菜鸟一枚,文中如有不妥之处还望多多指正;互相学习共同进步! 喜欢的朋友可以点下喜欢,并关注下!","categories":[{"name":"高级用法","slug":"高级用法","permalink":"https://titanjun.top/categories/高级用法/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"富文本","slug":"富文本","permalink":"https://titanjun.top/tags/富文本/"}]},{"title":"Swift函数式编程之Map&Reduce&Filter","slug":"Swift函数式编程之Map&Reduce&Filter","date":"2017-05-19T08:57:03.000Z","updated":"2018-04-10T09:05:46.582Z","comments":true,"path":"2017/05/19/Swift函数式编程之Map&Reduce&Filter/","link":"","permalink":"https://titanjun.top/2017/05/19/Swift函数式编程之Map&Reduce&Filter/","excerpt":"什么是函数式编程呢? 函数式编程其实是一种编程思想, 代码写出来只是它的表现形式. 在面向对象的编程思想中, 我们将要解决的一个个问题, 抽象成一个个类, 通过给类定义属性和方法, 让类帮助我们解决需要处理的问题.(其实面向对象也叫命令式编程, 就像给对象下一个个命令) 而在函数式编程中, 我们则通过函数描述我们要解决的问题, 以及解决问题需要怎样的方案. 函数本身可以作为变量, 作为参数, 作为返回值(这样说有一点抽象, 下面的解决方案中就是将函数作为函数的参数)","text":"什么是函数式编程呢? 函数式编程其实是一种编程思想, 代码写出来只是它的表现形式. 在面向对象的编程思想中, 我们将要解决的一个个问题, 抽象成一个个类, 通过给类定义属性和方法, 让类帮助我们解决需要处理的问题.(其实面向对象也叫命令式编程, 就像给对象下一个个命令) 而在函数式编程中, 我们则通过函数描述我们要解决的问题, 以及解决问题需要怎样的方案. 函数本身可以作为变量, 作为参数, 作为返回值(这样说有一点抽象, 下面的解决方案中就是将函数作为函数的参数) 1. Map的介绍 map用于将每个数组元素通过某个方法进行转换 Map在此处并非地图的意思, 它的含义是映射 将一个元素映射成另外一种元素(类似于字典中的Key/Value映射) 其实Swift系统本身是有映射的函数, 可以将一个集合映射成另外一个集合 map 方法接受一个闭包作为参数， 然后它会遍历整个数组，并对数组中每一个元素执行闭包中定义的操作。然后再返回一个操作后的数组；相当于对数组中的所有元素做了一个映射 示例分析: 实例一123456let arr = [1,2,3,4,5,6]let arr2 = arr.map(&#123; $0 * 3&#125;)//[3, 6, 9, 12, 15, 18]let arr3 = arr.flatMap(&#123; $0 + 2 &#125;)//[3, 4, 5, 6, 7, 8] 2. flatMap 我们对同样的数组使用 flatMap 进行处理， 得到了同样的结果。 那 flatMap 和 map 到底有什么区别呢？ 实例二12345let numbersCompound = [[1,2,3],[4,5,6]];var res = numbersCompound.map &#123; $0.map&#123; $0 + 2 &#125; &#125;// [[3, 4, 5], [6, 7, 8]]var flatRes = numbersCompound.flatMap &#123; $0.map&#123; $0 + 2 &#125; &#125;// [3, 4, 5, 6, 7, 8] flatMap 依然会遍历数组的元素，并对这些元素执行闭包中定义的操作。 但唯一不同的是，它对最终的结果进行了所谓的 “降维” 操作。 本来原始数组是一个二维的， 但经过 flatMap 之后，它变成一维的了。 下面咱们再来看一下 flatMap 的定义, 还是抛去 @noescape, rethrows 这些无关逻辑的关键字： 12func flatMap(transform: (Self.Generator.Element) throws -&gt; T?) -&gt; [T]func flatMap(transform: (Self.Generator.Element) -&gt; S) -&gt; [S.Generator.Element] 和 map 不同， flatMap 有两个重载。 参照我们刚才的示例， 我们调用的其实是第二个重载：flatMap 的闭包接受的是数组的元素，但返回的是一个 SequenceType 类型，也就是另外一个数组 下面让我们来看看flatMap 的另一种重载情况 12func flatMap(transform: (Self.Generator.Element) -&gt; T?) -&gt; [T] 从定义中我们看出， 它的闭包接收的是 Self.Generator.Element 类型， 返回的是一个 T? 。 我们都知道，在 Swift 中类型后面跟随一个 ?， 代表的是 Optional 值。 也就是说这个重载中接收的闭包返回的是一个 Optional 值。 更进一步来说，就是闭包可以返回 nil。 实例三123456let optionalArray: [String?] = [\"AA\", nil, \"BB\", \"CC\"];print（optionalArray）//[Optional(\"AA\"), nil, Optional(\"BB\"), Optional(\"CC\")]var optionalResult = optionalArray.flatMap&#123; $0 &#125;// [\"AA\", \"BB\", \"CC\"] flatMap 的返回结果中， 成功的将原数组中的 nil 值过滤掉了。 再仔细观察，你会发现更多。 使用 flatMap 调用之后， 数组中的所有元素都被解包了 关于$0的解释 $0代表传入的元素本身，而不是下标 $0.0代表传入的元组的第一个值，如果元组被命名过了，则可以直接带名字 $0.age代表传入的模型的age属性 1234567//元组类型let a1 = [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7)]let a2 = a1.map(&#123; $0.0 * 2 &#125;)//模型类型let ageArr = modelArr.map(&#123; $0.age &#125;)let nameArr = modelArr.map(&#123; $0.name &#125;) 3. zip的使用 3-1. zip 是将两个序列的元素，一一对应合并成元组，生成一个新序列。比如 1234let a = [1, 2, 3, 4]let b = [\"a\", \"b\", \"c\", \"d\", \"e\"]let c = zip(a, b).map &#123; $0 &#125;// c = [(1, \"a\"), (2, \"b\"), (3, \"c\"), (4, \"d\")] 生成的序列，如同原始两个序列的相互咬合，因此函数的名字为 zip。zip 的英文有拉链的意思。生成的序列 count 为原始序列的最小值。 3-2. zip 生成的序列通常会进行下一步处理。比如 12345func loadColors(colors: [UIColor]) &#123; zip(self.colorButtons, colors).forEach &#123; (bt, color) in bt.color = color &#125;&#125; 上面这段的语句，为颜色按钮分别赋予颜色值。相当于： 123456func loadColors(colors: [UIColor]) &#123; let minCount = min(colors.count, self.colorButtons.count) for i in 0 ..&lt; minCount &#123; self.colorButtons[i].color = colors[i] &#125;&#125; 再举一段代码。 123456let colors = [UIColor.red, UIColor.blue, UIColor.white]let buttons = zip(0 ..&lt; colors.count, colors).map &#123; (i, color) in let button = ColorButton(color: color) button.tag = i return button&#125; 这段代码，创建了颜色按钮，并用索引设置了对应的 tag。 最后 3-3. 这些简单的函数，配合起来可以达到一些高级的功能。比如: 1234let a = [\"a\", \"b\", \"c\", \"d\"]let b = [\"A\", \"B\", \"C\", \"D\"]let c = zip(a, b).flapMap &#123; [$0, $1] &#125;// c = [\"a\", \"A\", \"b\", \"B\", \"c\", \"C\", \"d\", \"D\"] 这里将两个序列的元素，间隔地插入，合并成一个序列。 3-4. zip和速记+来通过添加两个冲突的值来解析重复的键 123let keyNames2 = [\"a\", \"b\", \"c\", \"a\", \"b\"]let dict = Dictionary(zip(keyNames2, repeatElement(1, count: keyNames2.count)), uniquingKeysWith: +)//[\"b\": 2, \"a\": 2, \"c\": 1] 二、Filter的使用 filter用于选择数组元素中满足某种条件的元素 代码实例123let arr = [1,2,3,4,5,6]let arr2 = arr.filter(&#123; $0 &lt; 5 &#125;)//[1, 2, 3, 4] 三、Reduce的使用 reduce方法把数组元素组合计算为一个值 先看一段传统代码 1234567891011let moneyArray = [2,4,6,7,9,4,10] var sum = 0for money in moneyArray &#123; sum = sum + money&#125;//再看看数字相乘var product = 1for money in moneyArray &#123; product = product * money&#125; Swift中reduct在Array类中的定义为 1reduce(initial: T, combine: (T, Int) throws -&gt; T) 接收两个参数，一个为类型U的初始值，另一个为把类型为U的元素和类型为T的元素组合成一个类型为U的值的函数。最终结果整个数组就变成了一个类型为U的值。 reduce简化代码1234sum = moneyArray.reduce(0,&#123;$0 + $1&#125;)//Swift中操作符可用着函数，可简化成：sum = moneyArray.reduce(0,+) 需要注意的是combine函数的两参数类型不同，$0为计算结果类型，$1为数组元素类型 四、总结 1、需要说明的是数据比较大的时候，高阶函数会比传统实现更快，因为它可以并行执行（如运行在多核上），除非真的需要更高定制版本的map，reduce和filter，否则可以一直使用它们以获得更快的执行速度。 2、我确信当你使用map，filter，reduct的代码质量会更好。但也需要在合适的场景中使用它们，不要指望用它们来解决任何问题。没有放之四海而皆准的真理。 详情参考http://blog.csdn.net/fish_yan_/article/details/51785441详情参考http://www.cocoachina.com/swift/20150619/12173.html","categories":[{"name":"高级用法","slug":"高级用法","permalink":"https://titanjun.top/categories/高级用法/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://titanjun.top/tags/语法/"},{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"},{"name":"filter","slug":"filter","permalink":"https://titanjun.top/tags/filter/"},{"name":"reduce","slug":"reduce","permalink":"https://titanjun.top/tags/reduce/"}]},{"title":"Swift3.0基本语法03","slug":"Swift3.0基本语法03","date":"2016-12-30T14:16:13.000Z","updated":"2018-03-06T09:29:33.000Z","comments":true,"path":"2016/12/30/Swift3.0基本语法03/","link":"","permalink":"https://titanjun.top/2016/12/30/Swift3.0基本语法03/","excerpt":"willSet和didSet 属性观察器控制和响应属性的变化，当属性被设置的时候回调用属性观察器，主要有以下几个特点： 属性改变之前触发willSet方法，属性改变之后触发didSet方法 在给属性添加观察者之前必须要明确申明属性的类型，否则编译器会报错 属性初始化时，willSet和didSet都不会调用，只有在设置属性值时才会调用 当设置的值和原来的值一样时，willSet和didSet也会被调用 willSet有一个newValue参数，didSet有一个oldvalue参数","text":"willSet和didSet 属性观察器控制和响应属性的变化，当属性被设置的时候回调用属性观察器，主要有以下几个特点： 属性改变之前触发willSet方法，属性改变之后触发didSet方法 在给属性添加观察者之前必须要明确申明属性的类型，否则编译器会报错 属性初始化时，willSet和didSet都不会调用，只有在设置属性值时才会调用 当设置的值和原来的值一样时，willSet和didSet也会被调用 willSet有一个newValue参数，didSet有一个oldvalue参数 代码如下 12345678var age:Int = 18&#123; didSet&#123; print(&quot;didSet \\(oldValue)&quot;) &#125; willSet&#123; print(&quot;willSet \\(newValue)&quot;) &#125; &#125; 123456789101112131415161718192021222324252627282930/** * age重新赋值并打印 */age = 10;print(&quot; \\(age)&quot;)/*输出willSet 10didSet 1810*/age = 100print(&quot; \\(age)&quot;)/*输出willSet 100didSet 10100*/age = 200print(&quot; \\(age)&quot;)/*输出willSet 200didSet 100200*/age = 18print(&quot; \\(age)&quot;)/*输出willSet 18didSet 20018*/ 实例应用 cell内部,模型赋值 12345678910111213141516171819class HomeViewCell: UICollectionViewCell &#123; // MARK: 控件属性 @IBOutlet weak var albumImageView: UIImageView! @IBOutlet weak var liveImageView: UIImageView! @IBOutlet weak var nickNameLabel: UILabel! @IBOutlet weak var onlinePeopleLabel: UIButton! // MARK: 定义属性 var anchorModel : AnchorModel?&#123; didSet&#123; albumImageView.setImage(anchorModel!.isEvenIndex ? anchorModel?.pic74 : anchorModel?.pic51, \"home_pic_default\") liveImageView.isHidden = anchorModel?.live == 0 nickNameLabel.text = anchorModel?.name onlinePeopleLabel.setTitle(\"\\(anchorModel?.focus ?? 0)\", for: .normal) &#125; &#125; &#125; Swift中的set和get方法 OC中我们常重写set和get方法来改变UI，Swift中重写set和get方法是下面这种。 先定义一个变量，当调用set方法的时候，系统会有一个newValue，将newVaule赋值给我们定义的变量，然后从get方法里面返回去。 Swift中一般重写比较少 代码示例 123456789101112//定义一个变量var _tittle: String? var tittle: String?&#123; get&#123; return _tittle + &quot;123&quot; &#125; set&#123; _tittle = newValue + &quot;789&quot; &#125; &#125; ## Swift3.0语法其他相关文章","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://titanjun.top/categories/学习笔记/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://titanjun.top/tags/语法/"},{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"}]},{"title":"Swift基本语法02","slug":"Swift3.0基本语法02","date":"2016-12-28T03:44:30.000Z","updated":"2018-03-08T08:27:37.000Z","comments":true,"path":"2016/12/28/Swift3.0基本语法02/","link":"","permalink":"https://titanjun.top/2016/12/28/Swift3.0基本语法02/","excerpt":"上一篇介绍了Swift的常量/变量和循环,详情见: Swift3.0基本语法01","text":"上一篇介绍了Swift的常量/变量和循环,详情见: Swift3.0基本语法01 一、字符串的介绍 字符串在任何的开发中使用都是非常频繁的 OC和Swift中字符串的区别 在OC中字符串类型时NSString,在Swift中字符串类型是String OC中字符串@””,Swift中字符串”” 使用 String 的原因 String 是一个结构体，性能更高 NSString 是一个 OC 对象，性能略差 String 支持直接遍历 Swift 提供了 String 和 NSString 之间的无缝转换1234567// 1&gt; 定义不可变字符串 : 使用let修饰// let str : String = \"hello swift\"let str = \"Hello Swift\"// str = \"hello Objective-C\"// 2&gt; 定义可变字符串 : 使用var修饰var strM = \"Hello World\"strM = \"Hello China\" ##二、 字符串的使用 获取字符串的长度 获取字符集合,再获取集合的count属性 let length = str.characters.count 字符串拼接 两个字符串的拼接 1234let str1 = \"字符串\"let str2 = \"拼接\"// OC拼接方式 NSString stringwithFormat:@\"%@%@\", str1, str2let str3 = str1 + str2 字符串和其他数据类型的拼接 12345let name = \"tqj\"let age = 19let height = 1.87let infoStr = \"my nams is \\(name), age is \\(age), height is \\(height)\" 字符串的格式化::比如时间:01:02 123let min = 3let second = 4let timeStr = String(format: \"%02d:%02d\", min, second) 字符串的判断 判断字符串是否为空 1234567let str = \"1\"//输出falseprint(str.isEmpty)let str = \"\"//输出为trueprint(str.isEmpty) 其他判断和操作(Swift3.0特性) 123456789101112131415//判断是否包含某字符let str = &quot;Hello, playground&quot;let is1 = str.contains(&quot;ell&quot;)//输出trueprint(is1)//指定字符串的替换let str2 = str.replacingOccurrences(of: &quot;Hello&quot;, with: &quot;HELLO&quot;)print(str2) //输出HELLO, playground//转为大写let s1 = str.localizedUppercase//转为小写let s2 = str.localizedLowercase 字符串的截取 Swift中提供了特殊的截取方式 该方式非常麻烦 Index创建较为麻烦 简单的方式是将String转成NSString来使用 在标识符后加:as NSString即可 12345678let urlString = \"www.520it.com\"// 4.1.方式一:// 将String类型转成NSString类型,再进行截取: as NSStringlet header1 = (urlString as NSString).substring(to: 3)let range1 = NSMakeRange(4, 5)let middle1 = (urlString as NSString).substring(with: range1)let footer1 = (urlString as NSString).substring(from: 10) swift截取方式 1234567891011// 4.2.方式二:let headerIndex = urlString.index(urlString.startIndex, offsetBy: 3)let header2 = urlString.substring(to: headerIndex)let startIndex = urlString.index(urlString.startIndex, offsetBy: 4)let endIndex = urlString.index(urlString.startIndex, offsetBy: 9)let range = Range(startIndex..&lt;endIndex)let middle2 = urlString.substring(with: range)let footerIndex = urlString.index(urlString.endIndex, offsetBy: -3)let footer2 = urlString.substring(from: footerIndex) 三、数组的使用数组的介绍 数组（Array）是一串有序的由相同类型元素构成的集合 数组中的集合元素是有序的，可以重复出现 Swift中的数组 swift数组类型是Array，是一个泛型集合数组的初始化 数组分成:可变数组和不可变数组 使用let修饰的数组是不可变数组 使用var修饰的数组是可变数组1234// 1&gt; 定义不可变数组let array : [Any] = [\"why\", 18, 1.88]// 2&gt; 定义可变数组: 使用var修饰var arrayM = [Any]() 对数组的基本操作123456789// 增删改查// 2.1.添加元素arrayM.append(&quot;why&quot;)// 2.2.删除元素arrayM.remove(at: 0)// 2.3.修改元素arrayM[0] = &quot;yz&quot;// 2.4.获取元素let item = arrayM[1] 数组的遍历1234567891011121314151617181920// 3.1.获取数组的长度let count = array.count// 3.2.对数组进行遍历(可以获取到下标值)for i in 0..&lt; count &#123; print(array[i])&#125;// 3.3.对数组进行遍历(设置遍历区间)for item in array &#123; print(item)&#125;// 3.3.对数组进行遍历(不需要获取下标值)for item in array[0..&lt;2] &#123; print(item)&#125;// 3.5.对数组进行遍历(既获取下标值,又获取元素)for (index, item) in array.enumerated() &#123; print(index) print(item)&#125; 数组的合并123456789101112// 如果两个数组中存放的是相同的元素,那么在swift中可以对两个数组进行相加,直接合并let array1 = [\"why\", \"yz\"]let array2 = [\"lmj\", \"lnj\"]let array3 = [12, 20, 30]let resultArray = array1 + array2// let result = array1 + array3 错误写法// 不建议一个数组中存放多种类型的数据var array3 = [2, 3, \"why\"]var array4 = [\"yz\", 23]array3 + array4 四、字典字典的介绍 字典允许按照某个键来访问元素 字典是由两部分集合构成的，一个是键（key）集合，一个是值（value）集合 键集合是不能有重复元素的，而值集合是可以重复的，键和值是成对出现的 Swift中的字典 Swift字典类型是Dictionary，也是一个泛型集合字典的初始化 Swift中的可变和不可变字典 使用let修饰的数组是不可变字典 使用var修饰的数组是可变字典1234// 定义一个可变字典var dict1 : [String : Any] = [String : Any]()// 定义一个不可变字典let dict2 : [String : Any] = [\"name\" : \"why\", \"age\" : 18] 字典的基本使用1234567891011121314// 2.1.添加元素dictM[&quot;name&quot;] = &quot;why&quot;dictM[&quot;age&quot;] = 18dictM[&quot;height&quot;] = 1.88// 2.2.删除元素dictM.removeValue(forKey: &quot;height&quot;)dictM// 2.3.修改元素dictM[&quot;name&quot;] = &quot;lmj&quot;dictM.updateValue(&quot;lnj&quot;, forKey: &quot;name&quot;)dictM// 2.4.查找元素dictM[&quot;age&quot;] 字典的遍历1234567891011121314// 3.1.遍历字典中所有的keyfor key in dict.keys &#123; print(key)&#125;// 3.2.遍历字典中所有的valuefor value in dict.values &#123; print(value)&#125;// 3.3.遍历字典中所有的key/valuefor (key, value) in dict &#123; print(key, value)&#125; 字典的合并1234567var dict1 : [String : Any] = [\"name\" : \"why\", \"age\" : 18]let dict2 : [String : Any] = [\"height\" : 1.88, \"phoneNum\" : \"+86 110\"]//let resultDict = dict1 + dict2字典不可以相加合并，只能遍历for (key, value) in dict2 &#123; dict1[key] = value&#125; 五、元组的使用元组的介绍 元组是Swift中特有的,OC中并没有相关类型 它是什么呢? 它是一种数据结构，在数学中应用广泛 类似于数组或者字典 可以用于定义一组数据 组成元组类型的数据可以称为“元素”元组的定义 元组的常见写法 1234567891011121314151617181920// 3.使用元组保存信息(取出数据时,更加方便)// 3.1.写法一:let infoTuple0 = (&quot;why&quot;, 18, 1.88)let tupleName = infoTuple0.0let tupleAge = infoTuple0.1infoTuple0.0infoTuple0.1infoTuple0.2// 3.2.写法二:let infoTuple1 = (name : &quot;why&quot;,age : 18, height : 1.88)infoTuple1.ageinfoTuple1.nameinfoTuple1.height// 3.3.写法三:let (name, age, height) = (&quot;why&quot;, 18, 1.88)nameageheight 六、可选类型可选类型的介绍 注意: 可选类型时swift中较理解的一个知识点 暂时先了解,多利用Xcode的提示来使用 随着学习的深入,慢慢理解其中的原理和好处 概念: 在OC开发中,如果一个变量暂停不使用,可以赋值为0(基本属性类型)或者赋值为空(对象类型) 在swift开发中,nil也是一个特殊的类型.因为和真实的类型不匹配是不能赋值的(swift是强类型语言) 但是开发中赋值nil,在所难免.因此推出了可选类型 可选类型的取值: 空值 有值定义可选类型 定义一个可选类型有两种写法 最基本的写法 语法糖(常用)12345678// 错误写法// let string : String = nil// 正确写法:// 注意:name的类型是一个可选类型,但是该可选类型中可以存放字符串.// 写法一:定义可选类型let name : Optional&lt;String&gt; = nil// 写法二:定义可选类型,语法糖(常用)let name : String? = nil 可选类型的使用12345678910111213141516171819202122232425262728// 演练一:给可选类型赋值// 定义可选类型var string : Optional&lt;String&gt; = nil// 给可选类型赋值// 错误写法:因此该可选类型中只能存放字符串string = 123// 正确写法:string = &quot;Hello world&quot;// 打印结果print(string)// 结果:Optional(&quot;Hello world&quot;)\\n// 因为打印出来的是可选类型,所有会带Optional// 演练二:取出可选类型的值// 取出可选类型的真实值(解包)print(string!)// 结果:Hello world\\n// 注意:如果可选类型为nil,强制取出其中的值(解包),会出错string = nilprint(string!) // 报错// 正确写法:if string != nil &#123; print(string!)&#125;// 简单写法:为了让在if语句中可以方便使用string// 可选绑定if let str = string &#123; print(str)&#125; 真实应用场景 目的:让代码更加严谨1234567891011// 1.将字符串类型转成Int类型let str = &quot;123&quot;let result : Int? = Int(str) // nil/Int// 2.根据文件名称,读取路径let path : String? = Bundle.main.path(forResource: &quot;123.plist&quot;, ofType: nil)// 3.根据string,创建URLlet url = URL(string: &quot;http://www.520it.com/小码哥&quot;)// 4.从字典中取内容let dict : [String : Any] = [&quot;name&quot; : &quot;why&quot;, &quot;age&quot; : 18]dict[&quot;name&quot;]dict[&quot;height&quot;] 七、类型转化类型转化 常见的类型转化符号 as : 将实例转成某一种类型例子1234567891011// 1.定义数组let array : [AnyObject] = [12, \"why\", 1.88]// 2.取出第二个元素let objc = array[1]// 3.将objc转成真正的类型来使用// 3.1.as? 将AnyObject转成可选类型,通过判断可选类型是否有值,来决定是否转化成功了let age = objc as? Intprint(age) // 结果:Optional(12)// 3.2.as! 将AnyObject转成具体的类型,但是注意:如果不是该类型,那么程序会崩溃let age1 = objc as! Intprint(age1) // 结果:12 八、try throw 代码实践 throw catch 是 Xcode 7.0 对错误处理的一个非常大的变化 代码示例1234567891011121314151617181920212223// 2. 反序列化// 1.获取json文件路径 let jsonPath = NSBundle.mainBundle().pathForResource(&quot;MainVCSettings.json&quot;, ofType: nil) // 2.加载json数据 let jsonData = NSData(contentsOfFile: jsonPath!) // 3.序列化json do&#123;//解析成功 // throw是Xcode7最明显的一个变化, Xcode7之前都是通过传入error指针捕获异常, Xocode7开始通过try/catch捕获异常 let dictArray = try NSJSONSerialization.JSONObjectWithData(jsonData!, options: NSJSONReadingOptions.MutableContainers) // 遍历字典时候需要明确指明数组中的数据类型 for dict in dictArray as! [[String:String]] &#123; // 由于addChildVC方法参数不能为nil, 但是字典中取出来的值可能是nil, 所以需要加上! addChildViewController(dict[&quot;vcName&quot;]!, title: dict[&quot;title&quot;]!, imageName: dict[&quot;imageName&quot;]!) &#125; &#125;catch&#123;//解析失败 print(error) addChildViewController(&quot;HomeTableViewController&quot;, title: &quot;首页&quot;, imageName: &quot;tabbar_home&quot;) addChildViewController(&quot;MessageTableViewController&quot;, title: &quot;消息&quot;, imageName: &quot;tabbar_message_center&quot;) addChildViewController(&quot;DiscoverTableViewController&quot;, title: &quot;发现&quot;, imageName: &quot;tabbar_discover&quot;) addChildViewController(&quot;ProfileTableViewController&quot;, title: &quot;我&quot;, imageName: &quot;tabbar_profile&quot;) &#125; 如果能确保代码执行正确，可以强行 try!1let array = try! NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions.MutableContainers) 不过需要注意的是，一旦解析错误，程序会直接崩溃！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://titanjun.top/categories/学习笔记/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://titanjun.top/tags/语法/"},{"name":"Swift3.0","slug":"Swift3-0","permalink":"https://titanjun.top/tags/Swift3-0/"}]},{"title":"Swift3.0之基本语法01","slug":"Swift3.0之基本语法01","date":"2016-12-25T07:23:03.000Z","updated":"2018-03-08T08:27:51.000Z","comments":true,"path":"2016/12/25/Swift3.0之基本语法01/","link":"","permalink":"https://titanjun.top/2016/12/25/Swift3.0之基本语法01/","excerpt":"常量&amp;变量 在Swift中规定：在定义一个标识符时必须明确说明该标识符是一个常量还是变量 使用let来定义常量，定义之后不可以修改 使用var来定义变量，定义之后可以修改","text":"常量&amp;变量 在Swift中规定：在定义一个标识符时必须明确说明该标识符是一个常量还是变量 使用let来定义常量，定义之后不可以修改 使用var来定义变量，定义之后可以修改 变量的基本使用1234567import UIKitlet a : Int = 10// 错误写法,当一个标识符定义为常量时是不可以修改的// a = 20var b : Int = 20//因为b定义为变量,因此是可以修改的b = 30 常量和变量的使用注意:123456789101112131415161718192021222324252627282930import UIKit/* 常量使用注意： 1&gt; 优先使用常量 2&gt; 常量的本质 */// 1.注意一：在开发中let/var在选择时优先使用常量，防止不小被修改掉（let）// 如果一个标识符不需要修改，但是声明称了变量，那么编译器会报警告// 2.常量的本质：// 含义：指向的内存地址不可以修改，但是可以通过内存地址，找到对应的对象，之后修改对象内部的属性/* OC中创建对象： UIView *view = [[UIView alloc] init]; view = [[UIView alloc] init]; Swift中创建对象： var view : UIView = UIView() *//* 变量的做法 var view : UIView = UIView() view = UIView() */// 创建常量Viewlet view = UIView()// view = UIView() 错误做法view.alpha = 0.5// Swift中创建结构体：结构体类型()view.frame = CGRect(x: 0, y: 0, width: 100, height: 100)// Swift中调用方法，统一使用点语法view.backgroundColor = UIColor.red 创建对象补充 创建UIView对象，并且在UIView中添加UIButton 123456789101112131415161718192021import UIKit// 1.创建UIView对象// OC : [[UIView alloc] initWithFrame:CGRect]let viewRect = CGRect(x: 0, y: 0, width: 100, height: 100)let view : UIView = UIView(frame: viewRect)// 2.设置UIView的属性view.backgroundColor = UIColor.orange// 3.创建UIButtonlet btn : UIButton = UIButton(type: .custom)// 4.设置UIButton的属性btn.frame = CGRect(x: 0, y: 0, width: 50, height: 50)btn.backgroundColor = UIColor.purple/* Swift中枚举类型： 1&gt; 如果可以根据上下文推导出类型可以直接.具体的类型 2&gt; 如果根据上下文推导不出具体的类型，则需要：类型.具体的类型 */btn.setTitle(\"按钮\", for: .normal)btn.setTitleColor(UIColor.white, for: .normal)// 5.将btn添加到UIView中view.addSubview(btn) Swift中数据类型Swift类型的介绍 Swift中的数据类型也有:整型/浮点型/对象类型/结构体类型等等 先了解整型和浮点型 整型 有符号 Int8 : 有符号8位整型 Int16 : 有符号16位整型 Int32 : 有符号32位整型 Int64 : 有符号64位整型 Int ： 和平台相关(默认,相当于OC的NSInteger) 无符号 UInt8 : 无符号8位整型 UInt16 : 无符号16位整型 UInt32 : 无符号32位整型 UInt64 : 无符号64位整型 UInt : 和平台相关(常用,相当于OC的NSUInteger)(默认) 浮点型 Float : 32位浮点型 Double : 64浮点型(默认) 1234// 定义一个Int类型的变量m,并且赋值为10var m : Int = 10// 定义一个Double类型的常量n,并且赋值为3.14let n : Double = 3.14 Swift中的类型推导 Swift是强类型的语言 Swift中任何一个标识符都有明确的类型 注意: 如果定义一个标识符时有直接进行赋值,那么标识符后面的类型可以省略. 因为Swift有类型推导,会自动根据后面的赋值来决定前面的标识符的数据类型 可以通过option+鼠标左键来查看变量的数据类型 1234567891011import UIKitlet m = 20let n = 30.5// 错误写法 :// Swift中没有隐式转化，不会自动将一个Int类型转成Double类型，因此不同类型之间不能进行运算// let result = m + n// 正确做法// 1&gt; 将Int类型转成Double ： Double(标识符)// 2&gt; 将Double类型转成Int ： Int(标识符)let result1 = Double(m) + nlet result2 = m + Int(n) 逻辑分支一. 分支的介绍 分支即if/switch/三目运算符等判断语句 通过分支语句可以控制程序的执行流程 二. if分支语句 和OC中if语句有一定的区别 判断句可以不加() 在Swift的判断句中必须有明确的真假 不再有非0即真 必须有明确的Bool值 Bool有两个取值:false/true 1234567891011121314151617181920212223// 演练一:let a = 10// 错误写法://if a &#123;// print(&quot;a&quot;)//&#125;// 正确写法if a &gt; 9 &#123; print(a)&#125;// 演练二:let score = 87if score &lt; 60 &#123; print(&quot;不及格&quot;)&#125; else if score &lt;= 70 &#123; print(&quot;及格&quot;)&#125; else if score &lt;= 80 &#123; print(&quot;良好&quot;)&#125; else if score &lt;= 90 &#123; print(&quot;优秀&quot;)&#125; else &#123; print(&quot;完美&quot;)&#125; 三.guard的使用 guard是Swift2.0新增的语法 它与if语句非常类似，它设计的目的是提高程序的可读性 guard语句必须带有else语句，它的语法如下： 当条件表达式为true时候跳过else语句中的内容，执行语句组内容 条件表达式为false时候执行else语句中的内容，跳转语句一般是return、break、continue和throw 123456789101112131415guard 条件表达式 else &#123; // 条换语句 break&#125;语句组//---例子--- var age = 18func online(age : Int) -&gt; Void &#123; guard age &gt;= 18 else &#123; print(&quot;回家去&quot;) return &#125; print(&quot;可以上网&quot;)&#125;online(age) 四.switch分支switch的介绍 Switch作为选择结构中必不可少的语句也被加入到了Swift中 只要有过编程经验的人对Switch语句都不会感到陌生 但苹果对Switch进行了大大的增强，使其拥有其他语言中没有的特性switch的简单使用 基本用法和OC用法一致 不同之处: switch后可以不跟() case后可以不跟break(默认会有break) 例子: 12345678910&gt; let sex = 0&gt; switch sex &#123;&gt; case 0 :&gt; print(&quot;男&quot;)&gt; case 1 :&gt; print(&quot;女&quot;)&gt; default :&gt; print(&quot;其他&quot;)&gt; &#125;&gt; 简单使用补充: 一个case判断中,可以判断多个值 多个值以,隔开 12345678&gt; let sex = 0&gt; switch sex &#123;&gt; case 0, 1:&gt; print(\"正常人\")&gt; default:&gt; print(\"其他\")&gt; &#125;&gt; 简单使用补充: 如果希望出现之前的case穿透,则可以使用关键字fallthrough 123456789let sex = 0switch sex &#123;case 0: fallthroughcase 1: print(&quot;正常人&quot;)default: print(&quot;其他&quot;)&#125; switch支持区间判断 什么是区间? 通常我们指的是数字区间:0~10,100~200swift中的区间常见有两种 半开半闭区间:0..&lt;10 表示:0~9,不包括10 闭区间:0…10 表示:0~10 12345678910111213let score = 88switch score &#123;case 0..&lt;60: print(&quot;不及格&quot;)case 60..&lt;80: print(&quot;几个&quot;)case 80..&lt;90: print(&quot;良好&quot;)case 90..&lt;100: print(&quot;优秀&quot;)default: print(&quot;满分&quot;)&#125; 循环使用循环的介绍 在开发中经常会需要循环 常见的循环有:for/while/do while. 这里我们只介绍for/while,因为for/while最常见for循环的写法 区间for循环12345678910for i in 0..&lt;10 &#123; print(i)&#125;for i in 0...10 &#123; print(i)&#125;//特殊写法:如果在for循环中不需要用到下标ifor _ in 0..&lt;10 &#123;print(&quot;hello&quot;)&#125; Swift中遍历方法for in 和 forEach的区别 while和do while循环 while循环 while的判断句必须有正确的真假,没有非0即真 while后面的()可以省略1234567891011var a = 0while a &lt; 10 &#123; a++&#125;//--do while循环:使用repeat关键字来代替了do-- let b = 0repeat &#123; print(b) b++&#125; while b &lt; 20","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://titanjun.top/categories/学习笔记/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://titanjun.top/tags/语法/"},{"name":"Swift","slug":"Swift","permalink":"https://titanjun.top/tags/Swift/"}]},{"title":"iOS之NSDate的Category","slug":"iOS之NSDate的Category","date":"2016-11-25T13:56:30.000Z","updated":"2018-03-06T14:09:21.000Z","comments":true,"path":"2016/11/25/iOS之NSDate的Category/","link":"","permalink":"https://titanjun.top/2016/11/25/iOS之NSDate的Category/","excerpt":"判断日期是是否是今年？今天？","text":"判断日期是是否是今年？今天？ NSDate+Extension.h12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;@interface NSDate (Extension)//比较from和self的时间差值- (NSDateComponents *)deltaFrom:(NSDate *)from; //是否为今年- (BOOL)isThisYear;//是否为今天- (BOOL)isToday;//是否为昨天- (BOOL)isYesterday;//是否为明天- (BOOL)isTomorrow;@end NSDate+Extension.m12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#import \"NSDate+Extension.h\"@implementation NSDate (Extension)- (NSDateComponents *)deltaFrom:(NSDate *)from&#123; // 日历 NSCalendar *calendar = [NSCalendar currentCalendar]; // 比较时间 NSCalendarUnit unit = NSCalendarUnitDay | NSCalendarUnitMonth | NSCalendarUnitYear | NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond; return [calendar components:unit fromDate:from toDate:self options:0];&#125;- (BOOL)isThisYear&#123; // 日历 NSCalendar *calendar = [NSCalendar currentCalendar]; NSInteger nowYear = [calendar component:NSCalendarUnitYear fromDate:[NSDate date]]; NSInteger selfYear = [calendar component:NSCalendarUnitYear fromDate:self]; return nowYear == selfYear;&#125;- (BOOL)isToday&#123; NSDateFormatter *fmt = [[NSDateFormatter alloc] init]; fmt.dateFormat = @\"yyyy-MM-dd\"; NSString *nowString = [fmt stringFromDate:[NSDate date]]; NSString *selfString = [fmt stringFromDate:self]; return [nowString isEqualToString:selfString];&#125;- (BOOL)isYesterday&#123; // 2014-12-31 23:59:59 -&gt; 2014-12-31 // 2015-01-01 00:00:01 -&gt; 2015-01-01 // 日期格式化类 NSDateFormatter *fmt = [[NSDateFormatter alloc] init]; fmt.dateFormat = @\"yyyy-MM-dd\"; NSDate *nowDate = [fmt dateFromString:[fmt stringFromDate:[NSDate date]]]; NSDate *selfDate = [fmt dateFromString:[fmt stringFromDate:self]]; NSCalendar *calendar = [NSCalendar currentCalendar]; NSDateComponents *cmps = [calendar components:NSCalendarUnitDay | NSCalendarUnitMonth | NSCalendarUnitYear fromDate:selfDate toDate:nowDate options:0]; return cmps.year == 0 &amp;&amp; cmps.month == 0 &amp;&amp; cmps.day == 1;&#125;- (BOOL)isTomorrow&#123; NSDateFormatter *fmt = [[NSDateFormatter alloc] init]; fmt.dateFormat = @\"yyyy-MM-dd\"; NSDate *nowDate = [fmt dateFromString:[fmt stringFromDate:[NSDate date]]]; NSDate *selfDate = [fmt dateFromString:[fmt stringFromDate:self]]; NSCalendar *calendar = [NSCalendar currentCalendar]; NSDateComponents *cmps = [calendar components:NSCalendarUnitDay | NSCalendarUnitMonth | NSCalendarUnitYear fromDate:nowDate toDate:selfDate options:0]; return cmps.year == 0 &amp;&amp; cmps.month == 0 &amp;&amp; cmps.day == 1;&#125;@end 简单使用TopicModel#import “TopicModel.m”文件中12345678910111213141516171819202122232425262728293031323334- (NSString *)create_time&#123; // 日期格式化类 NSDateFormatter *fmt = [[NSDateFormatter alloc] init]; // 设置日期格式(y:年,M:月,d:日,H:时,m:分,s:秒) fmt.dateFormat = @\"yyyy-MM-dd HH:mm:ss\"; // 帖子的创建时间 NSDate *create = [fmt dateFromString:_create_time]; if (create.isThisYear) &#123; // 今年 if (create.isToday) &#123; // 今天 NSDateComponents *cmps = [[NSDate date] deltaFrom:create]; if (cmps.hour &gt;= 1) &#123; // 时间差距 &gt;= 1小时 return [NSString stringWithFormat:@\"%zd小时前\", cmps.hour]; &#125; else if (cmps.minute &gt;= 1) &#123; // 1小时 &gt; 时间差距 &gt;= 1分钟 return [NSString stringWithFormat:@\"%zd分钟前\", cmps.minute]; &#125; else &#123; // 1分钟 &gt; 时间差距 return @\"刚刚\"; &#125; &#125; else if (create.isYesterday) &#123; // 昨天 fmt.dateFormat = @\"昨天 HH:mm:ss\"; return [fmt stringFromDate:create]; &#125; else if(creat.isTomorrow)&#123; fmt.dateFormat = @\"明天 HH:mm:ss\"; return [fmt stringFromDate:create]; &#125;else &#123; // 其他 fmt.dateFormat = @\"MM-dd HH:mm:ss\"; return [fmt stringFromDate:create]; &#125; &#125; else &#123; // 非今年 return _create_time; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://titanjun.top/categories/iOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://titanjun.top/tags/Objective-C/"},{"name":"Category","slug":"Category","permalink":"https://titanjun.top/tags/Category/"}]},{"title":"iOS之UIMenuController的简单使用","slug":"iOS之UIMenuController的简单使用","date":"2016-11-22T03:52:30.000Z","updated":"2018-03-08T08:28:10.000Z","comments":true,"path":"2016/11/22/iOS之UIMenuController的简单使用/","link":"","permalink":"https://titanjun.top/2016/11/22/iOS之UIMenuController的简单使用/","excerpt":"UIMenuController须知 默认情况下, 有以下控件已经支持UIMenuController UITextField UITextView UIWebView","text":"UIMenuController须知 默认情况下, 有以下控件已经支持UIMenuController UITextField UITextView UIWebView 让其他控件也支持UIMenuController(比如UILabel) 自定义UILabel 12345678910111213141516171819- (void)setUp &#123; // 1.设置label可以交互 self.userInteractionEnabled = YES; // 2.添加点击手势 [self addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(lableClick)]];&#125;- (void)lableClick &#123; // 3.设置label为第一响应者,只有成为响应者才能够将MenuController显示在其上面 [self becomeFirstResponder]; // 4.初始化UIMenuController UIMenuController *menuController = [UIMenuController sharedMenuController]; // 5.设置UIMenuController显示的位置 // targetRect : 将要显示所在label的frame; // view : targetRect所在的坐标系参照物(父view或self) [menuController setTargetRect:self.frame inView:self.superview]; // [menuController setTargetRect:self.bounds inView:self];作用同上 // 6.显示UIMenuController [menuController setMenuVisible:YES animated:YES];&#125; 在UILable内重写2个方法 1234567891011121314151617/** * 让label有资格成为第一响应者 */- (BOOL)canBecomeFirstResponder&#123; return YES;&#125;/** * label能执行哪些操作(比如copy, paste等等) * @return YES:支持这种操作 */- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; if (action == @selector(cut:) || action == @selector(copy:) || action == @selector(paste:)) return YES; return NO;&#125; 3.实现各种操作方法12345678910111213141516171819202122- (void)cut:(UIMenuController *)menu&#123; // 将自己的文字复制到粘贴板 UIPasteboard *board = [UIPasteboard generalPasteboard]; // 清空文字 self.text = nil;&#125;- (void)copy:(UIMenuController *)menu&#123; // 将自己的文字复制到粘贴板 UIPasteboard *board = [UIPasteboard generalPasteboard]; board.string = self.text;&#125;- (void)paste:(UIMenuController *)menu&#123; // 将粘贴板的文字 复制 到自己身上 UIPasteboard *board = [UIPasteboard generalPasteboard]; self.text = board.string;&#125; 自定义UIMenuController内部的Item(在cell中) 由于手动添加的MenuItem默认触发控制器中的方法,所以将MenuController的显示/隐藏,添加MenuItem写到控制器 添加item 1234567891011121314151617181920212223- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; // 点击cell弹出UIMenuController // 1.如果menuController已经在显示,就隐藏他 // 注意,如果有一个cell正在显示menuController,这时再点击另外一个cell,上一个cell的menuController会消失,当前点击cell会显示,这是因为上一个cell不再是第一响应者了,menuController会自动释放 UIMenuController *menuController = [UIMenuController sharedMenuController]; if (menuController.isMenuVisible) &#123; [menuController setMenuVisible:NO animated:YES]; &#125;else &#123; // 2.显示MenuController // 先设置cell为第一响应者,同时不要忘记在cell中重写canBecomeFirstResponder和canPerformAction:withSender: JCMTopicCommentCell *cell = [tableView cellForRowAtIndexPath:indexPath]; [cell becomeFirstResponder]; // 添加menuItem UIMenuItem *item01 = [[UIMenuItem alloc]initWithTitle:@\"赞\" action:@selector(zanClick:)]; UIMenuItem *item02 = [[UIMenuItem alloc]initWithTitle:@\"回复\" action:@selector(responseClick:)]; UIMenuItem *item03 = [[UIMenuItem alloc]initWithTitle:@\"举报\" action:@selector(reportClick:)]; menuController.menuItems = @[item01,item02,item03]; // 设置menuControoler显示位置 CGRect showRect = CGRectMake(cell.x, cell.y + cell.height/2, cell.width, cell.height); [menuController setTargetRect:showRect inView:cell.superview]; // 显示menuController [menuController setMenuVisible:YES animated:YES]; &#125;&#125; cell中实现两个方法 12345678910111213141516/** * 让label有资格成为第一响应者 */- (BOOL)canBecomeFirstResponder&#123; return YES;&#125;/** * label能执行哪些操作(比如copy, paste等等) * @return YES:支持这种操作 */- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; if (action == @selector(cut:) || action == @selector(copy:) || action == @selector(paste:)) return YES; return NO;&#125; 处理方法的实现 1234567891011121314#pragma mark - MenuControllerClick// MenuController手动添加的item的方法实现必须放在controller中- (void)zanClick:(UIMenuController *)menu &#123; NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow]; NSLog(@\"%s %@\", __func__, [self commentInIndexPath:indexPath].content);&#125;- (void)responseClick:(UIMenuController *)menu &#123; NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow]; NSLog(@\"%s %@\", __func__, [self commentInIndexPath:indexPath].content);&#125;- (void)reportClick:(UIMenuController *)menu &#123; NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow]; NSLog(@\"%s %@\", __func__, [self commentInIndexPath:indexPath].content);&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://titanjun.top/categories/iOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://titanjun.top/tags/Objective-C/"},{"name":"UIMenuController","slug":"UIMenuController","permalink":"https://titanjun.top/tags/UIMenuController/"}]},{"title":"iOS之UITableView设置全屏分隔线","slug":"iOS之UITableView设置全屏分隔线","date":"2016-11-20T05:41:14.000Z","updated":"2018-03-08T08:28:56.000Z","comments":true,"path":"2016/11/20/iOS之UITableView设置全屏分隔线/","link":"","permalink":"https://titanjun.top/2016/11/20/iOS之UITableView设置全屏分隔线/","excerpt":"UICollectionView基础首先系统的分隔线有以下几种12345tableView.separatorStyle = UITableViewCellSeparatorStyleNone;-UITableViewCellSeparatorStyleNone //隐藏系统分隔线-UITableViewCellSeparatorStyleSingleLine //单分隔线-UITableViewCellSeparatorStyleSingleLineEtched //被侵蚀的单分隔线","text":"UICollectionView基础首先系统的分隔线有以下几种12345tableView.separatorStyle = UITableViewCellSeparatorStyleNone;-UITableViewCellSeparatorStyleNone //隐藏系统分隔线-UITableViewCellSeparatorStyleSingleLine //单分隔线-UITableViewCellSeparatorStyleSingleLineEtched //被侵蚀的单分隔线 自定义分隔线（首先要隐藏系统的分隔线） 通过xib或者代码在cell底部添加一条高度为1的UIView或者UILable分隔线。 通过drawRect：方法自绘一条分割线 12345678910// 自绘分割线- (void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); CGContextFillRect(context, rect); CGContextSetStrokeColorWithColor(context, [UIColor colorWithRed:0xE2/255.0f green:0xE2/255.0f blue:0xE2/255.0f alpha:1].CGColor); CGContextStrokeRect(context, CGRectMake(0, rect.size.height - 1, rect.size.width, 1));&#125; 3.重写cell的setFrame：方法12345678910- (void)setFrame:(CGRect)frame&#123; frame.size.height -= 1;//设置分隔线 //设置cell的左右间距 frame.origin.x = 5;//左间距为5 frame.size.width = [UIScreen mainScreen].bounds.size.width - 2 * frame.origin.x; // 给cellframe赋值 [super setFrame:frame];&#125; 4.利用系统属性设置(separatorInset, layoutMargins)设置 对tableView的separatorInset, layoutMargins属性的设置 1234567891011-(void)viewDidLoad &#123; [super viewDidLoad]; //1.调整(iOS7以上)表格分隔线边距 if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) &#123; self.tableView.separatorInset = UIEdgeInsetsZero; &#125; //2.调整(iOS8以上)view边距(或者在cell中设置preservesSuperviewLayoutMargins,二者等效) if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) &#123; self.tableView.layoutMargins = UIEdgeInsetsZero; &#125;&#125; 对cell的LayoutMargins属性的设置 12345678910111213141516171819//对cell的设置可以写在cellForRowAtIndexPath里,也可以写在willDisplayCell方法里-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *ID = @&quot;cell&quot;; FSDiscoverSpecialCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell == nil) &#123; cell = [[FSDiscoverSpecialCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID]; &#125; //2.调整(iOS8以上)tableView边距(与上面第2步等效,二选一即可) if ([cell respondsToSelector:@selector(setPreservesSuperviewLayoutMargins:)]) &#123; cell.preservesSuperviewLayoutMargins = NO; &#125; //3.调整(iOS8以上)view边距 if ([cell respondsToSelector:@selector(setLayoutMargins:)]) &#123; [cell setLayoutMargins:UIEdgeInsetsZero]; &#125; return cell;&#125; 三种方法优缺点比较： 方法1一般使用系统的cell，或者对cell没有特殊要求的情况下使用系统的分隔线； 方法2是比较好用的,但是有些情况下系统自带的cell就足够用了,仅仅为了分隔线却还必须再自定义cell,添加一个view,设置背景颜色和frame,又显得麻烦; 方法3比较取巧,但是也需要自定义cell,在某些情况下不允许改变tableView的背景色,使用场景有限; 方法4不需要自定义cell,对系统(iOS7,iOS8以上)做个简单判断即可.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://titanjun.top/categories/iOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://titanjun.top/tags/Objective-C/"},{"name":"UITableView","slug":"UITableView","permalink":"https://titanjun.top/tags/UITableView/"}]},{"title":"iOS之UICollectionView自定义布局","slug":"iOS之UICollectionView自定义布局","date":"2016-11-15T02:22:30.000Z","updated":"2018-03-08T08:31:58.000Z","comments":true,"path":"2016/11/15/iOS之UICollectionView自定义布局/","link":"","permalink":"https://titanjun.top/2016/11/15/iOS之UICollectionView自定义布局/","excerpt":"UICollectionView基础 UICollectionViewFlowLayout：视图布局对象（流水布局：一行排满，自动排到下行），继承自UICollectionViewLayout。UICollectionViewLayout内有一个collectionView属性，所有的视图布局对象都继承自UICollectionViewLayout。 若我们要自定义布局对象，我们一般继承UICollectionViewFlowLayout，然后重写里面的一些方法就可以了。 需要实现三个协议: UICollectionViewDataSource（数据源）、UICollectionViewDelegateFlowLayout（视图布局），自定义布局需要实现UICollectionViewDataSource、UICollectionViewDelegate两个协议即可。","text":"UICollectionView基础 UICollectionViewFlowLayout：视图布局对象（流水布局：一行排满，自动排到下行），继承自UICollectionViewLayout。UICollectionViewLayout内有一个collectionView属性，所有的视图布局对象都继承自UICollectionViewLayout。 若我们要自定义布局对象，我们一般继承UICollectionViewFlowLayout，然后重写里面的一些方法就可以了。 需要实现三个协议: UICollectionViewDataSource（数据源）、UICollectionViewDelegateFlowLayout（视图布局），自定义布局需要实现UICollectionViewDataSource、UICollectionViewDelegate两个协议即可。 一、自定义线性布局 首先要继承与流水布局UICollectionViewFlowLayout 12345#import &lt;UIKit/UIKit.h&gt;@interface LineCollectionViewLayout : UICollectionViewFlowLayout@end 重写相应的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#import \"LineCollectionViewLayout.h\"@implementation LineCollectionViewLayout- (instancetype)init&#123; if (self = [super init]) &#123; &#125; return self;&#125;/** * 用来做布局的初始化操作（不建议在init方法中进行布局的初始化操作） - 注意：一定要调用[super prepareLayout] */- (void)prepareLayout&#123; [super prepareLayout]; // 水平滚动 self.scrollDirection = UICollectionViewScrollDirectionHorizontal; // 设置内边距 CGFloat inset = (self.collectionView.frame.size.width - self.itemSize.width) * 0.5; self.sectionInset = UIEdgeInsetsMake(0, inset, 0, inset);&#125;/** * 这个方法的返回值是一个数组（数组里面存放着rect范围内所有元素的布局属性） * 这个数组中存放的都是UICollectionViewLayoutAttributes对象 * 这个方法的返回值决定了rect范围内所有元素的排布（frame）*//** UICollectionViewLayoutAttributes *attrs; 1.一个cell对应一个UICollectionViewLayoutAttributes对象 2.UICollectionViewLayoutAttributes对象决定了cell的frame */- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect&#123; // 获得super已经计算好的布局属性 NSArray *array = [super layoutAttributesForElementsInRect:rect]; // 计算collectionView最中心点的x值 CGFloat centerX = self.collectionView.contentOffset.x + self.collectionView.frame.size.width * 0.5; // 在原有布局属性的基础上，进行微调 for (UICollectionViewLayoutAttributes *attrs in array) &#123; // cell的中心点x 和 collectionView最中心点的x值 的间距 CGFloat delta = ABS(attrs.center.x - centerX); // 根据间距值 计算 cell的缩放比例 CGFloat scale = 1 - delta / self.collectionView.frame.size.width; // 设置缩放比例 attrs.transform = CGAffineTransformMakeScale(scale, scale); &#125; return array;&#125;/** * 当collectionView的显示范围发生改变的时候，是否需要重新刷新布局 * 一旦重新刷新布局，就会重新调用下面的方法： 1.prepareLayout 2.layoutAttributesForElementsInRect:方法 */- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES;&#125;/** * 这个方法的返回值，就决定了collectionView停止滚动时的偏移量 * proposedContentOffset：原本情况下，collectionView停止滚动时最终的偏移量 * velocity：滚动速率，通过这个参数可以了解滚动的方向 */- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity&#123; // 计算出最终显示的矩形框 CGRect rect; rect.origin.y = 0; rect.origin.x = proposedContentOffset.x; rect.size = self.collectionView.frame.size; // 获得super已经计算好的布局属性 NSArray *array = [super layoutAttributesForElementsInRect:rect]; // 计算collectionView最中心点的x值 CGFloat centerX = proposedContentOffset.x + self.collectionView.frame.size.width * 0.5; // 存放最小的间距值 CGFloat minDelta = MAXFLOAT; for (UICollectionViewLayoutAttributes *attrs in array) &#123; if (ABS(minDelta) &gt; ABS(attrs.center.x - centerX)) &#123; minDelta = attrs.center.x - centerX; &#125; &#125; // 修改原有的偏移量 proposedContentOffset.x += minDelta; return proposedContentOffset;&#125;@end 自定义环形布局 同样要继承与流水布局UICollectionViewFlowLayout 12345#import &lt;UIKit/UIKit.h&gt;@interface CircleCollectionViewLayout : UICollectionViewFlowLayout@end 重写相应的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#import \"CircleCollectionViewLayout.h\"@interface CircleCollectionViewLayout()/** 布局属性 */@property (nonatomic, strong) NSMutableArray *attrsArray;@end@implementation CircleCollectionViewLayout/** 懒加载 */- (NSMutableArray *)attrsArray&#123; if (!_attrsArray) &#123; _attrsArray = [NSMutableArray array]; &#125; return _attrsArray;&#125;- (void)prepareLayout&#123; [super prepareLayout]; [self.attrsArray removeAllObjects]; NSInteger count = [self.collectionView numberOfItemsInSection:0]; for (int i = 0; i &lt; count; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForItem:i inSection:0]; UICollectionViewLayoutAttributes *attrs = [self layoutAttributesForItemAtIndexPath:indexPath]; [self.attrsArray addObject:attrs]; &#125;&#125;- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect&#123; return self.attrsArray;&#125;/** * 这个方法需要返回indexPath位置对应cell的布局属性 */- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; NSInteger count = [self.collectionView numberOfItemsInSection:0]; CGFloat radius = 70; // 圆心的位置 CGFloat oX = self.collectionView.frame.size.width * 0.5; CGFloat oY = self.collectionView.frame.size.height * 0.5; UICollectionViewLayoutAttributes *attrs = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; attrs.size = CGSizeMake(50, 50); if (count == 1) &#123; attrs.center = CGPointMake(oX, oY); &#125; else &#123; CGFloat angle = (2 * M_PI / count) * indexPath.item; CGFloat centerX = oX + radius * sin(angle); CGFloat centerY = oY + radius * cos(angle); attrs.center = CGPointMake(centerX, centerY); &#125; return attrs;&#125;@end 对自定义布局的使用12345678910111213141516171819202122232425262728293031 // 创建布局 CircleCollectionViewLayout *layout = [[CircleCollectionViewLayout alloc] init]; // 创建CollectionView CGFloat collectionW = self.view.frame.size.width; CGFloat collectionH = 200; CGRect frame = CGRectMake(0, 150, collectionW, collectionH); UICollectionView *collectionView = [[UICollectionView alloc] initWithFrame:frame collectionViewLayout:layout]; collectionView.dataSource = self; collectionView.delegate = self; [self.view addSubview:collectionView]; self.collectionView = collectionView; // 注册 [collectionView registerNib:[UINib nibWithNibName:NSStringFromClass([PhotoCell class]) bundle:nil] forCellWithReuseIdentifier:photoId]; ``` - 增加 touchesBegan：方法，通过点击让两种布局相互转换```objc- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; if ([self.collectionView.collectionViewLayout isKindOfClass:[LineCollectionViewLayout class]]) &#123; [self.collectionView setCollectionViewLayout:[[CircleCollectionViewLayout alloc] init] animated:YES]; &#125; else &#123; LineCollectionViewLayout *layout = [[LineCollectionViewLayout alloc] init]; layout.itemSize = CGSizeMake(100, 100); [self.collectionView setCollectionViewLayout:layout animated:YES]; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://titanjun.top/categories/iOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://titanjun.top/tags/Objective-C/"},{"name":"UICollectionView","slug":"UICollectionView","permalink":"https://titanjun.top/tags/UICollectionView/"}]},{"title":"Mac破解版软件大全","slug":"Mac破解版软件大全","date":"2016-10-10T05:30:03.000Z","updated":"2018-03-08T08:29:58.000Z","comments":true,"path":"2016/10/10/Mac破解版软件大全/","link":"","permalink":"https://titanjun.top/2016/10/10/Mac破解版软件大全/","excerpt":"转自史蒂芬周的博客 转自苹果网 PC6","text":"转自史蒂芬周的博客 转自苹果网 PC6","categories":[],"tags":[{"name":"Mac 工具","slug":"Mac-工具","permalink":"https://titanjun.top/tags/Mac-工具/"}]}]}